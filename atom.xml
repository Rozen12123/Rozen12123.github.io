<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小江的博客</title>
  
  <subtitle>想成为一个温暖而有趣的人</subtitle>
  <link href="https://rozen12123.github.io/atom.xml" rel="self"/>
  
  <link href="https://rozen12123.github.io/"/>
  <updated>2023-10-18T09:06:47.136Z</updated>
  <id>https://rozen12123.github.io/</id>
  
  <author>
    <name>小江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电磁场总结</title>
    <link href="https://rozen12123.github.io/posts/aef64dc0.html"/>
    <id>https://rozen12123.github.io/posts/aef64dc0.html</id>
    <published>2023-10-03T08:56:55.000Z</published>
    <updated>2023-10-18T09:06:47.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场原理"><a href="#电磁场原理" class="headerlink" title="电磁场原理"></a>电磁场原理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场原理&quot;&gt;&lt;a href=&quot;#电磁场原理&quot; class=&quot;headerlink&quot; title=&quot;电磁场原理&quot;&gt;&lt;/a&gt;电磁场原理&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>单片机</title>
    <link href="https://rozen12123.github.io/posts/7f705d57.html"/>
    <id>https://rozen12123.github.io/posts/7f705d57.html</id>
    <published>2023-09-19T09:25:44.000Z</published>
    <updated>2023-10-19T15:06:54.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h1><h2 id="进制转换及其加减法，补码"><a href="#进制转换及其加减法，补码" class="headerlink" title="进制转换及其加减法，补码"></a>进制转换及其加减法，补码</h2><p>2，4，88，10，16进制之间的相互转化，具体内容见逻辑设计</p><h2 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h2><ol><li><p>数据大小</p><ol><li><p>储存容量是衡量微机内部储存器能储存二进制（Bit）信息量大小的一个技术指标</p></li><li><p>8位二进制数据称为一个字节（Byte）——最基本的计量单位，记为1B</p></li><li><p>16位二级制数据称为一个字（word）</p></li><li><p>32位二进制数据称为一个双字（Dword）</p><script type="math/tex; mode=display">2^{10}B=1KB,2^{10}KB=1MB,2^{10}MB=1GB,2^{10}GB=1TB</script></li></ol></li><li><p>只读存储器（ROM）</p><p>ROM是一种掉电后不丢失信息的储存器。由于这个原因，ROM也成为非易失性存储器。</p><p>&nbsp;</p><p>结构和容量</p><p>给定储存器芯片有12个地址引脚和4个数据引脚，此储存芯片有4096个位置（$2^{12}=4096$），每个位置能储存4位数据，所以<code>结构</code>就是4096×4，也常用4K×4表示。其<code>容量</code>是16Kb，因为总共是4K个位置，每个位置能保存4位数据</p><p>&nbsp;</p><p>一个容量是512K储存器芯片有8个数据引脚，请找出：（a）组织结构；（b）这个储存芯片的地址引脚数</p><p>（a）8个数据引脚可以保存8位数据，为了找出这个储存器芯片的位置数，需要用数据引脚数去除容量。512K/8=64K；所以储存芯片的组织结构是64K×8</p><p>（b）芯片有16根地址线，因为$2^{16}=64K$</p></li><li><p>随机访问储存器（RAM）</p><p>储存计算机运行中暂停的项目，当电脑关机时数据会丢失</p></li><li><p>总线设计</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306714.png" alt="image-20231019221602733"></p><ol><li><p>地址总线</p><p>cpu地址总线的数目决定了能与cpu进行通信的位置数，位置数通常等于$2^x$，x是地址线的数目。</p><p>每个位置最多可以有一个字节的数据，不用考虑数据总线的大小。</p><p>地址总线是单向的。</p><p>地址总线使用得越多，外设使用越多。</p></li><li><p>数据总线</p><p>数据总线是双向的，因为CPU需要使用它们接收和发送数据。使用的数据总线越多，CPU效率越高。</p></li><li><p>控制总线</p><p>向设备提供读取或写入信号，以提示CPU是否正在请求信息。</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVR0,#66H</span><br><span class="line">MOVR3,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH0</span><br><span class="line">PUSH3</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR3,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP3</span><br><span class="line">POP7</span><br><span class="line">POP0</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>pop代表把栈顶的值赋值给r几</p><p>例如pop 3就是把栈顶的值赋值给R3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVSP,#70H</span><br><span class="line">MOVR5,#66H</span><br><span class="line">MOVR2,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH5</span><br><span class="line">PUSH2</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR2,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP7</span><br><span class="line">POP2</span><br><span class="line">POP5</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>&amp;nbsp</p><h2 id="8051系统概述"><a href="#8051系统概述" class="headerlink" title="8051系统概述"></a>8051系统概述</h2><h3 id="8051控制器的内部框图"><a href="#8051控制器的内部框图" class="headerlink" title="8051控制器的内部框图"></a>8051控制器的内部框图</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306716.png" alt="image-20231019213820890"></p><h3 id="8501的主要特性"><a href="#8501的主要特性" class="headerlink" title="8501的主要特性"></a>8501的主要特性</h3><div class="table-container"><table><thead><tr><th>特性</th><th>数量</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td></tr><tr><td>RAM</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td></tr><tr><td>串行端口</td><td>1</td></tr><tr><td>中断源</td><td>6</td></tr></tbody></table></div><h3 id="8051及其成员对比"><a href="#8051及其成员对比" class="headerlink" title="8051及其成员对比"></a>8051及其成员对比</h3><div class="table-container"><table><thead><tr><th>特性</th><th>8051</th><th>8052</th><th>8031</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td><td>8K</td><td>0K</td></tr><tr><td>RAM</td><td>128KB</td><td>256KB</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td><td>3</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td><td>32</td><td>32</td></tr><tr><td>串行端口</td><td>1</td><td>1</td><td>1</td></tr><tr><td>中断源</td><td>6</td><td>8</td><td>6</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><p>大多数的8051单片机的寄存器是8位的，所以也叫8051为8位单片机</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306717.png" alt="image-20231019195634248" style="zoom:67%;"></p><p>8051中常用的寄存器有A（累加器）、B、RO、R1、R2、R3、R4、R5、R6、R7、DPTR（数据指针）以及PC（程序计数器）寄存器。除DPTR和程序计数器是16位外，以上寄存器都是8位。</p><p>&nbsp;</p><h3 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV 目的操作数，源操作数</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306718.png" alt="image-20231019200313361"></p><p>1.可直接将数值装载到A、B或R0~R7的任意意一个寄存器当中。然而，为表示装载的是立即数，必须在数值前加上符号（#），如下：</p><p>2.如果将0～F的值装载到8位寄存器中，则其余的位就默认为0.例如，对于指今MOV&ensp; A，#5”而言，结果是A=05，用二进制表示就是A=00000101。</p><p>3.装载太大的值到寄存器中时会出错。（装载的值超过八位）</p><p>4.将数值装载到寄存器中时，必须在数值前加上符号（#），否则就表示装载的是存储器中的数。例如，MOV &ensp;A，17H”指令代表的就是将存储单元17H中的数装载到A中，结果就是任意值。</p><p>&nbsp;</p><h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD A,源操作数；</span><br></pre></td></tr></table></figure><p>指令中的源操作数即可以是寄存器，也可以是立即数；</p><p>寄存器A必须存在于任何的算数运算中，但其只能是任何算术运算中的目的操作数而不能是源操作数。</p><p>&nbsp;</p><h3 id="8051汇编语言简介"><a href="#8051汇编语言简介" class="headerlink" title="8051汇编语言简介"></a>8051汇编语言简介</h3><p>1.汇编语言程序由一连串的汇编指令组成</p><p>2.一条汇编指令由4个字段组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[标签:]  助记符  [操作数]  [;注释] </span><br></pre></td></tr></table></figure><p>助记符即为指令</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306719.png" alt="image-20231019201422708" style="zoom:67%;"></p><p>3.方框号代表里面的字段是可选的，不是每条指令都必须包含</p><p>4.ADD和MOV就是助记符，即产生操作码的部分。ORG和END就是伪代码（指示符），这些指示符不产生任何机器代码（操作码），仅供汇编使用。</p><p>&nbsp;</p><p>8051中的程序计数器和ROM空间</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306720.png" alt="image-20231019202019120" style="zoom:67%;"></p><p>1.编写汇编语言需要将汇编程序写好写入asm文件中</p><p>2.asm源文件被送入8051汇编器，汇编器将指令换成机器代码，然后产生目标文件（obj）和列表（lst）文件</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306721.png" alt="image-20231019202418301" style="zoom:67%;"></p><p>3.汇编器的第三步是链接：链接程序接受一个或多个目标文件并生成带有扩展名”abs”的绝对目标文件</p><p>4.将“abs”文件送入名为”OH”的程序（目标文件转16进制）中,从而产生即将烧入ROM中的扩展名位”hex”的文件。</p><ul><li>DOS EDIT编辑器产生asm文件</li><li>8051编译器产生obj和lst文件</li><li>链接器程序产生abs文件</li><li>OH程序产生HEX文件</li></ul><p>&nbsp;</p><h3 id="8051中的程序计数器和ROM空间"><a href="#8051中的程序计数器和ROM空间" class="headerlink" title="8051中的程序计数器和ROM空间"></a>8051中的程序计数器和ROM空间</h3><h4 id="8051中的程序计数器（PC）"><a href="#8051中的程序计数器（PC）" class="headerlink" title="8051中的程序计数器（PC）"></a>8051中的程序计数器（PC）</h4><ol><li>程序计数器指向下一条将执行指令的地址。</li><li>当CPU从程序ROM中得到操作码时，程序计数器就会自动增加并指向下一条指令</li><li>8051中的程序计数器为16位，能访问的程序地址范围是0000H～FFFFH，共64KB代码。</li></ol><h4 id="上电8051唤醒的位置"><a href="#上电8051唤醒的位置" class="headerlink" title="上电8051唤醒的位置"></a>上电8051唤醒的位置</h4><ol><li>当上电后，8051程序计数器中的值就是0000，就表示第一个操作码存储在ROM地址0000H中。</li><li>8051系统中，第一个操作码就必须烧人程序ROM的存储位置0000H中，因为这是启动后它寻找第一条指令的位置。</li></ol><p>&nbsp;</p><h3 id="8051数据类型和指令"><a href="#8051数据类型和指令" class="headerlink" title="8051数据类型和指令"></a>8051数据类型和指令</h3><h4 id="BD"><a href="#BD" class="headerlink" title="BD"></a>BD</h4><p>DB指令是汇编器中使用最广泛的数据指示符之一，它用于定义8位数据。</p><p>十进制后面的D是可选的，但是二进制的B和十六进制的H是必须加的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306722.png" alt="image-20231019204830206"></p><h4 id="汇编指示符"><a href="#汇编指示符" class="headerlink" title="汇编指示符"></a>汇编指示符</h4><p>1.ORG：用于ROM中表示起始地址</p><p>2.EQU：用于定义常量，但是不占用系统空间</p><p>3.END：告诉汇编器源文件（asm）末尾所处的位置。END指令是8051程序的最后一位，意味着END指令之后的源代码都会被汇编器忽略。</p><p>&nbsp;</p><h3 id="8051标志位和PSW寄存器"><a href="#8051标志位和PSW寄存器" class="headerlink" title="8051标志位和PSW寄存器"></a>8051标志位和PSW寄存器</h3><p>8051中也有表示算数运算状态的标志寄存器，如<code>进位标志</code>。</p><p>8051中的标志寄存器叫做<code>程序状态字（PSW）寄存器</code></p><h4 id="PSW（程序状态字）寄存器"><a href="#PSW（程序状态字）寄存器" class="headerlink" title="PSW（程序状态字）寄存器"></a>PSW（程序状态字）寄存器</h4><p>PSW寄存器是一个8位寄存器，也叫标志寄存器，但是在8051中，PSW只用了6位，剩余两位是用户自定义标志位。</p><p>6为中有4位是<code>状态标志位</code>也就是一些指令执行后的结果状态，分别是CY（进位）、AC（辅助进位）、P（奇偶校验位）以及OV（溢出位）</p><p>PSW.3和PSW.4位被分别设计为了RS0和RS1，用于选择组寄存器。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306723.png" alt="image-20231019210419646"></p><p>PSW.5和PSW.1是通用状态标志位，供程序员使用。</p><div class="table-container"><table><thead><tr><th>名称</th><th>位置</th><th>解释</th></tr></thead><tbody><tr><td>CY</td><td>PSW.7</td><td>进位标志</td></tr><tr><td>AC</td><td>PSW.6</td><td>辅助进位标志</td></tr><tr><td>F0</td><td>PSW.5</td><td>可用于用户的通用目的</td></tr><tr><td>RS1</td><td>PSW.4</td><td>寄存器组选择器位1</td></tr><tr><td>RS0</td><td>PSW.3</td><td>寄存器组选择器位0</td></tr><tr><td>OV</td><td>PSW.2</td><td>溢出标志</td></tr><tr><td>—</td><td>PSW.1</td><td>用户可定义位</td></tr><tr><td>P</td><td>PSW.0</td><td>奇偶标志。通过硬件每条指令周期设置/清0                     来指明是累加器中的奇/偶位数。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306724.png" alt="image-20231019210748792"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单片机&quot;&gt;&lt;a href=&quot;#单片机&quot; class=&quot;headerlink&quot; title=&quot;单片机&quot;&gt;&lt;/a&gt;单片机&lt;/h1&gt;&lt;h2 id=&quot;进制转换及其加减法，补码&quot;&gt;&lt;a href=&quot;#进制转换及其加减法，补码&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>电磁场原理</title>
    <link href="https://rozen12123.github.io/posts/a3afa0e4.html"/>
    <id>https://rozen12123.github.io/posts/a3afa0e4.html</id>
    <published>2023-09-18T08:11:44.000Z</published>
    <updated>2023-09-25T09:16:34.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场"><a href="#电磁场" class="headerlink" title="电磁场"></a>电磁场</h1><h2 id="矢量的基本概念"><a href="#矢量的基本概念" class="headerlink" title="矢量的基本概念"></a>矢量的基本概念</h2><h3 id="1-矢量的表示"><a href="#1-矢量的表示" class="headerlink" title="1.矢量的表示"></a>1.矢量的表示</h3><ol><li><p>图形表示</p></li><li><p>数学表示</p><script type="math/tex; mode=display">\vec{A}= \vec{a_A}\left | \vec{A} \right | = \vec{a_A}A</script></li><li><p>坐标分量表示法</p></li></ol><script type="math/tex; mode=display">\vec{A}= \vec{a_x}A_x(x,y,z)+\vec{a_y}A_y(x,y,z)+\vec{a_z}A_z(x,y,z)</script><p>$a_A$是沿A的方向且大小等于1的无量纲的单位矢量</p><p>&nbsp;</p><h3 id="2-矢量的加减"><a href="#2-矢量的加减" class="headerlink" title="2.矢量的加减"></a>2.矢量的加减</h3><p><img src="/posts/a3afa0e4.htm/image-20230918162802552.png" alt="image-20230918162802552" style="zoom:50%;"></p><p>矢量的运算规则（Operation rules）</p><p>1.加减运算</p><script type="math/tex; mode=display">\begin{array}{ll}a.&A+B=B+A\\ \\ b.&A+B+C=(A+B)+C=A+(B+C)\\ \\ c.&A-B=A+(-B)\end{array}</script><script type="math/tex; mode=display">d  .\quad \begin{array}{r l}{if \quad A=\boldsymbol{a}_{x}A_{x}(x,y,z)+\boldsymbol{a}_{y}A_{y}(x,y,z)+\boldsymbol{a}_{z}A_{z}(x,y,z)}\\ {B=\boldsymbol{a}_{x}B_{x}(x,y;z)+\boldsymbol{a}_{y}B_{y}(x,y,z)+\boldsymbol{a}_{z}B_{z}(x,y,z)}\\ \end{array}</script><p>then</p><script type="math/tex; mode=display">\begin{array}{l}A\pm B=\boldsymbol a_x(A_x\pm B_x)+\boldsymbol a_y(A_y\pm B_y)+\boldsymbol a_z(A_z\pm B_z)\\ cA=\boldsymbol a_x(cA_y)+\boldsymbol a_y(cA_y)+\boldsymbol a_z(cA_z)\end{array}</script><p>2.点乘运算</p><script type="math/tex; mode=display">A \bullet B = AB \cos \theta (\theta \leq \pi)</script><script type="math/tex; mode=display">\theta=\cos^{-1}\frac{A\bullet B}{AB}=\cos^{-1}\frac{A_{x}B_{x}+A_{y}B_{y}+A_{z}B_{z}}{AB}</script><p>3.叉乘运算（vector or cross product）</p><script type="math/tex; mode=display">C=|A\times B|=AB\sin\theta</script><p><img src="/posts/a3afa0e4.htm/image-20230918170905521.png" alt="image-20230918170905521" style="zoom:50%;"></p><p>注意：叉乘有顺序，不可以使用交换律</p><p>方向：右手定则</p><p><img src="/posts/a3afa0e4.htm/image-20230918170845402.png" alt="image-20230918170845402" style="zoom:50%;"></p><script type="math/tex; mode=display">A\times B=a_{x}(A_{y}B_{z}-A_{z}B_{y})+a_{y}(A_{z}B_{x}-A_{x}B_{z})+a_{z}(A_{x}B_{y}-A_{y}B_{x})=\begin{vmatrix}\boldsymbol{a}_x&\boldsymbol{a}_y&\boldsymbol{a}_z\\ A_x&A_y&A_z\\ B_x&B_y&B_z\end{vmatrix}</script><script type="math/tex; mode=display">\theta=\sin^{-1}\frac{\left|A\times B\right|}{A B}</script><p>4.三个矢量相乘</p><ol><li>模的几何意义是六面体的体积<script type="math/tex; mode=display">\mathbf{A}\bullet(\mathbf{B}\times\mathbf{C})=\mathbf{B}\bullet(\mathbf{C}\times\mathbf{A})=\mathbf{C}\bullet(\mathbf{A}\times\mathbf{B})</script></li></ol><ol><li>遵从Back-cab rule</li></ol><script type="math/tex; mode=display">\begin{array}{l}\textbf{A}\times(\textbf{B}\times\textbf{C})=\textbf{B}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{C})-\textbf{C}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{B})\\  \textbf{D}=\textbf{B}\times\textbf{C}\qquad\textbf{F}=\textbf{A}\times(\textbf{B}\times\textbf{C})\end{array}</script><script type="math/tex; mode=display">\begin{aligned}F_x&=A_y D_z-A_z D_y\\ &=A_y(B_x C_y-B_y C_z)-A_z(B_z C_x-B_x C_z)\\ &=B_x(A_y C_y+A_zC_z)-C_x(A_y B_y+A_z B_z)\\ &=B_x(\textbf{A}\textbf{C})-C_x(\textbf{A}\textbf{B})\end{aligned}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="正交坐标系及其微分元（Orhogonal-coordinate-systems）"><a href="#正交坐标系及其微分元（Orhogonal-coordinate-systems）" class="headerlink" title="正交坐标系及其微分元（Orhogonal coordinate systems）"></a>正交坐标系及其微分元（Orhogonal coordinate systems）</h2><p>常用的正交曲线坐标系</p><ol><li>直角坐标系</li><li>圆柱坐标系</li><li>球坐标系</li></ol><p>坐标线（轴）：三个正交曲面两两相交而成的曲线</p><p>坐标原点（基准点）:三条坐标系的焦点</p><p>坐标单位矢量：空间任意一点与坐标线相切且指向变量增加方向的三个单位矢量</p><p>&nbsp;</p><h3 id="正交坐标系的微分元"><a href="#正交坐标系的微分元" class="headerlink" title="正交坐标系的微分元"></a>正交坐标系的微分元</h3><script type="math/tex; mode=display">\text{d}l=\left[(\text{d}l_1)^2+(\text{d}l_2)^2+(\text{d}l_3)^2\right]^{1/2}\\ =\left[(h_1\text{d}u_1)^2+(h_2\text{d}u_2)^2+(h_3\text{d}u_3)^2\right]^{1/2}</script><ol><li>Differential directed distance</li></ol><script type="math/tex; mode=display">   d\mathbf{1}=\mathbf{a}_{u1}dl_1+\mathbf{a}_{u2}dl_2+\mathbf{a}_{u3}dl_3</script><ol><li>Differential area<script type="math/tex; mode=display">\begin{aligned}ds_1&=dl_2dl_3&=h_2h_3ah_2dt_3\\ ds_2&=dl_1dl_3&=h_1h_3dh_1du_3\\ ds_3&=dl_1dl_2&=h_1h_2du_1du_2\end{aligned}</script></li></ol><ol><li>Differential volume</li></ol><script type="math/tex; mode=display">dv=h_1h_2h_3du_1du_2du_3</script><h4 id="1-直角坐标系（Cartesian-coordinates）"><a href="#1-直角坐标系（Cartesian-coordinates）" class="headerlink" title="1.直角坐标系（Cartesian coordinates）"></a>1.直角坐标系（Cartesian coordinates）</h4><script type="math/tex; mode=display">\text{(u}_1,\text{u}_2,\text{u}_3\text{)=(x,y,z)}</script><ol><li>线元<script type="math/tex; mode=display">\begin{matrix}d\vec{l}_x=dx\vec{a}_x\\ {d}\vec{l}_y={dy}\vec{a}_y\\ {d}\vec{l}_z={dz}\vec{a}_z\\d\vec{l}=dx\vec{a}_x+dy\vec{a}_y+d{z}\vec{a}_z\end{matrix}</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{matrix}d\vec{S}_x=dy dz\vec{a_x}\\ d\vec{S}_y=dx dz \vec{a_y}\\ d\vec{S}_z=dx dy\vec{a}_z\end{matrix}</script></li></ol><ol><li>体元<script type="math/tex; mode=display">dV=dx dy dz</script></li></ol><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><p>已知一个线的矢量表达式A，求</p><ol><li>若B与A平行，那么求B的单位矢量表达式</li><li>若B垂直于A，且B处于x平面，求B的单位矢量表达式</li></ol><p>1.A×B=0 带入求解</p><p>2.A·B=0 带入求解</p><h4 id="2-圆柱坐标系（Cylindrical-coordinates）"><a href="#2-圆柱坐标系（Cylindrical-coordinates）" class="headerlink" title="2.圆柱坐标系（Cylindrical coordinates）"></a>2.圆柱坐标系（Cylindrical coordinates）</h4><script type="math/tex; mode=display">\left(\mathrm{u}_1,\mathrm{u}_2,\mathrm{u}_3\right)=\left(\mathrm{r},\mathrm{\varphi ,z}\right)</script><ol><li><p>线元</p><script type="math/tex; mode=display">\text{d}\vec{l}=\text{d}r\vec{a}_r+r\text{d}\varphi\vec{a}_\varphi+\text{d}z\vec{a}_z</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{aligned}\text{d}\vec{S}_r=r\text{d}\varphi\text{d}z\vec{a}_r\\ \text{d}\vec{S}_\varphi=\text{d}r\text{d}z\vec{a}_\varphi\\ \text{d}\vec{S}_z=r\text{d}\varphi\text{d}r\vec{a}_z\end{aligned}</script></li></ol><ol><li>体元</li></ol><script type="math/tex; mode=display">\text{d}V=r\text{d}r\text{d}\varphi\text{d}z</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场&quot;&gt;&lt;a href=&quot;#电磁场&quot; class=&quot;headerlink&quot; title=&quot;电磁场&quot;&gt;&lt;/a&gt;电磁场&lt;/h1&gt;&lt;h2 id=&quot;矢量的基本概念&quot;&gt;&lt;a href=&quot;#矢量的基本概念&quot; class=&quot;headerlink&quot; title=&quot;矢量的基本概念</summary>
      
    
    
    
    
    <category term="电磁场" scheme="https://rozen12123.github.io/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性控制系统</title>
    <link href="https://rozen12123.github.io/posts/b9875b9f.html"/>
    <id>https://rozen12123.github.io/posts/b9875b9f.html</id>
    <published>2023-09-16T11:26:32.000Z</published>
    <updated>2023-10-19T11:36:46.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动控制原理"><a href="#自动控制原理" class="headerlink" title="自动控制原理"></a>自动控制原理</h1><p>​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统</p><p>​    控制系统中的操纵器：控制器（contriller）/补偿器（compensator）[重点在于控制参数与结构]</p><p>控制器需要考虑的三大性能</p><ol><li>稳定性（Stability）：有界输入对应有界输出（BIBO）</li><li>瞬时响应（Transient response）：指标：响应速度</li><li>稳态响应（Steady-state response）</li></ol><p>&nbsp;</p><p>控制目标：</p><ol><li>稳定不稳定的系统</li><li>提高系统的稳定性；使得系统具有更好的稳定性。等效于改善系统的瞬时响应：更快的响应，较小的超调量，减小振荡</li><li>精准跟踪输入命令：减少/消除特定类型输入的稳态误差</li></ol><p>&nbsp;</p><p>判断微分方程，线性或非线性，时变或定长</p><p>是否为线性：如果每一项都是c(t),r(t),高阶导数，则为线性。但是如果出现平方线与单常数x则为非线性。</p><p>时变与非时变：c(t),r(t)的系数全是常数，不存在变量t</p><p>&nbsp;</p><h2 id="传递方程（transfer-function）"><a href="#传递方程（transfer-function）" class="headerlink" title="传递方程（transfer function）"></a>传递方程（transfer function）</h2><script type="math/tex; mode=display">a_{n}\frac{d^{n}c(t)}{dt^{n}}+a_{n-1}\frac{d^{n-1}c(t)}{dt^{n-1}}+\cdots+a_{0}c(t)=b_{m}\frac{d^{m}r(t)}{dt^{m}}+b_{m-1}\frac{d^{m-1}r(t)}{dt^{m-1}}+\cdots+b_{0}r(t)</script><p>左右两边分别进行拉氏变换，我们假设其初始状态为0可得：</p><script type="math/tex; mode=display">(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)C(s)=(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)R(s)</script><script type="math/tex; mode=display">\frac{C(s)}{R(s)}=G(s)=\frac{(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)}{(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)}</script><p>解题步骤：</p><ol><li><p>Replace passive element values with their impedances.</p></li><li><p>Replace all sources and time variables with their Laplace transform.</p></li><li><p>Assume a transform current and a current direction in each mesh.</p></li><li><p>Write Kirchhoff’s voltage law around each mesh.</p></li><li><p>Solve the simultaneous equations for the output.</p></li><li><p>Form the transfer function</p></li><li><p>将无源元件值替换为其阻抗。</p></li><li><p>将所有源和时间变量替换为其拉普拉斯变换。</p></li><li><p>假设每个网格中存在变换电流和当前方向。</p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p></li><li><p>求解联立方程以获得输出。</p></li><li><p>形成传递函数</p></li></ol><p>例题如下：</p><p><img src="/posts/b9875b9f.htm/image-20231007193359608.png" alt="image-20231007193359608" style="zoom:67%;"></p><p>寻找其传递方程${I_2(s)/V(s)}$</p><ol><li><p>将无源元件值替换为其阻抗,并进行拉氏变换同时设定好电流在网格中的流动方向。</p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p><script type="math/tex; mode=display">(R_1+Ls)I_1(s)&-LsI_2(s)=V(s)\\-LsI_1(s)+\left(Ls+R_2+\frac{1}{Cs}\right)I_2(s)&=0</script></li><li><p>求解联立方程以获得输出。（一般情况下使用克莱姆法则）</p><script type="math/tex; mode=display">I_{2}(s)=\frac{\left|\begin{array}{cc}\left(R_{1}+L s\right) & V(s) \\-L s & 0\end{array}\right|}{\Delta}=\frac{L s V(s)}{\Delta}</script><script type="math/tex; mode=display">\left.\Delta=\left|\begin{matrix}(R_1+Ls)&-Ls\\\\-Ls&\left(Ls+R_2+\frac{1}{Cs}\right)\end{matrix}\right.\right|</script></li><li><p>整理可得传递方程为</p><script type="math/tex; mode=display">G(s)=\frac{I_{2}(s)}{V(s)}=\frac{Ls}{\Delta}=\frac{LCs^{2}}{(R_{1}+R_{2})LCs^{2}+(R_{1}R_{2}C+L)s+R_{1}}</script></li></ol><p>利用拉普拉斯变换解微分方程的步骤如下：</p><p>①对方程两侧同时进行拉普拉斯变换，其中的F(s)就是我们要求的原函数经过拉普拉斯变换的结果；</p><p>②带入初值条件；</p><p>③把要求的原函数F(s)用关于s的表达式g(s)表达；</p><p>④对③中得到的F(s)=g(s)两侧进行拉普拉斯逆变换即可得到微分方程的解。</p><p>微分的拉式变换</p><p>一次微分$L[f’(t)]=sF(s)-f(0)$</p><p>二次微分$L[f’’(t)]=s^2F(s)-sf(0)-f’(0)$</p><p>三次微分$L[f’’’(t)]=s^3F(s)-s^2f(0)-sf’(0)-f’’(0)$</p><script type="math/tex; mode=display">L[f^{\prime}(t)]=\int_{0}^{\infty}e^{-s t}[e^{a t}f(t)]d t=e^{-s t}f(t)|\begin{array}{c}\\ 0\end{array}+s\int_{0}^{\infty}e^{-s t}f(t)d t=s F(s)=f(0)</script><h3 id="直线机械系统的传递函数（Translational-Mechanical-System）"><a href="#直线机械系统的传递函数（Translational-Mechanical-System）" class="headerlink" title="直线机械系统的传递函数（Translational Mechanical System）"></a>直线机械系统的传递函数（Translational Mechanical System）</h3><p><img src="/posts/b9875b9f.htm/image-20231007195252596.png" alt="image-20231007195252596" style="zoom:80%;"></p><h3 id="旋转机械系统的传递函数（Rotational-Mechanical-System）"><a href="#旋转机械系统的传递函数（Rotational-Mechanical-System）" class="headerlink" title="旋转机械系统的传递函数（Rotational Mechanical System）"></a>旋转机械系统的传递函数（Rotational Mechanical System）</h3><p><img src="/posts/b9875b9f.htm/image-20231007195402243.png" alt="image-20231007195402243" style="zoom:80%;"></p><h2 id="梅森公式"><a href="#梅森公式" class="headerlink" title="梅森公式"></a>梅森公式</h2><p>计算<strong>任意</strong>输入节点到输出节点的传递函数的梅森增益公式为：</p><script type="math/tex; mode=display">P=\frac{1}{\Delta}\sum_{k=1}^{n}P_{k}\Delta_{k}</script><p>其中$\Delta$为系统的特征多项式，其计算公式为：</p><script type="math/tex; mode=display">\Delta=1-\sum L_a+\sum L_bL_c-\sum L_dL_eL_f+\cdots</script><p>其中:</p><p> $\sum L_a$为所有不同回路增益之和；</p><p>$\sum L_bL_c$为所有两两不接触回路增益之和；</p><p>$\sum L_dL_eL_f+\cdots$ 为所有互不接触的回路中，每次取其中三个回路的增益乘积之和；</p><p>后面的以此类推。n为从输入节点到输出节点的前向通路条数</p><p>$P_k$ 为从输入节点到输出节点的第k条前向通路的总增益；<br>$\Delta_{k}$ 为第k条前向通路的余子式，即把特征式$\Delta$中与该前向通道相接触的回路增益置零后剩余的部分。</p><p>在做题中一共分为4步：</p><ol><li><p>先找出所有的闭环回路，即为 $\sum L_a$，再找出两两不相邻回路，即为$\sum L_bL_c$，依次类推直到找全,求出整个系统的特征式</p></li><li><p>接着找出系统的前向通路，即为$ \sum P_{k}$</p></li><li><p>找到每一项的余子式，各回路均与前向通路如果有接触，其余子式为1；如果相互没有接触<br>，其余子式为$1-其闭环回路$</p></li><li><p>带入即可求得其传递函数</p></li></ol><h2 id="一阶系统分析"><a href="#一阶系统分析" class="headerlink" title="一阶系统分析"></a>一阶系统分析</h2><p>一阶系统的传递函数标准形式为：$G(s)=\frac{C(s)}{R(s)}=\frac{1}{Ts+1}$</p><p>以输入信号为单位脉冲响应举例，单位脉冲信号的拉式变换为1，即$R(s)=1$其拉氏变换应为其自身的拉式变换。化简s的系数为1可得：$G(s)=\frac{1}{Ts+1}=\frac{1}{T}\cdot\frac{1}{s+1/T}$</p><p>进行拉氏变换：$c(t)=\mathscr{L}^{\prime}\bigl[G(s)\bigr]=\frac{1}{T}\cdot\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>有例题如下：</p><p>根据框图可以求得其传递函数为：$\frac{C(s)}{R(s)}=\frac{K_{h}G(s)}{1+K_{f}G(s)}=\frac{10K_{h}}{1+10K_{f}}\cdot\frac{1}{\frac{0.2}{1+10K_{f}}s+1}$</p><p>改变题目给定的传递时间由0.2变为0.02</p><p>可得：$\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}\cdot\frac1{\frac{0.2}{1+10K_\mathrm{f}}s+1}=\frac{10}{0.02s+1}$</p><p>列式可得：$\left.\left\{\begin{array}{cc}\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}=10\\\\\frac{0.2}{1+10K_\mathrm{f}}=0.02\\\end{array}\right.\right.$</p><p>解:$K_{f}=0.9,K_{h}=10$</p><p>&nbsp;</p><h2 id="劳斯判据"><a href="#劳斯判据" class="headerlink" title="劳斯判据"></a>劳斯判据</h2><p>可以根据<code>闭环传递函数的特征方程</code>如下表格对应写拉斯表</p><p>举例:</p><p><img src="/posts/b9875b9f.htm/image-20231018172633894.png" alt="image-20231018172633894" style="zoom:67%;"></p><p>由于第一列的系数不全为正，因此系统不稳定。</p><p>例题：</p><p><img src="/posts/b9875b9f.htm/image-20231018172746303.png" alt="image-20231018172746303" style="zoom:67%;"></p><p>由于第一列的系数都大于零，所以该系统稳定。</p><h3 id="劳斯判据中的特殊情况"><a href="#劳斯判据中的特殊情况" class="headerlink" title="劳斯判据中的特殊情况"></a>劳斯判据中的特殊情况</h3><p>（1）在计算中，第一列有零出现。</p><p>出现这种情况时，可以用一个很小的正数代替，继续完成计算。如果第一列中的元素除了出现的零值外，其余全部大于零，则说明系统有临界稳定的特征根。</p><p>（2）第一列的系数出现变号：改变符号（正负相互转化）的次数，即不稳定根的个数。</p><p>举例：$s^{3}-3s+2=0$</p><p>其劳斯表为：<img src="/posts/b9875b9f.htm/image-20231018173756661.png" alt="image-20231018173756661" style="zoom:67%;"></p><p>这个变号的次数即为不稳定跟的个数。</p><p>（3）出现零行（即劳斯表的每一行都是0），则存在大小相等，方向相反的根。</p><p>$s^{5}+2s^{4}+24s^{3}+48s^{2}-25s-50=0$</p><p>劳斯表计算中出现零行时，可用零行的前一行作辅助多项式$P（s）$，然后由$\frac{dP(s)}{ds}$的系数行代替零行，完成劳斯表的计算，如下面例题所示。<br><img src="/posts/b9875b9f.htm/image-20231018174123715.png" alt="image-20231018174123715" style="zoom:67%;"></p><p>&nbsp;</p><p>例题：</p><p><img src="/posts/b9875b9f.htm/image-20231018174402971.png" alt="image-20231018174402971" style="zoom:80%;"></p><p>根据框图可以得到其闭环传递函数为：$G_c(s)=\frac{\frac{10}{s(s+2)}}{1+(1+10s)\frac{10}{s(s+2)}}=\frac{10}{s^2+102s+10}$</p><p>闭环特征方程为：$s^2+102s+10=0$</p><p>据此列劳斯表易，其系数全部为正，即方程稳定。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="二阶系统分析"><a href="#二阶系统分析" class="headerlink" title="二阶系统分析"></a>二阶系统分析</h2><p>二阶系统的结构图如下：</p><p>其开环传递函数为：</p><script type="math/tex; mode=display">G_{_{o}}(s)=\frac{\omega_{n}^{2}}{s(s+2\zeta\omega_{_{n}})}</script><p>闭环传递函数的分母多项式等于零的代数方程称为二阶系统的闭环特征方程，即</p><script type="math/tex; mode=display">s^{2}+2\zeta\omega_{_n}s+\omega_{_n}^{2}=0</script><p>闭环特征方程的两个根称为二阶系统的特征根，即</p><script type="math/tex; mode=display">s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}</script><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>量纲</th></tr></thead><tbody><tr><td>$\zeta$</td><td>二阶系统的阻尼比</td><td>1</td></tr><tr><td>$ \omega_{_n}$</td><td>无阻尼振荡频率</td><td>rad/s</td></tr></tbody></table></div><p>根据$\zeta$的值范围的不同，一共有如下物种情况：</p><div class="table-container"><table><thead><tr><th>范围</th><th>特征根位置</th><th>系统响应情况</th></tr></thead><tbody><tr><td>$\zeta &gt; 1$</td><td>特征根为一对不相等的负实根，位于s平面的负实轴上</td><td>过阻尼</td></tr><tr><td>$\zeta = 1$</td><td>特征根为一对相等的负实根；也是位于s平面的负实轴上</td><td>临界阻尼</td></tr><tr><td>$0&lt; \zeta &lt;1$</td><td>特征根为一对带有负实部的共钜复数根，位于s平面的左半平面上</td><td>欠阻尼</td></tr><tr><td>$\zeta = 0$</td><td>特征根为一对纯虚根，位于s平面的虚轴上</td><td>无阻尼</td></tr><tr><td>$\zeta &lt; 0$</td><td>特征根位于s平面的右半平面上</td><td>发散</td></tr></tbody></table></div><p><img src="/posts/b9875b9f.htm/image-20231018175617105.png" alt="image-20231018175617105" style="zoom:80%;"></p><h3 id="二阶系统的性能指标计算"><a href="#二阶系统的性能指标计算" class="headerlink" title="二阶系统的性能指标计算"></a>二阶系统的性能指标计算</h3><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>计算式</th></tr></thead><tbody><tr><td>$\omega_{\mathrm{d}}$</td><td>阻尼振荡频率（rad/s）</td><td>$\omega_{\mathrm{d}}=\omega_{_n}\sqrt{1-\xi^{2}}$</td></tr><tr><td>$t_r$</td><td>上升时间</td><td>$t_{_r}=\frac{\pi-\beta}{\omega_{_\mathrm{d}}}$</td></tr><tr><td>$t_p$</td><td>峰值时间</td><td>$t_{_p}=\frac{\pi}{\omega_{_d}}$</td></tr><tr><td>$M_p$</td><td>超调量</td><td>$M_p=\mathrm{e}^{-\frac\zeta{\sqrt{1-\zeta^2}}\pi}\times100\%$</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>依照一阶系统调节时间的计算公式可以近似估算二阶欠阻尼系统的调节时间为:</p><p>$t_{_s}=3T={\frac{3}{\zeta\omega_{_n}}},\pm5\%\text{误差带宽度时}$</p><p>$t_{_s}=4T=\frac{4}{\zeta\omega_{_n}},\pm2\%\text{误差带宽度时}$</p><p>&nbsp;</p><p>有例题如下：</p><p>根据框图易得其开环传递函数如下：</p><script type="math/tex; mode=display">G_{_o}(s)=\frac{5K}{s(s+34.5)}</script><p>（1）闭环传递函数：</p><script type="math/tex; mode=display">G_{_c}(s)=\frac{G_{_s}(s)}{1+G_{_s}(s)}=\frac{\frac{5K}{s(s+34.5)}}{1+\frac{5K}{s(s+34.5)}}=\frac{5K}{s^{2}+34.5s+5K}=\frac{1}{s^{2}+34.5s+1000}</script><p>带入标准二阶传递函数形式，可得特征根参数：</p><script type="math/tex; mode=display">G_{\mathrm{c}}(s)=\frac{1}{s^{2}+34.5s+1000}=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{n}s+\omega_{n}^{2}}</script><script type="math/tex; mode=display">\begin{gathered}2\zeta\omega_{n}=34.5,\omega_{n}^{2}=1000 \\\omega_{n}=31.6\mathrm{rad/s} \\\zeta=0.545 \end{gathered}</script><p>峰值时间：<script type="math/tex">t_{_p}=\frac{\pi}{\omega_{_d}}=\frac{\pi}{\omega_{_n}\sqrt{1-\zeta^{^2}}}=0.12\mathrm{s}</script></p><p>超调量：$M_{_p}=\mathrm{e}^{-\frac{\zeta}{\sqrt{1-\zeta^{2}}}\pi}\times100\%=0.13\times100\%=13\%$</p><p>调节时间：$\begin{aligned}t_{s}&amp;=\frac{3}{\zeta\omega_{n}}=0.17\mathrm{s}(\pm5\%)\\t_{s}&amp;=\frac{4}{\zeta\omega_{n}}=0.23\mathrm{s}(\pm2\%)\end{aligned}$</p><p>（2）讨论K=1500和K=13.5时，对系统动态性能的影响。</p><p>当K=1500时，闭环传递函数为：$G_{_{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{7500}{s^{2}+34.5s+7500}$</p><p>特征参数：$\omega_{n}=86.6\mathrm{rad/s},\zeta=0.2$</p><p>性能指标：$t_{_p}=0.037s,M_{_p}=52.7\%,t_{_s}=0.17s$</p><p>可得其阻尼振荡频率：$\omega_{\mathrm{d}}=\omega_{\mathrm{n}}\sqrt{1-\zeta^{2}}=86.6\sqrt{1-0.2^{2}}\mathrm{rad/s=84.85rad/s}$</p><p>&nbsp;</p><p>当K=13.5时，闭环传递函数为:</p><p>$G_{\mathrm{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{67.5}{s^{2}+34.5s+67.5}$</p><p>对应特征参数为：$\omega_{_n}=8.22\mathrm{rad/s}$</p><p>$\zeta=2.1$</p><p>此时，系统为过阻尼的，没有超调量，曲线上升很慢。由近似计算可求得调节时间为：$t_{s}\approx3T_{1}=1.44\mathrm{s}$</p><h4 id="过阻尼情况下的调节时间"><a href="#过阻尼情况下的调节时间" class="headerlink" title="过阻尼情况下的调节时间"></a>过阻尼情况下的调节时间</h4><p>过阻尼系统的阻尼系数比：$\zeta&gt;1$</p><p>特征根为两个不相等的负实根：$s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}$</p><p>闭环传递函数为：$G_{c}\left(s\right)=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{_{n}}s+\omega_{n}^{2}}=\frac{\frac{1}{T_{1}T_{2}}}{\left(s+\frac{1}{T_{1}}\right)\left(s+\frac{1}{T_{2}}\right)}$</p><p>注意到在时间响应$ c（t）$的表达式中，当$T_2&lt;&lt;T_1$时，因为第三项极快地衰减到零。忽略该项后，时间响应$c(t)$可以近似为一阶系统的时间响应</p><p>$c(t)\approx1-\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>因此，一阶系统的调节时间$t_s$用一阶系统的时间常数T作为参变量表示为:</p><p>$t_s=3T,\text{取误差带宽度为}\pm5\%\text{时}$</p><p>$t_s=4T,\text{取误差带宽度为}\pm2\%\text{时}$</p><p><img src="/posts/b9875b9f.htm/image-20231018182939773.png" alt="image-20231018182939773" style="zoom:50%;"></p><p>&nbsp;</p><h3 id="二阶系统响应特性的改善"><a href="#二阶系统响应特性的改善" class="headerlink" title="二阶系统响应特性的改善"></a><strong>二阶系统响应特性的改善</strong></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动控制原理&quot;&gt;&lt;a href=&quot;#自动控制原理&quot; class=&quot;headerlink&quot; title=&quot;自动控制原理&quot;&gt;&lt;/a&gt;自动控制原理&lt;/h1&gt;&lt;p&gt;​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>结构化数字设计</title>
    <link href="https://rozen12123.github.io/posts/3c5c3e03.html"/>
    <id>https://rozen12123.github.io/posts/3c5c3e03.html</id>
    <published>2023-09-13T02:38:58.000Z</published>
    <updated>2023-09-26T08:49:50.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字化结构设计"><a href="#数字化结构设计" class="headerlink" title="数字化结构设计"></a>数字化结构设计</h1><h2 id="层次建模的概念"><a href="#层次建模的概念" class="headerlink" title="层次建模的概念"></a>层次建模的概念</h2><h3 id="设计方法学"><a href="#设计方法学" class="headerlink" title="设计方法学"></a>设计方法学</h3><p>两种基本的设计方法：<code>自底向上</code>和<code>自顶向下</code>设计</p><p>1.自底向上</p><p>2.自顶向下</p><p>通常情况下，两种方法混合使用。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>​     Verilog使用模块（module）的概念来代表一个基本的功能块。</p><p>​    一个模块可以是一个元件，也可以是低层次模块的组合</p><h3 id="1-模块声明"><a href="#1-模块声明" class="headerlink" title="1.模块声明"></a>1.模块声明</h3><p>​    在Verilog中，模块声明是由关键字module开始，关键字endmodule必须出现在模块定义的结尾。每个模块必须有一个模块名，由它唯一的标志这个模块。模块的端口列表则描述这个模块的输入和输出端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;模块名&gt;(&lt;模块端口列表&gt;);</span><br><span class="line">...</span><br><span class="line">&lt;模块的内容&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>例如在脉动进位计数器的例子中，T触发器可以定义为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> T_FF (q, clock ,reset);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;T触发器的功能描述&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>​    使用Verilog可以在每个模块内4个抽象层次进行描述，定义如下：</p><ol><li>行为或算法级：注重实现的算法，并不注重硬件实现的细节</li><li>数据流级：说明数据的流程对模块进行描述，数据如何在各个寄存器之间流动，以及如何处理这些数据。</li><li>门级：从组成电路的逻辑门及其之间的相互关系的角度设计模块。</li><li>开关级：通过开关，储存节点及其互连关系来设计模块。</li></ol><p>&nbsp;</p><h3 id="2-模块实例"><a href="#2-模块实例" class="headerlink" title="2.模块实例"></a>2.模块实例</h3><p>​    模块声明类似于一个模板，使用这个模板就可以创建实际的对象。当一个模块被调用的时候，Verilog会根据模板创建一个唯一的模块对象，每个对象都有其各自的名字、变量、参数和输入/输出（I/O）接口。</p><p>​    从模板创建对象的过程称为<code>实例化</code>（instantiation），创建的对象称为<code>实例</code>（instance）</p><p>&nbsp;</p><p>​    在Verilog中，不允许在模块声明中嵌套模块，也就是在模块声明的module和endmodule关键字之间不能再包含模块声明。模块之间的相互调用是通过实例引用来完成的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它引用了4个触发器。它们之间的连接参见2.2节</span></span><br><span class="line"><span class="comment">//定义名为ripple_carry_counter（脉动进位计数器）的模块</span></span><br><span class="line"><span class="keyword">module</span> ripple_carry_counter(q,clk,reget);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>]q;<span class="comment">//输人输出端口的信号和向量声明，以后会讲解</span></span><br><span class="line"><span class="keyword">input</span> clk,reset；<span class="comment">//输入/输出端口的信号声明，以后会讲解</span></span><br><span class="line"><span class="comment">//生成了4个触发器TEF的实例，每个实例都有自己的名字，每个实例都传递一组信号</span></span><br><span class="line"><span class="comment">//注意每个实例都是FF模块的副本</span></span><br><span class="line">    TFF tff0 (q[<span class="number">0</span>]，clk,reset);</span><br><span class="line">    TFF tff1 (q[<span class="number">1</span>]，q[<span class="number">0</span>]，reset);</span><br><span class="line">    TFF tff2 (q&#123;<span class="number">2</span>&#125;，q[<span class="number">1</span>]，reset);</span><br><span class="line">    TFF tff3 (q[<span class="number">3</span>]，q[<span class="number">2</span>]，reset);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//定义名为TFF（触发器）的模块。它引用了一个D触发器。我们在本模块中假设</span></span><br><span class="line"><span class="comment">//D触发器（DEF）已经在该设计中的别处定义了，参见图2.4，看它们之间的互相连接</span></span><br><span class="line">moaule TFF (q,clk,reset);</span><br><span class="line"><span class="comment">//以后将对下列语句做进一步的解释</span></span><br><span class="line"><span class="keyword">output</span> q;<span class="number">0</span></span><br><span class="line"><span class="keyword">input</span> clk,reset;</span><br><span class="line"><span class="keyword">wire</span> d;</span><br><span class="line">DFF dff0（q,d,clk,reset）;<span class="comment">//调用（实例引用）DFF，取名为dffo</span></span><br><span class="line"><span class="keyword">not</span> n1（d,q）;<span class="comment">//非门（not）是veri1og语言的内部原语部件（primitive），以后会讲解</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>ps:关键字必须是小写字母</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Verilog中的基本词法约定与c语言类似。</p><h3 id="数字声明"><a href="#数字声明" class="headerlink" title="数字声明"></a>数字声明</h3><ol><li><p>指明位数的数字</p><p>指明位数的数字表现形式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;size&gt;&#x27;&lt;base format&gt;&lt;number&gt;</span><br></pre></td></tr></table></figure><p>$<size>$用来指明数字的宽度（二级制的个数），只能用十进制表示。Base format表示用什么进制</size></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1111</span><span class="comment">//这是一个4位的二进制数</span></span><br><span class="line"><span class="number">12&#x27;habc</span><span class="comment">//这是一个12位的十六进制数</span></span><br><span class="line"><span class="number">16&#x27;d255</span><span class="comment">//这是一个16位的十进制数</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>不指明位数的数字</p><p>没有指定基数默认为十进制数。如果没有指定宽度，则默认为32位</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">234566</span><span class="comment">//这是一个32位的十进制数</span></span><br><span class="line"><span class="number">&#x27;hc3</span><span class="comment">//这是一个32位的十六进制数</span></span><br><span class="line"><span class="number">&#x27;o21</span><span class="comment">//这是一个32位的八进制数</span></span><br></pre></td></tr></table></figure></li><li><p>X和Z值</p><p>x表示不确定值，z表示高阻值；不区分x，y的大小写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;h13x</span><span class="comment">//这是一个12位的十六进制数，四个最低位不确定6&#x27;hx//这是一个6位的十六进制数，所有位都不确定</span></span><br><span class="line"><span class="number">32&#x27;bz</span><span class="comment">//这是一个32位的高阻值</span></span><br></pre></td></tr></table></figure><p>​    16进制为基数的表示中x或z表示4位，在8进制，x，z表示3位，在2进制中x，z代表1位。如果某数的最高位是0，x或z，verilog语言约定将分别使用0，x，z自动对这个数进行扩展，填满余下的更高位。如果最高位是1，余下的更高位用0来扩展。</p></li><li><p>复数</p><p>对于常数，我们可以通过在表示位宽的数字前面增加一个减号来表示它是一个负数，因为表示大小的常数总是正的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d3</span><span class="comment">//这是一个6位的用二进制补码形式存储的十进制数3，表示负数</span></span><br><span class="line">-<span class="number">6</span>&#x27;sd3<span class="comment">//这是一个6位的用于带符号算术运算的负数</span></span><br><span class="line"><span class="number">4</span>&#x27;d-<span class="number">2</span><span class="comment">//非法说明</span></span><br></pre></td></tr></table></figure></li><li><p>下划线和问号</p><p>除了第一个字符，下划线可以出现在数字中的任何位置，它的作用只是提高可读性，在编译阶段会被忽略，？是z的另一种表示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;b1111_0000_1010</span><span class="comment">//用下划线符号来提高可读性4&#x27;b10??//相当于4&#x27;b10zz</span></span><br></pre></td></tr></table></figure></li><li><p>转义标识符</p><p>转义标识符以反斜线“\”开始，以空白符（空格、制表符和换行符）结束。Verilog将反斜线和空白符之间的字符逐个进行处理。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\a+b-C <span class="comment">//译者注：与a+b-c等同</span></span><br><span class="line">\**my_name** <span class="comment">//译者注：如果作为标识符则与**my_name**等同</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>值的种类</p><p>Verilog使用四值逻辑和八种信号强度来对实际的硬件电路建模。</p><p>| 值的级别 | 硬件电路中的条件 |<br>| ———— | ———————— |<br>| 0        | 逻辑0，条件为假  |<br>| 1        | 逻辑0，条件为假  |<br>| x        | 逻辑值不确定     |<br>| z        | 高阻，浮动状态   |</p><p>| 强度等级 | 类型 | 程度 |<br>| ———— | —— | —— |<br>| supply   | 驱动 | 最强 |<br>| strong   | 驱动 |      |<br>| pull     | 驱动 |      |<br>| large    | 储存 |      |<br>| weak     | 驱动 |      |<br>| medium   | 储存 |      |<br>| small    | 储存 |      |<br>| highz    | 高阻 | 最弱 |</p></li><li><p>线网</p><ol><li><p>线网（net：代表了一类数据类型，包括wire，wand，wor，tri，trireg等）标识硬件单元之间的连接。</p></li><li><p>就像在真实的电路中一样，线网由其连接器件的输出连续驱动。</p></li><li><p>线网一般使用关键字wire进行声明。如果没有明显说明向量，则默认线网的位宽为1</p></li><li><p>线网的默认值为z（trireg类型的线网例外，其默认值为x），线网的值由驱动源确定，如果没有驱动源，则线网的值为z</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//声明上面的电路中a是wrie（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> b,c;<span class="comment">//声明上面的电路中b和c也是wire（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> d = <span class="number">1&#x27;b0</span>;<span class="comment">//连线d在声明时，d被赋值为逻辑值0</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><ol><li><p>寄存器用来表示储存元件，它保持原有的树脂，直到被改写。</p></li><li><p>寄存器数据类型一般通过关键字reg来声明，默认值为X</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> reset;<span class="comment">//声明能保持数值的变量reset</span></span><br><span class="line">initia1 <span class="comment">//这个结构将在以后讨论</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">reset = <span class="number">1&#x27;b1</span>;<span class="comment">//把reset初始化为1，使数字电路复位</span></span><br><span class="line">#<span class="number">100</span> reset=<span class="number">1&#x27;b0</span>;<span class="comment">//经过100个时间单位后，reset置逻辑0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>向量</p><ol><li><p>线网和寄存器类型的数据均可以声明为向量（位宽大于1）。若在声明中没有指定位宽，则默认为标量（1位）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//标量线网变量，默认</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] bus;<span class="comment">//8位的总线</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] busA,busB,busC;<span class="comment">//3条32位宽的总线</span></span><br><span class="line"><span class="keyword">reg</span> clock;<span class="comment">//标量寄存器，默认</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">40</span>] virtual_addr;<span class="comment">//向量寄存器，41位宽的虚拟地址</span></span><br></pre></td></tr></table></figure><ol><li><p>向量域选择</p><p>对于上面例子中声明的向量，我们可以指定它的某一位或若干个相邻位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">busA[<span class="number">7</span>] <span class="comment">//向量busA的第7位</span></span><br><span class="line">bus[<span class="number">2</span>:<span class="number">0</span>]<span class="comment">//向量bus的最低3位</span></span><br><span class="line"><span class="comment">//如果写成bus[0:2]是非法的，因为高位应该写在范围说明的左侧</span></span><br><span class="line">virtual_addr[<span class="number">0</span>:<span class="number">1</span>]<span class="comment">//向量virtual_addr的两个最高位</span></span><br></pre></td></tr></table></figure></li><li><p>可变的向量域选择</p><p>[<startingbit>+：width]：从起始位开始递增，位宽为width。</startingbit></p><p>[<startingbit>-：width]：从起始位开始递减，位宽为width。</startingbit></p></li></ol></li></ol><p>起始位可以是一个变量，但是位宽必须是一个常量。下面的例子说明了可变的向量域选择的使用方法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">255</span>:<span class="number">0</span>]data1;<span class="comment">//data1【255】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>:<span class="number">255</span>]data2;<span class="comment">//data2【0】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>]<span class="keyword">byte</span>;</span><br><span class="line"><span class="comment">//用变量选择向量的一部分</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data131:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data1【31:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data2【24:31】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data2【24:311//超始位可以是变量，但宽度必须是常数。因此可以通过可变域选择，//用循环语句选取一个很长的向量的所有位</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">32</span>;j=j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">byte</span>=data1[(j*<span class="number">8</span>)+<span class="number">8</span>];<span class="comment">//次序是【7:0】，【15:81..【255:248】</span></span><br><span class="line"><span class="comment">//用于初始化向量的一个域</span></span><br><span class="line">data1[(byteNum*<span class="number">8</span>)+:<span class="number">8</span>] = <span class="number">8&#x27;b0</span>;<span class="comment">//如果byteNum=1，共有8位被清零，【15:8】</span></span><br></pre></td></tr></table></figure></li><li><p>数字，实数和时间寄存器的数据类型</p><p>除reg类型之外，Verilog还支持integer,real和time寄存器数据类型。</p><ol><li><p>整数</p><p>用关键字integer进行声明，虽然可以用reg类型的寄存器作为通用变量，但声明一个整体类型的变量来完成计数会更为方便。</p><p>整数默认位宽为宿主机的字的位数，最小应为32位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> counter;<span class="comment">//一般用途的变量，作为计数器initial</span></span><br><span class="line">coumter=-<span class="number">1</span>;<span class="comment">//把-1存储到计数器中</span></span><br></pre></td></tr></table></figure></li><li><p>实数</p><p>用real来声明，实数声明不能带有范围，默认值为0。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> delta;<span class="comment">//定义一个名为delta的实型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">delta = <span class="number">4</span>e10;<span class="comment">//delta被赋值，用科学记数法表示</span></span><br><span class="line">delta = <span class="number">2</span><span class="variable">.13</span>;<span class="comment">//delta被赋值为2.13</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;<span class="comment">//定义一个名为的整型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">i = delta;<span class="comment">//1得到值2（2.13取整数部分）</span></span><br></pre></td></tr></table></figure></li><li><p>时间寄存器</p><p>仿真是按仿真时间进行的，其宽度与具体实现有关，最小为64位。用time来声明。通过调用系统函数$time可以得到当前的仿真时间。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span> save_simtime;<span class="comment">//定义时间类型的变量savesim time initial</span></span><br><span class="line">save sim <span class="keyword">time</span>=<span class="built_in">$time</span>;<span class="comment">//把当前的仿真时间记录下来</span></span><br></pre></td></tr></table></figure></li><li><p>数组</p><p>在Verilog中允许声明reg,integer,time,real,realtime及其向量类型的数组，对数组的维数没有限制。</p><p>形如&lt;数组名&gt;&lt;下标&gt;。对于多维数组来讲，用户需要说明其每一维的索引。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> count[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个计数变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> boo1[<span class="number">31</span>:<span class="number">0</span>];<span class="comment">//由32个1位的布尔（boolean）寄存器变量组成的数组</span></span><br><span class="line"><span class="keyword">time</span> chk_point[<span class="number">1</span>:<span class="number">100</span>];<span class="comment">//由100个时间检查变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] port_id[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个端口标识变量组成的数组，端口变量的位宽为5</span></span><br><span class="line"><span class="keyword">integer</span> matrix[<span class="number">4</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>];<span class="comment">//二维的整数型数组</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">63</span>:<span class="number">0</span>] array_4d[<span class="number">15</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//四维64位寄存器型数组</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] w_array2[<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明8位向量的数组</span></span><br><span class="line"><span class="keyword">wire</span> w_array1[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明1位线型变量的二维数组</span></span><br></pre></td></tr></table></figure><p>不要将数组和线网或寄存器向量混淆起来，向量是一个单独的元件，它的位宽是n；数组由多个元件组成，其中每个元件元素的赋值位n或1。</p><p>下面的例子显示了对数组元素的赋值：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count[<span class="number">5</span>]=<span class="number">0</span>;<span class="comment">//把count数组中的第5个整数型单元（32位）复位</span></span><br><span class="line">chk_point[<span class="number">100</span>]=<span class="number">0</span>;<span class="comment">//把chk_point数组中的第100个时间型单元（64位）复位</span></span><br><span class="line">port_id[<span class="number">3</span>]=<span class="number">0</span>;<span class="comment">//把port_id数组中的第3个寄存器型单元（5位）复位</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">33559</span>;<span class="comment">//把数组中第1行第0列的整数型单元（32位）置为33559</span></span><br><span class="line">array_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//把四维数组中索引号为【o】【O】【0】【O】的寄存器型单元</span></span><br><span class="line"><span class="comment">//的0-15位都置为0</span></span><br><span class="line">port_id=<span class="number">0</span>;<span class="comment">//非法，企图写整个数组</span></span><br><span class="line">matrix[<span class="number">1</span>] = <span class="number">0</span>；<span class="comment">//非法，企图写数组的整个第2行，即从matrix【1】【0】直到matrix【1】【255】</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><p>在数字电路仿真中，需要对寄存器文件ROM和RAM建模。如果需要访问储存器中的一个特定字，可以将字的地址作为数组的下标来完成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> memibit[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的1位存储器mem1bit</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] membyte[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的字节（8位）存储器membyte </span></span><br><span class="line">membyte[<span class="number">511</span>]<span class="comment">//取出存储器membyte中地址511处所存的字节</span></span><br></pre></td></tr></table></figure></li><li><p>参数</p><p>Verilog允许使用关键字parameter在模块内定义常数。参数代表常数，不能像变量那样赋值，但是每个模块实例的参数值可以在编译阶段被重载。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> port_id=<span class="number">5</span>;<span class="comment">//定义常数portid为5</span></span><br><span class="line"><span class="keyword">parameter</span> cache_1ine_width=<span class="number">256</span>;<span class="comment">//定义高速缓冲器总线宽度为常数256</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">signed</span>[<span class="number">15</span>:<span class="number">0</span>] WIDTH;<span class="comment">//把参数WIDTH规定为有正负号，宽度为16位</span></span><br></pre></td></tr></table></figure><p>Verilog中的局部参数使用关键字localparam来定义，其作用等同于参数，区别在于它的值不能改变。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>  state1 = <span class="number">4&#x27;b0001</span>,</span><br><span class="line">state2 = <span class="number">4&#x27;b0010</span>,</span><br><span class="line">state3 = <span class="number">4&#x27;b0100</span>,</span><br><span class="line">state4 = <span class="number">4&#x27;b1000</span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><ol><li><p>字符串保存在reg类型的变量中，每个字符占用8位（一个字节），因此寄存器变量的宽度应足够大。</p></li><li><p>如果寄存器变量的宽度大于字符串的大小，则Verilog使用0来填充左边的空余位；如果寄存器变量的宽度小于字符串的大小，则Verilog截去字符串最左边的位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">8</span>*<span class="number">18</span>:<span class="number">1</span>] string_value;<span class="comment">//声明变量string_vaiue，其宽度为18个字节</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">string_value = <span class="string">&quot;Hello Verilog World&quot;</span>;<span class="comment">//字符串可以存储在变量中</span></span><br></pre></td></tr></table></figure></li><li><p>有一些特殊字符在显示字符串时有特定的意义，例如换行符，制表符和显示参数值。如果需要在字符串中显示这些特殊字符，则必须加前缀转义字符。</p></li></ol></li></ol><div class="table-container"><table><thead><tr><th>转义字符</th><th>显示的字符</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>tab（制表空格）</td></tr><tr><td>%%</td><td>%</td></tr><tr><td>\\\</td><td>\\</td></tr><tr><td>\\”</td><td>“</td></tr><tr><td>\000</td><td>1到3个八进制数字字符</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><h2 id="系统任务和编译指令"><a href="#系统任务和编译指令" class="headerlink" title="系统任务和编译指令"></a>系统任务和编译指令</h2><h3 id="系统任务"><a href="#系统任务" class="headerlink" title="系统任务"></a>系统任务</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字化结构设计&quot;&gt;&lt;a href=&quot;#数字化结构设计&quot; class=&quot;headerlink&quot; title=&quot;数字化结构设计&quot;&gt;&lt;/a&gt;数字化结构设计&lt;/h1&gt;&lt;h2 id=&quot;层次建模的概念&quot;&gt;&lt;a href=&quot;#层次建模的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="课程" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子信息科学与技术攻略</title>
    <link href="https://rozen12123.github.io/posts/69d7a7f9.html"/>
    <id>https://rozen12123.github.io/posts/69d7a7f9.html</id>
    <published>2023-09-06T14:46:37.000Z</published>
    <updated>2023-09-18T02:42:04.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电子信息科学与技术攻略"><a href="#电子信息科学与技术攻略" class="headerlink" title="电子信息科学与技术攻略"></a>电子信息科学与技术攻略</h1><p>亲爱的学弟学妹们：</p><p>  首先，我要热烈欢迎你们加入电子信息科学与技术专业！恭喜你们顺利踏上了大学的征程，这将是一个充满挑战和成长的旅程。我是电子信息科学与技术专业的一名本科生，非常高兴能在这里与你们分享一些有关入学和大学生活的经验。</p><p>  在你们即将开始的学术和生活冒险中，我相信你们会遇到各种新的机会和挑战。作为学长，我们愿意与你们分享我们的经验，帮助你们更快地适应大学生活。不管你们面临什么问题，都请放心来寻求帮助，我们将竭尽全力支持你们。</p><p>  接下来，让我们一起探讨一些入学后关于学习的一些建议。无论你们有什么疑问或需要，都可以随时私信我。</p><h2 id="关于电子信息科学信息与技术"><a href="#关于电子信息科学信息与技术" class="headerlink" title="关于电子信息科学信息与技术"></a>关于电子信息科学信息与技术</h2><p>  在刚入学时我也对这个专业充满疑问，根本不知道这个专业是什么，要学什么，可以用来干什么。</p><p>  简单来说，电子信息科学与技术是一门涵盖电子工程、计算机科学和信息技术的跨学科领域。它关注的是如何处理、传输和管理信息，以及如何使用电子设备和计算机系统来解决实际问题。</p><p>  具体来说，这个领域包括了以下重要方面：</p><ol><li><strong>电子工程：</strong> 电子信息科学与技术涉及设计、开发和维护各种电子设备和系统，如电路、通信设备、传感器和嵌入式系统。这些技术在现代社会中无处不在，用于各种应用，从智能手机到医疗设备。</li><li><strong>计算机科学：</strong> 这个领域强调计算机系统的设计、编程和软件开发。学生将学习如何编写代码、开发应用程序，并理解计算机硬件和软件之间的相互作用。</li><li><strong>通信技术：</strong> 电子信息科学与技术还涉及到数据通信和网络技术，包括互联网、移动通信和无线传感器网络。这是现代社会中信息传递的关键组成部分。</li><li><strong>信息处理：</strong> 学生将学习如何处理和分析数据，以从中提取有用的信息。这包括数据挖掘、人工智能和机器学习等技术，这些技术在商业、科学和许多其他领域中都有广泛的应用。</li></ol><p>当然如果只这么说的话还是会有些抽象，不过不用担心，接下来的文章里我会对我们的专业做更加详细的解释。</p><p>​    这是一门涉及知识很广的学科，但你不得不说也是一门非常有趣的学科。我最开始知道这个专业并且对此感兴趣是在B站上看到的一个视频。是<strong>稚晖君</strong>做的一个小电视，我当时就被深深得吸引了，如此小的一个小电视上个怎么可以实现这么多功能，完全都可以当作一个电脑来使用。</p><p><a href="https://www.bilibili.com/video/BV1jE41137eu/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【自制】技术宅UP耗时三个月，自制B站最强小电视！【硬核】【3分钟从草图到实物】_哔哩哔哩_bilibili</a></p><p>​    随后，我又在B站发现了更多电子信息专业可以做的很多东西。</p><p><a href="https://www.bilibili.com/video/BV1BW41147kC/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">基于Arduino的十个可以DIY的炫酷项目_哔哩哔哩_bilibili</a></p><p>​    这对还没有开始学习大学知识的你来说可能就像魔法一样，我最开始刚进入大学的时候也是感觉这一切都是那么迷茫，不知道怎办开始，怎么学习才能做出来像这些视频里一样的diy项目。</p><p>​    但是经过一个学期的学习，我在大一上学期结束的那个寒假也用自己所学的东西，做了一个很简易的流水灯，虽然现在看起来是很简单的一个小制作，但是在当时把流水灯点亮的那一刻，心里的成就感是很强烈得，足够开心很久很久。</p><p><a href="https://www.bilibili.com/video/BV1uR4y1u7z5/?spm_id_from=333.999.0.0">做了个流水灯_哔哩哔哩_bilibili</a></p><p>希望你也可以在之后的学习中，做出一些很有趣的小制作。</p><p>&nbsp;</p><h2 id="电子信息科学与技术课程设置及其相关资料"><a href="#电子信息科学与技术课程设置及其相关资料" class="headerlink" title="电子信息科学与技术课程设置及其相关资料"></a>电子信息科学与技术课程设置及其相关资料</h2><h3 id="大一（Freshman-Year）"><a href="#大一（Freshman-Year）" class="headerlink" title="大一（Freshman Year）"></a><strong>大一（Freshman Year）</strong></h3><h4 id="第一学期课程（Curriculum-in-First-Semester）："><a href="#第一学期课程（Curriculum-in-First-Semester）：" class="headerlink" title="第一学期课程（Curriculum in First Semester）："></a>第一学期课程（Curriculum in First Semester）：</h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（一）College Physical Education I</p><p>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</p><p>l 线性代数导论（Introduction to Linear Algebra）</p><p>l 大学物理Ⅰ（University Physics Ⅰ）</p><p>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</p><p>l 编程导论（Introduction to Programming）</p><h4 id="第二学期课程（Curriculum-in-Second-Semester）："><a href="#第二学期课程（Curriculum-in-Second-Semester）：" class="headerlink" title="第二学期课程（Curriculum in Second Semester）："></a><strong>第二学期课程（Curriculum in Second Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（二）College Physical Education II</p><p>l 微积分Ⅱ和III（Calculus Ⅱ and III）</p><p>l 大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</p><p>l 工程学导论Ⅱ（Introduction to Engineering Ⅱ）</p><p>l 电路原理及实验（Electrical Circuit Theory and Lab）</p><h3 id="大二（Sophomore-Year）"><a href="#大二（Sophomore-Year）" class="headerlink" title="大二（Sophomore Year）"></a><strong>大二（Sophomore Year）</strong></h3><h4 id="第三学期课程（Curriculum-in-Third-Semester）："><a href="#第三学期课程（Curriculum-in-Third-Semester）：" class="headerlink" title="第三学期课程（Curriculum in Third Semester）："></a><strong>第三学期课程（Curriculum in Third Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（三）College Physical Education III</p><p>l 常微分方程导论（Introduction to Ordinary Differential）</p><p>l 大学物理III及实验（University Physics III and Lab）</p><p>l 数据结构（Data Structures）</p><p>l 电子学Ⅰ及实验（Electronics Ⅰ and Lab）</p><h4 id="第四学期课程（Curriculum-in-Forth-Semester）"><a href="#第四学期课程（Curriculum-in-Forth-Semester）" class="headerlink" title="第四学期课程（Curriculum in Forth Semester）"></a><strong>第四学期课程（Curriculum in Forth Semester）</strong></h4><p>l 大学体育（四）（College Physical Education IV）</p><p>l 工程概率基础（Introduction to Engineering Probability）</p><p>l 信号与系统（Circuits，Signals and System）</p><p>l 逻辑设计（Logic Design）</p><p>l 数字设计实验（Digital Design Lab）</p><p>l 电子学Ⅱ和实验（Electronics Ⅱ and Lab）</p><p>l 微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</p><p>l 电子电路CAD （Electronic Circuit CAD）</p><h3 id="大三（Junior-Year）"><a href="#大三（Junior-Year）" class="headerlink" title="大三（Junior Year）"></a><strong>大三（Junior Year）</strong></h3><h4 id="第五学期课程（Curriculum-in-Fifth-Semester）"><a href="#第五学期课程（Curriculum-in-Fifth-Semester）" class="headerlink" title="第五学期课程（Curriculum in Fifth Semester）"></a><strong>第五学期课程（Curriculum in Fifth Semester）</strong></h4><p>l 离散时间信号与系统（Discrete-Time Signals and Systems）</p><p>l 电磁场原理（Electromagnetic Field Theory）</p><p>l 固态电子学（Solid-State Electronics）</p><p>l 单片机原理（MCU Principle）</p><p>l 结构化数字设计（含FPGA）Structured Digital Design</p><p>l 创新项目实践（一）Practice of Innovation Project I</p><h4 id="第六学期课程（Curriculum-in-Sixth-Semester）"><a href="#第六学期课程（Curriculum-in-Sixth-Semester）" class="headerlink" title="第六学期课程（Curriculum in Sixth Semester）"></a><strong>第六学期课程（Curriculum in Sixth Semester）</strong></h4><p>l 嵌入式微处理系统设计（Embedded Microprocessor System Design）</p><p>l 通信系统（Communication Systems）</p><p>l 线性控制系统（Linear Control Systems）</p><p>l 电力电子（Power Electronics）</p><p>l VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</p><p>l 模拟集成电路（Analog Integrated Circuit）</p><p>l 创新项目实践（二）Practice of Innovation Project II</p><h3 id="大四（Senior-Year）"><a href="#大四（Senior-Year）" class="headerlink" title="大四（Senior Year）"></a><strong>大四（Senior Year）</strong></h3><h4 id="第七学期课程（Curriculum-in-Seventh-Semester）"><a href="#第七学期课程（Curriculum-in-Seventh-Semester）" class="headerlink" title="第七学期课程（Curriculum in Seventh Semester）"></a><strong>第七学期课程（Curriculum</strong> <strong>in Seventh Semester）</strong></h4><p>l 数字图像处理（Introduction to Digital Image Processing）</p><p>l 现场可编程逻辑阵列（Field programmable logic array）</p><p>l 高级项目设计（Advanced project design）</p><p>l 集成电路EDA（Integrated circuit EDA）</p><p>l 版图设计（Layout design）</p><p>l 专业实习（Internship）</p><h4 id="第八学期课程（Curriculum-in-Eighth-Semester）"><a href="#第八学期课程（Curriculum-in-Eighth-Semester）" class="headerlink" title="第八学期课程（Curriculum in Eighth Semester）"></a><strong>第八学期课程（Curriculum in Eighth Semester）</strong></h4><p>l 毕业设计（Senior Project）</p><p>&nbsp;</p><p>关于大学期间所有能用到得课本已经全部整理出来，链接就放到下面。</p><p>链接：<a href="https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg">https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg</a> 提取码：2038</p><p>​    这一部分要感谢一名学长，将我们所有的文档归纳起来并且分享给大家，我也把这位学长的原博客链接放到下面。这篇博客里还有所有对于我们课程的相关资料的推荐，我个人也是这篇博客的受益者。</p><p><a href="https://y006.github.io/2022/03/23/15-24-59/">电子专业资料共享计划 | Blog (y006.github.io)</a></p><p>​    如果打不开上面的博客，可能是因为博客的地址在GitHub，而你的电脑又没有开vpn。</p><p>关于vpn是什么，怎么使用，你可以去看这个视频。</p><p><a href="https://www.bilibili.com/video/BV1LX4y1E7AS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【科普】VPN到底是什么，你还敢用吗_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="课程部分"><a href="#课程部分" class="headerlink" title="课程部分"></a>课程部分</h2><p>​    大家最关心的莫过于自己将要学习的课程以及如何去学好他们，接下来我将对此讲一些自己的看法，如果你有更好的建议或者发现了错误也希望你及时联系我。</p><p>​    但是大学的知识学习不等同于高中，高中的一贯学习套路是：</p><ol><li>先学会基础知识，了解最基本的概念</li><li>反复练习简单题，中档题及压轴题</li><li>将练习后的题目分类总结，总结成一套自己的方法，直到考试碰到此类问题可以立即有思路，很快地解出题目。</li></ol><p>​    但是在大学如果你仍然按高中的学习方法明显是很吃力的，因为对于三年学习六门科目的学习方法去应对一学期学十几门课的实际情况，明显是不可能的。</p><p>​    我就对大一第一学期的课程做一些简单的介绍。我把课程分为三类，<code>基础类</code>，<code>导论类</code>，<code>应用类</code></p><h3 id="基础类：工程微积分，线性代数导论，大学物理"><a href="#基础类：工程微积分，线性代数导论，大学物理" class="headerlink" title="基础类：工程微积分，线性代数导论，大学物理"></a><em>基础类</em>：工程微积分，线性代数导论，大学物理</h3><p>​    基础类的课程设计了很多的基础概念，公式，和思想。学习这类课程需要你对自己学习过的知识有一个清晰的框架，以至于自己学习完这门课后知道自己都学习了什么内容。</p><p>​    例如你想去做一个平衡车，你学习完这些知识之后你要很清楚知道，微积分中的PID算法可以用来解决调节平衡角度的问题，大学物理的角动量可以让你更加了解平衡的机械部分是如何实现的。</p><h3 id="导论类：工程学导论，编程导论"><a href="#导论类：工程学导论，编程导论" class="headerlink" title="导论类：工程学导论，编程导论"></a><em>导论类</em>：工程学导论，编程导论</h3><p>​    导论类课程一般会带你们使用一种新的技术解决一个问题，这类课程不需要你像基础列课程学习得那么细致，对概念那么精通，你只需要知道这么课大概都讲了什么，用到了什么工具。</p><p>​    例如现在需要你在图纸上画出一个很标准的心形，或者一个零件。这时候你知道，自己在工程学导论中使用CAD可以用来解决这个问题，这个过程中，你不知道软件的工具在哪里，怎么使用，或者使用什么方案，这些都不要紧，你只需要知道有这些工具，并且这些工具可以解决什么问题就可以了。</p><p>​    当然，这也并不代表你就可以只是听故事一样听完整门课程就可以了，上课的例题，或者作业题也需要你去实践一下。</p><p>​    在编程导论中你知道用编程可以解决很多实际问题，它可以帮你计算，管理系统，等等。那你知道这些功能以后去自己写一个学生成绩管理系统是不是也是一个比较有趣的事情</p><p>&nbsp;</p><h3 id="实践类：编程导论"><a href="#实践类：编程导论" class="headerlink" title="实践类：编程导论"></a><em>实践类</em>：编程导论</h3><p>​    大多的实践类课程就是在你有一定的学习基础后，可以用这些基础的知识结合硬件去做一些项目。我们学习的编程导论虽然是一门导论课，但是编程在我们之后的学习生活中是不可或缺的一部分，这门课重要到即使它是一门导论课，也值得我们去把他当作一门实践类课程去学习。</p><p>​    你可以在学习了解完基础知识以后，写一个简单的猜数字游戏，学生成绩管理系统等等。</p><p>​    &nbsp;</p><p>​    或许对于还没有开始上课的你来说看这些内容还有些懵，但是在之后的学习生活中你会对此有更加深刻的体会。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>​    大一的课程是整个大学的基础，十分重要，其中的微积分，线性代数，大学物理，编程导论等也是之后很多课程的基础。</p><p>​    比如：大二你们要学习的常微分的基础就是微积分与线性代数，如果这两门你在最开始就没有学好，那在之后的学习中是很头疼的一件事情，你仍然要返回去学习这些基础课程。所以，希望同学们在最开始的时候就好好学习这些课程。</p><h4 id="l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）"><a href="#l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）" class="headerlink" title="l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）"></a>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</h4><p>微积分一中，主要的大方面学习分几部分</p><ol><li><p>对极限的理解</p></li><li><p>导数的进阶应用</p></li><li><p>微积分中重要思想———积分</p></li><li><p>积分方法的学习</p></li></ol><h5 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h5><p>在第二章极限的学习中，相较于初等数学，了解到了极限与无穷的概念，在图形中分析计算垂直与水平渐近线可以加深对与极限的理解。</p><p>要学会对连续性进行判断，从而判断出任意点的类型（如可去间断点，跳跃间断点等）</p><p>其次，在极限式子的计算中，多数较难的式子均可以最终化简为两个重要极限的形式。</p><script type="math/tex; mode=display">\lim _{x \rightarrow 0} \frac{\sin x}{x}=1 \quad \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e</script><p>由此，对于两个总要的极限的应用就显得及其重要，当然在极限中，熟练运用洛必达法则也是必不可少的</p><p>&nbsp; </p><h5 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h5><p>在高数开始接触导数便移入了很多新的概念，在导数中，很重要的一点就是加深对链法则的理解，这个对以后学习各类积分微分知识都是帮助很大的。</p><p>如果对链法则的理解加深了，关于隐函数求导，符合函数求导，三角函数求导中的一系列问题都可以迎刃而解。</p><p>如果可以，多用导数的概念定义式进行积分的运算，会加深对于极限的理解。</p><p>在导数中有一系列相关的应用问题</p><ol><li><p>求最大最小值</p></li><li><p>求极大极小值</p></li><li><p>凹度与拐点</p></li></ol><p>这些问题无非都是通过1.函数的一阶导2.函数的二阶导3.临界点进行求值</p><p>三个方面进行分析，从而就可以对上诉三个问题进行求解</p><p>熟练理解中值定理，并可以对简单的式子进行推导</p><p> &nbsp;</p><h5 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h5><p>在积分的学习中我也认为是本书中最重要的一个概念，对积分的理解不应该只是会算出各种各样的积分形式，我们当然会学习很多各种各样的积分方法，不限于:<code>分部积分法</code>，<code>三角积分法</code>，<code>三角换元法</code>，<code>分布分式法</code>……..这些方法在大量的练习中我们可以熟练地去解出各种类型的式子，配合506页的公式表，当然效果肯定会更棒。</p><p>对<code>反函数</code>，<code>对数指数</code>模型，<code>反三角函数</code>，在推导过一遍可以对公式进行记背。</p><p>在微积分的应用中，我们不应该仅仅停留在解出图形的<code>面积</code>，<code>体积</code>。</p><p>深刻理解微积分，把整个要计算的图形，分为极限趋向0的无数个点，由点去积分成线，再将由无数的线与一定区间进行积分，可以得到面，对面再积分可以得到体积。这是从一维到三维，我们都是很容易理解的。</p><p>但到四维呢？如果我们对于每个点再赋予一个维度的含义，那么这个式子就可以表达整个图形的质量。</p><p>这样去深刻理解每个维度之间的积分关系，就显得非常奇妙。</p><p>对于中间一些题型呢，如下</p><ol><li><p>求面积</p></li><li><p>求体积</p></li><li><p>求弧长</p></li></ol><p>&nbsp;</p><p>但是总得来说，上述只是对基础知识点的一个概述，微积分在我们的生活中可谓是应用广泛，比如在音乐播放器使用微积分来调整音频信号的音量和频率，以确保音乐听起来和谐而流畅；在电梯系统使用微积分来计算电梯的速度和位置，以便顺利地将你从一楼带到其他楼层；在电子游戏中的物理引擎使用微积分来模拟物体的运动和碰撞，以使游戏更加真实。</p><p>对于微积分，在你学完相关内容后你可以去看这些内容，可以更加加深你对知识的理解。</p><p><a href="https://www.bilibili.com/video/BV1qW411N7FU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【官方双语/合集】微积分的本质 - 系列合集_哔哩哔哩_bilibili</a></p><p>宋浩老师的视频也很适合你去进行预习或者打基础</p><p><a href="https://www.bilibili.com/video/BV1UW411k7Jv/?spm_id_from=333.337.search-card.all.click">《微积分》《高等数学》全程教学视频—宋浩老师_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-线性代数导论（Introduction-to-Linear-Algebra）"><a href="#l-线性代数导论（Introduction-to-Linear-Algebra）" class="headerlink" title="l 线性代数导论（Introduction to Linear Algebra）"></a>l 线性代数导论（Introduction to Linear Algebra）</h4><p>​    线性代数是一门数学分支，它主要研究向量、向量空间和线性变换等概念。它在电子信息科学与技术领域中具有关键作用，因为它提供了处理多维数据和解决复杂问题的数学工具。</p><p>​    注意，这门线性代数是一个数学工具，就好比你学习了方程以后就可以用使用方程来解决一些数学问题，而同样的，当你学习过线性代数以后，你也可以通过线性代数来解决一些数学或者工程上的问题。</p><ol><li><strong>向量和向量空间：</strong> 线性代数的核心概念之一是向量。向量可以用来表示多维数据，如在图像处理、信号处理和数据分析中常见的数据结构。线性代数还研究了向量空间，这是一组满足特定性质的向量的集合。向量空间理论为我们提供了处理和分析数据的框架。</li><li><strong>线性变换：</strong> 另一个重要的概念是线性变换，它描述了如何将一个向量空间映射到另一个向量空间。线性变换在图像处理、信号处理和控制系统等领域中广泛应用。例如，在通信系统中，线性变换可以用来描述信号的传输和变换。</li><li><strong>矩阵：</strong> 矩阵是线性代数中的另一个核心概念，它用于表示线性变换和解决线性方程组。在电子信息科学与技术中，矩阵常常用于描述电路、信号处理滤波器和数据转换等。</li></ol><p>​    我也在知乎上发现了一篇十分详细的知识点，链接在下方。</p><p><a href="https://zhuanlan.zhihu.com/p/453305373">【数学】线性代数知识点总结（精炼版） - 知乎 (zhihu.com)</a></p><p>​    宋浩老师的视频也是相当经典。</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.337.search-card.all.click">《线性代数》高清教学视频 “惊叹号”系列 宋浩老师_哔哩哔哩_bilibili</a></p><p>​    如果在学习完基础内容，会解一些基本题型后，你可以去看3Blue1Brown的视频，相信你在看完之后会对线性代数有更加深刻的认识。</p><p><a href="https://www.bilibili.com/video/BV1ib411t7YR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">-UP主汉语配音-【线性代数的本质】合集-转载于3Blue1Brown官方双语】_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-大学物理Ⅰ（University-Physics-Ⅰ）"><a href="#l-大学物理Ⅰ（University-Physics-Ⅰ）" class="headerlink" title="l 大学物理Ⅰ（University Physics Ⅰ）"></a>l 大学物理Ⅰ（University Physics Ⅰ）</h4><p>​    大学物理Ⅰ的大部分内容其实我们已经在高中学习过了，但要注意的是，大学的物理相较与初中的物理更贴合实际，更具有普遍性。解决这部分实际问题就需要结合微积分知识和大学物理把很多过程微分成很多很小的过程，然后在把这很多很小的过程累积在一起。</p><p>​    例如下面这个图片</p><p>​    在小球从O到A的过程中，弹簧的力一直在发生变化，如果我们需要求在原点O到A点弹簧的弹性势能，用中学的知识，我们可以用图像法分析出</p><script type="math/tex; mode=display">E = \frac{1}{2} k x ^2</script><p>​    在大学学习了微积分以后我们就可以将每一个微小过程中的做的功微分后积分在一起，结果是一样的</p><script type="math/tex; mode=display">E = \int_{0}^{x} kx dx</script><p>​    </p><p>​    但是假设k的值不是恒定的，用高中的知识就无法解决了，但是我们可以用二重积分来解决这个问题，这也就是为什么大学里解决的问题更具有普遍性的例子。也希望大家在学习物理的过程不要只局限与写题，而是多去思考这个过程。</p><p>​    学习大学物理你可以去看东北大学马文蔚老师的物理课。</p><p><a href="https://www.bilibili.com/video/BV1qW411H7UX/?spm_id_from=333.337.search-card.all.click">【大学物理】东北大学-马文蔚_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）"><a href="#l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）" class="headerlink" title="l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）"></a>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</h4><p>​    工程学导论的主要目标是引导你们进入电子信息科学与技术领域。它将帮助你们了解电子技术、通信系统、计算机科学和信息处理等方面的基本概念。</p><p>​    我们将介绍CAD（计算机辅助设计）工具、MATLAB和C++编程，这些工具在电子信息科学与技术领域中非常重要。</p><p>​    大家在课上认真听讲，积极完成老师布置的课下作业，如果你还有精力，那你可以去B站，谷歌，GitHub去了解更多的内容，这门课不是重点也不是难点，你们只需要知道了解我们上课学习的内容即可。</p><p>&nbsp;</p><h4 id="l-编程导论（Introduction-to-Programming）"><a href="#l-编程导论（Introduction-to-Programming）" class="headerlink" title="l 编程导论（Introduction to Programming）"></a>l 编程导论（Introduction to Programming）</h4><p>​    最开始我对编程的感觉就是黑客在都是黑色的屏幕上敲命令行，感觉就像是拥有魔法一样，敲几行代码就可以实现一些不可思议的功能。后来我开始接触编程，还很清楚得记得我在学习完if和for语句做出一个猜数字的游戏后激动的心情。</p><p>​    包括我之前做的那款心形流水灯也是用c语言进行编程的，学会了编程语言就好比你有了一把利器，解决之前不敢想象的问题。</p><p>​    如果你是刚刚入门，我希望你去看翁恺老师的c语言程序设计，这可谓是大家编程梦开始的地方。</p><p><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click">浙江大学翁恺教你C语言程序设计！C语言基础入门！_哔哩哔哩_bilibili</a></p><p>​    如果你已经开始了c++语言的学习，那我推荐你去看黑马程序员的视频，这个视频用很简单的语言就可以解释清楚复杂的知识点，也希望你尽可能得把所有视频上的程序都自己敲写一遍。</p><p><a href="https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></p><p>​    工欲善其事必先利其器，当然学习编程你就需要一款好的编译器，我推荐编程小白使用Visual Studio，这一款编译软件不要配置复杂的编译环境，可谓是上手即用，而且关于其的学习资料还比较多。下载方式如下。</p><p><a href="https://www.bilibili.com/video/BV1Xt411g7jT/?spm_id_from=333.337.search-card.all.click">vs2022(Visual Studio 2022)权威指南&amp;&amp;C语言&amp;&amp;软件工程开发的方向&amp;&amp;技巧要领_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>​    很明显，如果我们只学习课堂上教授的这部分内容，我们并没有办法去完成自己的diy项目或者小制作。我在最开始也有着这个疑问，不知道怎么样去动手实践，但是在之后摸索了很多方法之后，我认为初学者去学习arduino入门是很可行的一个道路。</p><p>​    Arduino是一款便捷灵活、方便上手的开源电子原型平台。很多重来没有接触过电子知识的创客也可用通过arduino来制作自己的小发明，更不用说我们这些科班出身的大学生。</p><p>​    你完全可用自己去淘宝买一套arduino的学习套件，跟着<code>太极创客</code>中的视频模仿，一步一步体会自己动手去做出来一个实物的快乐。</p><p><a href="https://www.bilibili.com/video/BV164411J7GE/?spm_id_from=333.337.search-card.all.click">【太极创客】零基础入门学用Arduino 第一部分 合辑_哔哩哔哩_bilibili</a></p><p>​    希望你一定不要把这作为自己的学习任务，自己去制作小发明就好比自己在拼乐高，去给玩偶涂色等等。是激动人心的一件事。我曾寒假在家就碰到了一个问题，屋子的灯只有一个开关，而我每次睡觉前关灯都需要爬下床去关灯然后抹黑爬回床上。于是我就花了一个下午的时间用蓝牙加舵机使用arduino的开发板制作了一个简易的智能开关。</p><p><a href="https://www.bilibili.com/video/BV1JF411r78p/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">arduino➕舵机➕蓝牙智能灯_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="竞赛部分"><a href="#竞赛部分" class="headerlink" title="竞赛部分"></a>竞赛部分</h2><p>​    我非常建议大一的新生去参加蓝桥杯的单片机赛道，虽然正常情况下大家在大三才会学到单片机的使用，可能在学习中你们并不知道138译码器，与非门等等这些概念，甚至设计功能都不知道这其中的原理是什么，但是这并不妨碍我们先去学习，去接触。</p><p>​    推荐你先去看江科大的单片机以后再去针对比赛看小蜜蜂的比赛视频，蓝桥杯在每年年末报名，次年的四五月份进行比赛。无论如何，只要付出了，这对你绝对是一段很宝贵的学习经历，而且这个比赛的获奖率也是很高的，每年的大一小白参加最后也是有很多获得了省奖。</p><p><a href="https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click">51单片机入门教程-2020版 程序全程纯手打 从零开始入门_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Bt41187hw/?spm_id_from=333.337.search-card.all.click">【小蜜蜂笔记】蓝桥杯大赛-单片机设计与开发基础技能与进阶强化教程_哔哩哔哩_bilibili</a></p><p>​    </p><p>&nbsp;</p><h2 id="寻找资源"><a href="#寻找资源" class="headerlink" title="寻找资源"></a>寻找资源</h2><p>​    大学的学习不同于高中，在高中针对固定的学科学校会统一给同学们发很多教辅，卷子，资料。</p><p>​    但是大学中并不会这样，甚至有些学科你甚至没有课本，电子版课本老师没有发给你的话，你可能上课连课本都没有了。这就需要你有一定的资源检索能力，对于想要学习的内容可以找到对应的学习资料或者网站。</p><p>​    下面会向大家介绍一些资源和网站。</p><h3 id="Chatgpt"><a href="#Chatgpt" class="headerlink" title="Chatgpt"></a>Chatgpt</h3><p>​    我把这个重量级的大模型放在第一位，是因为chatgpt是2022年底发布的，是人类最新技术的应用，强大到令人惊叹。</p><p>​    我曾经在2021年入学的时候遇到过很多问题，我想参加竞赛，想要在有限的时间内学好十几门课程，当了解到单片机，微处理器想去学习，但是会发现很难很难找到老师，去给你解答各种各样的问题，为你答疑解惑制定具体的学习方案。</p><p>​    直到Chatgpt的出现，我发现这个大模型就好像是一个无所不知的老师，你可以去问他任何你已有的疑问，甚至不限于学习，生活，情感，等等等。关于Chatgpt具体是什么，你可以看下面这个视频。</p><p><img src="/posts/69d7a7f9.htm/image-20230916201601406.png" alt="image-20230916201601406" style="zoom:100%;"></p><p><a href="https://www.bilibili.com/video/BV11m4y1B7ur/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">ChatGPT是什么？两分钟带你了解! （中英熟肉字幕）_哔哩哔哩_bilibili</a></p><p>​    当然你也需要找到正确使用它的方式，以至他可以更好理解你的问题并且为你回答，你可以看下面这个网站总结了如何对Chatgpt进行有效提问。</p><p><a href="https://flowus.cn/flowus101/share/f0601ddc-72e5-4b4e-ab17-0af2cce98732">GitHub - PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南 (flowus.cn)</a></p><p>Chatgpt的网址放在下方，你可以去某宝购买一个账号，开vpn登录即可使用（vpn的地址最好是非亚州区，挂在美国更好）</p><p><a href="https://chat.openai.com/auth/login">ChatGPT (openai.com)</a></p><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h3><p>​    bilibili大家号称B站大学，B站上可谓是有着无数的学习资源，通常找一个课程，一个编程项目，去B站搜索这些资源链接都会出现在评论区的第一条或者视频的介绍中，点击链接下载即可。</p><p>​    B站也有着更种各样的优秀课程，宋浩老师的高数系列，3blue1brown等等，上课没听懂不用去担心，B站大学为你兜底。</p><p>​    你同样也可以在B站学习如何去寻找资源。</p><p><a href="https://www.bilibili.com/video/BV17P4y187Kw/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道能帮你找到所有想要资源！！！第2期_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Db4y1a7sa/?vd_source=db4533a45f532ba6c1133faafbf7f171">收藏血赚！3分钟大学逆袭，各专业最有用资源大合集！_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1TN411d7FL/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道，能帮你找到所有想要资源！第1期_哔哩哔哩_bilibili</a></p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>​    如果你想参加一个比赛，一个项目，去知乎搜索相关内容，它会给到你更加客观的答案（现在可能会对各种事情的看法会更加现实和消极）</p><p>​    如果你是想听听大家对一个事件，一个学科或者是各种各样问题的看法或者意见，那欢迎你来到知乎。</p><p>&nbsp;</p><h3 id="CDSN"><a href="#CDSN" class="headerlink" title="CDSN"></a>CDSN</h3><p>​    <em>CSDN</em>是全球知名中文IT技术交流平台，如果你是在学习编程语言，机器学习，各种各样的技术知识，这绝对是你绕不开的一个平台，去互联网上去寻找响应的代码，你很有可能就是在csdn上找到答案。</p><p>​    比如你正在学习数据结构的链表，但是你上课有没有太听懂，你就可以去csdn搜索链表，会出现各种各样关于链表的总结，其中可能就会点进我的主页（悄悄安利自己一波）</p><p><a href="https://blog.csdn.net/u011146203/article/details/127587997?spm=1001.2014.3001.5501">（数据结构）链表_指针怎么取数据域_江江江江江江江江江的博客-CSDN博客</a></p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>​    在开始学习编程的时候，经常会遇到编译错误的问题，但是这也可能是之前别人学习时也碰到的问题，把错误复制下来输入到搜索引擎，一般情况下你也会在其中找到你想要的答案。</p><p><a href="https://www.baidu.com/">百度一下，你就知道 (baidu.com)</a></p><p>&nbsp;</p><h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>​    去旅游想知道那里有什么好吃的，生了xx要怎么处理，想要去学习做个什么饭等等这些生活中的问题小红书会给你答案，（我也经常会去小红书上大家安利的美食店）。但毕竟是社交平台，还有微博，知乎这些，关于大家对事情都有自己的看法，保持正确三观，遵从内心的想法，不要别人说风就是雨。有时候看太多一些社会，工作还是情感上的内容会平添很多焦虑。希望大家可以自由愉快地享受大学生活。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>因为我目前也只是一名刚进入大三的本科生，很多想法见解可能在之后的学习过程中也会有不同的体验，如果你有更好的建议或者发现了一些错误请及时私信我，本文档将持续进行更新……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电子信息科学与技术攻略&quot;&gt;&lt;a href=&quot;#电子信息科学与技术攻略&quot; class=&quot;headerlink&quot; title=&quot;电子信息科学与技术攻略&quot;&gt;&lt;/a&gt;电子信息科学与技术攻略&lt;/h1&gt;&lt;p&gt;亲爱的学弟学妹们：&lt;/p&gt;
&lt;p&gt;  首先，我要热烈欢迎你们加入电子</summary>
      
    
    
    
    
    <category term="学习攻略" scheme="https://rozen12123.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>cpu制作</title>
    <link href="https://rozen12123.github.io/posts/68d8d011.html"/>
    <id>https://rozen12123.github.io/posts/68d8d011.html</id>
    <published>2023-08-22T10:15:33.000Z</published>
    <updated>2023-10-11T08:54:28.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu的制作"><a href="#cpu的制作" class="headerlink" title="cpu的制作"></a>cpu的制作</h1><p>cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可完成搭建。</p><p>而且自己制作cpu是一件非常有趣的一件事情，去理解身边的电脑，手机等等的一些运作的底层原理。</p><p>那么现在，我们就从最开始最简单的电路开始搭建吧。</p><h2 id="电路搭建"><a href="#电路搭建" class="headerlink" title="电路搭建"></a>电路搭建</h2><h3 id="与或非门，同或异或门"><a href="#与或非门，同或异或门" class="headerlink" title="与或非门，同或异或门"></a>与或非门，同或异或门</h3><p><img src="/posts/68d8d011.htm/image-20231010180429855.png" alt="image-20231010180429855" style="zoom:67%;"></p><p>与或非是计算机逻辑门的最基础的部件，其他任意的部件都可以通过与或非三种门来表示。</p><h3 id="八位加法器"><a href="#八位加法器" class="headerlink" title="八位加法器"></a>八位加法器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> eight_bit_full_adder  (</span><br><span class="line">  <span class="keyword">input</span> A,</span><br><span class="line">  <span class="keyword">input</span> B,</span><br><span class="line">  <span class="keyword">output</span> S,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> S = (A ^ B);</span><br><span class="line">  <span class="keyword">assign</span> C = (A &amp; B);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> DIG_Add</span><br><span class="line">#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">input</span> c_i,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">    <span class="keyword">output</span> c_o</span><br><span class="line">);</span><br><span class="line">   <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">   <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> \?????  (</span><br><span class="line">  <span class="keyword">input</span> A1,</span><br><span class="line">  <span class="keyword">input</span> B1,</span><br><span class="line">  <span class="keyword">input</span> A2,</span><br><span class="line">  <span class="keyword">input</span> B2,</span><br><span class="line">  <span class="keyword">input</span> A3,</span><br><span class="line">  <span class="keyword">input</span> B3,</span><br><span class="line">  <span class="keyword">input</span> A4,</span><br><span class="line">  <span class="keyword">input</span> B4,</span><br><span class="line">  <span class="keyword">input</span> A5,</span><br><span class="line">  <span class="keyword">input</span> B5,</span><br><span class="line">  <span class="keyword">input</span> A6,</span><br><span class="line">  <span class="keyword">input</span> B6,</span><br><span class="line">  <span class="keyword">input</span> A7,</span><br><span class="line">  <span class="keyword">input</span> B7,</span><br><span class="line">  <span class="keyword">input</span> A0,</span><br><span class="line">  <span class="keyword">input</span> B0,</span><br><span class="line">  <span class="keyword">output</span> S0,</span><br><span class="line">  <span class="keyword">output</span> S1,</span><br><span class="line">  <span class="keyword">output</span> S2,</span><br><span class="line">  <span class="keyword">output</span> S3,</span><br><span class="line">  <span class="keyword">output</span> S4,</span><br><span class="line">  <span class="keyword">output</span> S5,</span><br><span class="line">  <span class="keyword">output</span> S6,</span><br><span class="line">  <span class="keyword">output</span> S7,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> s8;</span><br><span class="line">  <span class="keyword">wire</span> s9;</span><br><span class="line">  <span class="keyword">wire</span> s10;</span><br><span class="line">  <span class="keyword">wire</span> s11;</span><br><span class="line">  <span class="keyword">wire</span> s12;</span><br><span class="line">  <span class="keyword">wire</span> s13;</span><br><span class="line">  <span class="keyword">wire</span> s14;</span><br><span class="line">  \???  \???_i0 (</span><br><span class="line">    <span class="variable">.A</span>( A0 ),</span><br><span class="line">    <span class="variable">.B</span>( B0 ),</span><br><span class="line">    <span class="variable">.S</span>( S0 ),</span><br><span class="line">    <span class="variable">.C</span>( s8 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i1 (</span><br><span class="line">    <span class="variable">.a</span>( s8 ),</span><br><span class="line">    <span class="variable">.b</span>( A1 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B1 ),</span><br><span class="line">    <span class="variable">.s</span>( S1 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s9 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i2 (</span><br><span class="line">    <span class="variable">.a</span>( A2 ),</span><br><span class="line">    <span class="variable">.b</span>( s9 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B2 ),</span><br><span class="line">    <span class="variable">.s</span>( S2 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s10 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i3 (</span><br><span class="line">    <span class="variable">.a</span>( s10 ),</span><br><span class="line">    <span class="variable">.b</span>( A3 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B3 ),</span><br><span class="line">    <span class="variable">.s</span>( S3 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s11 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i4 (</span><br><span class="line">    <span class="variable">.a</span>( s11 ),</span><br><span class="line">    <span class="variable">.b</span>( A4 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B4 ),</span><br><span class="line">    <span class="variable">.s</span>( S4 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s12 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i5 (</span><br><span class="line">    <span class="variable">.a</span>( s12 ),</span><br><span class="line">    <span class="variable">.b</span>( A5 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B5 ),</span><br><span class="line">    <span class="variable">.s</span>( S5 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s13 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i6 (</span><br><span class="line">    <span class="variable">.a</span>( s13 ),</span><br><span class="line">    <span class="variable">.b</span>( A6 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B6 ),</span><br><span class="line">    <span class="variable">.s</span>( S6 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s14 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i7 (</span><br><span class="line">    <span class="variable">.a</span>( s14 ),</span><br><span class="line">    <span class="variable">.b</span>( A7 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B7 ),</span><br><span class="line">    <span class="variable">.s</span>( S7 ),</span><br><span class="line">    <span class="variable">.c_o</span>( C )</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h3><p>与门可以存储下来0，或门可以存储下来1，我们把与门和或门进行一个组合，就能做出来第一个有用的电路结构。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> latch  (</span><br><span class="line">  <span class="keyword">input</span> Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">output</span> Out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> Out_temp;</span><br><span class="line">  <span class="keyword">assign</span> Out_temp = ((Out_temp | (Din &amp; WE)) &amp; ~ (~ Din &amp; WE));</span><br><span class="line">  <span class="keyword">assign</span> Out = Out_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器=8位锁存器/16/32位</p><p>一次可以存储8位数据。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><p><img src="/posts/68d8d011.htm/image-20231011105654618.png" alt="image-20231011105654618" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="带边缘触发的锁存器"><a href="#带边缘触发的锁存器" class="headerlink" title="带边缘触发的锁存器"></a>带边缘触发的锁存器</h3><h4 id="为什么需要时钟"><a href="#为什么需要时钟" class="headerlink" title="为什么需要时钟"></a>为什么需要时钟</h4><p>大家都见过划船的，划船需要一个喊口号的主要原因是为了保证协调。通过喊口号，船员们可以同步动作，确保船在平稳且有效率地前进。<br>CPU需要clock来同步内部操作，如执行指令、进行数据传输等。Clock提供了精确的时间控制，确保每个内部操作在正确的顺序与速度内执行，从而确保CPU的正常工作。另外，Clock还与CPU的频率相关，通过控制Clock频率，可以控制CPU的速度。</p><h4 id="时钟信号是什么"><a href="#时钟信号是什么" class="headerlink" title="时钟信号是什么"></a>时钟信号是什么</h4><p>时钟信号就是周期性的高低电平变化的信号<br>我们可以用两个普通的寄存器加上一个非门，组成一个带有边缘触发的寄存器。<br>在按钮按下的一瞬间，电压从低电平到高电平的一瞬间，Din的数据被存储起来。</p><p>&nbsp;</p><h3 id="寄存器REG"><a href="#寄存器REG" class="headerlink" title="寄存器REG"></a>寄存器REG</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th><th></th></tr></thead><tbody><tr><td>D</td><td>数据输入</td><td></td></tr><tr><td>C</td><td>时钟信号</td><td></td></tr><tr><td>en</td><td>使能端口，高电平工作</td></tr></tbody></table></div><p>存储器-寄存器</p><blockquote><p>可以做的扩展，增加输入使能WE和输出使能OE<br>寄存器访问速度快，因为寄存器的每一条数据线都是直接接出来的。</p></blockquote><p>&nbsp;</p><h3 id="十六位的内存"><a href="#十六位的内存" class="headerlink" title="十六位的内存"></a>十六位的内存</h3><p>内存地址：从并行到串行<br>内存单元格要自己自己在哪一行和哪一列，需要有row和column<br>内存单元要有ld（load）读的控制<br>内存单元要有str（store）有存的控制<br>内存单元要有数据的输入</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>row&amp;column</td><td>确定需要储存的地址</td></tr><tr><td>ld（load）</td><td>读的控制</td></tr><tr><td>str（store）</td><td>存的控制</td></tr></tbody></table></div><p>内存地址：从并行到串行<br>内存地址的作用主要是为了节省数据线，简化电路数量有了内存地址的概念后，输入和输出只需要1条数据线了先选中需要读写的内存单元，再输入输出</p><p>&nbsp;</p><h3 id="8位的寄存器"><a href="#8位的寄存器" class="headerlink" title="8位的寄存器"></a>8位的寄存器</h3><p>设计8位（bit）的寄存器，用于CPU存储的临时计算的数据</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DIG_Register_BUS #(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> C,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]D,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]Q</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] state = <span class="number">&#x27;h0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Q = state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> C) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (en)</span><br><span class="line">        state &lt;= D;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="number">8_</span>REG  (</span><br><span class="line">  <span class="keyword">input</span> Clock,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data_temp;</span><br><span class="line">  DIG_Register_BUS #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Register_BUS_i0 (</span><br><span class="line">    <span class="variable">.D</span>( Din ),</span><br><span class="line">    <span class="variable">.C</span>( Clock ),</span><br><span class="line">    <span class="variable">.en</span>( WE ),</span><br><span class="line">    <span class="variable">.Q</span>( Stored_Data_temp )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( Stored_Data_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> Stored_Data = Stored_Data_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>基于上面的原理图，我们分别设计4位和8位的寄存器4位的寄存器用于程序计数器（PC）和MAR（内存地址寄存器）<br>8位的寄存器用于指令寄存器（IR），CPU通用临时寄存器（RegA）（RegB），内存缓存寄存器（MBR）等。分别测试4位和8位的寄存器。</p><p><img src="/posts/68d8d011.htm/image-20231011154050156.png" alt="image-20231011154050156" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="逻辑和算数运算单元（ALU）"><a href="#逻辑和算数运算单元（ALU）" class="headerlink" title="逻辑和算数运算单元（ALU）"></a>逻辑和算数运算单元（ALU）</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>RegA</td><td>8位的寄存器数据</td></tr><tr><td>RegB</td><td>8位的寄存器数据</td></tr><tr><td>OE</td><td>输出允许</td></tr><tr><td>ALUResult</td><td>ALU内部计算结果，方便观察调试</td></tr><tr><td>Carry</td><td>溢出位引出1位信号线</td></tr><tr><td>Dout</td><td>输出数据8位，默认高阻态</td></tr></tbody></table></div><p><img src="/posts/68d8d011.htm/image-20231011155356141.png" alt="image-20231011155356141" style="zoom:80%;"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">module</span> DIG_Add</span><br><span class="line">  #(</span><br><span class="line">  <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">  )</span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">  <span class="keyword">input</span> c_i,</span><br><span class="line">  <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">  <span class="keyword">output</span> c_o</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">  <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line">  <span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegA,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegB,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result,</span><br><span class="line">  <span class="keyword">output</span> Carry</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result_temp;</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i0 (</span><br><span class="line">    <span class="variable">.a</span>( RegA ),</span><br><span class="line">    <span class="variable">.b</span>( RegB ),</span><br><span class="line">    <span class="variable">.c_i</span>( <span class="number">1&#x27;b0</span> ),</span><br><span class="line">    <span class="variable">.s</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.c_o</span>( Carry )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> ALU_Result = ALU_Result_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="CPU框架搭建"><a href="#CPU框架搭建" class="headerlink" title="CPU框架搭建"></a>CPU框架搭建</h3><p><img src="/posts/68d8d011.htm/image-20231011161355384.png" alt="image-20231011161355384" style="zoom:80%;"></p><p><img src="/posts/68d8d011.htm/image-20231011165424214.png" alt="image-20231011165424214" style="zoom:80%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpu的制作&quot;&gt;&lt;a href=&quot;#cpu的制作&quot; class=&quot;headerlink&quot; title=&quot;cpu的制作&quot;&gt;&lt;/a&gt;cpu的制作&lt;/h1&gt;&lt;p&gt;cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单cpu的内部结构</title>
    <link href="https://rozen12123.github.io/posts/dee20e4.html"/>
    <id>https://rozen12123.github.io/posts/dee20e4.html</id>
    <published>2023-08-09T16:14:36.000Z</published>
    <updated>2023-10-10T08:16:20.615Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>verilog基础语法</title>
    <link href="https://rozen12123.github.io/posts/20b3f144.html"/>
    <id>https://rozen12123.github.io/posts/20b3f144.html</id>
    <published>2023-08-07T10:56:38.000Z</published>
    <updated>2023-08-09T15:51:29.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="verilog基础语法"><a href="#verilog基础语法" class="headerlink" title="verilog基础语法"></a>verilog基础语法</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Verilog 是区分大小写的。</p><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><p>标识符（identifier）可以是任意一组字母、数字、<strong>$</strong> 符号和 <strong>_</strong>(下划线)符号的合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元符开始。</p><p>关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。</p><p>Verilog 中关键字全部为小写。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter ; <span class="comment">//reg 为关键字， counter 为标识符</span></span><br><span class="line"><span class="keyword">input</span> clk; <span class="comment">//input 为关键字，clk 为标识符</span></span><br><span class="line"><span class="keyword">input</span> CLK; <span class="comment">//CLK 与 clk是 2 个不同的标识符</span></span><br></pre></td></tr></table></figure><p>Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：</p><ul><li>0：逻辑 0 或 “假”</li><li>1：逻辑 1 或 “真”</li><li>x 或 X：未知</li><li>z 或 Z：高阻</li></ul><p><strong>x</strong> 意味着信号数值的不确定，即在实际电路里，信号可能为 1，也可能为 0。</p><p><strong>z</strong> 意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 pad 的 input 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0 。</p><h3 id="整数数值表示方法"><a href="#整数数值表示方法" class="headerlink" title="整数数值表示方法"></a>整数数值表示方法</h3><p>数字声明时，合法的基数格式有 4 种，包括：十进制(‘d 或 ‘D)，十六进制(‘h 或 ‘H)，二进制（’b 或 ‘B），八进制（’o 或 ‘O）。数值可指明位宽，也可不指明位宽。</p><p><strong>指明位宽：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1011</span>         <span class="comment">// 4bit 数值</span></span><br><span class="line"><span class="number">32&#x27;h3022_c0de</span>   <span class="comment">// 32bit 的数值</span></span><br></pre></td></tr></table></figure><p><strong>不指明位宽:</strong></p><p>一般直接写数字时，默认为十进制表示，例如下面的 3 种写法是等效的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">&#x27;d100</span> ; <span class="comment">//一般会根据编译器自动分频位宽，常见的为32bit</span></span><br><span class="line">counter = <span class="number">100</span> ;</span><br><span class="line">counter = <span class="number">32&#x27;h64</span> ;</span><br></pre></td></tr></table></figure><p><code>位宽就是**内存或显存一次能传输的数据量**。 简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。</code></p><p><strong>负数表示</strong></p><p>通常在表示位宽的数字前面加一个减号来表示负数。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d15</span>  </span><br><span class="line">-<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="实数表示方法"><a href="#实数表示方法" class="headerlink" title="实数表示方法"></a>实数表示方法</h3><p>实数表示方法主要有两种方式：</p><p><strong>科学计数法：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="variable">.2e4</span>         <span class="comment">//大小为12000</span></span><br><span class="line"><span class="number">1_0001</span>e4      <span class="comment">//大小为100010000</span></span><br><span class="line"><span class="number">1</span>E-<span class="number">3</span>          <span class="comment">//大小为0.001</span></span><br></pre></td></tr></table></figure><h3 id="字符串表示方法"><a href="#字符串表示方法" class="headerlink" title="字符串表示方法"></a>字符串表示方法</h3><p>字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含<code>回车符</code>。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。例如，为存储字符串 “www.runoob.com”, 需要 14*8bit 的存储单元。例如：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;<span class="comment">//先定义字符串的大小14*8bit </span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="Verilog的数据类型"><a href="#Verilog的数据类型" class="headerlink" title="Verilog的数据类型"></a>Verilog的数据类型</h2><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p><h3 id="线网（wire）"><a href="#线网（wire）" class="headerlink" title="线网（wire）"></a>线网（wire）</h3><p>wire 类型表示硬件单元之间的<code>物理连线</code>，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>   interrupt ;</span><br><span class="line"><span class="keyword">wire</span>   flag1, flag2 ;</span><br><span class="line"><span class="keyword">wire</span>   gnd = <span class="number">1&#x27;b0</span> ;</span><br></pre></td></tr></table></figure><p>线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。</p><h3 id="寄存器（reg）"><a href="#寄存器（reg）" class="headerlink" title="寄存器（reg）"></a>寄存器（reg）</h3><p>寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>    clk_temp;</span><br><span class="line"><span class="keyword">reg</span>    flag1, flag2 ;</span><br></pre></td></tr></table></figure><p>例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rstn ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rstn = <span class="number">1&#x27;b0</span> ;</span><br><span class="line">    #<span class="number">100</span> ;</span><br><span class="line">    rstn = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>当位宽大于 1 时，wire 或 reg 即可声明为向量的形式。例如：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]      counter ;    <span class="comment">//声明4bit位宽的寄存器counter</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>-<span class="number">1</span>:<span class="number">0</span>]  gpio_data;   <span class="comment">//声明32bit位宽的线型变量gpio_data</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">2</span>]     addr ;       <span class="comment">//声明7bit位宽的线型变量addr，位宽范围为8:2</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">31</span>]     data ;       <span class="comment">//声明32bit位宽的寄存器变量data, 最高有效位为0</span></span><br></pre></td></tr></table></figure><p>对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如：</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>]     data_low = data[<span class="number">0</span>:<span class="number">9</span>] ;</span><br><span class="line">addr_temp[<span class="number">3</span>:<span class="number">2</span>] = addr[<span class="number">8</span>:<span class="number">7</span>] + <span class="number">1&#x27;b1</span> ;</span><br></pre></td></tr></table></figure><p>Verilog 支持可变的向量域选择，例如：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]     data1 ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]      byte1 [<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">integer</span> j ;</span><br><span class="line"><span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=<span class="number">3</span>;j=j+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        byte1[j] = data1[(j+<span class="number">1</span>)*<span class="number">8</span>-<span class="number">1</span> : j*<span class="number">8</span>]; </span><br><span class="line">        <span class="comment">//把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。</strong></p><ul><li><strong>[bit+: width]</strong> : 从起始 bit 位开始递增，位宽为 width。</li><li><strong>[bit-: width]</strong> : 从起始 bit 位开始递减，位宽为 width。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">A = data1[<span class="number">31</span>-: <span class="number">8</span>] ;</span><br><span class="line">A = data1[<span class="number">31</span>:<span class="number">24</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">B = data1[<span class="number">0</span>+ : <span class="number">8</span>] ;</span><br><span class="line">B = data1[<span class="number">0</span>:<span class="number">7</span>] ;</span><br></pre></td></tr></table></figure><p><strong>对信号重新进行组合成新的向量时，需要借助大括号。例如：</strong></p><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]    temp1, temp2 ;</span><br><span class="line"><span class="keyword">assign</span> temp1 = &#123;byte1[<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>], data1[<span class="number">31</span>:<span class="number">8</span>]&#125;;  <span class="comment">//数据拼接</span></span><br><span class="line"><span class="keyword">assign</span> temp2 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//赋值32位的数值0</span></span><br></pre></td></tr></table></figure><h2 id="整数，实数，时间寄存器变量"><a href="#整数，实数，时间寄存器变量" class="headerlink" title="整数，实数，时间寄存器变量"></a>整数，实数，时间寄存器变量</h2><p>整数，实数，时间等数据类型实际也属于寄存器类型。</p><p><strong>整数（integer）</strong>(相当于int)</p><p>整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。例如：</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reg [31:0]      data1 ;</span><br><span class="line">reg [3:0]       byte1 [7:0]; //数组变量，后续介绍</span><br><span class="line">integer j ;  //整型变量，用来辅助生成数字电路</span><br><span class="line">always@* begin</span><br><span class="line">    for (j=0; j&lt;=3;j=j+1) begin</span><br><span class="line">        byte1[j] = data1[(j+1)*8-1 : j*8]; </span><br><span class="line">        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>此例中，integer 信号 j 作为辅助信号，将 data1 的数据依次赋值给数组 byte1。综合后实际电路里并没有 j 这个信号，j 只是辅助生成相应的硬件电路。</p><p><code>always@* begin</code>：</p><ul><li>这是一个组合逻辑块的定义，<code>always@*</code>表示该组合逻辑块会在任何输入变化时执行。</li></ul><p><strong>时序逻辑</strong>：</p><ul><li><code>always @ (posedge clk)</code> 表示在时钟上升沿触发的时序逻辑。</li><li>在时钟上升沿触发时，将执行<code>begin</code>和<code>end</code>之间的代码块。</li></ul><p><strong>实数（real）</strong></p><p>实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。例如：</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>        data1 ;</span><br><span class="line"><span class="keyword">integer</span>     temp ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    data1 = <span class="number">2</span>e3 ;</span><br><span class="line">    data1 = <span class="number">3</span><span class="variable">.75</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    temp = data1 ; <span class="comment">//temp 值的大小为3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>时间（time）</strong></p><p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time$ 获取当前仿真时间。例如：</p><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span>       current_time ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">       #<span class="number">100</span> ;</span><br><span class="line">       current_time = <span class="built_in">$time</span> ; <span class="comment">//current_time 的大小为 100</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。</p><p>数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：<strong>&lt;数组名&gt;[&lt;下标&gt;]</strong>。对于多维数组来讲，用户需要说明其每一维的索引。例如：</p><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>          flag [<span class="number">7</span>:<span class="number">0</span>] ; <span class="comment">//8个整数组成的数组</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       counter [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个4bit计数器组成的数组</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]       addr_bus [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个8bit wire型变量组成的数组</span></span><br><span class="line"><span class="keyword">wire</span>             data_bit[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>] ; <span class="comment">//声明1bit wire型变量的二维数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]       data_4d[<span class="number">11</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>] ; <span class="comment">//声明4维的32bit数据变量数组</span></span><br></pre></td></tr></table></figure><p>下面显示了对数组元素的赋值操作：</p><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag [<span class="number">1</span>]   = <span class="number">32&#x27;d0</span> ; <span class="comment">//将flag数组中第二个元素赋值为32bit的0值</span></span><br><span class="line">counter[<span class="number">3</span>] = <span class="number">4&#x27;hF</span> ;  <span class="comment">//将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4&#x27;hF，即可省略宽度; </span></span><br><span class="line"><span class="keyword">assign</span> addr_bus[<span class="number">0</span>]        = <span class="number">8&#x27;b0</span> ; <span class="comment">//将数组addr_bus中第一个元素的值赋值为0</span></span><br><span class="line"><span class="keyword">assign</span> data_bit[<span class="number">0</span>][<span class="number">1</span>]     = <span class="number">1&#x27;b1</span>;  <span class="comment">//将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1&#x27;b1; 是非法的。</span></span><br><span class="line">data_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] = <span class="number">15&#x27;d3</span> ;  <span class="comment">//将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3</span></span><br></pre></td></tr></table></figure><p>虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1。它们在结构的定义上就有所区别。</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。例如：</p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>               membit[<span class="number">0</span>:<span class="number">255</span>] ;  <span class="comment">//256bit的1bit存储器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]        mem[<span class="number">0</span>:<span class="number">1023</span>] ;    <span class="comment">//1Kbyte存储器，位宽8bit</span></span><br><span class="line">mem[<span class="number">511</span>] = <span class="number">8&#x27;b0</span> ;                  <span class="comment">//令第512个8bit的存储单元值为0</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>      data_width = <span class="number">10&#x27;d32</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      mem_size = data_width * <span class="number">10</span> ;</span><br></pre></td></tr></table></figure><p>但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。</p><p>局部参数用 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 localparam 来说明。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p><p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”, 需要 14*8bit 的存储单元：</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;run.runoob.com&quot;</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>有一些特殊字符在显示字符串中有特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前面加前缀转义字符 <strong>\</strong> 。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">显示字符</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">%</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">1到3个8进制数字字符</td></tr></tbody></table></div><p>其实，在 SystemVerilog（主要用于 Verilog 仿真的编程语言）语言中，已经可以直接用关键字 string 来表示字符串变量类型，这为 Verilog 的仿真带来了极大的便利。有兴趣的学者可以简单学习下 SystemVerilog。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a^b ;          <span class="comment">//a与b进行异或操作</span></span><br><span class="line">address[<span class="number">9</span>:<span class="number">0</span>] + <span class="number">10&#x27;b1</span> ;  <span class="comment">//地址累加</span></span><br><span class="line">flag1 &amp;&amp; flag2 ;  <span class="comment">//逻辑与操作</span></span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。</p><p>操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。</p><h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//实数</span></span><br><span class="line"><span class="keyword">real</span> a, b, c;</span><br><span class="line">c = a + b ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       cprmu_1, cprmu_2 ;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cprmu_2 = cprmu_1 ^ cprmu_2 ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">reg</span>  flag1 ;</span><br><span class="line">flag = calculate_result(A, B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//非法操作数</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]         res;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]        temp;</span><br><span class="line"><span class="keyword">always</span>@ （*）<span class="keyword">begin</span></span><br><span class="line">    res    = cprmu_2 – cprmu_1 ;</span><br><span class="line">    <span class="comment">//temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。</p><p>大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 2 种写法都是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自右向左关联，两种写法等价</span></span><br><span class="line">A+B-C ;</span><br><span class="line">(A+B）-C ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span><br><span class="line">A ? B : C ? D : F ;</span><br><span class="line">A ? B : (C ? D : F) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法不等价</span></span><br><span class="line">(A ? B : C) ? D : F ;  <span class="comment">//结果 D 或 F</span></span><br><span class="line">A ? B : C ? D : F ; <span class="comment">//结果为 B、D 或 F</span></span><br></pre></td></tr></table></figure><p>不同操作符之间，优先级是不同的。下表列出了操作符优先级从高至低的排列顺序。当没有圆括号时，Verilog 会根据操作符优先级对表达式进行计算。为了避免由操作符优先级导致的计算混乱，在不确定优先级时，建议用圆括号将表达式区分开来。</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">操作符号</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">单目运算</td><td style="text-align:left">+ - ! ~</td><td style="text-align:left">最高</td></tr><tr><td style="text-align:left">乘、除、取模</td><td style="text-align:left">* / %</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt;  &gt;&gt;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">等价</td><td style="text-align:left">== != === !===</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">归约</td><td style="text-align:left">&amp; ~&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">^ ~^</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">~\</td><td></td><td></td></tr><tr><td style="text-align:left">逻辑</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td></td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">最低</td></tr></tbody></table></div><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>算术操作符包括单目操作符和双目操作符。</p><p>双目操作符对 2 个操作数进行算术运算，包括乘（<em>）、除（/）、加（+）、减（-）、求幂（*</em>）、取模（%）。</p><h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  a, b;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]  c ;</span><br><span class="line">a = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">b = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">c = a+b;        <span class="comment">//结果为c=b&#x27;b1011</span></span><br><span class="line">c = a/b;          <span class="comment">//结果为c=4，取整</span></span><br></pre></td></tr></table></figure><p>如果操作数某一位为 X，则计算结果也会全部出现 X。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">4&#x27;b100x</span> ;</span><br><span class="line">c = a+b ;       <span class="comment">//结果为c=4&#x27;bxxxx</span></span><br></pre></td></tr></table></figure><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。否则，高位将被截断，导致结果高位丢失。无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]        mula ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]        mulb;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>]        res ;</span><br><span class="line">mula = <span class="number">4&#x27;he</span>   ;</span><br><span class="line">mulb = <span class="number">2&#x27;h3</span>   ;</span><br><span class="line">res  = mula * mulb ; <span class="comment">//结果为res=6&#x27;h2a, 数据结果没有丢失位数</span></span><br></pre></td></tr></table></figure><p>+ 和 - 也可以作为单目操作符来使用，表示操作数的正负性。此类操作符优先级最高。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">4</span>  <span class="comment">//表示负4</span></span><br><span class="line">+<span class="number">3</span>  <span class="comment">//表示正3</span></span><br></pre></td></tr></table></figure><p>负数表示时，可以直接在十进制数字前面增加一个减号 <strong>-</strong>，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mula = -<span class="number">4&#x27;d4</span> ;</span><br><span class="line">mulb = <span class="number">2</span> ;</span><br><span class="line">res = mula * mulb ;      <span class="comment">//计算结果为res=-6&#x27;d8, 即res=6&#x27;h38，正常</span></span><br><span class="line">res = mula * (-<span class="number">&#x27;d4</span>) ;    <span class="comment">//(4的32次幂-4) * 2, 结果异常</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符有大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=）。</p><p>关系操作符的正常结果有 2 种，真（1）或假（0）。</p><p>如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">3</span> ;</span><br><span class="line">X = <span class="number">3&#x27;b1xx</span> ;</span><br><span class="line">    </span><br><span class="line">A &gt; B     <span class="comment">//为真</span></span><br><span class="line">A &lt;= B    <span class="comment">//为假</span></span><br><span class="line">A &gt;= Z    <span class="comment">//为X，不确定</span></span><br></pre></td></tr></table></figure><h3 id="等价操作符"><a href="#等价操作符" class="headerlink" title="等价操作符"></a>等价操作符</h3><p>等价操作符包括逻辑相等（ == ） ，逻辑不等（!=），全等（ ===  ），非全等（  !  ）。</p><p>等价操作符的正常结果有 2 种：为真（1）或假（0）。</p><p>逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。</p><p>全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">8&#x27;h04</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bxxxx</span> ;</span><br><span class="line">D = <span class="number">4&#x27;hx</span> ;</span><br><span class="line">A == B        <span class="comment">//为真</span></span><br><span class="line">A == (B + <span class="number">1</span>)  <span class="comment">//为假</span></span><br><span class="line">A == C        <span class="comment">//为X，不确定</span></span><br><span class="line">A === C       <span class="comment">//为假，返回值为0</span></span><br><span class="line">C === D       <span class="comment">//为真，返回值为1</span></span><br></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）。</p><p>逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。</p><p>如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。</p><p>如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。</p><p>逻辑操作符的操作数可以为变量，也可以为表达式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">3</span>; </span><br><span class="line">B = <span class="number">0</span>; </span><br><span class="line">C = <span class="number">2&#x27;b1x</span> ;</span><br><span class="line">    </span><br><span class="line">A &amp;&amp; B    <span class="comment">//     为假</span></span><br><span class="line">A || B    <span class="comment">//     为真</span></span><br><span class="line">! A       <span class="comment">//     为假</span></span><br><span class="line">! B       <span class="comment">//     为真</span></span><br><span class="line">A &amp;&amp; C    <span class="comment">//     为X，不确定</span></span><br><span class="line">A || C    <span class="comment">//     为真，因为A为真</span></span><br><span class="line">(A==<span class="number">2</span>) &amp;&amp; (! B)  <span class="comment">//为真，此时第一个操作数为表达式</span></span><br></pre></td></tr></table></figure><h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><p>按位操作符包括：取反（~），与（&amp;），或（|），异或（^），同或（~^）。</p><p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作。</p><p>如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p><p>取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p><p>下图给出了按位操作符的逻辑规则。</p><div class="table-container"><table><thead><tr><th style="text-align:left">&amp;(与）</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">\</th><th style="text-align:left">(或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th>x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">^(异或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">~^(同或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr></tbody></table></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b0101</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bx010</span> ;</span><br><span class="line">    </span><br><span class="line">~A        <span class="comment">//4&#x27;b1010</span></span><br><span class="line">A &amp; B     <span class="comment">//4&#x27;b0001</span></span><br><span class="line">A | B     <span class="comment">//4&#x27;b1101</span></span><br><span class="line">A^B       <span class="comment">//4&#x27;b1100</span></span><br><span class="line">A ~^ B    <span class="comment">//4&#x27;b0011</span></span><br><span class="line">B | C     <span class="comment">//4&#x27;b1011</span></span><br><span class="line">B&amp;C       <span class="comment">//4&#x27;bx000</span></span><br></pre></td></tr></table></figure><h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（~&amp;），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。</p><p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p><p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">&amp;A ;      <span class="comment">//结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#x27;b0，可用来判断变量A是否全1</span></span><br><span class="line">~|A ;     <span class="comment">//结果为 ~(1 | 0 | 1 | 0) = 1&#x27;b0, 可用来判断变量A是否为全0</span></span><br><span class="line">^A ;      <span class="comment">//结果为 1 ^ 0 ^ 1 ^ 0 = 1&#x27;b0</span></span><br></pre></td></tr></table></figure><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>算术左移和逻辑左移时，右边低位会补 0。</p><p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1100</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">A = A &gt;&gt; <span class="number">2</span> ;        <span class="comment">//结果为 4&#x27;b0011</span></span><br><span class="line">A = A &lt;&lt; <span class="number">1</span>;         <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">A = A &lt;&lt;&lt; <span class="number">1</span> ;       <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">C = B + (A&gt;&gt;&gt;<span class="number">2</span>);    <span class="comment">//结果为 2 + (-4/4) = 1, 4&#x27;b0001</span></span><br></pre></td></tr></table></figure><h3 id="拼接操作符"><a href="#拼接操作符" class="headerlink" title="拼接操作符"></a>拼接操作符</h3><p>拼接操作符用大括号 <strong>{，}</strong> 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。</p><p>拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">B = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">Y1 = &#123;B, A[<span class="number">3</span>:<span class="number">2</span>], A[<span class="number">0</span>], <span class="number">4&#x27;h3</span> &#125;;  <span class="comment">//结果为Y1=&#x27;b1100_0011</span></span><br><span class="line">Y2 = &#123;<span class="number">4</span>&#123;B&#125;, <span class="number">3&#x27;d4</span>&#125;;  <span class="comment">//结果为 Y2=7&#x27;b111_1100</span></span><br><span class="line">Y3 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值</span></span><br></pre></td></tr></table></figure><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件表达式有 3 个操作符，结构描述如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition_expression ? true_expression : false_expression</span><br></pre></td></tr></table></figure><p>计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> hsel    = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b0</span>) ? hsel_p1 : hsel_p2 ;</span><br><span class="line"><span class="comment">//当信号 addr 高 2bit 为 0 时，hsel 赋值为 hsel_p1; 否则，将 hsel_p2 赋值给 hsel。</span></span><br></pre></td></tr></table></figure><p>其实，条件表达式类似于 2 路（或多路）选择器，其描述方式完全可以用 if-else 语句代替。</p><p>当然条件操作符也能进行嵌套，完成一个多次选择的逻辑。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>   hsel = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b00</span>) ? hsel_p1 : </span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b01</span>) ? hsel_p2 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b10</span>) ? hsel_p3 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b11</span>) ? hsel_p4 ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;verilog基础语法&quot;&gt;&lt;a href=&quot;#verilog基础语法&quot; class=&quot;headerlink&quot; title=&quot;verilog基础语法&quot;&gt;&lt;/a&gt;verilog基础语法&lt;/h1&gt;&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilog</title>
    <link href="https://rozen12123.github.io/posts/ffaf1e77.html"/>
    <id>https://rozen12123.github.io/posts/ffaf1e77.html</id>
    <published>2023-08-07T09:51:42.000Z</published>
    <updated>2023-08-09T15:51:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartus"><a href="#Quartus" class="headerlink" title="Quartus"></a>Quartus</h1><h3 id="使用—全加器"><a href="#使用—全加器" class="headerlink" title="使用—全加器"></a>使用—全加器</h3><h3 id="原理图方式（而输入或门）"><a href="#原理图方式（而输入或门）" class="headerlink" title="原理图方式（而输入或门）"></a>原理图方式（而输入或门）</h3><p><img src="/posts/ffaf1e77.htm/image-20230807180738812.png" alt="image-20230807180738812" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181223960.png" alt="image-20230807181223960" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181408224.png" alt="image-20230807181408224" style="zoom:50%;"></p><p>然后完成一个2选1的原理图</p><p><img src="/posts/ffaf1e77.htm/image-20230807181746258.png" alt="image-20230807181746258" style="zoom:50%;"></p><p>然后点击new选择University Program VWF</p><p><img src="/posts/ffaf1e77.htm/image-20230807181829430.png" alt="image-20230807181829430" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181944693.png" alt="image-20230807181944693" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807182059221.png" alt="image-20230807182059221" style="zoom:50%;"></p><p>将其全部移入</p><p><img src="/posts/ffaf1e77.htm/image-20230807182228594.png" alt="image-20230807182228594" style="zoom:50%;"></p><p>选择器件然后点击设置时间。</p><p><img src="/posts/ffaf1e77.htm/image-20230807182426708.png" alt="image-20230807182426708" style="zoom:50%;"></p><h3 id="用verilog进行电路设计"><a href="#用verilog进行电路设计" class="headerlink" title="用verilog进行电路设计"></a>用verilog进行电路设计</h3><p><img src="/posts/ffaf1e77.htm/image-20230807183308472.png" alt="image-20230807183308472" style="zoom:50%;"></p><p>右击选择Insert Template</p><p><img src="/posts/ffaf1e77.htm/image-20230807183728558.png" alt="image-20230807183728558" style="zoom:50%;"></p><p>！！Verilog HDL要求module描述的实例名称必须与储存文件名一致，我们将程序性稍做修改</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quartus II Verilog Template</span></span><br><span class="line"><span class="comment">// Signed adder/subtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder_sub</span><br><span class="line">#(<span class="keyword">parameter</span> WIDTH=<span class="number">16</span>)</span><br><span class="line">(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] datab,</span><br><span class="line"><span class="keyword">input</span> add_sub,  <span class="comment">// if this is 1, add; else subtract</span></span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (add_sub)</span><br><span class="line">result &lt;= dataa + datab;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result &lt;= dataa - datab;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>Verilog HDL程序是以module为基本单位的，形式上以$module<name>$开头,以$endmodule$结尾，模块名称$name$可以由设计者自定，并要求和文件存储名称一致。</name></p></li><li><p>$module<name>$和$endmodule$之间成为<code>模块实体</code>，其包括输入输出端口及数据类型描述，接下来是实际语句体描述。输入输出端口数据名称和类型的描述，要放在模块名称后面，并且用括号括起来。</name></p></li><li><p>输入/输出/双向端口变量描述一般以如下形式，不同端口之间要用逗号<code>，</code>隔开</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="comment">//output 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line"><span class="comment">//bidir 变量宽度 变量名称</span></span><br></pre></td></tr></table></figure></li><li><p>Verilog HDL中主要有两种类型<code>导线型</code>$wire$和<code>寄存器型</code>$reg$。在端口变量描述中$wire$可以省略。</p><p>各种类型容纳变量都是容纳的二进制数，他们能够纳二进制数的位数称之为<code>线宽</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如[7:0],表示有8位宽度的向量，内部的二进制数或存放二进制数的位置编号是7，6，5，4，3，2，1，0</span></span><br></pre></td></tr></table></figure></li><li><p>形参要用parameter保留字来定义，形式为：$parameter 形参名称 = 常数$，大多数情况下形参都用大写字母来表示</p></li><li><p>$lways @ (posedge clk)$是一个结构体语句的头，有多个语句时要用$begin … end$语句括起来，其代表只要clk上升沿到来，该$begin … end$语句体的内容就会被执行一遍。always语句括号内的变量成为敏感变量，多个敏感变量同时存在，用<code>or</code>或者<code>，</code>分开。$posedge$和$negedge$必须在每个敏感变量之前修饰，如果下降沿有效则用$negedge$修饰。</p></li><li><p>$always$中的语句都是按顺序执行的。</p></li><li><p>这个Add_Sub程序中设计了一个16位的加减法运算器，输入输出端口有两个16位的数据导线$dataa$和$datab$一个时钟输入导线$clk$，一个控制选择加减法运算的导线Sub，输出端口是一个16位的寄存器$result$。每当时钟上升沿到来的时刻，依据Sub为0还是1进行加法或者减法运算，并且将结果送到$result$寄存器。</p></li></ol><p>&nbsp;</p><p><img src="/posts/ffaf1e77.htm/image-20230807220923070.png" alt="image-20230807220923070" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartus&quot;&gt;&lt;a href=&quot;#Quartus&quot; class=&quot;headerlink&quot; title=&quot;Quartus&quot;&gt;&lt;/a&gt;Quartus&lt;/h1&gt;&lt;h3 id=&quot;使用—全加器&quot;&gt;&lt;a href=&quot;#使用—全加器&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>acfly飞控</title>
    <link href="https://rozen12123.github.io/posts/a4e8942.html"/>
    <id>https://rozen12123.github.io/posts/a4e8942.html</id>
    <published>2023-07-29T13:25:07.000Z</published>
    <updated>2023-08-09T15:51:29.039Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>立创eda专业版</title>
    <link href="https://rozen12123.github.io/posts/9c8613dc.html"/>
    <id>https://rozen12123.github.io/posts/9c8613dc.html</id>
    <published>2023-07-25T09:58:36.000Z</published>
    <updated>2023-08-11T12:26:02.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="立创eda专业版"><a href="#立创eda专业版" class="headerlink" title="立创eda专业版"></a>立创eda专业版</h1><h2 id="1-新建文档"><a href="#1-新建文档" class="headerlink" title="1.新建文档"></a>1.新建文档</h2><p>创建工程，命名规则如下</p><p>文件名-版本-日期</p><p>例如：GD32F230C8T6-V1.0.0-20230725</p><p>&nbsp;</p><h2 id="2-原理图设计环境设置"><a href="#2-原理图设计环境设置" class="headerlink" title="2.原理图设计环境设置"></a>2.原理图设计环境设置</h2><p>设置—&gt;常规—&gt;设置原理图尺寸为0.1</p><p>保存—&gt;自动保存</p><p><img src="/posts/9c8613dc.htm/image-20230725180844637.png" alt="image-20230725180844637" style="zoom: 50%;"></p><p><img src="/posts/9c8613dc.htm/image-20230725181110414.png" alt="image-20230725181110414" style="zoom:50%;"></p><p>右方图页中可以更改相关信息，例如图纸尺寸，以及右下角的各种信息。</p><p><img src="/posts/9c8613dc.htm/image-20230725182334274.png" alt="image-20230725182334274" style="zoom:50%;"></p><p>&nbsp;</p><h2 id="3-电源转换电路"><a href="#3-电源转换电路" class="headerlink" title="3.电源转换电路"></a>3.电源转换电路</h2><p>在库中，选择器件进行原理图绘制，同时在绘制原理图时要注意对应的封装。</p><p>寻找元器件不仅可以通过==元器件的名称==去找，还可以通过==供应商编号==去找。</p><p><img src="/posts/9c8613dc.htm/image-20230725184044652.png" alt="image-20230725184044652" style="zoom:50%;"></p><p>并且通过折线和文本进行模块化的标注。</p><h2 id="4-查找元器件"><a href="#4-查找元器件" class="headerlink" title="4.查找元器件"></a>4.查找元器件</h2><p>当供应商编号查找不到元器件时，假如是0.1uf的电容，我们可以在立创商城中找到响应的替代品，复制其的器件型号，在专业版的库中进行查找。</p><p>&nbsp;</p><h2 id="5-更改网络标签"><a href="#5-更改网络标签" class="headerlink" title="5.更改网络标签"></a>5.更改网络标签</h2><p>点击网络标签出现预览按钮以后按住tab键即可</p><p>&nbsp;</p><h2 id="原理图转pcb"><a href="#原理图转pcb" class="headerlink" title="原理图转pcb"></a>原理图转pcb</h2><h3 id="1-设置板框"><a href="#1-设置板框" class="headerlink" title="1.设置板框"></a>1.设置板框</h3><p>放置—&gt;板框—&gt;矩形</p><p><img src="/posts/9c8613dc.htm/image-20230725203709836.png" alt="image-20230725203709836" style="zoom:50%;"></p><p>当然我们也可用通过右侧的矩形轮廓，修改板框的大小。</p><p>单击板框右键—&gt;添加—&gt;添加圆角，即可设置板框为圆角</p><p>&nbsp;</p><h3 id="2-规则设置"><a href="#2-规则设置" class="headerlink" title="2.规则设置"></a>2.规则设置</h3><p>设计—&gt;设计规则—&gt;导线设置为8mil—&gt;全部设置为8mil</p><p>设置导线，最小，默认，最大分别为10，10，30</p><p><img src="/posts/9c8613dc.htm/image-20230725205824273.png" alt="image-20230725205824273" style="zoom:50%;"></p><p>添加一个导线规则，最小，默认，最大分别设为10，30，30</p><p><img src="/posts/9c8613dc.htm/image-20230725210044705.png" alt="image-20230725210044705" style="zoom:50%;"></p><p>过孔尺寸按如下设置即可</p><p><img src="/posts/9c8613dc.htm/image-20230725210222093.png" alt="image-20230725210222093" style="zoom:50%;"></p><p>铺铜规则—-&gt;网络间隔和到边框均改为20</p><p><img src="/posts/9c8613dc.htm/image-20230725211405979.png" alt="image-20230725211405979" style="zoom:50%;"></p><p>之后，在网络规则中进行设置</p><p>&nbsp;</p><h3 id="3-绘制定位孔"><a href="#3-绘制定位孔" class="headerlink" title="3.绘制定位孔"></a>3.绘制定位孔</h3><p><code>放置</code>——&gt;<code>挖槽区域</code>——&gt;<code>圆孔</code></p><p><img src="/posts/9c8613dc.htm/image-20230811190718746.png" alt="image-20230811190718746" style="zoom:50%;"></p><p>在右侧可以设置相关参数</p><p><img src="/posts/9c8613dc.htm/image-20230811190950371.png" alt="image-20230811190950371" style="zoom:50%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="4-绘制OLED模块定位孔"><a href="#4-绘制OLED模块定位孔" class="headerlink" title="4.绘制OLED模块定位孔"></a>4.绘制OLED模块定位孔</h3><h4 id="丝印边框"><a href="#丝印边框" class="headerlink" title="丝印边框"></a>丝印边框</h4><p><img src="/posts/9c8613dc.htm/image-20230811191917326.png" alt="image-20230811191917326" style="zoom:67%;"></p><p>1.选择顶层丝印层—&gt;2.网格类型选用正方形—&gt;3.选择为矩形</p><p>&nbsp;</p><h3 id="5-布局"><a href="#5-布局" class="headerlink" title="5.布局"></a>5.布局</h3><p>在原理图中选择<code>对应元器件</code>—-&gt;<code>设计</code>—&gt;<code>布局传递</code></p><p>这样回到pcb图就会自动选择相关元器件</p><p><img src="/posts/9c8613dc.htm/image-20230811192421560.png" alt="image-20230811192421560" style="zoom:67%;"></p><p>ps：丝印放置规则，横着为从左到右，竖着为从上到下</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="6-布线"><a href="#6-布线" class="headerlink" title="6.布线"></a>6.布线</h3><p>常用<code>焊盘</code>，<code>过孔</code>,<code>单路布线</code></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="7-修改位号丝印大小"><a href="#7-修改位号丝印大小" class="headerlink" title="7.修改位号丝印大小"></a>7.修改位号丝印大小</h3><p>右键丝印点击查找</p><p><img src="/posts/9c8613dc.htm/image-20230811201254714.png" alt="image-20230811201254714" style="zoom:50%;"></p><p>查找—-&gt;查找全部—&gt;线宽8mil—&gt;线高70mil</p><p>&nbsp;</p><h3 id="8-添加丝印"><a href="#8-添加丝印" class="headerlink" title="8.添加丝印"></a>8.添加丝印</h3><p><img src="/posts/9c8613dc.htm/image-20230811201619036.png" alt="image-20230811201619036" style="zoom:67%;"></p><p><img src="/posts/9c8613dc.htm/image-20230811201740095.png" alt="image-20230811201740095" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="9-泪滴"><a href="#9-泪滴" class="headerlink" title="9.泪滴"></a>9.泪滴</h3><p><img src="/posts/9c8613dc.htm/image-20230811201848466.png" alt="image-20230811201848466" style="zoom:67%;"></p><p>&nbsp;</p><h3 id="10-铺铜"><a href="#10-铺铜" class="headerlink" title="10.铺铜"></a>10.铺铜</h3><p>点击选择矩形</p><p><img src="/posts/9c8613dc.htm/image-20230811202050096.png" alt="image-20230811202050096" style="zoom:67%;"></p><p>网络选择GND</p><p>图层顶层和底层分别进行铺铜，如果顶层有大面积没有铺铜，在此区域添加过孔然后继续铺铜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;立创eda专业版&quot;&gt;&lt;a href=&quot;#立创eda专业版&quot; class=&quot;headerlink&quot; title=&quot;立创eda专业版&quot;&gt;&lt;/a&gt;立创eda专业版&lt;/h1&gt;&lt;h2 id=&quot;1-新建文档&quot;&gt;&lt;a href=&quot;#1-新建文档&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="eda" scheme="https://rozen12123.github.io/tags/eda/"/>
    
  </entry>
  
  <entry>
    <title>k210与esp32串口通信</title>
    <link href="https://rozen12123.github.io/posts/bfa0354e.html"/>
    <id>https://rozen12123.github.io/posts/bfa0354e.html</id>
    <published>2023-07-07T07:22:55.000Z</published>
    <updated>2023-07-12T13:50:22.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k210与esp32串口通信"><a href="#k210与esp32串口通信" class="headerlink" title="k210与esp32串口通信"></a>k210与esp32串口通信</h1><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO，<strong>外部I对应上图K210的IO而非Maxiduino</strong></p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>&nbsp;</p><h2 id="maxiduino与电脑串口进行通信"><a href="#maxiduino与电脑串口进行通信" class="headerlink" title="maxiduino与电脑串口进行通信"></a>maxiduino与电脑串口进行通信</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">11</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">10</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello word!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="esp32-s3与电脑串口进行通信"><a href="#esp32-s3与电脑串口进行通信" class="headerlink" title="esp32_s3与电脑串口进行通信"></a>esp32_s3与电脑串口进行通信</h2><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://blog.csdn.net/Naisu_kun/article/details/86004049">(8条消息) 使用Arduino开发ESP32（02）：串口（Serial port）使用说明_arduino esp32 serial_Naisu Xu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_50064262/article/details/119006749">(8条消息) ESP32 之 ESP-IDF 教学（九）—— 串口通信（UART）_esp32 idf 串口_Augtons正(单片机)的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1A3411Z7gd/?spm_id_from=333.880.my_history.page.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">40 ESP32之UART串口简介 - 基于Arduino_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k210与esp32串口通信&quot;&gt;&lt;a href=&quot;#k210与esp32串口通信&quot; class=&quot;headerlink&quot; title=&quot;k210与esp32串口通信&quot;&gt;&lt;/a&gt;k210与esp32串口通信&lt;/h1&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32_s3多任务处理</title>
    <link href="https://rozen12123.github.io/posts/a1417d5c.html"/>
    <id>https://rozen12123.github.io/posts/a1417d5c.html</id>
    <published>2023-07-05T13:07:40.000Z</published>
    <updated>2023-07-06T07:47:38.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-S3多任务处理"><a href="#esp32-S3多任务处理" class="headerlink" title="esp32_S3多任务处理"></a>esp32_S3多任务处理</h1><h2 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2><ul><li>多任务的概念：同一时间内执行多个任务，它充分利用CPU资源，提高程序的执行效率。</li><li>对于单核CPU处理多任务，操作系统会给每个运行的任务一小段运行的时间，时间一到，然后立马切换任务，由于交替切换的速度过快，以人的眼光去看感觉每个程序都是同时执行的错觉。</li><li>相对于多核CPU，操作系统会给每个内核安排一个执行的软件同时运行，从而达到同一个时间内执行多任务的效果。</li><li>ESP32的任务和操作系统的进程的概念是一样的</li></ul><ul><li>ESP32有两颗CPU，包含ProtocolcPU（称为CPUO或PRO_CPU）和ApplicationcPu（称为CPU1或APP_CPU）。这两个核实际上是相同的，并且共享相同的内存</li><li>我们之前用的setup和loop方法都是在CPU1上执行的CPUO一直不干活，我们要使用多任务让它动起来。</li><li>保证所有的任务都以合理正确的速率推进，不被其它任务所阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void1oop（）&#123;</span><br><span class="line">task1（）<span class="comment">//这个需要较长的操作，比如59oms</span></span><br><span class="line">task2（）；<span class="comment">//这个需要50ms执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如上代码，任务一的时间较长，但任务二时间较短，就会有一定冲突。此时就适合双线程来完成任务。</p><h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>参考：<a href="https://blog.csdn.net/a568713197/article/details/81542772">(8条消息) UCOS学习笔记（四）时间片轮转调度_ucosii时间片轮转调度_爱吃肉的大高个的博客-CSDN博客</a></p><h3 id="多任务处理相关函数"><a href="#多任务处理相关函数" class="headerlink" title="多任务处理相关函数"></a>多任务处理相关函数</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">tXTaskCreatePinnedToCore</span><span class="params">(TaskFunctiont_t pvTaskcode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="type">const</span> <span class="type">uint32_t</span> usstackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> pvParameters,UBaseType_t uxPriority,TaskHandle_t <span class="type">const</span> pvCreatedTask,<span class="type">const</span> BaseType_t xCoreID)</span>；</span><br></pre></td></tr></table></figure><ul><li>pvTaskCode：指向任务输入函数的指针。任务必须被实现为永不Return（如：死循环），或者应该使用</li><li>vtTaskDelete:函数终止</li><li>pcName：该任务的描述性名称，最大长度16字节</li><li>usStackDepth：指定为字节数的任务堆栈的大小</li><li>pvParameters：将用作所创建的任务的参数的指针，在创建任务的时候可以向任务传递参数。</li><li>uxPriority：任务运行的优先级。目前ESP32的优先级有25级，0-24，数字越大优先级越高，Idle为0，loop任务的优先级是1</li><li>pvCreatedTask：用于传递回所创建任务的句柄</li><li>xCoreID：如果值为tskNOAFFINITY，则创建的任务不会固定到任何CPU，调度程序可以在任何可用的核心上运行。值0或1表示任务应固定到的CPU的索引编号。指定大于（portNUMPROCESSORS-1）的值将导致函数失败</li><li>函数成功返回pdPASS，其它值都是失败。</li></ul><h4 id="任务函数原型"><a href="#任务函数原型" class="headerlink" title="任务函数原型"></a>任务函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> task（<span class="type">void</span>* param）;</span><br></pre></td></tr></table></figure><h4 id="获取任务的优先级"><a href="#获取任务的优先级" class="headerlink" title="获取任务的优先级"></a>获取任务的优先级</h4><p>如果在任务函数里获取本任务的优先级可以使用uxTaskPriorityGet（NULL）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(<span class="type">const</span> TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure><h4 id="获取本任务在哪个CPU上运行"><a href="#获取本任务在哪个CPU上运行" class="headerlink" title="获取本任务在哪个CPU上运行"></a>获取本任务在哪个CPU上运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t IRAM_ATTR <span class="title function_">xPortGetcoreID</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h4><p>如果在任务函数体内使用vTaskDelete（NULL）来结束本任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="互斤量（xSemaphoreHandle）"><a href="#互斤量（xSemaphoreHandle）" class="headerlink" title="互斤量（xSemaphoreHandle）"></a>互斤量（xSemaphoreHandle）</h3><p>互压量又称互床信号量（本质是信号量），是一种特殊的二值信号量，它用于实现对临界资源的独占式处理（它不会屏蔽CPU的中断处理）任意时刻互压量的状态只有两种，开锁或闭锁。当互斤量被任务持有时，该互压量处于闭锁状态，这个任务获得互压量的所有权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle<span class="comment">//互斤锁，也算是一种信号量</span></span><br></pre></td></tr></table></figure><p>创建一个互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle xMutex = xSemaphoreCreateMutex()</span><br></pre></td></tr></table></figure><p>获取互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake (xSemaphore,xBlockTime)</span><br></pre></td></tr></table></figure><p>功能：在普通任务中获取信号量<br>参数：xSemaphore信号量句柄<br>           xBlockTime等待的节拍数，立即返回，portMAX_DELAY等待到信号到来<br>ESP32默认的一节拍是1ms<br>返回值：pdTRUE：获取成功1pdFALSE：获取失败</p><p>释放互压锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive（xSemaphore）</span><br></pre></td></tr></table></figure><p>功能：在普通任务中释放信号量，也就是将信号量设为有信号的状态返回值：pdTRUE：设置成功 ，pdFALSE：设置失败</p><p>&nbsp;</p><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (xSemaphoreTake(xMutex,portMAX_DELAY))</span><br><span class="line">//临界资源处理</span><br><span class="line">xSemaphoreGive(xMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line">xSemaphoreHandle xMutex; <span class="comment">//互斥量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;          <span class="comment">//互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = *((<span class="type">int</span>*)param);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.print(<span class="string">&quot;I am task1, Param: &quot;</span>);</span><br><span class="line">    Serial.print(p);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot; number: %d&quot;</span>, number);</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println();</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.println(<span class="string">&quot;I am task2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      number++;</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  </span><br><span class="line">  TaskHandle_t handle1;</span><br><span class="line">  <span class="type">int</span> param = <span class="number">30</span>;</span><br><span class="line">  xMutex = xSemaphoreCreateMutex();</span><br><span class="line">  xTaskCreatePinnedToCore(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;param, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line">  xTaskCreatePinnedToCore(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; I am loop &quot;</span>, core);</span><br><span class="line">  <span class="keyword">auto</span> pri = uxTaskPriorityGet(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot; priority: %d&quot;</span>, pri);</span><br><span class="line">  Serial.println();</span><br><span class="line">  delay(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">//一个任务的delay不会影响到其它任务的运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY))&#123; </span><br><span class="line"><span class="comment">//临界资源处理</span></span><br><span class="line">xSemaphoreGive（xMutex）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多并行任务创建"><a href="#多并行任务创建" class="headerlink" title="多并行任务创建"></a>多并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_FREERTOS_UNICORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FreeRTOS任务优先级：任务优先级数值越小，任务优先级越低。</span></span><br><span class="line"><span class="comment">一、 FreeRTOS 中任务的最高优先级是通过 FreeRTOSConfig.h 文件中的 configMAX_PRIORITIES 进行</span></span><br><span class="line"><span class="comment">配置的，用户实际可以使用的优先级范围是 0 到 configMAX_PRIORITIES – 1。比如我们配置此宏定</span></span><br><span class="line"><span class="comment">义为 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5。</span></span><br><span class="line"><span class="comment">二、用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0。</span></span><br><span class="line"><span class="comment">三、用户配置宏定义 configMAX_PRIORITIES 的最大值不要超过 32，即用户任务可以使用的优先级</span></span><br><span class="line"><span class="comment">范围是0到31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// define two tasks for Blink &amp; AnalogRead</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the setup function runs once when you press reset or power the board</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize serial communication at 115200 bits per second:</span></span><br><span class="line">  USBSerial.begin(<span class="number">115200</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Now set up two tasks to run independently.</span></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskBlink</span><br><span class="line">    ,  <span class="string">&quot;TaskBlink&quot;</span>   <span class="comment">// A name just for humans</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// This stack size can be checked &amp; adjusted by reading the Stack Highwater</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">2</span>  <span class="comment">// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskAnalogReadA3</span><br><span class="line">    ,  <span class="string">&quot;AnalogReadA3&quot;</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// Stack size</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">1</span>  <span class="comment">// Priority</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Empty. Things are done in Tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*---------------------- Tasks ---------------------*/</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Blink</span></span><br><span class="line"><span class="comment">  Turns on an LED on for one second, then off for one second, repeatedly.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  If you want to know what pin the on-board LED is connected to on your ESP32 model, check</span></span><br><span class="line"><span class="comment">  the Technical Specs of your board.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize digital LED_BUILTIN on pin 13 as an output.</span></span><br><span class="line">  pinMode(<span class="number">45</span>, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="comment">// A Task shall never return or exit.</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(<span class="number">45</span>, HIGH);   <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">    digitalWrite(<span class="number">45</span>, LOW);    <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AnalogReadSerial</span></span><br><span class="line"><span class="comment">  Reads an analog input on pin A3, prints the result to the serial monitor.</span></span><br><span class="line"><span class="comment">  Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)</span></span><br><span class="line"><span class="comment">  Attach the center pin of a potentiometer to pin A3, and the outside pins to +5V and ground.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// read the input on analog pin A3:</span></span><br><span class="line">    <span class="type">int</span> sensorValueA3 = analogRead(A3);</span><br><span class="line">    <span class="comment">// print out the value you read:</span></span><br><span class="line">    USBSerial.print(<span class="string">&quot;A3-&gt;&quot;</span>);</span><br><span class="line">    USBSerial.println(sensorValueA3);</span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="基于多核并行任务创建"><a href="#基于多核并行任务创建" class="headerlink" title="基于多核并行任务创建"></a>基于多核并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//  多线程基于FreeRTOS，可以多个任务并行处理；</span></span><br><span class="line"><span class="comment">//  ESP32具有两个32位Tensilica Xtensa LX6微处理器；</span></span><br><span class="line"><span class="comment">//  实际上我们用Arduino进行编程时只使用到了第一个核（大核），第0核并没有使用</span></span><br><span class="line"><span class="comment">//  多线程可以指定在那个核运行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_MULTCORE 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskOne</span><span class="params">(<span class="type">void</span> *xTask1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task1 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskTwo</span><span class="params">(<span class="type">void</span> *xTask2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task2 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    USBSerial.begin(<span class="number">115200</span>);</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !USE_MULTCORE</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskOne,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskOne&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">1</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskTwo,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskTwo&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">2</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个参数至关重要，决定这个任务创建在哪个核上.PRO_CPU 为 0, APP_CPU 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</span></span><br><span class="line">    xTaskCreatePinnedToCore(xTaskOne, <span class="string">&quot;TaskOne&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(xTaskTwo, <span class="string">&quot;TaskTwo&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial.<span class="built_in">printf</span>(<span class="string">&quot;XTask is running\r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32-S3多任务处理&quot;&gt;&lt;a href=&quot;#esp32-S3多任务处理&quot; class=&quot;headerlink&quot; title=&quot;esp32_S3多任务处理&quot;&gt;&lt;/a&gt;esp32_S3多任务处理&lt;/h1&gt;&lt;h2 id=&quot;多任务介绍&quot;&gt;&lt;a href=&quot;#多任务介</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32开发环境搭建（arduino）</title>
    <link href="https://rozen12123.github.io/posts/ec4b5731.html"/>
    <id>https://rozen12123.github.io/posts/ec4b5731.html</id>
    <published>2023-07-05T06:56:01.000Z</published>
    <updated>2023-07-06T07:47:56.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32开发环境搭建（arduino）"><a href="#esp32开发环境搭建（arduino）" class="headerlink" title="esp32开发环境搭建（arduino）"></a>esp32开发环境搭建（arduino）</h1><h2 id="首先下载arduino-IDE最新版"><a href="#首先下载arduino-IDE最新版" class="headerlink" title="首先下载arduino IDE最新版"></a>首先下载arduino IDE最新版</h2><p>网址：<a href="https://www.arduino.cc/en/software">Software | Arduino</a></p><p><img src="https://i.imgtg.com/2023/07/05/Oxe1Rb.png" alt="Oxe1Rb.png" border="0"></p><p>点击windows win10</p><p><img src="https://i.imgtg.com/2023/07/05/Oxehu6.png" alt="Oxehu6.png" border="0"></p><p>点击just download</p><p>此时即可下载到电脑。</p><h3 id="方法二（github）"><a href="#方法二（github）" class="headerlink" title="方法二（github）"></a>方法二（github）</h3><p>打开网址<a href="https://github.com/arduino/arduino-ide">arduino/arduino-ide: Arduino IDE 2.x (github.com)</a></p><p>点击code<img src="/posts/ec4b5731.htm/OxenFP.png" alt="OxenFP.png" border="0"></p><p>点击Download ZIP下载压缩包，下载完压缩即可。</p><p><a href="https://imgtg.com/image/Oxe79l"><img src="/posts/ec4b5731.htm/Oxe79l.png" alt="Oxe79l.png" border="0"></a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="安装esp32开发环境"><a href="#安装esp32开发环境" class="headerlink" title="安装esp32开发环境"></a>安装esp32开发环境</h2><p>你需要向 Arduino IDE 板管理器添加一个额外的源，然后安装 ESP32。</p><p>打开<code>文件</code> 菜单下的 <code>首选项</code>。</p><p><img src="https://i.imgtg.com/2023/07/05/OxeFEF.png" alt="OxeFEF.png" border="0"></p><p>把下面的链接复制粘贴到 <code>附加开发板管理网址</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/05/OxeeUg.png" alt="OxeeUg.png" border="0"></p><p>再安装 ESP32 开发板，选择 <code>工具</code> 菜单中的 <code>开发板</code> -&gt; <code>开发板管理器...</code></p><p><img src="https://i.imgtg.com/2023/07/05/OxeryB.png" alt="OxeryB.png" border="0"></p><p>在搜索栏搜索esp32，点击安装即可</p><p><img src="https://i.imgtg.com/2023/07/05/OxeAds.png" alt="OxeAds.png" border="0"></p><p>完成安装后即可在 工具—-&gt;开发板中发现esp32</p><p><img src="https://i.imgtg.com/2023/07/05/OxeZaK.png" alt="OxeZaK.png" border="0"></p><p>&nbsp;</p><h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>如果在连接esp32后没有反应则需要下载驱动</p><p>链接：<a href="https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc">https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc</a><br>提取码：m1bc</p><p>下在完可以在<strong>设备管理器</strong>中查看到设备</p><p><img src="https://i.imgtg.com/2023/07/05/Oxevea.png" alt="Oxevea.png" border="0"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;a href=&quot;#esp32开发环境搭建（arduino）&quot; class=&quot;headerlink&quot; title=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;/a&gt;esp32开发环境搭建（arduino）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32WIFI</title>
    <link href="https://rozen12123.github.io/posts/e7f7981b.html"/>
    <id>https://rozen12123.github.io/posts/e7f7981b.html</id>
    <published>2023-07-02T06:20:25.000Z</published>
    <updated>2023-07-06T07:46:04.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WiFi-应用"><a href="#WiFi-应用" class="headerlink" title="WiFi 应用"></a><strong>WiFi</strong> <strong>应用</strong></h1><p>通过前面的实验，我们已经对 ESP32-S2 有了一定的了解。从本章开始，将迎来非常重要实用的内容，那就是 WIFI 应用。ESP32-S2 就是为 WIFI 无线连接而生的。通过本章内容，我们可以看到基于 MicroPython 的 WIFI 开发是多么的简单而美妙。物联网的学习变得非常简单有趣！事不宜迟，马上开始学习。</p><h2 id="连接无线路由器"><a href="#连接无线路由器" class="headerlink" title="连接无线路由器"></a><strong>连接无线路由器</strong></h2><p>⚫ <strong>前言：</strong></p><p>WIFI 是物联网中非常重要的角色，现在基本上家家户户都有 WIFI 网络了，通过 WIFI 接入到互联网，成了智能家居产品普遍的选择。而要想上网，首先需要连接上无线路由器。这一节我们就来学习如何通过 MicroPython 编程连上路由器。</p><p>⚫ <strong>实验目的：</strong></p><p>编程实现连接路由器，将 IP 地址等相关信息通过 OLED 显示（只支持 2.4G网络）。</p><p>⚫ <strong>实验讲解：</strong></p><p>连接路由器上网是我们每天都做的事情，日常生活中我们只需要知道路由器的账号和密码，就能使用电脑或者手机连接到无线路由器，然后上网冲浪。</p><p>MicroPython 已经集成了 network 模块，开发者使用内置的 network 模块函数可以非常方便地连接上路由器。但往往也有各种连接失败的情况，如密码不正确等。这时候我们只需要再加上一些简单的判断机制，避免陷入连接失败的死循环即可！</p><p>我们先来看看 network 基于 WiFi（WLAN 模块）的构造函数和使用方法。</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>wlan = network.WLAN(interface_id)</p><p>构建 WIFI 连接对象。interface_id:分为热点 network.AP_IF 和客户端</p><p>network.STA_IF 模式。</p><p><strong>使用方法</strong></p><p>wlan.active([is_active])</p><p>激活 wlan 接口。Ture：激活；False:关闭。</p><p>wlan.scan ()</p><p>扫描允许访问的 SSID。</p><p>wlan.isconnected()</p><p>检查设备是否已经连接上。返回 Ture:已连接；False：未连接。</p><p>wlan.connected(ssid,passwork)</p><p>WIFI 连接。ssid:账号；passwork：密码。</p><p>wlan.ifconfig([ip,subnet,gateway,dns])</p><p>设备信息配置。ip：IP 地址；subnet:子网掩码；gateway:网关地址；dns:DNS</p><p>信息。<strong>（如果参数为空，则返回当前连接信息。）</strong></p><p>wlan.disconnected()</p><p>断开连接。</p><p>&nbsp;</p><p>从上表可以看到 MicroPython 通过模块封装，让 WIFI 联网变得非常简单。模块包含热点 AP 模块和客户端 STA 模式，热点 AP 是指电脑端直接连接 ESP32-S2发出的热点实现连接，但这样你的电脑就不能上网了，因此我们一般情况下都是使用 STA 模式。也就是电脑和设备同时连接到相同网段的路由器上。模块上电后可以先判断是否已经连接到网络，如果是则无需再次连接，否的话则进入 WIFI 连接状态，指示灯闪烁，连接成功后指示灯常亮，IP 等相关信息通过 OLED 显示和串口打印。另外需要配置超时 15 秒还没连接成功时执行取消连接，避免因无法连接而陷入死循环。代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702142321217.png" alt="image-20230702142321217" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：编程实现连接路由器，将IP地址等相关信息通过OLED显示（只支持2.4G网络）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> network,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;01Studio&#x27;</span>, <span class="string">&#x27;88888888&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行WIFI连接函数</span></span><br><span class="line">WIFI_Connect()</span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>本节是 WIFI 应用的基础，成功连接到无线路由器的实验后，后面就可以做socket 等相关网络通信的应用了。</p><p>&nbsp;</p><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a><strong>Socket</strong> <strong>通信</strong></h2><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了如何通过 MicroPython 编程实现 pyWiFi-ESP32-S2 模块连接到无线路由器。这一节我们则来学习一下 Socket 通信实验。Socket 几乎是整个互联网通信的基础。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 Socket 编程实现 pyWiFi-ESP32-S2 与电脑服务器助手建立连接，相互收发数据。</p><p>⚫ <strong>实验讲解：</strong></p><p>Socket 我们听得非常多了，但由于网络工程是一门系统工程，涉及的知识非常广，概念也很多，任何一个知识点都能找出一堆厚厚的的书，因此我们经常会混淆。在这里，我们尝试以最容易理解的方式来讲述 Socket，如果需要全面了解，可以自行查阅相关资料学习。</p><p>我们先来看看网络层级模型图，这是构成网络通信的基础：</p><p>我们看看 TCP/IP 模型的传输层和应用层，传输层比较熟悉的概念是 TCP 和UDP，UPD 协议基本就没有对 IP 层的数据进行任何的处理了。而 TCP 协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。应用层中网页常用的则是 HTTP。那么我们先来解析一下这 TCP 和 HTTP 两者的关系。我们知道网络通信是最基础是依赖于 IP 和端口的，HTTP 一般情况下默认使用端口 80。举个简单的例子：我们逛淘宝，浏览器会向淘宝网的网址（本质是IP）和端口发起请求，而淘宝网收到请求后响应，向我们手机返回相关网页数据信息，实现了网页交互的过程。而这里就会引出一个多人连接的问题，很多人访问淘宝网，实际上接收到网页信息后就断开连接，否则淘宝网的服务器是无法支撑这么多人长时间的连接的，哪怕能支持，也非常占资源。</p><p>也就是应用层的 HTTP 通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。简单来说，Socket 抽象层介于传输层和应用层之间，跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p>套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议（通常是 <strong>TCP</strong> <strong>或</strong> <strong>UDP</strong>），本地主机的 <strong>IP</strong> <strong>地址，本地进程的协议端**</strong>口，远地主机的<strong>IP</strong> <strong>地址，远地进程的协议端口。</strong></p><p>所以，socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，简单理解就是其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等等。以下是通讯流程：</p><p><img src="/posts/e7f7981b.htm/image-20230702143005669.png" alt="image-20230702143005669" style="zoom:70%;"></p><p>从上图可以看到，建了 Socket 通信需要一个服务器端和一个客户端，以本实验为例，pyWiFi-ESP32-S2 作为客户端，电脑使用网络调试助手作为服务器端，双方使用 TCP 协议传输。对于客户端，则需要知道电脑端的 IP 和端口即可建立连接。（端口可以自定义，范围在 0~65535，注意不占用常用的 80 等端口即可。）以上的内容，简单来说就是如果用户面向应用来说，那么 ESP32-S2 只需要知道<strong>通讯协议是</strong> <strong>TCP</strong> <strong>或</strong> <strong>UDP**</strong>、服务器的<strong> </strong>IP<strong> </strong>和端口号**这 3 个信息，即可向服务器发起连接和发送信息。就这么简单。</p><p>MicroPython 已经封装好相关模块 usocket,跟传统的 socket 大部分兼容，两者均可使用，本实验使用 usocket，对象如下介绍：</p><p><strong>构造函数</strong></p><p>s=usocket.socekt(af=AF_INET, type=SOCK_STREAM,proto=IPPROTO_TCP)</p><p>构建 usocket 对象。</p><p>af: AF_INET→IPV4，AF_INET6 → IPV6；</p><p>type: SCOK_STREAM→TCP，SOCK_DGRAM→UDP；</p><p>proto: IPPROTO_TCP→TCP 协议，IPPROTO_UDP→UDP 协议。</p><p>（如果要构建 TCP 连接，可以使用默认参数配置，即不输入任何参数。）</p><p><strong>使用方法</strong></p><p>addr=usocket.getaddrinfo(‘www.01studio.org’, 80)[0][-1]</p><p>获取 Socket 通信格式地址。返回：(‘47.91.208.161’,80)</p><p>s.connect(address)</p><p>创建连接。address:地址格式为 IP+端口。例：(‘192.168.1.115’,10000)</p><p>s.send(bytes)</p><p>发送。bytes：发送内容格式为字节</p><p>s.recv(bufsize)</p><p>接收数据。bufsize：单次最大接收字节个数。</p><p>s.bind(address)</p><p>绑定，用于服务器角色</p><p>s.listen([backlog])</p><p>监听，用于服务器角色。backlog:允许连接个数，必须大于 0。</p><p>s.accept()</p><p>接受连接，用于服务器角色。</p><p>&nbsp;</p><p>本实验中 pyWiFi-ESP32-S2 属于客户端，因此只用到客户端的函数即可。实验代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702143126631.png" alt="image-20230702143126631" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过Socket编程实现pyWiFi-ESP32与电脑服务器助手建立TCP连接，相互收发数据。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">import</span> network,usocket,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;henu-student&#x27;</span>, <span class="string">&#x27;hbwz12138&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断WIFI是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> WIFI_Connect():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建socket连接TCP类似，连接成功后发送“Hello 01Studio！”给服务器。</span></span><br><span class="line">    s=usocket.socket()</span><br><span class="line">    addr=(<span class="string">&#x27;192.168.1.115&#x27;</span>,<span class="number">10000</span>) <span class="comment">#服务器IP和端口</span></span><br><span class="line">    s.connect(addr)</span><br><span class="line">    s.send(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">    text=s.recv(<span class="number">128</span>) <span class="comment">#单次最多接收128字节</span></span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打印接收到的信息为字节，可以通过decode(&#x27;utf-8&#x27;)转成字符串</span></span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        s.send(<span class="string">&#x27;I got:&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    time.sleep_ms(<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>WIFI 连接代码在上一节已经讲解，这里不再重复，WIFI 连接成功后返回 True，否则返回 False。程序在返回连接成功后建了 Socket 连接，连接成功发送‘Hello 01Studio!’信息到服务器。另外 RTOS 定时器设定了了每 300ms 处理从服务器接收到的数据。将接收到数据通过串口打印和发送给服务器。</p><p>⚫ <strong>实验结果：</strong></p><p>先在电脑端打开网络调试助手并建立服务器，软件在 零一科技（01Studio）MicroPython 开发套件配套资料_latest\01-开发工具\01-Windows\网络调试助手下的 NetAssist.exe ，直接双击打开即可！</p><p><img src="/posts/e7f7981b.htm/image-20230702143433653.png" alt="image-20230702143433653" style="zoom:67%;"></p><p>以下是新建服务器的方法，打开网络调试助手后在左上角协议类型选择 TCP Server；中间的本地 IP 地址是自动识别的，不要修改，这个就是服务器的 IP 地址。然后端口写 10000（0-65535 都可以。），点击连接，成功后红点亮。如下图：</p><p><img src="/posts/e7f7981b.htm/image-20230702143452690.png" alt="image-20230702143452690" style="zoom:80%;"></p><p>在时候服务器已经在监听状态！用户需要根据自己的实际情况自己输入 WIFI信息和服务器 IP 地址+端口。即修改上面的代码以下部分内容。（服务器 IP 和端口可以在网络调试助手找到。）</p><p>WiFi 网络信息：</p><p>wlan.connect(‘01Studio’, ‘88888888’) #输入 WIFI 账号密码</p><p>服务器信息：</p><p>addr=(‘192.168.1.115’,10000) #服务器 IP 和端口</p><p>下载程序，开发板成功连接 WIFI 后，发起了 socket 连接，连接成功可以可以看到网络调试助手收到了开发板发来的信息。在下方列表多了一个连接对象，点击选中</p><p>选中后我们在发送框输入信息“Hi”，点击发送，可以看到开发板的 REPL 打印出来信息 Hi。为字节数据。另外由于程序将收到的信息发回给服务器，所以在网络调试助手中也接收到开发板返回的信息：I got:Hi。</p><p><img src="/posts/e7f7981b.htm/image-20230702143554343.png" alt="image-20230702143554343" style="zoom:60%;"></p><p><img src="/posts/e7f7981b.htm/image-20230702143618314.png" alt="image-20230702143618314" style="zoom:80%;"></p><p>⚫ <strong>总结：</strong></p><p>通过本节学习，我们了解了socket通信原理以及使用MicroPython进行socket编程并且通信的实验。得益于优秀的封装，让我们可以直接面向 socket 对象编程就可以快速实现 socket 通信，从而开发更多的网络应用，例如将前面采集到的传感器数据发送到服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WiFi-应用&quot;&gt;&lt;a href=&quot;#WiFi-应用&quot; class=&quot;headerlink&quot; title=&quot;WiFi 应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;WiFi&lt;/strong&gt; &lt;strong&gt;应用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通过前面的实验，我们已经对 ES</summary>
      
    
    
    
    
    <category term="espe32" scheme="https://rozen12123.github.io/tags/espe32/"/>
    
  </entry>
  
  <entry>
    <title>esp32传感器</title>
    <link href="https://rozen12123.github.io/posts/30e8a1b9.html"/>
    <id>https://rozen12123.github.io/posts/30e8a1b9.html</id>
    <published>2023-07-02T04:20:30.000Z</published>
    <updated>2023-07-06T07:47:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传感器实验"><a href="#传感器实验" class="headerlink" title="传感器实验"></a><strong>传感器实验</strong></h1><p>日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程师驱动一款未接触过的传感器的一般流程是：了解传感器原理、设计电路图、信号时序分析和编程。没个几天折腾不出来。生活中有很多传感器已经是非常通用了，前人已经做好封装函数模块，我们直接调用函数即可。我们不需要将时间花在“怎么用”上，而更多的是考虑“用到什么地方”！</p><h3 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a><strong>温度传感器</strong> <strong>DS18B20</strong></h3><p>⚫ <strong>前言：</strong></p><p>相信没有电子爱好者不知道 DS18B20 的，DS18B20 是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。DS18B20 数字温度传感器接线方便，封装成后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式，型号多种多样。主要根据应用场合的不同而改变其外观。封装后的 DS18B20 可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我，们来看看原理图：</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我们来看看原理图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140646041.png" alt="image-20230702140646041" style="zoom:50%;"></p><p>可以看到 DS18B20 传感器连接到了 pyBase 的 X11 引脚上。也就是连接到pyWiFi-ESP32-S2 的引脚 41，如下图所示：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140747976.png" alt="image-20230702140747976" style="zoom:50%;"></p><p>也就是说我们需要针对引脚 41 编写程序来驱动 DS18B20。那么我们需要自己来编写驱动么？如果你有兴趣的可以自己尝试一下。这部分我们 01Studio 已经收集整理和编写好了，单总线模块文件是：onewire.py，DS18B20 模块的文件是 ds18x20.py。如果你学习过前面基于 STM32 平台应该不陌生。而对于 ESP32-S2,这两个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可！单总线模块（onewire）和 ds18x20 模块说明如下：</p><p><strong>构造函数</strong></p><p>ow=onewire.OneWire(machine.Pin(id))</p><p>构建单总线对象。id:引脚编号；</p><p><strong>使用方法</strong></p><p>ow.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ow.reset()</p><p>总线设备复位。</p><p>ow.readbyte()</p><p>读 1 个字节。</p><p>ow.writebyte(0x12)</p><p>写入 1 个字节。</p><p>ow.write(‘123’)</p><p>写入多个字节。</p><p>ow.select_rom(b’12345678’)</p><p>根据 ROM 编号选择总线上指定设备</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>ds=ds18x20.DS18X20(ow)</p><p>构建 DS18B20 传感器对象。ow:定义好的单总线对象；</p><p><strong>使用方法</strong></p><p>ds.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ds.convert_temp()</p><p>温度转换。</p><p>ds.read_temp(rom)</p><p>获取温度值。rom：表示对应的设备号。</p><p>&nbsp;</p><p>大部分场景下温度的变化不会太频繁，我们可以每隔 1 秒采集一次，显示精度为小数点后 2 位，基本满足大部分应用需求。编程逻辑如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140853444.png" alt="image-20230702140853444" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：温度传感器DS18B20</span></span><br><span class="line"><span class="string">说明：通过编程采集温度数据，并在OLED上显示。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"><span class="keyword">import</span> onewire,ds18x20,time</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化DS18B20</span></span><br><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) <span class="comment">#使能单总线</span></span><br><span class="line">ds = ds18x20.DS18X20(ow)        <span class="comment">#传感器是DS18B20</span></span><br><span class="line">rom = ds.scan()         <span class="comment">#扫描单总线上的传感器地址，支持多个传感器同时连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_get</span>(<span class="params">tim</span>):</span><br><span class="line">    ds.convert_temp()</span><br><span class="line">    temp = ds.read_temp(rom[<span class="number">0</span>]) <span class="comment">#温度显示,rom[0]为第1个DS18B20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#OLED数据显示</span></span><br><span class="line">    oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">    oled.text(<span class="string">&#x27;MicroPython&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;Temp test:&#x27;</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%temp)+<span class="string">&#x27; C&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>) <span class="comment">#显示temp,保留2位小数</span></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(-<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=temp_get) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验拓展：</strong></p><p>pyBase 开发底板预留了外界传感器接口，只要接线正确就可以进行更多的传感器实验。我们将带金属探头的 DS18B20 传感器接到 pyBase 右侧上面的传感器母座，其连接到 pyBase 的“Y11”引脚,也就是对应 pyWiFi-ESP32-S2 的引脚 10。</p><p>所以只要将原程序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) </span><br></pre></td></tr></table></figure><p>改成 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">10</span>))，</span><br></pre></td></tr></table></figure><p>即可驱动外接的 DS18B20。</p><p>⚫ <strong>总结</strong></p><p>DS18B20 作为我们第一个实验传感器，使用 MicroPython 编程非常容易就用起来了，而且精度和稳定性丝毫没有影响。温度传感器只是一个敲门砖，接下来我们将会学习更多的传感器应用。</p><p>&nbsp;</p><h3 id="温湿度传感器-DHT11"><a href="#温湿度传感器-DHT11" class="headerlink" title="温湿度传感器 DHT11"></a><strong>温湿度传感器</strong> <strong>DHT11</strong></h3><p>⚫ <strong>前言：</strong></p><p>温湿度也是我们日常非常常见的指标，我们使用的是 DHT11 数字温湿度传感器。这是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。</p><p>DHT11 具有小体积、极低的功耗，信号传输距离可达 20 米以上，使其成为给类应用甚至最为苛刻的应用场合的最佳选择。产品为 4 针单排引脚封装，连接方便。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温湿度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DHT11 虽然有 4 个引脚，但其中第 3 个引脚是悬空的，也就是说 DHT11 也是单总线的传感器，只占用 1 个 IO 口。</p><p><img src="/posts/30e8a1b9.htm/image-20230702141333793.png" alt="image-20230702141333793" style="zoom:80%;"></p><p>我们来看看 DHT11 在开发板上的接线图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141347945.png" alt="image-20230702141347945" style="zoom:67%;"></p><p>可以看到 DHT11 连接到 pyBase 的‘X12’引脚，也就是连接到 pyWiFi-ESP32-S2 的引脚 42，如下图所示：</p><p>因此可以针对引脚 42 编程来驱动 DHT11 传感器，模块文件是 dht.py。而对于 pyWiFi-ESP32-S2,这个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可。函数模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>d = dht.DHT11(machine.Pin(id))</p><p>构建 DHT11 传感器对象。id:传感器所连接的引脚；</p><p><strong>使用方法</strong></p><p>d.measure()</p><p>测量温湿度。</p><p>d.temperature()</p><p>获取温度值。</p><p>d.humidity()</p><p>获取湿度值</p><p>建议上电先延时 1 秒，让 DHT11 稳定后再开始读取。代码编写流程如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141458320.png" alt="image-20230702141458320" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="人体感应传感器"><a href="#人体感应传感器" class="headerlink" title="人体感应传感器"></a><strong>人体感应传感器</strong></h3><p>⚫ <strong>前言：</strong></p><p>人体感应传感器，在室内安防应用非常普遍，其原理是由探测元件将探测到人体的红外辐射转变成微弱的电压信号，经过放大后输出。为了提高探测器的探测灵敏度以增大探测距离，一般在探测器的前方装设一个塑料的菲涅尔透镜，它和放大电路相配合，可将信号放大 70dB 以上，这样就可以测出 5~10 米范围内人的行动。</p><p>⚫ <strong>实验目的：</strong></p><p>通过外部中断编程来检测人体感应模块，当有人出现时候 OLED 通过“GetPeople!！！”闪烁提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传感器实验&quot;&gt;&lt;a href=&quot;#传感器实验&quot; class=&quot;headerlink&quot; title=&quot;传感器实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;传感器实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32基础实验</title>
    <link href="https://rozen12123.github.io/posts/7fbb683d.html"/>
    <id>https://rozen12123.github.io/posts/7fbb683d.html</id>
    <published>2023-07-01T14:34:17.000Z</published>
    <updated>2023-07-06T07:47:50.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a><strong>基础实验</strong></h1><p>MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的实现，也就是说我们只要理解和熟练相关的函数用法，就可以很好</p><p>的玩转 MicroPython。它让我们可以做到不关心硬件和底层原理（当然有兴趣和能力的小伙伴可以深入研究）而直接跑起硬件。</p><h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 上有 1 个 LED（蓝色），控制 LED 使用 machine 中的 Pin 对</p><p>象，其构造函数和使用方法如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>led=machine.Pin(id,mode,pull)</td></tr><tr><td>构建 led 对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>led.value([x])</td></tr><tr><td>引脚电平值。输出状态：x=0 表示低电平，x=1 表示高电平；输入状态：无须</td></tr><tr><td>参数，返回当前引脚值。</td></tr><tr><td>led.on()</td></tr><tr><td>使引脚输出高电平“1”。</td></tr><tr><td>led.off()</td></tr><tr><td>使引脚输出低电平“0”。</td></tr><tr><td>更详细内容，请查看 micropython 库文档：<a href="https://docs.01studio.cc/">https://docs.01studio.cc/</a></td></tr></tbody></table></div><p>上表对 MicroPython 的 machine 中 Pin 对象做了详细的说明，machine 是大</p><p>模块，Pin 是 machine 下面的其中一个小模块，在 python 编程里有两种方式引用</p><p>相关模块:</p><p><strong>方式</strong> <strong>1</strong> <strong>是</strong>：import machine，然后通过 machine.Pin 来操作；</p><p><strong>方式</strong> <strong>2</strong> <strong>是</strong>：from machine import Pin,意思是直接从 machine 中引入 Pin 模块，</p><p>然后直接通过构建 led 对象来操作。显然方式 2 会显得更直观和方便，本实验也</p><p>是使用方式 2 来编程。代码编写流程如下：</p><p>从原理图可以看到 LED 跟模块引脚 2 相连，通过输出高电平方式点亮</p><p><img src="/posts/7fbb683d.htm/image-20230701223726651.png" alt="image-20230701223726651" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮 LED 蓝灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入 Pin 模块</span></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 led 对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮 LED，也可以使用 led.on()</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>从第一个实验我们可以看到，使用 MicroPython 来开发关键是要学会构造函</p><p>数和其使用方法，便可完成对相关对象的操作，在强大的模块函数支持下，实验</p><p>只用了简单的两行代码便实现了点亮 LED 灯。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h2><p>⚫ <strong>前言：</strong></p><p>按键是最简单也最常见的输入设备，很多产品都离不开按键，包括早期的iPhone。有了按键输入功能，我们就可以做很多好玩的东西了。</p><p>⚫ <strong>实验目的：</strong></p><p>使用按键功能，通过检测按键被按下后，改变 LED（蓝灯）的亮灭状态。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板上有 2 个按键，RST 和 KEY，RST 顾名思义是复位用的，所以真正自带可以用的就只有 1 个按键 KEY。</p><p>让我们先来搞清楚 MicroPython 里面 Pin 模块实现按键的构造函数和使用方法。</p><p>&nbsp;</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>KEY.value()</td></tr><tr><td>引脚电平值。输入状态：无须参数，返回当前引脚值 0 或者 1。</td></tr></tbody></table></div><p>可以看到跟上一节 LED 一样，只是输入/输出状态的一个改变。从下面原理图可以看到，我们只需要在开发板上电后判断 KEY 引脚的电平，当被按下时候引</p><p>脚为低电平“0</p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p><img src="/posts/7fbb683d.htm/image-20230701224121294.png" alt="image-20230701224121294" style="zoom:67%;"></p><p>常用的方法就是当检测按键值为 0 时，延时一段时间，大约 10ms，再判断按键引脚值仍然是 0，是的话说明按键被按下。延时使用 time 模块，使用方法如</p><p>下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 睡眠 1 秒</span></span><br><span class="line">time.sleep_ms(<span class="number">500</span>) <span class="comment"># 睡眠 500 毫秒</span></span><br><span class="line">time.sleep_us(<span class="number">10</span>) <span class="comment"># 睡眠 10 微妙</span></span><br><span class="line">start = time.ticks_ms() <span class="comment"># 获取毫秒计时器开始值</span></span><br><span class="line">delta = time.ticks_diff(time.ticks_ms(), start) <span class="comment"># 计算从上电开始到当前时间</span></span><br><span class="line">的差值</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：按键</span></span><br><span class="line"><span class="string">说明：通过按键改变 LED 的亮灭状态</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 LED 对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建 KEY 对象</span></span><br><span class="line">state=<span class="number">0</span> <span class="comment">#LED 引脚状态</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下</span></span><br><span class="line"> time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state=<span class="keyword">not</span> state <span class="comment">#使用 not 语句而非~语句</span></span><br><span class="line"> LED.value(state) <span class="comment">#LED 状态翻转</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;KEY&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">not</span> KEY.value(): <span class="comment">#检测按键是否松开</span></span><br><span class="line"> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看到，初始化各个对象后，进入循环，当检测到 KEY 的值为0（按键被按下）时候，先做了 10ms 的延时，再次判断；</p><p>state 为 LED 状态的值，每次按键按下后通过使用 not 来改变。这里注意的是在 python 里使用‘not’而不是‘~’的方式。not 返回的是 True 和 False，即</p><p>0,1。而~ 是取反操作，会导致出错。</p><p>&nbsp;</p><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h2><p>⚫ <strong>前言：</strong></p><p>前面我们在做普通的 GPIO 时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如</p><p>某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断</p><p>的在实际项目的应用非常普遍.</p><p>⚫ <strong>实验目的：</strong></p><p>利用中断方式来检查按键 KEY 状态，被按键被按下（产生外部中断）后使 LED</p><p>的亮灭状态翻转</p><p>⚫ <strong>实验讲解：</strong></p><p>外部中断也是通过 machine 模块的 Pin 子模块来配置，我们先来看看其配构</p><p>造函数和使用方法</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th><th></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td><td></td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td><td></td></tr><tr><td><strong>使用方法</strong></td><td></td></tr><tr><td>KEY.irq(handler,trigger)</td><td></td></tr><tr><td>配置中断模式。</td><td></td></tr><tr><td>handler:中断执行的回调函数；</td><td></td></tr><tr><td>trigger: 触发中断的方式，共 4 种，分别是 Pin.IRQ_FALLING（下降沿触发）、</td><td></td></tr><tr><td>Pin.IRQ_RISING（上升沿触发）、Pin.IRQ_LOW_LEVEL（低电平触发）、</td><td></td></tr><tr><td>Pin.IRQ_HIGH_LEVEL（高电平触发）</td></tr></tbody></table></div><p>上升沿和下降沿触发统称边沿触发。从上一节按键可以看到，按键被按下时一个引脚值从 1 到 0 变化的过程，边沿触发就是指这个过程。</p><p><img src="/posts/7fbb683d.htm/image-20230701224921935.png" alt="image-20230701224921935" style="zoom:50%;"></p><p>由此可见，我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产生中断。</p><p>编程思路中断跟按键章节类似，在初始化中断后，当系统检测到外部终端时候，执行 LED 亮灭状态反转的代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：外部中断</span></span><br><span class="line"><span class="string">说明：通过按键改变LED的亮灭状态（外部中断方式）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建LED对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">state=<span class="number">0</span>  <span class="comment">#LED引脚状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LED状态翻转函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state = <span class="keyword">not</span> state</span><br><span class="line">        LED.value(state)</span><br><span class="line"></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中需要注意的地方：</p><p>1、state 是全局变量，因此在 fun 函数里面用该变量必须添加 globalstate 代码，否则会在函数里面新建一个样的变量造成冲突。</p><p>2、在定义回调函数 fun 的时候，需要将 Pin 对象 KEY 传递进去。</p><p>⚫ <strong>总结：</strong></p><p>从参考代码来看，只是用了几行代码就实现了实验功能，而且相对于使用while True 实时检测函数来看，代码的效率大大增强。外部中断的应用非常广，</p><p>出来普通的按键输入和电平检测外，很大一部分输入设备，比如传感器也是通过外部中断方式来实时检测.</p><p>&nbsp;</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><p>⚫ <strong>前言：</strong></p><p>定时器，顾名思义就是用来计时的，我们常常会设定计时或闹钟，然后时间到了就告诉我们要做什么了。单片机也是这样，通过定时器可以完成各种预设好</p><p>的任务。</p><p>⚫ <strong>实验目的：</strong></p><p>通过定时器让 LED 周期性每秒闪烁 1 次。</p><p>⚫ <strong>实验讲解：</strong></p><p>ESP32-S2 内置 RTOS（实时操作系统）定时器，在 machine 的 Timer 模块中。通过 MicroPython 可以轻松编程使用。我们也是只需要了解其构造对象函数和使</p><p>用方法即可！</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>tim=machine.Timer(id)</td></tr><tr><td>构建定时器对象。</td></tr><tr><td>【id】ESP32-S2 有 2 路硬件定时器，id=0~1，也可以定义成-1，即RTOS 虚拟定时器</td></tr><tr><td></td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>tim.init(period,mode,callback)</td></tr><tr><td>定时器初始化。</td></tr><tr><td>period:单位为 ms；</td></tr><tr><td>mode：2 种工作模式，Timer.ONE_SHOT（执行一次）、Timer.PERIODIC（周期性）；callback:定时器中断后的回调函数。</td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类似，代码编程流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701225642158.png" alt="image-20230701225642158" style="zoom:75%;"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：定时器</span></span><br><span class="line"><span class="string">说明：通过定时器让LED周期性每秒闪烁1次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,Timer</span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line">Counter = <span class="number">0</span></span><br><span class="line">Fun_Num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> Counter</span><br><span class="line">    Counter = Counter + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(Counter)</span><br><span class="line">    led.value(Counter%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=fun) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="I2C-总线（OLED-显示屏）"><a href="#I2C-总线（OLED-显示屏）" class="headerlink" title="I2C 总线（OLED 显示屏）"></a><strong>I2C</strong> <strong>总线（</strong>OLED <strong>显示屏）</strong></h3><p>前面学习了按键输入设备后，这一节我们来学习输出设备 OLED 显示屏，其实之前的 LED 灯也算是输出设备，因为它们确切地告诉了我们硬件的状态。只是</p><p>相对于只有亮灭的 LED 而言，显示屏可以显示更多的信息，体验更好。</p><p>⚫ <strong>实验讲解：</strong></p><p><strong>什么是</strong> <strong>I2C**</strong>？**</p><p>I2C 是用于设备之间通信的双线协议，在物理层面，它由 2 条线组成：SCL 和SDA，分别是时钟线和数据线。也就是说不通设备间通过这两根线就可以进行通</p><p>信。</p><p><strong>什么是</strong> <strong>OLED</strong> <strong>显示屏？</strong></p><p>OLED 的特性是自己发光，不像 TFT LCD 需要背光，因此可视度和亮度均高，其次是电压需求低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成</p><p>本低等特点。简单来说跟传统液晶的区别就是里面像素的材料是由一个个发光二极管组成，因为密度不高导致像素分辨率低，所以早期一般用作户外 LED 广告</p><p>牌。随着技术的成熟，使得集成度越来越高。小屏也可以制作出较高的分辨率。</p><p><img src="/posts/7fbb683d.htm/image-20230701230249879.png" alt="image-20230701230249879" style="zoom:50%;"></p><p>在了解完 I2C 和 OLED 显示屏后，我们先来看看 pyBase 开发板的原理图，也就是上面的 OLED 接口是如何连线的。</p><p><img src="/posts/7fbb683d.htm/image-20230701230306218.png" alt="image-20230701230306218" style="zoom:50%;"></p><p>我们从 pyWiFi-ESP32-S2 和 pyBase 相结合的原理图可以看到 GPIO38—Y6—SCL, GPIO40—Y8—SDA 的连接关系：</p><p><img src="/posts/7fbb683d.htm/image-20230701230321167.png" alt="image-20230701230321167" style="zoom:50%;"></p><p>本实验将使用 MicroPython 的 Machine 模块来定义 Pin 口和 I2C 初始化。具体如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>i2c = machine.I2C(scl,sda)i2c = machine.I2C(scl,sda)</td></tr><tr><td>构建 I2C 对象。scl:时钟引脚；sda:数据引脚。构建 I2C 对象。scl:时钟引脚；sda:数据引脚。</td></tr><tr><td><strong>使用方法**</strong>使用方法**</td></tr><tr><td>i2c.scan()i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,nbytes)i2c.readfrom(addr,nbytes)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；</td></tr><tr><td>i2c.write(buf)</td></tr><tr><td>写数据。buf:数据内容；</td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306.py 文件里面。开发者只需要拷贝到 pyBoard 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306.py 文件代码。OLED 显示屏对象介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>oled = SSD1306_I2C(width, height, i2c, addr)</td></tr><tr><td>构 OLED 显示屏对象。width:屏幕宽像素；height: 屏幕高像素；i2c:定义好的</td></tr><tr><td>I2C 对象; addr:显示屏设备地址。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>oled.text(string,x,y)</td></tr><tr><td>将 string 字符写在指定为位置。string：字符；x:横坐标；y:纵坐标。</td></tr><tr><td>oled.show()</td></tr><tr><td>执行显示。</td></tr><tr><td>oled.fill(RGB)</td></tr><tr><td>清屏。RGB：0 表示黑色，1 表示白色。</td></tr></tbody></table></div><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><p><img src="/posts/7fbb683d.htm/image-20230701231539182.png" alt="image-20230701231539182" style="zoom:80%;"></p><h4 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：I2C总线(OLED显示屏)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin         <span class="comment">#从machine模块导入I2C、Pin子模块</span></span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C     <span class="comment">#从ssd1306模块中导入SSD1306_I2C子模块</span></span><br><span class="line"></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))   <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>) <span class="comment">#OLED显示屏初始化：128*64分辨率,OLED的I2C地址是0x3c</span></span><br><span class="line"></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>,  <span class="number">0</span>)      <span class="comment">#写入第1行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>,  <span class="number">0</span>, <span class="number">20</span>)      <span class="comment">#写入第2行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>,  <span class="number">0</span>, <span class="number">50</span>)      <span class="comment">#写入第3行内容</span></span><br><span class="line"></span><br><span class="line">oled.show()   <span class="comment">#OLED执行显示</span></span><br></pre></td></tr></table></figure><p>上述代码中 OLED 的 I2C 地址是 0x3C,不同厂家的产品地址可能预设不一样，具体参考厂家的说明书。或者也可以通过 I2C.scan()来获取设备地址。另外记得将我们提供的示例代码中的 ssd1306.py 驱动文件拷贝到 pyWiFiESP32-S2 的文件系统下，跟 main.py 保持同一个路径。</p><p><img src="/posts/7fbb683d.htm/image-20230701231632416.png" alt="image-20230701231632416" style="zoom:50%;"></p><p>⚫ <strong>总结：</strong></p><p>这一节我们学会了驱动 OLED 显示屏，换着以往如果从使用单片机从 0 开发的话你需要了解 I2C 总线原理，了解 OLED 显示屏的使用手册，编程 I2C 代码，有经验的嵌入式工程师搞不好也要弄个几天。现在基本半个小时解决问题。当然前提是别人已经给你搭好桥了，有了强大的底层驱动代码支持，我们只做好应用就好。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="RTC-实时时钟"><a href="#RTC-实时时钟" class="headerlink" title="RTC 实时时钟"></a><strong>RTC</strong> <strong>实时时钟</strong></h3><p>⚫ <strong>前言：</strong></p><p>时钟可以说我们日常最常用的东西了，手表、电脑、手机等等无时无刻不显示当前的时间。可以说每一个电子爱好者心中都希望拥有属于自己制作的一个电子时钟，接下来我们就用 MicroPython 开发板来制作一个属于自己的电子时钟。</p><p>⚫ <strong>实验讲解：</strong></p><p>实验的原理是读取 RTC 数据，然后通过 OLED 显示。毫无疑问，强大的MicroPython 已经集成了内置时钟函数模块。位于 machine 的 RTC 模块中，具体介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>rtc=machine.RTC()</td></tr><tr><td>构建 RTC 对象。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>rtc.datetime((2019, 4, 1, 0, 0, 0, 0, 0))</td></tr><tr><td>设置日期和时间。按顺序分别是：（年，月，日，星期，时，分，秒，微秒），</td></tr><tr><td>其中星期使用 0-6 表示周一至周日。</td></tr><tr><td>rtc.datetime()</td></tr><tr><td>获取当前日期和时间</td></tr></tbody></table></div><p>从上表可以看到 RTC()的使用方法，我们需要做的就是先设定时间，然后再获取当前芯片里的时间，通过 OLED 显示屏显示，如此循环。在循环里，如果一直获取日期时间数据会造成资源浪费，所以可以每隔第一段时间获取一次数据，又由于肉眼需要看到至少每秒刷新一次即可，这里每隔 300ms 获取一次数据，使用前面学习过的 RTOS 定时器来计时，具体编程流程如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701232806658.png" alt="image-20230701232806658" style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：RTC实时时钟</span></span><br><span class="line"><span class="string">说明：使用Thonny连接开发板会自动更新RTC时间</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, SoftI2C, RTC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义星期和时间（时分秒）显示字符列表</span></span><br><span class="line">week = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tues&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">time_list = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化所有相关对象</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>)) <span class="comment">#I2C初始化：sda--&gt;40, scl--&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">rtc = RTC()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次上电配置时间，按顺序分别是：年，月，日，星期，时，分，秒，次秒级；这里做了</span></span><br><span class="line"><span class="comment"># 一个简单的判断，检查到当前年份不对就修改当前时间，开发者可以根据自己实际情况来</span></span><br><span class="line"><span class="comment"># 修改。</span></span><br><span class="line"><span class="keyword">if</span> rtc.datetime()[<span class="number">0</span>] != <span class="number">2023</span>:</span><br><span class="line">    rtc.datetime((<span class="number">2021</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RTC_Run</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    datetime = rtc.datetime()  <span class="comment"># 获取当前时间</span></span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;RTC Clock&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)  <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示日期，字符串可以直接用“+”来连接</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(datetime[<span class="number">0</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">1</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">2</span>]) + <span class="string">&#x27; &#x27;</span> + week[datetime[<span class="number">3</span>]], <span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间需要判断时、分、秒的值否小于10，如果小于10，则在显示前面补“0”以达</span></span><br><span class="line">    <span class="comment"># 到较佳的显示效果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">if</span> datetime[i] &lt; <span class="number">10</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间</span></span><br><span class="line">    oled.text(time_list[<span class="number">0</span>] + <span class="built_in">str</span>(datetime[<span class="number">4</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">1</span>] + <span class="built_in">str</span>(datetime[<span class="number">5</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">2</span>] + <span class="built_in">str</span>(datetime[<span class="number">6</span>]), <span class="number">0</span>, <span class="number">55</span>)</span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器</span></span><br><span class="line">tim = Timer(<span class="number">0</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=RTC_Run) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于实验要用到 OLED 显示屏，所以同样别忘了将示例代码该实验文件夹下的 ssd1306.py 文件复制到 pyWiFi-ESP32-S2 的文件系统里面。</p><p>由于 ESP32-S2 没有后备电池引脚，所以不支持掉电保存。因此 pybase 上面的纽扣电池是不起作用的。</p><p>⚫ <strong>总结：</strong></p><p>细心的用户或许已经发现运行程序后 RTC 时间自动更新，那是因为 thonny每次连接 MicroPython 开发板会自动更新开发板的 RTC 时间。</p><p>RTC 实时时钟的可玩性很强，我们还可以根据自己的风格来设定数字显示位置，以及加上一些属于自己的字符标识。打造自己的电子时钟。</p><p>&nbsp;</p><h3 id="ADC（电位器）"><a href="#ADC（电位器）" class="headerlink" title="ADC（电位器）"></a><strong>ADC</strong>（电位器）</h3><p>⚫ <strong>前言：</strong></p><p>ADC(analog to digital conversion) 模拟数字转换。意思就是将模拟信号转化成数字信号，由于单片机只能识别二级制数字，所以外界模拟信号常常会通过 ADC转换成其可以识别的数字信息。常见的应用就是将变化的电压转成数字信号。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程调用 MicroPython 的内置 ADC 函数，实现测量输入电压，并显示到屏幕上。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyBase 开发底板的 X7 引脚连接到了电位器，通过电位器的调节可以使得 X7引脚上的电压变化范围实现从 0-3.3V。</p><p><img src="/posts/7fbb683d.htm/image-20230701233122746.png" alt="image-20230701233122746" style="zoom:50%;"></p><p><img src="/posts/7fbb683d.htm/image-20230701233132565.png" alt="image-20230701233132565" style="zoom:50%;"></p><p>从上图可以看到，电位器引脚对应 pyBase 的 X7,实际是跟 pyWiFi-ESP32-S2</p><p>的‘</p><p>6’引脚 ADC 输入引脚相连。ESP32-S2 的 ADC 默认只能测量 0-1V 的量程，</p><p>但 ESP32-S2 内部集成了衰减器，最大支持 11dB 衰减，通过配置衰减器最多能测</p><p>量 3V 左右的电压。我们来看看 ADC 模块的构造函数和使用方法。</p><p><strong>构造函数</strong></p><p>adc=machine.ADC(Pin(id))</p><p>构建 ADC 对象。</p><p>【id】目前仅支持 ESP32-S2 的 ADC1，共 10 个通道：</p><p>GPIO1: ADC1_0</p><p>GPIO2: ADC1_1</p><p>GPIO3: ADC1_2</p><p>GPIO4: ADC1_3</p><p>GPIO5: ADC1_4</p><p>GPIO6: ADC1_5</p><p>GPIO7: ADC1_6</p><p>GPIO8: ADC1_7</p><p>GPIO9: ADC1_8</p><p>GPIO10: ADC1_9</p><p><strong>使用方法</strong></p><p>adc.read()</p><p>获取 ADC 值。测量精度是 13 位，返回 0- 8191（表示 0-1V）。</p><p>adc.atten(attenuation)</p><p>配置衰减器。配置衰减器能增加电压测量范围，但是以精度为代价的。</p><p>attenuation:衰减设置</p><p>ADC.ATTN_0DB： 0dB 衰减, 最大输入电压为 1.00v - 这是默认配置；</p><p>ADC.ATTN_2_5DB： 2.5dB 衰减, 最大输入电压约为 1.34v；</p><p>ADC.ATTN_6DB：6dB 衰减, 最大输入电压约为 2.00v；</p><p>ADC.ATTN_11DB：11dB 衰减, 最大输入电压约为 3.3v。</p><p>你没看错，就这么简单，两句函数就可以获得 ADC 数值。我们将在本实验中以默认的量程 0-1V 来测试。让我们来理顺一下编程逻辑。先导入相关模块，然后初始化模块。在循环中不断读取 ADC 的值，转化成电压值后在 OLED 上面显示，每隔 300 毫秒读取一次，具体如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701233235973.png" alt="image-20230701233235973" style="zoom:75%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：ADC-电压测量</span></span><br><span class="line"><span class="string">说明：通过对ADC数据采集，转化成电压在显示屏上显示。ADC精度13位（0~8191），默认电压0-1V。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,ADC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))  <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">adc = ADC(Pin(<span class="number">6</span>)) <span class="comment">#6引脚跟pyBase的电位器相连接</span></span><br><span class="line">adc.atten(ADC.ATTN_11DB) <span class="comment">#开启衰减，测量量程增大到3.3V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ADC_Test</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;ADC&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)      <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取ADC数值</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(adc.read()),<span class="number">0</span>,<span class="number">40</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;(8191)&#x27;</span>,<span class="number">60</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算电压值，获得的数据0-4095相当于0-1V，（&#x27;%.2f&#x27;%）表示保留2位小数</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%(adc.read()/<span class="number">8191</span>*<span class="number">3.3</span>)),<span class="number">0</span>,<span class="number">55</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;V&#x27;</span>,<span class="number">40</span>,<span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启定时器</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=ADC_Test) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>这一节我们学习了 ADC 的应用，主要用于电压的检测。有兴趣的用户可以尝试使用其衰减器测试，可以扩充电压量程，但精度会有所下降。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM（无源蜂鸣器）"><a href="#PWM（无源蜂鸣器）" class="headerlink" title="PWM（无源蜂鸣器）"></a><strong>PWM</strong>（无源蜂鸣器）</h3><p>⚫ <strong>前言：</strong></p><p>上一节的 ADC 是信号输入，这节的 PWM 就是一个信号输出。PWM（脉冲宽度调制），主要用于输出不同频率、占空比（一个周期内高电平出现时间占总时间比例）的方波。以实现固定频率或平均电压输出。</p><p>⚫ <strong>实验目的：</strong></p><p>通过不同频率的 PWM 信号输出，驱动无源蜂鸣器发出不同频率的声音。</p><p>⚫ <strong>实验讲解：</strong></p><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyWiFi-ESP32-S2 的 PWM 输出频率是在变化的。pyBase 开发底板上的无源蜂鸣器连接到 pyBase 引脚 X5。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702110722346.png" alt="image-20230702110722346" style="zoom:50%;"></p><p>从 pyWiFi-ESP32-S2 原理图可以看到由底板蜂鸣器 X5 连接到 ESP32-S2 的引脚 4。</p><p><img src="/posts/7fbb683d.htm/image-20230702110739134.png" alt="image-20230702110739134" style="zoom:50%;"></p><p>PWM 可以通过 ESP32-S2 所有 GPIO 引脚输出. 所有通道都有 1 个特定的频率，从 0 到 40M 之间（单位是 Hz）。占空比的值为 0 至 1023 之间。在本实验中我们用到引脚 4。</p><p>先看看 PWM 模块对象：</p><p><strong>构造函数</strong></p><p>pwm=machine.PWM(machine.Pin(id),freq,duty)</p><p>构建 PWM 对象。id:引脚编号；freq:频率值；duty:占空比；配置完后 PWM 自</p><p>动生效。</p><p><strong>使用方法</strong></p><p>pwm.freq(freq)</p><p>设置频率。freq:频率值在 1-1000 之间，freq 为空时表示获取当前频率值。</p><p>pwm.duty(duty)</p><p>设置占空比。duty:占空比在 0-1023 之间，duty 为空时表示获取当前占空比值。</p><p>pwm.deinit()</p><p>关闭 PWM。</p><p>无源蜂鸣器我们可以用特定频率的方波来驱动，方波的原理很简单，就是一定频率的高低电平转换，可以简单理解成占空比为 50%的 PWM 输出。</p><p>结合上述讲解，总结出代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：PWM</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过不同频率的PWM信号输出，驱动无源蜂鸣器发出不同频率的声音。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">Beep = PWM(Pin(<span class="number">4</span>), freq=<span class="number">0</span>, duty=<span class="number">512</span>) <span class="comment"># 在同一语句下创建和配置PWM,占空比50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率200Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">200</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率400Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">400</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率600Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">600</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率800Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">800</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率1000Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">1000</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">Beep.deinit()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART</strong>（串口通信）</h3><p>⚫ <strong>前言：</strong></p><p>串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板一共有 2 个串口，编号是 0-1，如下表：</p><div class="table-container"><table><thead><tr><th>UART(0)</th><th>TX</th><th>43</th></tr></thead><tbody><tr><td></td><td>RT</td><td>44</td></tr><tr><td>UART(1)</td><td>TX</td><td>任意映射IO</td></tr><tr><td></td><td>RX</td><td>任意映射IO</td></tr></tbody></table></div><p>由于 UART0 用于下载和 REPL 调试，因此我们使用 UART1 来进行本节实验。</p><p>我们先来了解一下串口对象的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>uart=machine.UART(id,baudrate,tx=None,rx=None bits=8, parity=None, stop=1,…)</p><p>创建 UART 对象。</p><p>【id】0-1</p><p>【baudrate】波特率，常用 115200、9600</p><p>【tx】自定义 IO</p><p>【rx】自定义 IO</p><p>【bits】数据位</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>…</p><p>特别说明： ESP32-S2 的 UART 引脚映射到其它 IO 来使用，用户可以通过构造</p><p>函数时候指定如 tx=8,rx=9 的方式来改变串口引脚，实现更灵活的应用。</p><p><strong>使用方法</strong></p><p>uart.deinit()</p><p>关闭串口</p><p>uart.any()</p><p>返回等待读取的字节数据，0 表示没有</p><p>uart.read([<em>nbytes</em>])</p><p>【nbytes】读取字节数</p><p>UART.readline()</p><p>读行</p><p>UART.write(<em>buf</em>)</p><p>【buf】串口 TX 写数据</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p><img src="/posts/7fbb683d.htm/image-20230702111650095.png" alt="image-20230702111650095" style="zoom:50%;"></p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用串口 2，也就是 8（TX）和 9（RX），接线示意图如下：</p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：串口通信</span></span><br><span class="line"><span class="string">说明：通过编程实现串口通信，跟电脑串口助手实现数据收发。</span></span><br><span class="line"><span class="string">平台：pyWiFi-ESP32</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入串口模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line">uart=UART(<span class="number">1</span>,<span class="number">115200</span>,rx=<span class="number">9</span>,tx=<span class="number">8</span>) <span class="comment">#设置串口号1和波特率</span></span><br><span class="line"></span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)<span class="comment">#发送一条数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断有无收到信息</span></span><br><span class="line">    <span class="keyword">if</span> uart.<span class="built_in">any</span>():</span><br><span class="line"></span><br><span class="line">        text=uart.read(<span class="number">128</span>) <span class="comment">#接收128个字符</span></span><br><span class="line">        <span class="built_in">print</span>(text) <span class="comment">#通过REPL打印串口3接收的数据</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>我们按照上述方式将 USB 转 TTL 的 TX 接到开发板的 RX（</p><p>9），USB 转 TTL 的</p><p>RX 接到开发板的 TX（</p><p>8）。GND 接一起，3.3V 可以选择接或不接。</p><p>根据上图设备管理器里面的信息，将串口工具配置成 COM14，REPL 串口配置成 COM27（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到开发板上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到 pyWiFi-ESP32-S2 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702111909798.png" alt="image-20230702111909798" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="LCD-显示屏"><a href="#LCD-显示屏" class="headerlink" title="LCD 显示屏"></a><strong>LCD</strong> <strong>显示屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>前面用到的 OLED 显示屏虽然能显示信息，但是颜色只有黑白，而且分辨率也比较低 128x64，本节我们来学习 3.2 寸 TFT_LCD 彩色显示屏的使用方法。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 MicorPython 编程方式实现 LCD 的各种显示功能，包括画点、线、矩形、圆形、显示英文、显示图片等</p><p>&nbsp;</p><p>实验用的 LCD 是 3.2 寸，驱动是的 ILI9341，使用 SPI 方式跟 ESP32-S2 通信，按以往嵌入式 C 语言开发，我们需要对 ILI9341 进行编程实现驱动，然后再建立各种描点、划线、以及显示图片函数。</p><p>使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点我们只需要搞清各个对象函数使如何使用即可。总的来说和前面实验一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉开发板该外设是怎么接线，初始化参数如何，而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！</p><p>我们管这些函数的集合叫<strong>驱动</strong>，驱动可以是预先在固件里面，也可以通过.py文件存放在开发板文件系统。也就是说工程师已经将复杂的底层代码封装好，我们顶层直接使用 python 开发即可，人生苦短。我们来看看 pyWiFi-ESP32-S2P 开发板 3.2 寸 LCD 的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>tftlcd.LCD32(portrait=1)</p><p>构建 3.2 寸 LCD 对象。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p>LCD32.fill(color)</p><p>【color】RGB 颜色数据；如(255,0,0)表示红色。</p><p>LCD32.drawPixel(x,y,color)</p><p>画点。</p><p>【x】:横坐标，</p><p>【y】:纵坐标，</p><p>【color】:颜色。</p><p>LCD32.drawLine(x0,y0,x1,y1,color)</p><p>画线段。</p><p>【x0,y0】:起始坐标，</p><p>【x1,y1】:终点坐标，</p><p>【color】:颜色</p><p>LCD32.drawRect(x,y,width,height,color,border=1,fillcolor=None)</p><p>画矩形。</p><p>【</p><p>x,y】:起始坐标，</p><p>【width】:宽度，</p><p>【height】:高度，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.drawCircle(x,y,radius,color,border=1,fillcolor=None)</p><p>画圆。</p><p>【x, y】:圆心，</p><p>【radius】:半径，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.printStr(text,x,y,color,backcolor=None,size=2)</p><p>写字符。</p><p>【text】:字符，</p><p>【x,y】:起始坐标,</p><p>【color】:字体颜色；</p><p>【backcolor】:字体背景颜色；</p><p>【size】:字体尺寸（1-小号，2-标准，3-中号，4-大号）</p><p>LCD32.Picture(x,y,filename)</p><p>显示图片。支持图片格式类型：jpg、bmp</p><p>【x,y】:起始坐标。</p><p>【filename】: 图片路径+名称，如：”/cat.jpg”</p><p><strong>（‘</strong>/<strong>’表示开发板的板载</strong> <strong>flash</strong> <strong>的根目录。）</strong></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们在使用中将以上功能都跑一遍先看看编程流程图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：3.2寸LCD液晶显示屏</span></span><br><span class="line"><span class="string">说明：通过编程实现LCD的各种显示功能，包括填充、画点、线、矩形、圆形、显示英文、显示图片等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义常用颜色</span></span><br><span class="line">RED = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">GREEN = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">BLUE = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line"><span class="comment"># 构建3.2寸LCD对象并初始化</span></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认方向竖屏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充白色</span></span><br><span class="line">d.fill(WHITE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画点</span></span><br><span class="line">d.drawPixel(<span class="number">5</span>, <span class="number">5</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画线段</span></span><br><span class="line">d.drawLine(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画矩形</span></span><br><span class="line">d.drawRect(<span class="number">5</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">40</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画圆</span></span><br><span class="line">d.drawCircle(<span class="number">100</span>, <span class="number">120</span>, <span class="number">30</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写字符,4种尺寸</span></span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">200</span>, RED, size=<span class="number">1</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">230</span>, GREEN, size=<span class="number">2</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">270</span>, BLUE, size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment">#等待5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/1.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/2.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/01studio.jpg&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>将示例程序的素材文件上传到 pyWiFi-ESP32-S2P 开发板。<strong>（也可以只上传单</strong>张图片，注意修改代码中文件的路径即可。）</p><p>&nbsp;</p><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了 LCD 实验，但 LCD 只能显示相关内容，跟人是缺乏交互的。好比我们的智能手机，如果只有显示不能触碰，那么就没有可玩性了。因此本节学习一下 3.2 寸 LCD 的电阻触摸屏使用方法。</p><p>⚫ <strong>实验讲解：</strong></p><p>01Studio 配套的 3.2 寸 LCD 上带电阻触摸屏,驱动芯片为 XPT2046。当手指按下时候，通过简单的编程即可返回一个坐标，我们来看看其 micropython 构造函数和使用方法：</p><p><strong>构造函数</strong></p><p><strong>touch.XPT2046(portrait=1)</strong></p><p>构建触摸屏对象。<strong>XPT2046</strong> 表示驱动芯片型号。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p><strong>XPT2046.tick_inc()</strong></p><p>手动刷新触摸。</p><p><strong>XPT2046.read()</strong></p><p>读取触摸屏数据，返回（states,x,y）</p><p>【states】-当前触摸状态：0：按下；1：移动；2：松开。</p><p>【x】:触摸横坐标</p><p>【y】:触摸纵坐标</p><p>&nbsp;</p><p>学会了触摸对象用法后，我们可以编程实现触摸后屏幕打点表示，然后左上角显示当前触摸的坐标。另外再加入一个按键，按下清空屏幕。编程流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：电阻触摸屏</span></span><br><span class="line"><span class="string">说明：电阻触摸屏采集触摸信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> touch <span class="keyword">import</span> XPT2046</span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色</span></span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line">RED=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认竖屏</span></span><br><span class="line">d.fill(WHITE) <span class="comment">#填充白色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#电阻触摸屏初始化，方向和LCD一致</span></span><br><span class="line">t = XPT2046(portrait=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    </span><br><span class="line">    d.fill(WHITE) <span class="comment">#清屏</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#USR按键初始化</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    data = t.read() <span class="comment">#获取触摸屏坐标</span></span><br><span class="line">    <span class="built_in">print</span>(data) <span class="comment">#REPL打印</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当产生触摸时</span></span><br><span class="line">    <span class="keyword">if</span> data[<span class="number">0</span>]!=<span class="number">2</span>: <span class="comment">#0：按下； 1：移动； 2：松开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#触摸坐标画圆</span></span><br><span class="line">        d.drawCircle(data[<span class="number">1</span>], data[<span class="number">2</span>], <span class="number">5</span>, BLACK, fillcolor=BLACK)</span><br><span class="line">        d.printStr(<span class="string">&#x27;(X:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">1</span>])+<span class="string">&#x27; Y:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">2</span>])+<span class="string">&#x27;)&#x27;</span>,<span class="number">10</span>,<span class="number">10</span>,RED,size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep_ms(<span class="number">20</span>) <span class="comment">#触摸响应间隔</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>运行程序，首次运行会自动提示进行触摸校准（电阻屏需要校准），按提示分别点击四个角落进行校准，如校准失败会自动重复。校准成功会自动保存一个“touch.cail”文件到开发板 flash，下次无须再校准。</p><p>成功后出现空白画面，用手指触摸屏幕或者在屏幕上滑动，可以看到描点并在 LCD 左上角显示当前坐标。</p><p>重启开发板，可以看到文件系统多了一个“touch.cail”，在运行电阻屏初始化时候会检测这个文件，如果存在则不进行校准，若想重新校准的用户可以把这个文件删除即可！</p><p>⚫ <strong>总结：</strong></p><p>没有触摸屏的 LCD 就失去了灵魂，有了触摸屏，跟开发板的交互就变得有意思了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础实验&quot;&gt;&lt;a href=&quot;#基础实验&quot; class=&quot;headerlink&quot; title=&quot;基础实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32</title>
    <link href="https://rozen12123.github.io/posts/86375cb2.html"/>
    <id>https://rozen12123.github.io/posts/86375cb2.html</id>
    <published>2023-07-01T13:55:14.000Z</published>
    <updated>2023-07-06T07:47:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32"><a href="#esp32" class="headerlink" title="esp32"></a>esp32</h1><h2 id="ESP32-S2-平台"><a href="#ESP32-S2-平台" class="headerlink" title="ESP32-S2 平台"></a><strong>ESP32-S2</strong> <strong>平台</strong></h2><h3 id="pyWiFi-ESP32-S2"><a href="#pyWiFi-ESP32-S2" class="headerlink" title="pyWiFi-ESP32-S2"></a><strong>pyWiFi-ESP32-S2</strong></h3><p>pyWiFi-ESP32-S2 是由 01Studio 设计研发，基于 ESP32-S2 平台的 MicroPython</p><p>开发板，主要特点如下：</p><p> 自动下载电路</p><p> 板载锂电池输入接口和充电电路</p><p> 标准 24P 摄像头接口</p><p> USB OTG 接口</p><p> 全 IO 引出</p><p> 按键和 LED 排列整齐，丝印清晰</p><p> 兼容 pyBoard 接口</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701220231747.png" class title="image-20230701220231747"><img src="/posts/86375cb2.htm/86375cb2/image-20230701220244595.png" class title="image-20230701220244595"><h3 id="开发环境快速建立"><a href="#开发环境快速建立" class="headerlink" title="开发环境快速建立"></a><strong>开发环境快速建立</strong></h3><p>ESP32-S2 是基于是继 ESP32 普遍板后推出的一个版本，主要特点是引脚数量非常多。还支持标准 USB HOST。</p><h4 id="安装开发软件-Thonny"><a href="#安装开发软件-Thonny" class="headerlink" title="安装开发软件 Thonny"></a><strong>安装开发软件</strong> <strong>Thonny</strong></h4><p>Thonny Python IDE 是一款开源软件，以极简方式设计，对 MicroPython 的兼容性非常友善。而且支持 Windows、Mac OS、Linux、树莓派。由于开源，所以软</p><p>件迭代速度非常快，功能日趋成熟。具体安装方法如下：在 <a href="https://thonny.org/">https://thonny.org/</a> 下载最新版，选择自己的开发平台进行下载安装即可(这里选择 Windows！)：</p><p>&nbsp;</p><h3 id="REPL-串口交互调试"><a href="#REPL-串口交互调试" class="headerlink" title="REPL 串口交互调试"></a><strong>REPL</strong> <strong>串口交互调试</strong></h3><p>yWiFi-ESP32-S2 的 MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试开发板。我们打开 Thonny，将开发板连接到电脑。点击右下角：</p><p><img src="/posts/86375cb2.htm/image-20230701221427314.png" alt="image-20230701221427314" style="zoom:50%;"></p><p>在弹出的列表选择：<strong>Configure interpreter</strong></p><img src="/posts/86375cb2.htm/86375cb2/image-20230701221436676.png" class title="image-20230701221436676"><p>选择“MicroPython（ESP32）”和开发板对应的串口号，点击确认。</p><p><img src="/posts/86375cb2.htm/image-20230701221656057.png" alt="image-20230701221656057" style="zoom:50%;"></p><p>连接成功后可以在 shell（串口终端）看到固件的相关信息：</p><p><img src="/posts/86375cb2.htm/image-20230701221713389.png" alt="image-20230701221713389" style="zoom:50%;"></p><p>我们在 Shell 里面输入 print(“Hello 01Studio!”) , 按回车，可以看到打印出Hello 01Studio 字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">LED = Pin(<span class="number">2</span>, Pin.OUT) </span><br><span class="line">LED.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/posts/86375cb2.htm/image-20230701221806760.png" alt="image-20230701221806760" style="zoom:50%;"></p><p>接下来我们将上一节的三行代码逐行输入和逐行按回车，可以看到 LED 灯也被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701222057224.png" alt="image-20230701222057224" style="zoom:50%;"></p><p>REPL 还有一个强大的功能就是打印错误的代码来调试程序，在后面代码运行时候，如果程序出错，出错信息将通过 REPL 打印。</p><p><img src="/posts/86375cb2.htm/image-20230701222115947.png" alt="image-20230701222115947" style="zoom:50%;"></p><p><strong>REPL</strong> <strong>终端常用键盘按键：</strong></p><p>Ctrl + C : 打断正在运行的程序（特别是含 While True: 的代码）；</p><p>Ctrl + D : 软件复位开发板</p><p>&nbsp;</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p>pyWiFi-ESP32-S2 里面内置了文件系统，可以简单理解成上电后运行的 python文件，这个可以通过 Thonny 非常方便地读写。</p><p>点击 <strong>视图</strong>—<strong>文件</strong> ：</p><p><img src="/posts/86375cb2.htm/image-20230701222203009.png" style="zoom:50%;"></p><p>可以看到左边出现本地和开发板的实时文件浏览窗口：</p><p><img src="/posts/86375cb2.htm/image-20230701222237796.png" alt="image-20230701222237796" style="zoom:50%;"></p><p>在本地文件点击右键—上传到即可将相关文件发送到开发板，也可以将开发板上的文件发送到本地，非常方便。</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><strong>代码测试</strong></h3><p>前面已经安装好了 Thonny IDE 和配置，接下来使用最简单的方式来做一个点亮 LED 蓝灯的实验。具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮LED蓝灯</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入Pin模块</span></span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建led对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮LED，也可以使用led.on()</span></span><br></pre></td></tr></table></figure><p>运行功能代码是保存在开发板的 RAM（内存）里面，断电后丢失，那么如何实现开发板上电运行我们的代码呢？方法如下：</p><p>Micropython 上电默认先运行名字为 boot.py 文件，然后在运行 main.py 文件，如果没有 boot.py 那么直接运行 main.py。</p><p><strong>boot.py:</strong> <strong>一般用于配置初始化参数；</strong></p><p><strong>main.py**</strong>：主程序**</p><p>也就是我们只需要将代码以 main.py 文件发送到开发板，那么开发板就可以实现上电运行相关程序。</p><p>我们将 LED 例程的 main.py 发送到开发板</p><p><img src="/posts/86375cb2.htm/image-20230701222956537.png" alt="image-20230701222956537" style="zoom:50%;"></p><p>按下开发板的复位键，可以看到 LED 蓝灯被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701223032307.png" alt="image-20230701223032307" style="zoom:50%;"></p><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>固件更新是指重新烧写开发板的出厂文件或者是升级的固件，使用上海乐鑫提供的官方软件烧录：</p><p><img src="/posts/86375cb2.htm/image-20230701223127927.png" alt="image-20230701223127927" style="zoom:50%;"></p><p>芯片这里选择 ESP32-S2，develop 开发者模式，然后点击 OK :</p><p><img src="/posts/86375cb2.htm/image-20230701223146766.png" alt="image-20230701223146766" style="zoom:50%;"></p><p>选择 SPIDownload，在下图箭头位置点击，选择要烧录固件。</p><p>其它配置选项也请参考下图，注意下载地址是 <strong>0x1000</strong>。（COM 串口是选择自己的串口，在设备管理器查询。）</p><p><img src="/posts/86375cb2.htm/image-20230701223234252.png" alt="image-20230701223234252" style="zoom:50%;"></p><p>配置好后，先点击“ERASE”按钮刷除模块里面内容。点击软件下方“ERASE”按钮，刷除成功后，左边绿色框出现完成字样</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223253705.png" class title="image-20230701223253705"><p>刷除成功后，点击“START”按钮开始烧录，烧录完成有左边绿色框出现“完成”字样。完成后记得点”stop”按钮或者关闭软件释放串口。</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223316527.png" class title="image-20230701223316527">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32&quot;&gt;&lt;a href=&quot;#esp32&quot; class=&quot;headerlink&quot; title=&quot;esp32&quot;&gt;&lt;/a&gt;esp32&lt;/h1&gt;&lt;h2 id=&quot;ESP32-S2-平台&quot;&gt;&lt;a href=&quot;#ESP32-S2-平台&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>k210项目</title>
    <link href="https://rozen12123.github.io/posts/384e6f73.html"/>
    <id>https://rozen12123.github.io/posts/384e6f73.html</id>
    <published>2023-03-19T10:30:52.000Z</published>
    <updated>2023-07-06T07:52:19.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="照相机"><a href="#照相机" class="headerlink" title="照相机"></a>照相机</h2><p>本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复</p><p>外部中断按键实验：请参阅 <strong>4.4</strong> <strong>外部中断</strong> 章节内容；</p><p>拍摄照片实验：请参阅 <strong>5.9</strong> <strong>图片拍摄</strong> 章节内容。</p><p>拍照后我们应该让图片停留一段时间，让用户观察照片的拍摄情况，然后再进行继续拍摄。代码编写流程如下：</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, utime</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 KEY 的外部 IO</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建 KEY 对象</span></span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># or sensor.GRAYSCALE</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># or sensor.QVGA (or others)</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #摄像头后置模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">key_node = <span class="number">0</span> <span class="comment">#按键标志位</span></span><br><span class="line">name_num = <span class="number">0</span> <span class="comment">#照片名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 按键和其回调函数</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"></span><br><span class="line"> <span class="keyword">global</span> key_node</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">  key_node = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> lcd.display(sensor.snapshot()) <span class="comment"># LCD 实时显示</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> key_node==<span class="number">1</span>: <span class="comment">#按键被按下</span></span><br><span class="line">  key_node = <span class="number">0</span> <span class="comment">#清空按键标志位</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#拍照并保存，保存文件用时间来命名。</span></span><br><span class="line">  lcd.display(sensor.snapshot().save(<span class="built_in">str</span>(name_num)+<span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line">  name_num=name_num+<span class="number">1</span> <span class="comment">#名字编码加 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Done! Reset the camera to see the saved image.&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#延时 3 秒，观看拍摄图片</span></span><br><span class="line"></span><br><span class="line">  utime.sleep_ms(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a><strong>视频播放器</strong></h2><p>音视频解码是一个复杂的过程，但 K210 底层 MicroPython 库写好后，着重应用来编程就变得非常简单了。和以往一样，我们只需要熟悉模块用法即可。</p><p>本实验实验 01Studio 音频模块，基于 PAM8403 的一款 D 类功放 IC，和麦克风一样使用 I2S 接口通信，这里不再重复 I2S 内容。</p><p>而视频播放被封装成 video 模块，在前面视频录制章节内容已经介绍过，这里重温一下，模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：视频播放器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">翻译和注释：01Studio</span></span><br><span class="line"><span class="string">说明：AVI视频播放。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> video,time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">    audio_en=GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频控制IO</span></span><br><span class="line">fm.register(<span class="number">34</span>,  fm.fpioa.I2S0_OUT_D1, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">35</span>,  fm.fpioa.I2S0_SCLK, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">33</span>,  fm.fpioa.I2S0_WS, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#播放avi文件</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/badapple.avi&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印视频文件信息</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音量调节</span></span><br><span class="line">v.volume(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v.play() == <span class="number">0</span>: <span class="comment">#播放完毕</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;play end&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">v.__del__() <span class="comment">#销毁对象，释放内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本实验播放的视频是 badapple.avi，文件在本例程文件夹中，先将该文件拷贝到 sd 卡。然后将 sd 卡插到 pyAI-K210。</p><p>接上 01Studio 音频模块，运行本实验程序代码，可以见到串口终端打印了avi 视频信息后，开发板便开始播放视频。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="NES-游戏机"><a href="#NES-游戏机" class="headerlink" title="NES 游戏机"></a><strong>NES</strong> <strong>游戏机</strong></h2><p>MaixPy 集成了 NES 的 MicroPython 模块,用户通过几行代码就可以实现游戏的加载，已经使用键盘或者标准游戏手柄来操控。NES 对象如下：</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nes</span><br></pre></td></tr></table></figure><p>导入 nes 模块；</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=<span class="number">16</span>,vol=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>初始化 nes 游戏模拟器；</p><p>【rc_type】遥控类型。nes.KEYBOARD:REPL 中使用键盘；nes.JOYSTICK:PS2 手柄。</p><p>【cs,mosi,miso,clk】使用 PS2 手柄时的引脚配置；</p><p>【repeat】键盘按键重复率；</p><p>【vol】音量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.run(xx.nes)</span><br></pre></td></tr></table></figure><p>运行 nes 文件。</p><p>*更多使用说明请阅读官方文档：</p><p>&nbsp;</p><p>键盘和手柄的快捷键如下：</p><h4 id="键盘（串口）"><a href="#键盘（串口）" class="headerlink" title="键盘（串口）"></a>键盘（串口）</h4><p>【移动】：WSAD(上下左右)</p><p>【A】：J</p><p>【B】：K</p><p>【start】：M 或 Enter</p><p>【option】：N 或\</p><p>【退出】：ESC</p><p>【音量-】：-</p><p>【音量+】：=</p><p>【运行速度-】：R</p><p>【运行速度+】：F</p><h4 id="PS2-手柄"><a href="#PS2-手柄" class="headerlink" title="PS2 手柄"></a>PS2 手柄</h4><p>【移动】：方向键(上下左右)</p><p>【A】：口</p><p>【B】：X</p><p>【start】：START</p><p>【option】：SELECT</p><p>【退出】：暂无</p><p>【音量-】：R2</p><p>【音量+】：R1</p><p>【运行速度-】：L1</p><p>【运行速度+】：L2</p><p>从上表 NES 对象看到，只需要简单的初始化和运行语句，即可运行 NES 游戏模拟器，编程思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> nes, lcd</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化nes，配置为键盘控制</span></span><br><span class="line">nes.init(nes.KEYBOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行游戏</span></span><br><span class="line">nes.run(<span class="string">&quot;/sd/Bomberman.nes&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;照相机&quot;&gt;&lt;a href=&quot;#照相机&quot; class=&quot;headerlink&quot; title=&quot;照相机&quot;&gt;&lt;/a&gt;照相机&lt;/h2&gt;&lt;p&gt;本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复&lt;/p&gt;
&lt;p&gt;外部中断按键实验：请参阅 &lt;stron</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
</feed>
