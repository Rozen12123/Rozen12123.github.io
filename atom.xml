<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小江的博客</title>
  
  <subtitle>想成为一个温暖而有趣的人</subtitle>
  <link href="https://rozen12123.github.io/atom.xml" rel="self"/>
  
  <link href="https://rozen12123.github.io/"/>
  <updated>2024-01-26T15:06:11.122Z</updated>
  <id>https://rozen12123.github.io/</id>
  
  <author>
    <name>小江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习--案例：流行电影统计</title>
    <link href="https://rozen12123.github.io/posts/84343a8a.html"/>
    <id>https://rozen12123.github.io/posts/84343a8a.html</id>
    <published>2024-01-26T11:52:55.000Z</published>
    <updated>2024-01-26T15:06:11.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习—案例：流行电影统计"><a href="#机器学习—案例：流行电影统计" class="headerlink" title="机器学习—案例：流行电影统计"></a>机器学习—案例：流行电影统计</h1><p>现在我们有一组从2006年到2016年1000部最流行的电影数据</p><p>数据来源：<a href="https://www.kaggle.com/damianpanek/sunday-eda/data">https://www.kaggle.com/damianpanek/sunday-eda/data</a></p><ul><li>问题1：我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？</li><li>问题2：对于这一组电影数据，如果我们想rating，runtime的分布情况，应该如何呈现数据？</li><li>问题3：对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先获取导入包，获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件的路径</span></span><br><span class="line">path = <span class="string">&quot;./IMDB-Movie-Data.csv&quot;</span></span><br><span class="line"><span class="comment">#读取文件</span></span><br><span class="line">df = pd.read_csv(path)</span><br></pre></td></tr></table></figure><h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>我们想知道这些电影数据中评分的平均分，导演的人数等信息，我们应该怎么获取？</p><ul><li>得出评分的平均分</li></ul><p>使用mean函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;Rating&quot;</span>].mean()</span><br></pre></td></tr></table></figure><ul><li>得出导演人数信息</li></ul><p>求出唯一值，然后进行形状获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 导演的人数</span></span><br><span class="line"><span class="comment"># df[&quot;Director&quot;].unique().shape[0]</span></span><br><span class="line">np.unique(df[<span class="string">&quot;Director&quot;</span>]).shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>对于这一组电影数据，如果我们想<strong>Rating</strong>，<strong>Runtime (Minutes)</strong>的分布情况，应该如何呈现数据？</p><ul><li>直接呈现，以直方图的形式</li></ul><p>选择分数列数据，进行plot</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;Rating&quot;</span>].plot(kind=<span class="string">&#x27;hist&#x27;</span>,figsize=(<span class="number">20</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure><ul><li>Rating进行分布展示</li></ul><p>进行绘制直方图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)</span><br><span class="line">plt.hist(df[<span class="string">&quot;Rating&quot;</span>].values,bins=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>修改刻度的间隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求出最大最小值</span></span><br><span class="line">max_ = df[<span class="string">&quot;Rating&quot;</span>].<span class="built_in">max</span>()</span><br><span class="line">min_ = df[<span class="string">&quot;Rating&quot;</span>].<span class="built_in">min</span>()</span><br><span class="line"><span class="comment"># 生成刻度列表</span></span><br><span class="line">t1 = np.linspace(min_,max_,num=<span class="number">21</span>)</span><br><span class="line"><span class="comment"># [ 1.9 2.255 2.61 2.965 3.32 3.675 4.03 4.385 4.74 5.095 5.45 5.805 6.16 6.515 6.87 7.225 7.58 7.935 8.29 8.645 9.]</span></span><br><span class="line"><span class="comment"># 修改刻度</span></span><br><span class="line">plt.xticks(t1)</span><br><span class="line"><span class="comment"># 添加网格</span></span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><ul><li>Runtime (Minutes)进行分布展示</li></ul><p>进行绘制直方图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)</span><br><span class="line">plt.hist(df[<span class="string">&quot;Runtime (Minutes)&quot;</span>].values,bins=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>修改间隔</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求出最大最小值</span></span><br><span class="line">max_ = df[<span class="string">&quot;Runtime (Minutes)&quot;</span>].<span class="built_in">max</span>()</span><br><span class="line">min_ = df[<span class="string">&quot;Runtime (Minutes)&quot;</span>].<span class="built_in">min</span>()</span><br><span class="line"><span class="comment"># # 生成刻度列表</span></span><br><span class="line">t1 = np.linspace(min_,max_,num=<span class="number">21</span>)</span><br><span class="line"><span class="comment"># 修改刻度</span></span><br><span class="line">plt.xticks(np.linspace(min_,max_,num=<span class="number">21</span>))</span><br><span class="line"><span class="comment"># 添加网格</span></span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><h3 id="问题三：对于这一组电影数据，如果我们希望统计电影分类-genre-的情况，应该如何处理数据？"><a href="#问题三：对于这一组电影数据，如果我们希望统计电影分类-genre-的情况，应该如何处理数据？" class="headerlink" title="问题三：对于这一组电影数据，如果我们希望统计电影分类(genre)的情况，应该如何处理数据？"></a>问题三：对于这一组电影数据，如果我们希望统计电影分类<strong>(genre)</strong>的情况，应该如何处理数据？</h3><ul><li>思路<ul><li>1、创建一个全为0的dataframe，列索引置为电影的分类，temp_df</li><li>2、遍历每一部电影，temp_df中把分类出现的列的值置为1</li><li>3、求和</li></ul></li><li>1、创建一个全为0的dataframe，列索引置为电影的分类，temp_df</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行字符串分割</span></span><br><span class="line">temp_list = [i.split(<span class="string">&quot;,&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> df[<span class="string">&quot;Genre&quot;</span>]]</span><br><span class="line"><span class="comment"># 获取电影的分类</span></span><br><span class="line"></span><br><span class="line">genre_list = np.unique([i <span class="keyword">for</span> j <span class="keyword">in</span> temp_list <span class="keyword">for</span> i <span class="keyword">in</span> j])</span><br><span class="line"><span class="comment"># 增加新的列</span></span><br><span class="line">temp_df = pd.DataFrame(np.zeros([df.shape[<span class="number">0</span>],genre_list.shape[<span class="number">0</span>]]),columns=genre_list)</span><br></pre></td></tr></table></figure><p>2、遍历每一部电影，temp_df中把分类出现的列的值置为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    temp_df.loc[i,temp_list[i]]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(temp_df.<span class="built_in">sum</span>().sort_values())</span><br></pre></td></tr></table></figure><p>3、求和,绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp_df.<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>).plot(kind=<span class="string">&quot;bar&quot;</span>,figsize=(<span class="number">20</span>,<span class="number">8</span>),fontsize=<span class="number">20</span>,colormap=<span class="string">&quot;cool&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习—案例：流行电影统计&quot;&gt;&lt;a href=&quot;#机器学习—案例：流行电影统计&quot; class=&quot;headerlink&quot; title=&quot;机器学习—案例：流行电影统计&quot;&gt;&lt;/a&gt;机器学习—案例：流行电影统计&lt;/h1&gt;&lt;p&gt;现在我们有一组从2006年到2016年100</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--pandas</title>
    <link href="https://rozen12123.github.io/posts/31ce2bbd.html"/>
    <id>https://rozen12123.github.io/posts/31ce2bbd.html</id>
    <published>2024-01-24T12:53:28.000Z</published>
    <updated>2024-01-26T15:06:17.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>优势：</p><ul><li>增强图表可读性</li><li>便捷的数据处理能力</li><li>读取文件方便</li><li>封装了Matplotlib、Numpy的画图和计算</li></ul><p>更详细的教程：<a href="https://www.runoob.com/pandas/pandas-tutorial.html">Pandas 教程 | 菜鸟教程 (runoob.com)</a></p><h2 id="Pandas数据结构"><a href="#Pandas数据结构" class="headerlink" title="Pandas数据结构"></a><strong>Pandas</strong>数据结构</h2><p>Pandas中一共有三种数据结构，分别为：Series、DataFrame和MultiIndex（老版本中叫Panel ）。</p><p>其中Series是一维数据结构，DataFrame是二维的表格型数据结构，MultiIndex是三维的数据结构。</p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a><strong>Series</strong></h3><p>Series是一个类似于一维数组的数据结构，它能够保存任何类型的数据，比如整数、字符串、浮点数等，主要由一组数据和与之相关的索引两部分构成。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401242106791.png" alt="image-20240124210604659"></p><h3 id="Series的创建"><a href="#Series的创建" class="headerlink" title="Series的创建"></a><strong>Series</strong>的创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.Series(data=<span class="literal">None</span>, index=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>data：传入的数据，可以是ndarray、list等</li><li>index：索引，必须是唯一的，且与数据的长度相等。如果没有传入索引参数，则默认会自动创建一个从0-N的整数索引。</li><li>dtype：数据的类型</li></ul><p>通过已有数据创建</p><ul><li>指定内容，默认索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(np.arange(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><ul><li>指定索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series([<span class="number">6.7</span>,<span class="number">5.6</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure><ul><li>通过字典数据创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color_count = pd.Series(&#123;<span class="string">&#x27;red&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>:<span class="number">200</span>, <span class="string">&#x27;green&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;yellow&#x27;</span>:<span class="number">1000</span>&#125;)</span><br><span class="line">color_count</span><br></pre></td></tr></table></figure><h3 id="Series的属性"><a href="#Series的属性" class="headerlink" title="Series的属性"></a><strong>Series</strong>的属性</h3><p><strong>Series</strong>中提供了两个属性<strong>index</strong>和<strong>values</strong></p><ul><li>index</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color_count.index</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>values</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color_count.values</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">200</span>, <span class="number">500</span>, <span class="number">100</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure><p>也可以使用索引来获取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color_count[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a><strong>DataFrame</strong></h2><p>DataFrame是一个类似于二维数组或表格(如excel)的对象，既有行索引，又有列索引</p><ul><li><p>行索引，表明不同行，横向索引，叫index，0轴，axis=0</p></li><li><p>列索引，表名不同列，纵向索引，叫columns，1轴，axis=1</p></li></ul><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401242117200.png" alt="image-20240124211733076"></p><h3 id="DataFrame的创建"><a href="#DataFrame的创建" class="headerlink" title="DataFrame的创建"></a><strong>DataFrame</strong>的创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.DataFrame(data=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数：</p><p>index：行标签。如果没有传入索引参数，则默认会自动创建一个从0-N的整数索引。</p><p>columns：列标签。如果没有传入索引参数，则默认会自动创建一个从0-N的整数索引。</p><p>通过已有数据创建,举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.random.randn(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>例子，创建学生成绩表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成10名同学，5门功课的数据</span></span><br><span class="line">score = np.random.randint(<span class="number">40</span>, <span class="number">100</span>, (<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 使用Pandas中的数据结构</span></span><br><span class="line">score_df = pd.DataFrame(score)</span><br></pre></td></tr></table></figure><ul><li>增加行、列索引</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造行索引序列</span></span><br><span class="line">subjects = [<span class="string">&quot;语文&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="string">&quot;英语&quot;</span>, <span class="string">&quot;政治&quot;</span>, <span class="string">&quot;体育&quot;</span>]</span><br><span class="line"><span class="comment"># 构造列索引序列</span></span><br><span class="line">stu = [<span class="string">&#x27;同学&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(score_df.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="comment"># 添加行索引</span></span><br><span class="line">data = pd.DataFrame(score, columns=subjects, index=stu)</span><br></pre></td></tr></table></figure><h3 id="DataFrame的属性"><a href="#DataFrame的属性" class="headerlink" title="DataFrame的属性"></a><strong>DataFrame</strong>的属性</h3><ul><li><strong>shape</strong></li><li><strong>index</strong></li><li><strong>columns</strong></li><li><strong>values</strong></li><li><strong>T</strong></li></ul><ul><li><strong>shape</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>index</strong></li></ul><p>DataFrame的行索引列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.index</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;同学0&#x27;</span>, <span class="string">&#x27;同学1&#x27;</span>, <span class="string">&#x27;同学2&#x27;</span>, <span class="string">&#x27;同学3&#x27;</span>, <span class="string">&#x27;同学4&#x27;</span>, <span class="string">&#x27;同学5&#x27;</span>, <span class="string">&#x27;同学6&#x27;</span>, <span class="string">&#x27;同学7&#x27;</span>, <span class="string">&#x27;同学8&#x27;</span>, <span class="string">&#x27;同学9&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>columns</strong></li></ul><p>DataFrame的列索引列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.columns</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Index([<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="string">&#x27;政治&#x27;</span>, <span class="string">&#x27;体育&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>values</strong></li></ul><p>直接获取其中array的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.values</span><br><span class="line"></span><br><span class="line">array([[<span class="number">92</span>, <span class="number">55</span>, <span class="number">78</span>, <span class="number">50</span>, <span class="number">50</span>],</span><br><span class="line">[<span class="number">71</span>, <span class="number">76</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">96</span>],</span><br><span class="line">[<span class="number">45</span>, <span class="number">84</span>, <span class="number">78</span>, <span class="number">51</span>, <span class="number">68</span>],</span><br><span class="line">[<span class="number">81</span>, <span class="number">91</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">76</span>],</span><br><span class="line">[<span class="number">86</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">67</span>, <span class="number">95</span>],</span><br><span class="line">[<span class="number">46</span>, <span class="number">86</span>, <span class="number">56</span>, <span class="number">61</span>, <span class="number">99</span>],</span><br><span class="line">[<span class="number">46</span>, <span class="number">95</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">56</span>],</span><br><span class="line">[<span class="number">80</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">57</span>],</span><br><span class="line">[<span class="number">41</span>, <span class="number">93</span>, <span class="number">90</span>, <span class="number">41</span>, <span class="number">97</span>],</span><br><span class="line">[<span class="number">65</span>, <span class="number">83</span>, <span class="number">57</span>, <span class="number">57</span>, <span class="number">40</span>]])</span><br></pre></td></tr></table></figure><ul><li><strong>T</strong></li></ul><p>转置</p><p>data.T</p><ul><li>显示前n行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head(n)</span><br></pre></td></tr></table></figure><ul><li>显示后n行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.tail(n)</span><br></pre></td></tr></table></figure><p>ps：如果不加参数，默认是显示前5行或者后五行。</p><h3 id="DatatFrame索引的设置"><a href="#DatatFrame索引的设置" class="headerlink" title="DatatFrame索引的设置"></a><strong>DatatFrame</strong>索引的设置</h3><h4 id="修改行列索引值"><a href="#修改行列索引值" class="headerlink" title="修改行列索引值"></a>修改行列索引值</h4><p>注意，只能整行整列得修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu = [<span class="string">&quot;学生_&quot;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(score_df.shape[<span class="number">0</span>])]</span><br><span class="line"><span class="comment"># 必须整体全部修改</span></span><br><span class="line">data.index = stu</span><br></pre></td></tr></table></figure><h4 id="重设索引"><a href="#重设索引" class="headerlink" title="重设索引"></a>重设索引</h4><ul><li>reset_index(drop=False)<ul><li>设置新的下标索引</li><li>drop:默认为False，不删除原来索引，如果为True,删除原来的索引值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置索引,drop=False</span></span><br><span class="line">data.reset_index()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置索引,drop=True</span></span><br><span class="line">data.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="以某列值设置为新的索引"><a href="#以某列值设置为新的索引" class="headerlink" title="以某列值设置为新的索引"></a>以某列值设置为新的索引</h4><ul><li>set_index(keys, drop=True)<ul><li><strong>keys</strong> : 列索引名成或者列索引名称的列表</li><li><strong>drop</strong> : boolean, default True.当做新的索引，删除原来的列</li></ul></li></ul><p>1.创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;month&#x27;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line"><span class="string">&#x27;year&#x27;</span>: [<span class="number">2012</span>, <span class="number">2014</span>, <span class="number">2013</span>, <span class="number">2014</span>],</span><br><span class="line"><span class="string">&#x27;sale&#x27;</span>:[<span class="number">55</span>, <span class="number">40</span>, <span class="number">84</span>, <span class="number">31</span>]&#125;)</span><br></pre></td></tr></table></figure><p>2.以月份设置新的索引</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;month&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3.设置多个索引，以年和月份</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.set_index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="MultiIndex与Panel"><a href="#MultiIndex与Panel" class="headerlink" title="MultiIndex与Panel"></a><strong>MultiIndex</strong>与<strong>Panel</strong></h3><h4 id="MultiIndex"><a href="#MultiIndex" class="headerlink" title="MultiIndex"></a><strong>MultiIndex</strong></h4><p>MultiIndex是三维的数据结构;</p><p>多级索引（也称层次化索引）是pandas的重要功能，可以在Series、DataFrame对象上拥有2个以及2个以上的索引。</p><h4 id="multiIndex的特性"><a href="#multiIndex的特性" class="headerlink" title="multiIndex的特性"></a><strong>multiIndex</strong>的特性</h4><p>打印刚才的df的行索引结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.index</span><br></pre></td></tr></table></figure><p>多级或分层索引对象。</p><ul><li>index属性<ul><li>names:levels的名称</li><li>levels：每个level的元组值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.index.names</span><br><span class="line"><span class="comment"># FrozenList([&#x27;year&#x27;, &#x27;month&#x27;])</span></span><br><span class="line">df.index.levels</span><br><span class="line"><span class="comment"># FrozenList([[1, 2], [1, 4, 7, 10]])</span></span><br></pre></td></tr></table></figure><p><strong>multiIndex</strong>的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrays = [[1, 1, 2, 2], [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;, &#x27;blue&#x27;]]</span><br><span class="line">pd.MultiIndex.from_arrays(arrays, names=(&#x27;number&#x27;, &#x27;color&#x27;))</span><br></pre></td></tr></table></figure><h4 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a><strong>Panel</strong></h4><h4 id="panel的创建"><a href="#panel的创建" class="headerlink" title="panel的创建"></a><strong>panel</strong>的创建</h4><ul><li><em>class</em> pandas.Panel (<em>data=None</em>, <em>items=None</em>, <em>major_axis=None</em>, <em>minor_axis=None</em>)<ul><li>作用：存储3维数组的Panel结构</li><li>参数：<ul><li><strong>data</strong> : ndarray或者dataframe</li><li><strong>items</strong> : 索引或类似数组的对象，axis=0</li><li><strong>major_axis</strong> : 索引或类似数组的对象，axis=1</li><li><strong>minor_axis</strong> : 索引或类似数组的对象，axis=2</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = pd.Panel(data=np.arange(<span class="number">24</span>).reshape(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>),</span><br><span class="line">items=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>),</span><br><span class="line">major_axis=pd.date_range(<span class="string">&#x27;20130101&#x27;</span>, periods=<span class="number">3</span>),</span><br><span class="line">minor_axis=[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="查看panel数据"><a href="#查看panel数据" class="headerlink" title="查看panel数据"></a>查看<strong>panel</strong>数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[:,:,<span class="string">&quot;first&quot;</span>]</span><br><span class="line">p[<span class="string">&quot;B&quot;</span>,:,:]</span><br></pre></td></tr></table></figure><h3 id="基本数据操作"><a href="#基本数据操作" class="headerlink" title="基本数据操作"></a>基本数据操作</h3><p>导入数据，数据放在上方的资源中了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./stock_day.csv&quot;</span>)</span><br><span class="line"><span class="comment"># 删除一些列，让数据更简单些，再去做后面的操作</span></span><br><span class="line">data = data.drop([<span class="string">&quot;ma5&quot;</span>,<span class="string">&quot;ma10&quot;</span>,<span class="string">&quot;ma20&quot;</span>,<span class="string">&quot;v_ma5&quot;</span>,<span class="string">&quot;v_ma10&quot;</span>,<span class="string">&quot;v_ma20&quot;</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h4><p>直接使用行列索引<strong>(</strong>先列后行<strong>)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用行列索引名字的方式（先列后行）</span></span><br><span class="line">data[<span class="string">&#x27;open&#x27;</span>][<span class="string">&#x27;2018-02-27&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不支持的操作</span></span><br><span class="line"><span class="comment"># 错误</span></span><br><span class="line">data[<span class="string">&#x27;2018-02-27&#x27;</span>][<span class="string">&#x27;open&#x27;</span>]</span><br></pre></td></tr></table></figure><p>只能先行后列</p><h4 id="结合loc或者iloc使用索引"><a href="#结合loc或者iloc使用索引" class="headerlink" title="结合loc或者iloc使用索引"></a>结合<strong>loc</strong>或者<strong>iloc</strong>使用索引</h4><p>获取从’2018-02-27’:’2018-02-22’，’open’的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用loc:只能指定行列索引的名字</span></span><br><span class="line">data.loc[<span class="string">&#x27;2018-02-27&#x27;</span>:<span class="string">&#x27;2018-02-22&#x27;</span>, <span class="string">&#x27;open&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iloc可以通过索引的下标去获取</span></span><br><span class="line"><span class="comment"># 获取前3天数据,前5列的结果</span></span><br><span class="line">data.iloc[:<span class="number">3</span>, :<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="使用ix组合索引"><a href="#使用ix组合索引" class="headerlink" title="使用ix组合索引"></a>使用<strong>ix</strong>组合索引</h4><p>获取行第1天到第4天，[‘open’, ‘close’, ‘high’, ‘low’]这个四个指标的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用ix进行下表和名称组合做引</span></span><br><span class="line">data.ix[<span class="number">0</span>:<span class="number">4</span>, [<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>]]</span><br><span class="line"><span class="comment"># 推荐使用loc和iloc来获取的方式</span></span><br><span class="line">data.loc[data.index[<span class="number">0</span>:<span class="number">4</span>], [<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>]]</span><br><span class="line">data.iloc[<span class="number">0</span>:<span class="number">4</span>, data.columns.get_indexer([<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>])]</span><br></pre></td></tr></table></figure><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p>对DataFrame当中的close列进行重新赋值为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改原来的值</span></span><br><span class="line">data[<span class="string">&#x27;close&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">data.close = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>排序有两种形式，一种对于索引进行排序，一种对于内容进行排序<ul><li>使用df.sort_values(by=, ascending=)</li><li>单个键或者多个键进行排序,<ul><li>参数：</li><li>by：指定排序参考的键</li><li>ascending:默认升序<ul><li>ascending=False:降序</li><li>ascending=True:升序</li></ul></li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照开盘价大小进行排序 , 使用ascending指定按照大小排序</span></span><br><span class="line">data.sort_values(by=<span class="string">&quot;open&quot;</span>, ascending=<span class="literal">True</span>).head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照多个键进行排序</span></span><br><span class="line">data.sort_values(by=[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;high&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对索引进行排序</span></span><br><span class="line">data.sort_index()</span><br></pre></td></tr></table></figure><h4 id="Series排序"><a href="#Series排序" class="headerlink" title="Series排序"></a><strong>Series</strong>排序</h4><ul><li>使用series.sort_values(ascending=True)进行排序</li></ul><p>series排序时，只有一列，不需要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;p_change&#x27;</span>].sort_values(ascending=<span class="literal">True</span>).head()</span><br></pre></td></tr></table></figure><ul><li>使用series.sort_index()进行排序</li></ul><p>与df一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对索引进行排序</span></span><br><span class="line">data[<span class="string">&#x27;p_change&#x27;</span>].sort_index().head()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>1.索引<ul><li>直接索引 — 先列后行,是需要通过索引的字符串进行获取</li><li>loc — 先行后列,是需要通过索引的字符串进行获取</li><li>iloc — 先行后列,是通过下标进行索引</li><li>ix — 先行后列, 可以用上面两种方法混合进行索引</li></ul></li><li>2.赋值<ul><li>data[“”] = **</li><li>data. <strong>=</strong></li></ul></li><li>3.排序<ul><li>dataframe<ul><li>对象.sort_values()</li><li>对象.sort_index()</li></ul></li><li>series<ul><li>对象.sort_values()</li><li>对象.sort_index()</li></ul></li></ul></li></ul><h2 id="DataFrame运算"><a href="#DataFrame运算" class="headerlink" title="DataFrame运算"></a><strong>DataFrame</strong>运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><ul><li>add(other)</li></ul><p>比如进行数学运算加上具体的一个数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&#x27;open&#x27;</span>].add(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>sub(other)’</li></ul><h3 id="逻辑运算-可用于筛选"><a href="#逻辑运算-可用于筛选" class="headerlink" title="逻辑运算(可用于筛选)"></a>逻辑运算(可用于筛选)</h3><h4 id="逻辑运算符号"><a href="#逻辑运算符号" class="headerlink" title="逻辑运算符号"></a>逻辑运算符号</h4><ul><li>例如筛选data[“open”] &gt; 23的日期数据<ul><li>data[“open”] &gt; 23返回逻辑结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑判断的结果可以作为筛选的依据</span></span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span>].head()</span><br></pre></td></tr></table></figure><ul><li>完成多个逻辑判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[(data[<span class="string">&quot;open&quot;</span>] &gt; <span class="number">23</span>) &amp; (data[<span class="string">&quot;open&quot;</span>] &lt; <span class="number">24</span>)].head()</span><br></pre></td></tr></table></figure><h4 id="逻辑运算函数"><a href="#逻辑运算函数" class="headerlink" title="逻辑运算函数"></a>逻辑运算函数</h4><ul><li>query(expr)<ul><li>expr:查询字符串</li></ul></li></ul><p>通过query使得刚才的过程更加方便简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.query(<span class="string">&quot;open&lt;24 &amp; open&gt;23&quot;</span>).head()</span><br></pre></td></tr></table></figure><ul><li>isin(values)</li></ul><p>例如判断’open’是否为23.53和23.85</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以指定值进行一个判断，从而进行筛选操作</span></span><br><span class="line">data[data[<span class="string">&quot;open&quot;</span>].isin([<span class="number">23.53</span>, <span class="number">23.85</span>])]</span><br></pre></td></tr></table></figure><h3 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h3><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a><strong>describe</strong></h4><p>综合分析: 能够直接得出很多统计结果, count , mean , std , min , max 等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算平均值、标准差、最大值、最小值</span></span><br><span class="line">data.describe()</span><br></pre></td></tr></table></figure><h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><p>Numpy当中已经详细介绍，在这里我们演示min(最小值), max(最大值), mean(平均值), median(中位数), var(方差), std(标准差),mode(众数)结果:</p><p>对于单个函数去进行统计的时候，坐标轴还是按照默认列<strong>“columns” (axis=0, default)</strong>，如果要对行<strong>“index”</strong> 需要指定<strong>(axis=1)</strong></p><ul><li>max()、min()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用统计函数：0 代表列求结果， 1 代表行求统计结果</span></span><br><span class="line">data.<span class="built_in">max</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>std()、var()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方差</span></span><br><span class="line">data.var(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准差</span></span><br><span class="line">data.std(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>median()</strong>：中位数</li></ul><p>中位数为将数据从小到大排列，在最中间的那个数为中位数。如果没有中间数，取中间两个数的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;COL1&#x27;</span> : [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line"><span class="string">&#x27;COL2&#x27;</span> : [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]&#125;)</span><br><span class="line">df.median()</span><br></pre></td></tr></table></figure><ul><li>idxmax()、idxmin()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求出最大值的位置</span></span><br><span class="line">data.idxmax(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求出最小值的位置</span></span><br><span class="line">data.idxmin(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="累计统计函数"><a href="#累计统计函数" class="headerlink" title="累计统计函数"></a>累计统计函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>cunsum</td><td>计算前n个数的和</td></tr><tr><td>cunmax</td><td>计算前n个数的最大值</td></tr><tr><td>cunmin</td><td>计算前n个数的最小值</td></tr><tr><td>cunprod</td><td>计算前n个数的积</td></tr></tbody></table></div><p>这里我们按照时间的从前往后来进行累计</p><ul><li>排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序之后，进行累计求和</span></span><br><span class="line">data = data.sort_index()</span><br></pre></td></tr></table></figure><ul><li>对p_change进行求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stock_rise = data[<span class="string">&#x27;p_change&#x27;</span>]</span><br><span class="line"><span class="comment"># plot方法集成了前面直方图、条形图、饼图、折线图</span></span><br><span class="line">stock_rise.cumsum()</span><br></pre></td></tr></table></figure><p>如果要使用plot函数，需要导入matplotlib.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># plot显示图形</span></span><br><span class="line">stock_rise.cumsum().plot()</span><br><span class="line"><span class="comment"># 需要调用show，才能显示出结果</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="自定义运算"><a href="#自定义运算" class="headerlink" title="自定义运算"></a>自定义运算</h3><ul><li>apply(func, axis=0)<ul><li>func:自定义函数</li><li>axis=0:默认是列，axis=1为行进行运算</li></ul></li><li>定义一个对列，最大值-最小值的函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>]].apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>(), axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>算术运算</li><li>逻辑运算<ul><li>1.逻辑运算符号</li><li>2.逻辑运算函数<ul><li>对象.query()</li><li>对象.isin()</li></ul></li></ul></li><li>统计运算<ul><li>1.对象.describe()</li><li>2.统计函数</li><li>3.累积统计函数</li></ul></li><li>自定义运算<ul><li>apply(func, axis=0)</li></ul></li></ul><h2 id="Pandas画图"><a href="#Pandas画图" class="headerlink" title="Pandas画图"></a><strong>Pandas</strong>画图</h2><h3 id="pandas-DataFrame-plot"><a href="#pandas-DataFrame-plot" class="headerlink" title="pandas.DataFrame.plot"></a><strong>pandas.DataFrame.plot</strong></h3><ul><li>DataFrame.plot (<em>kind=’line’</em>)</li><li>kind : str，需要绘制图形的种类<ul><li><strong>‘line’ : line plot (default)</strong></li><li>‘bar’ : vertical bar plot</li><li>‘barh’ : horizontal bar plot<ul><li>关于“barh”的解释：</li><li><a href="http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.barh.html">http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.barh.html</a></li></ul></li><li>‘hist’ : histogram</li><li>‘pie’ : pie plot</li><li>‘scatter’ : scatter plot</li></ul></li></ul><h3 id="pandas-Series-plot"><a href="#pandas-Series-plot" class="headerlink" title="pandas.Series.plot"></a><strong>pandas.Series.plot</strong></h3><h2 id="文件读取与存储"><a href="#文件读取与存储" class="headerlink" title="文件读取与存储"></a>文件读取与存储</h2><p>我们的数据大部分存在于文件当中，所以pandas会支持复杂的IO操作，pandas的API支持众多的文件格式，如CSV、SQL、XLS、JSON、HDF5。</p><p>ps：最常用的HDF5和CSV文件</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401242224276.png" alt="image-20240124222423129"></p><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a><strong>CSV</strong></h3><h4 id="read-csv"><a href="#read-csv" class="headerlink" title="read_csv"></a><strong>read_csv</strong></h4><ul><li>pandas.read_csv(filepath_or_buffer, sep =’,’, usecols )<ul><li>filepath_or_buffer:文件路径</li><li>sep :分隔符，默认用”,”隔开</li><li>usecols:指定读取的列名，列表形式</li></ul></li><li>举例：读取之前的股票的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文件,并且指定只获取&#x27;open&#x27;, &#x27;close&#x27;指标</span></span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./data/stock_day.csv&quot;</span>, usecols=[<span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;close&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="to-csv"><a href="#to-csv" class="headerlink" title="to_csv"></a><strong>to_csv</strong></h4><ul><li><p>DataFrame.to_csv(path_or_buf=None, sep=’, ’, columns=None, header=True, index=True, mode=’w’, encoding=None)</p><ul><li>path_or_buf :文件路径</li><li>sep :分隔符，默认用”,”隔开</li><li>columns :选择需要的列索引</li><li><p>header :boolean or list of string, default True,是否写进列索引值</p></li><li><p>index:是否写进行索引</p></li><li><p>mode:’w’：重写, ‘a’ 追加</p></li></ul></li><li><p>举例：保存读取出来的股票数据</p><ul><li>保存’open’列的数据，然后读取查看结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选取10行数据保存,便于观察数据</span></span><br><span class="line">data[:<span class="number">10</span>].to_csv(<span class="string">&quot;./test.csv&quot;</span>, columns=[<span class="string">&#x27;open&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取，查看结果</span></span><br><span class="line">pd.read_csv(<span class="string">&quot;./test.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>会发现将索引存入到文件当中，变成单独的一列数据。如果需要删除，可以指定index参数,删除原来的文件，重新保存一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index:存储不会讲索引值变成一列数据</span></span><br><span class="line">data[:<span class="number">10</span>].to_csv(<span class="string">&quot;./test.csv&quot;</span>, columns=[<span class="string">&#x27;open&#x27;</span>], index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a><strong>HDF5</strong></h3><h4 id="read-hdf与to-hdf"><a href="#read-hdf与to-hdf" class="headerlink" title="read_hdf与to_hdf"></a><strong>read_hdf</strong>与<strong>to_hdf</strong></h4><p><strong>HDF5</strong>文件的读取和存储需要指定一个键，值为要存储的<strong>DataFrame</strong></p><ul><li><p>pandas.read_hdf(path_or_buf，key =None，** kwargs)</p><p>从h5文件当中读取数据</p><ul><li>path_or_buffer:文件路径</li><li>key:读取的键</li><li>return:Theselected object</li></ul></li><li><p>DataFrame.to_hdf(path_or_buf, <em>key</em>, <em>*\</em>kwargs*)</p></li></ul><ul><li>读取文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day_close = pd.read_hdf(<span class="string">&quot;./day_close.h5&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果读取的时候出现错误</p><p>需要安装安装tables模块避免不能读取HDF5文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tables</span><br></pre></td></tr></table></figure><ul><li>存储文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day_close.to_hdf(<span class="string">&quot;./data/test.h5&quot;</span>, key=<span class="string">&quot;day_close&quot;</span>)</span><br></pre></td></tr></table></figure><p>再次读取的时候, 需要指定键的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_close = pd.read_hdf(<span class="string">&quot;./data/test.h5&quot;</span>, key=<span class="string">&quot;day_close&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意：优先选择使用<strong>HDF5</strong>文件存储</p><ul><li>HDF5在存储的时候支持压缩，使用的方式是<strong>blosc</strong>，这个是速度最快的也是pandas默认支持的</li><li>使用压缩可以提磁盘利用率，节省空间</li><li>HDF5还是跨平台的，可以轻松迁移到hadoop 上面</li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><strong>JSON</strong></h3><p>JSON是我们常用的一种数据交换格式，前面在前后端的交互经常用到，也会在存储的时候选择这种格式。所以我们需要知道Pandas如何进行读取和存储JSON格式</p><h4 id="read-json"><a href="#read-json" class="headerlink" title="read_json"></a><strong>read_json</strong></h4><ul><li><p>pandas.read_json(path_or_buf=None, orient=None, typ=’frame’, lines=False)</p><ul><li><p>将JSON格式准换成默认的Pandas DataFrame格式</p></li><li><p>orient : string,Indication of expected JSON string format.</p><ul><li><p>‘split’ : dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</p><ul><li>split 将索引总结到索引，列名到列名，数据到数据。将三部分都分开了</li></ul></li><li><p><strong>‘records’ : list like [{column -&gt; value}, … , {column -&gt; value}]</strong></p><ul><li>records 以 columns：values 的形式输出</li></ul></li><li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p><ul><li>index 以 index：{columns：values}… 的形式输出</li></ul></li><li><p><strong>‘columns’ : dict like {column -&gt; {index -&gt; value}}</strong>,默认该格式</p><ul><li>colums 以 columns:{index:values} 的形式输出</li></ul></li><li><p>‘values’ : just the values array</p><ul><li>values 直接输出值</li></ul></li></ul></li><li><p>lines : boolean, default False</p><ul><li>按照每行读取json对象</li></ul></li><li><p>typ : default ‘frame’， 指定转换成的对象类型series或者dataframe</p></li></ul></li></ul><p><strong>read_josn</strong> 案例</p><ul><li>数据介绍</li></ul><p>这里使用一个新闻标题讽刺数据集，格式为json。 is_sarcastic ：1讽刺的，否则为0； headline ：新闻报道的标题； article_link ：链接到原始新闻文章。存储格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>: <span class="string">&quot;https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;</span>, <span class="string">&quot;headline&quot;</span>: <span class="string">&quot;former versace store clerk sues over secret &#x27;black code&#x27; for minority shoppers&quot;</span>, <span class="string">&quot;is_sarcastic&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>: <span class="string">&quot;https://www.huffingtonpost.com/entry/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;</span>, <span class="string">&quot;headline&quot;</span>: <span class="string">&quot;the &#x27;roseanne&#x27; revival catches up to our thorny political mood, for better and worse&quot;</span>, <span class="string">&quot;is_sarcastic&quot;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>读取</li></ul><p>orient指定存储的json格式，lines指定按照行去变成一个样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_read = pd.read_json(<span class="string">&quot;./data/Sarcasm_Headlines_Dataset.json&quot;</span>, orient=<span class="string">&quot;records&quot;</span>, lines=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="to-json"><a href="#to-json" class="headerlink" title="to_json"></a><strong>to_json</strong></h4><ul><li>DataFrame.to_json(<em>path_or_buf=None</em>, <em>orient=None</em>, <em>lines=False</em>)<ul><li>将Pandas 对象存储为json格式</li><li><em>path_or_buf=None</em>：文件地址</li><li>orient:存储的json形式，{‘split’,’records’,’index’,’columns’,’values’}</li><li>lines:一个对象存储为一行</li></ul></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li>存储文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_read.to_json(<span class="string">&quot;./data/test.json&quot;</span>, orient=<span class="string">&#x27;records&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;former versace store clerk sues over secret &#x27;black code&#x27; for minority shoppers&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;,&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;the &#x27;roseanne&#x27; revival catches up to our thorny political mood, for better and worse&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;,&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/local.theonion.com\/mom-starting-to-fear-son-s-web-series-closest-thing-she-1819576697&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;mom starting to fear son&#x27;s web series closest thing she will have to grandchild&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/politics.theonion.com\/boehner-just-wants-wife-to-listen-not-come-up-with-alt-1819574302&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;boehner just wants wife to listen, not come up with alternative debt-reduction ideas&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">1</span>&#125;,&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/jk-rowling-wishes-snape-happy-birthday_us_569117c4e4b0cad15e64fdcb&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;j.k. rowling wishes snape happy birthday in the most magical way&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;,&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/advancing-the-worlds-women_b_6810038.html&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;advancing the world&#x27;s women&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;,....]</span><br></pre></td></tr></table></figure><ul><li>修改lines参数为True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_read.to_json(<span class="string">&quot;./data/test.json&quot;</span>, orient=<span class="string">&#x27;records&#x27;</span>, lines=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;former versace store clerk sues over secret &#x27;black code&#x27; for minority shoppers&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;the &#x27;roseanne&#x27; revival catches up to our thorny political mood, for better and worse&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/local.theonion.com\/mom-starting-to-fear-son-s-web-series-closest-thing-she-1819576697&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;mom starting to fearson&#x27;s web series closest thing she will have to grandchild&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/politics.theonion.com\/boehner-just-wants-wife-to-listen-not-come-up-with-alt-1819574302&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;boehner just wants wife to listen, not come up with alternative debt-reduction ideas&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;article_link&quot;</span>:<span class="string">&quot;https:\/\/www.huffingtonpost.com\/entry\/jk-rowling-wishes-snape-happy-birthday_us_569117c4e4b0cad15e64fdcb&quot;</span>,<span class="string">&quot;headline&quot;</span>:<span class="string">&quot;j.k. rowling wishes snape happy birthday in the most magical way&quot;</span>,<span class="string">&quot;is_sarcastic&quot;</span>:<span class="number">0</span>&#125;...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高级处理-缺失值处理"><a href="#高级处理-缺失值处理" class="headerlink" title="高级处理-缺失值处理"></a>高级处理<strong>-</strong>缺失值处理</h2><ul><li>isnull判断是否有缺失数据NaN</li><li>fillna实现缺失值的填充</li><li>dropna实现缺失值的删除</li><li>replace实现数据的替换</li></ul><h3 id="如何处理nan"><a href="#如何处理nan" class="headerlink" title="如何处理nan"></a>如何处理<strong>nan</strong></h3><ul><li>获取缺失值的标记方式(NaN或者其他标记方式)</li><li>如果缺失值的标记方式是NaN<ul><li>判断数据中是否包含NaN：<ul><li>pd.isnull(df),</li><li>pd.notnull(df)</li></ul></li><li>存在缺失值nan:<ul><li>1、删除存在缺失值的:dropna(axis=’rows’)<ul><li>注：不会修改原数据，需要接受返回值</li></ul></li><li>2、替换缺失值:fillna(value, inplace=True)<ul><li>value:替换成的值</li><li>inplace:True:会修改原数据，False:不替换修改原数据，生成新的对象</li></ul></li></ul></li></ul></li><li>如果缺失值没有使用NaN标记，比如使用”？”<ul><li>先替换‘?’为np.nan，然后继续处理</li></ul></li></ul><h3 id="电影数据的缺失值处理"><a href="#电影数据的缺失值处理" class="headerlink" title="电影数据的缺失值处理"></a>电影数据的缺失值处理</h3><p>电影数据文件获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取电影数据</span></span><br><span class="line">movie = pd.read_csv(<span class="string">&quot;./data/IMDB-Movie-Data.csv&quot;</span>)</span><br></pre></td></tr></table></figure><p>判断缺失值是否存在</p><ul><li>pd.notnull()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.notnull(movie)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">all</span>(pd.notnull(movie))</span><br></pre></td></tr></table></figure><h3 id="存在缺失值nan-并且是np-nan"><a href="#存在缺失值nan-并且是np-nan" class="headerlink" title="存在缺失值nan,并且是np.nan"></a>存在缺失值<strong>nan,</strong>并且是<strong>np.nan</strong></h3><ul><li>1、删除</li></ul><p>pandas删除缺失值，使用dropna的前提是，缺失值的类型必须是np.nan</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不修改原数据</span></span><br><span class="line">movie.dropna()</span><br><span class="line"><span class="comment"># 可以定义新的变量接受或者用原来的变量名</span></span><br><span class="line">data = movie.dropna()</span><br></pre></td></tr></table></figure><p>2、替换缺失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换存在缺失值的样本的两列</span></span><br><span class="line"><span class="comment"># 替换填充平均值，中位数</span></span><br><span class="line"><span class="comment"># movie[&#x27;Revenue (Millions)&#x27;].fillna(movie[&#x27;Revenue (Millions)&#x27;].mean(), inplace=True)</span></span><br></pre></td></tr></table></figure><p>替换所有缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> movie.columns:</span><br><span class="line"><span class="keyword">if</span> np.<span class="built_in">all</span>(pd.notnull(movie[i])) == <span class="literal">False</span>:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">movie[i].fillna(movie[i].mean(), inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="不是缺失值nan，有默认标记的"><a href="#不是缺失值nan，有默认标记的" class="headerlink" title="不是缺失值nan，有默认标记的"></a>不是缺失值<strong>nan</strong>，有默认标记的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wis = pd.read_csv(<span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上数据在读取时，可能会报如下错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:<span class="number">833</span>)&gt;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局取消证书验证</span></span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure><p>处理思路分析：</p><ul><li>1、先替换‘?’为np.nan<ul><li>df.replace(to_replace=, value=)<ul><li>to_replace:替换前的值</li><li>value:替换后的值</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把一些其它值标记的缺失值，替换成np.nan</span></span><br><span class="line">wis = wis.replace(to_replace=<span class="string">&#x27;?&#x27;</span>, value=np.nan)</span><br></pre></td></tr></table></figure><p>2、在进行缺失值的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除</span></span><br><span class="line">wis = wis.dropna()</span><br></pre></td></tr></table></figure><h2 id="高级处理-数据离散化"><a href="#高级处理-数据离散化" class="headerlink" title="高级处理-数据离散化"></a>高级处理<strong>-</strong>数据离散化</h2><h3 id="什么是数据的离散化"><a href="#什么是数据的离散化" class="headerlink" title="什么是数据的离散化"></a>什么是数据的离散化</h3><p>连续属性的离散化就是在连续属性的值域上，将值域划分为若干个离散的区间，最后用不同的符号或整数 值代表落在每个子区间中的属性值。</p><h3 id="读取股票的数据"><a href="#读取股票的数据" class="headerlink" title="读取股票的数据"></a>读取股票的数据</h3><p>先读取股票的数据，筛选出p_change数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&quot;./stock_day.csv&quot;</span>)</span><br><span class="line">p_change= data[<span class="string">&#x27;p_change&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="将股票涨跌幅数据进行分组"><a href="#将股票涨跌幅数据进行分组" class="headerlink" title="将股票涨跌幅数据进行分组"></a>将股票涨跌幅数据进行分组</h3><p>使用的工具：</p><ul><li><p>pd.qcut(data, q)：</p><ul><li>对数据进行分组将数据分组，一般会与value_counts搭配使用，统计每组的个数</li></ul></li><li><p>series.value_counts()：统计分组次数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行分组</span></span><br><span class="line">qcut = pd.qcut(p_change, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 计算分到每个组数据个数</span></span><br><span class="line">qcut.value_counts()</span><br></pre></td></tr></table></figure><p>自定义区间分组：</p><ul><li>pd.cut(data, bins)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己指定分组区间</span></span><br><span class="line">bins = [-<span class="number">100</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">100</span>]</span><br><span class="line">p_counts = pd.cut(p_change, bins)</span><br></pre></td></tr></table></figure><h3 id="将股票涨跌幅数据进行分组-1"><a href="#将股票涨跌幅数据进行分组-1" class="headerlink" title="将股票涨跌幅数据进行分组"></a>将股票涨跌幅数据进行分组</h3><p>使用的工具：</p><ul><li>pd.qcut(data, q)：<ul><li>对数据进行分组将数据分组，一般会与value_counts搭配使用，统计每组的个数</li></ul></li><li>series.value_counts()：统计分组次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行分组</span></span><br><span class="line">qcut = pd.qcut(p_change, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 计算分到每个组数据个数</span></span><br><span class="line">qcut.value_counts()</span><br></pre></td></tr></table></figure><p>自定义区间分组：</p><ul><li>pd.cut(data, bins)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自己指定分组区间</span></span><br><span class="line">bins = [-<span class="number">100</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">100</span>]</span><br><span class="line">p_counts = pd.cut(p_change, bins)</span><br></pre></td></tr></table></figure><h3 id="股票涨跌幅分组数据变成one-hot编码"><a href="#股票涨跌幅分组数据变成one-hot编码" class="headerlink" title="股票涨跌幅分组数据变成one-hot编码"></a>股票涨跌幅分组数据变成<strong>one-hot</strong>编码</h3><ul><li>什么是<strong>one-hot</strong>编码</li></ul><p>把每个类别生成一个布尔列，这些列中只有一列可以为这个样本取值为1.其又被称为独热编码。</p><ul><li>pandas.get_dummies(<em>data</em>, <em>prefix=None</em>)<ul><li>data:array-like, Series, or DataFrame</li><li>prefix:分组名字</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得出one-hot编码矩阵</span></span><br><span class="line">dummies = pd.get_dummies(p_counts, prefix=<span class="string">&quot;rise&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="高级处理-合并"><a href="#高级处理-合并" class="headerlink" title="高级处理-合并"></a>高级处理<strong>-</strong>合并</h2><p>如果你的数据由多张表组成，那么有时候需要将不同的内容合并在一起分析</p><h3 id="pd-concat实现数据合并"><a href="#pd-concat实现数据合并" class="headerlink" title="pd.concat实现数据合并"></a>pd.concat实现数据合并</h3><ul><li>pd.concat([data1, data2], axis=1)<ul><li>按照行或列进行合并,axis=0为列索引，axis=1为行索引</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照行索引进行</span></span><br><span class="line">pd.concat([data, dummies], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="pd-merge"><a href="#pd-merge" class="headerlink" title="pd.merge"></a><strong>pd.merge</strong></h3><ul><li>pd.merge(left, right, how=’inner’, on=None)<ul><li>可以指定按照两组数据的共同键值对合并或者左右各自</li><li>left : DataFrame</li><li>right : 另一个DataFrame</li><li>on : 指定的共同键</li><li>how:按照什么方式连接</li></ul></li></ul><h3 id="pd-merge合并"><a href="#pd-merge合并" class="headerlink" title="pd.merge合并"></a><strong>pd.merge</strong>合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line"><span class="comment"># 默认内连接</span></span><br><span class="line">result = pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>左连接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;left&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>右连接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;right&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>外链接</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = pd.merge(left, right, how=<span class="string">&#x27;outer&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>pd.concat([数据1, 数据2], axis=**)</li><li>pd.merge(left, right, how=, on=)<ul><li>how — 以何种方式连接</li><li>on — 连接的键的依据是哪几个</li></ul></li></ul><h2 id="高级处理-交叉表与透视表"><a href="#高级处理-交叉表与透视表" class="headerlink" title="高级处理-交叉表与透视表"></a>高级处理<strong>-</strong>交叉表与透视表</h2><h3 id="交叉表与透视表什么作用"><a href="#交叉表与透视表什么作用" class="headerlink" title="交叉表与透视表什么作用"></a>交叉表与透视表什么作用</h3><p>探究股票的涨跌与星期几有关？</p><p>以下图当中表示，<strong>week</strong>代表星期几，<strong>1,0</strong>代表这一天股票的涨跌幅是好还是坏，里面的数据代表比例可以理解为所有时间为星期一等等的数据当中涨跌幅好坏的比例</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401261927547.png" alt="image-20240126192731386"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401261927185.png" alt="image-20240126192737066"></p><ul><li>交叉表：交叉表用于计算一列数据对于另外一列数据的分组个数<strong>(</strong>用于统计分组频率的特殊透视表<strong>)</strong><ul><li>pd.crosstab(value1, value2)</li></ul></li><li>透视表：透视表是将原有的<strong>DataFrame</strong>的列分别作为行索引和列索引，然后对指定的列应用聚集函数<ul><li>data.pivot_table(）</li><li>DataFrame.pivot_table([], index=[])</li></ul></li></ul><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><ul><li><p>准备两列数据，星期数据以及涨跌幅是好是坏数据</p></li><li><p>进行交叉表计算</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寻找星期几跟股票张得的关系</span></span><br><span class="line"><span class="comment"># 1、先把对应的日期找到星期几</span></span><br><span class="line">date = pd.to_datetime(data.index).weekday</span><br><span class="line">data[<span class="string">&#x27;week&#x27;</span>] = date</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、假如把p_change按照大小去分个类0为界限</span></span><br><span class="line">data[<span class="string">&#x27;posi_neg&#x27;</span>] = np.where(data[<span class="string">&#x27;p_change&#x27;</span>] &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过交叉表找寻两列数据的关系</span></span><br><span class="line">count = pd.crosstab(data[<span class="string">&#x27;week&#x27;</span>], data[<span class="string">&#x27;posi_neg&#x27;</span>])</span><br></pre></td></tr></table></figure><p>但是我们看到count只是每个星期日子的好坏天数，并没有得到比例，该怎么去做？</p><ul><li>对于每个星期一等的总天数求和，运用除法运算求出比例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 算数运算，先求和</span></span><br><span class="line"><span class="built_in">sum</span> = count.<span class="built_in">sum</span>(axis=<span class="number">1</span>).astype(np.float32)</span><br><span class="line"><span class="comment"># 进行相除操作，得出比例</span></span><br><span class="line">pro = count.div(<span class="built_in">sum</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p>使用plot画出这个比例，使用stacked的柱状图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pro.plot(kind=<span class="string">&#x27;bar&#x27;</span>, stacked=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="使用pivot-table-透视表-实现"><a href="#使用pivot-table-透视表-实现" class="headerlink" title="使用pivot_table(透视表)实现"></a>使用<strong>pivot_table(</strong>透视表<strong>)</strong>实现</h3><p>使用透视表，刚才的过程更加简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过透视表，将整个过程变成更简单一些</span></span><br><span class="line">data.pivot_table([<span class="string">&#x27;posi_neg&#x27;</span>], index=<span class="string">&#x27;week&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="高级处理-分组与聚合"><a href="#高级处理-分组与聚合" class="headerlink" title="高级处理-分组与聚合"></a>高级处理<strong>-</strong>分组与聚合</h2><p>分组与聚合通常是分析数据的一种方式，通常与一些统计函数一起使用，查看数据的分组情况</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401261931808.png" alt="image-20240126193145539"></p><h3 id="分组API"><a href="#分组API" class="headerlink" title="分组API"></a>分组<strong>API</strong></h3><ul><li>DataFrame.groupby(key, as_index=False)<ul><li>key:分组的列数据，可以多个</li></ul></li><li>案例:不同颜色的不同笔的价格数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col =pd.DataFrame(&#123;<span class="string">&#x27;color&#x27;</span>: [<span class="string">&#x27;white&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>], <span class="string">&#x27;object&#x27;</span>: [<span class="string">&#x27;pen&#x27;</span>,<span class="string">&#x27;pencil&#x27;</span>,<span class="string">&#x27;pencil&#x27;</span>,<span class="string">&#x27;ashtray&#x27;</span>,<span class="string">&#x27;pen&#x27;</span>],<span class="string">&#x27;price1&#x27;</span>:[<span class="number">5.56</span>,<span class="number">4.20</span>,<span class="number">1.30</span>,<span class="number">0.56</span>,<span class="number">2.75</span>],<span class="string">&#x27;price2&#x27;</span>:[<span class="number">4.75</span>,<span class="number">4.12</span>,<span class="number">1.60</span>,<span class="number">0.75</span>,<span class="number">3.15</span>]&#125;)</span><br></pre></td></tr></table></figure><ul><li>进行分组，对颜色分组，price进行聚合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分组，求平均值</span></span><br><span class="line">col.groupby([<span class="string">&#x27;color&#x27;</span>])[<span class="string">&#x27;price1&#x27;</span>].mean()</span><br><span class="line">col[<span class="string">&#x27;price1&#x27;</span>].groupby(col[<span class="string">&#x27;color&#x27;</span>]).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组，数据的结构不变</span></span><br><span class="line"></span><br><span class="line">col.groupby([<span class="string">&#x27;color&#x27;</span>], as_index=<span class="literal">False</span>)[<span class="string">&#x27;price1&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><h3 id="星巴克零售店铺数据"><a href="#星巴克零售店铺数据" class="headerlink" title="星巴克零售店铺数据"></a>星巴克零售店铺数据</h3><p>现在我们有一组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>从文件中读取星巴克店铺数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入星巴克店的数据</span></span><br><span class="line">starbucks = pd.read_csv(<span class="string">&quot;./data/starbucks/directory.csv&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="进行分组聚合"><a href="#进行分组聚合" class="headerlink" title="进行分组聚合"></a>进行分组聚合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照国家分组，求出每个国家的星巴克零售店数量</span></span><br><span class="line">count = starbucks.groupby([<span class="string">&#x27;Country&#x27;</span>]).count()</span><br></pre></td></tr></table></figure><p>画图显示结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count[<span class="string">&#x27;Brand&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>假设我们加入省市一起进行分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置多个索引，set_index()</span></span><br><span class="line">starbucks.groupby([<span class="string">&#x27;Country&#x27;</span>, <span class="string">&#x27;State/Province&#x27;</span>]).count()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pandas&quot;&gt;&lt;a href=&quot;#pandas&quot; class=&quot;headerlink&quot; title=&quot;pandas&quot;&gt;&lt;/a&gt;pandas&lt;/h1&gt;&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增强图表可读性&lt;/li&gt;
&lt;li&gt;便捷的数据处理能力&lt;/li&gt;
&lt;li&gt;读</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--numpy</title>
    <link href="https://rozen12123.github.io/posts/90e03a8a.html"/>
    <id>https://rozen12123.github.io/posts/90e03a8a.html</id>
    <published>2024-01-19T06:39:19.000Z</published>
    <updated>2024-01-26T15:04:39.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习—numpy"><a href="#机器学习—numpy" class="headerlink" title="机器学习—numpy"></a>机器学习—numpy</h1><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401191712425.png" alt="image-20240119171233276"></p><p>Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。</p><p>Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。</p><p>Numpy使用<strong>ndarray</strong>对象来处理多维数组，该对象是一个快速而灵活的大数据容器。</p><p>更详细的Numpy教程：<a href="https://www.runoob.com/numpy/numpy-tutorial.html">NumPy 教程 | 菜鸟教程 (runoob.com)</a></p><h2 id="ndarray介绍"><a href="#ndarray介绍" class="headerlink" title="ndarray介绍"></a><strong>ndarray</strong>介绍</h2><p>使用<strong>Python</strong>列表可以存储一维数组，通过列表的嵌套可以实现多维数组，那么为什么还需要使用<strong>Numpy</strong>的<strong>ndarray</strong>呢？</p><p>在这里我们通过一段代码运行来体会到ndarray的好处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">a.append(random.random())</span><br><span class="line"><span class="comment"># 通过%time魔法方法, 查看当前行的代码运行一次所花费的时间</span></span><br><span class="line">%time sum1=<span class="built_in">sum</span>(a)</span><br><span class="line">b=np.array(a)</span><br><span class="line">%time sum2=np.<span class="built_in">sum</span>(b)</span><br></pre></td></tr></table></figure><p>在结果中发现，通过numpy计算后的时间比原生python要快很多。</p><p>从中我们看到ndarray的计算速度要快很多，节约了时间。</p><p>机器学习的最大特点就是大量的数据运算，那么如果没有一个快速的解决方案，那可能现在python也在机器学习领域达不到好的效果。</p><h3 id="numpy和原生python的储存"><a href="#numpy和原生python的储存" class="headerlink" title="numpy和原生python的储存"></a>numpy和原生python的储存</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401191722813.png" alt="image-20240119172237683"></p><p>简单说，ndarry储存数据与数据地址都是连续的，相比于原生python省去了寻址的时间，可以省掉很多循环语句的执行时间。</p><h3 id="ndarray属性"><a href="#ndarray属性" class="headerlink" title="ndarray属性"></a>ndarray属性</h3><p>NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为 1，二维数组的秩为 2，以此类推。</p><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。</p><p>NumPy 的数组中比较重要 ndarray 对象属性有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ndarray.ndim</td><td style="text-align:left">秩，即轴的数量或维度的数量</td></tr><tr><td style="text-align:left">ndarray.shape</td><td style="text-align:left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td style="text-align:left">ndarray.size</td><td style="text-align:left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td style="text-align:left">ndarray.dtype</td><td style="text-align:left">ndarray 对象的元素类型</td></tr><tr><td style="text-align:left">ndarray.itemsize</td><td style="text-align:left">ndarray 对象中每个元素的大小，以字节为单位</td></tr></tbody></table></div><h3 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h3><h4 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h4><p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">shape</td><td style="text-align:left">数组形状</td></tr><tr><td style="text-align:left">dtype</td><td style="text-align:left">数据类型，可选</td></tr><tr><td style="text-align:left">order</td><td style="text-align:left">有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table></div><p>下面是一个创建空数组的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = np.empty([<span class="number">3</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span> (x)</span><br></pre></td></tr></table></figure><p><strong>注意</strong> − 数组元素为随机值，因为它们未初始化。</p><h4 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h4><p>创建指定大小的数组，数组元素以 0 来填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">shape</td><td style="text-align:left">数组形状</td></tr><tr><td style="text-align:left">dtype</td><td style="text-align:left">数据类型，可选</td></tr><tr><td style="text-align:left">order</td><td style="text-align:left">‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</td></tr></tbody></table></div><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.zeros(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置类型为整数</span></span><br><span class="line">y = np.zeros((<span class="number">5</span>,), dtype = <span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">z = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = [(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])  </span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><h4 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones"></a>numpy.ones</h4><p>创建指定形状的数组，数组元素以 1 来填充：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype = None, order = &#x27;C&#x27;)</span><br></pre></td></tr></table></figure><p>参数说明同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 默认为浮点数</span></span><br><span class="line">x = np.ones(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自定义类型</span></span><br><span class="line">x = np.ones([<span class="number">2</span>,<span class="number">2</span>], dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h4 id="numpy-ones-like"><a href="#numpy-ones-like" class="headerlink" title="numpy.ones_like"></a>numpy.ones_like</h4><p>numpy.ones_like 用于创建一个与给定数组具有相同形状的数组，数组元素以 1 来填充。</p><p>numpy.ones 和 numpy.ones_like 都是用于创建一个指定形状的数组，其中所有元素都是 1。</p><p>它们之间的区别在于：numpy.ones ==可以直接指定要创建的数组的形状==，而 numpy.ones_like 则是==创建一个与给定数组具有相同形状的数组==。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones_like(a, dtype=None, order=&#x27;K&#x27;, subok=True, shape=None)</span><br></pre></td></tr></table></figure><p>参数说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">a</td><td style="text-align:left">给定要创建相同形状的数组</td></tr><tr><td style="text-align:left">dtype</td><td style="text-align:left">创建的数组的数据类型</td></tr><tr><td style="text-align:left">order</td><td style="text-align:left">数组在内存中的存储顺序，可选值为 ‘C’（按行优先）或 ‘F’（按列优先），默认为 ‘K’（保留输入数组的存储顺序）</td></tr><tr><td style="text-align:left">subok</td><td style="text-align:left">是否允许返回子类，如果为 True，则返回一个子类对象，否则返回一个与 a 数组具有相同数据类型和存储顺序的数组</td></tr><tr><td style="text-align:left">shape</td><td style="text-align:left">创建的数组的形状，如果不指定，则默认为 a 数组的形状。</td></tr></tbody></table></div><p>创建一个与 arr 形状相同的，所有元素都为 1 的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个 3x3 的二维数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个与 arr 形状相同的，所有元素都为 1 的数组</span></span><br><span class="line">ones_arr = np.ones_like(arr)</span><br><span class="line"><span class="built_in">print</span>(ones_arr)</span><br></pre></td></tr></table></figure><h3 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h3><ul><li><strong>np.array(object, dtype)</strong></li><li><strong>np.asarray(a, dtype)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 从现有的数组当中创建</span></span><br><span class="line">a1 = np.array(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于索引的形式，并没有真正的创建一个新的</span></span><br><span class="line">a2 = np.asarray(a)</span><br></pre></td></tr></table></figure><p>两者的区别：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401231703882.png" alt="image-20240123170350598"></p><h3 id="生成固定范围的数组"><a href="#生成固定范围的数组" class="headerlink" title="生成固定范围的数组"></a>生成固定范围的数组</h3><h4 id="np-linspace-start-stop-num-endpoint"><a href="#np-linspace-start-stop-num-endpoint" class="headerlink" title="np.linspace (start, stop, num, endpoint)**"></a>np.linspace (start, stop, num, endpoint)**</h4><p>创建等差数组 — 指定数量</p><p>参数:</p><ul><li>start:序列的起始值</li><li>stop:序列的终止值</li><li>num:要生成的等间隔样例数量，默认为50</li><li>endpoint:序列中是否包含stop值，默认为ture</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成等间隔的数组</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">返回结果：</span><br><span class="line">array([ <span class="number">0.</span>, <span class="number">10.</span>, <span class="number">20.</span>, <span class="number">30.</span>, <span class="number">40.</span>, <span class="number">50.</span>, <span class="number">60.</span>, <span class="number">70.</span>, <span class="number">80.</span>, <span class="number">90.</span>, <span class="number">100.</span>])</span><br></pre></td></tr></table></figure><h4 id="np-arange-start-stop-step-dtype"><a href="#np-arange-start-stop-step-dtype" class="headerlink" title="np.arange(start,stop, step, dtype)"></a><strong>np.arange(start,stop, step, dtype)</strong></h4><ul><li>创建等差数组 — 指定步长</li><li>参数<ul><li>step:步长,默认值为1</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">50</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">返回结果：</span><br><span class="line">array([<span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">34</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">42</span>,</span><br><span class="line"><span class="number">44</span>, <span class="number">46</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure><h4 id="np-logspace-start-stop-num"><a href="#np-logspace-start-stop-num" class="headerlink" title="np.logspace(start,stop, num)"></a><strong>np.logspace(start,stop, num)</strong></h4><ul><li>创建等比数列</li><li>参数:<ul><li>num:要生成的等比数列数量，默认为50</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成10^x</span></span><br><span class="line">np.logspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">返回结果:</span><br><span class="line">array([ <span class="number">1.</span>, <span class="number">10.</span>, <span class="number">100.</span>])</span><br></pre></td></tr></table></figure><h3 id="生成随机数组"><a href="#生成随机数组" class="headerlink" title="生成随机数组"></a>生成随机数组</h3><h4 id="使用模块介绍"><a href="#使用模块介绍" class="headerlink" title="使用模块介绍"></a>使用模块介绍</h4><ul><li>np.random模块</li></ul><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>正态分布是一种概率分布。正态分布是具有两个参数μ和σ的连续型随机变量的分布，第一参数μ是服从正态分布的随机变量的均值，第二个参数σ是此随机变量的标准差，所以正态分布记作<strong>N(μ</strong>，<strong>σ )</strong></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401231707587.png" alt="image-20240123170710382" style="zoom:80%;"></p><p><strong>μ</strong>决定了其位置，其标准差<strong>σ</strong>决定了分布的幅度。当μ = 0,σ = 1时的正态分布是标准正态分布。</p><ul><li>方差</li></ul><p>是在概率论和统计方差衡量一组数据时离散程度的度量</p><script type="math/tex; mode=display">\sigma^2=\frac{(x_1-M)^2+(x_2-M)^2+(x_3-M)^2+\ldots\ldots(x_n-M)^2}n</script><p>其中M为平均值，n为数据总个数，σ 为标准差，σ ^2可以理解一个整体为方差</p><p>$\sigma=\sqrt{\frac{1}{N}\sum_{i=1}^{N}{(x_{i}-\mu)}^{2}}$</p><h4 id="正态分布创建方式"><a href="#正态分布创建方式" class="headerlink" title="正态分布创建方式"></a>正态分布创建方式</h4><p>np.random.randn(<em>d0, d1, …, dn</em>)</p><p>功能：从标准正态分布中返回一个或多个样本值</p><ul><li><strong>np.random.normal(</strong>loc=0.0, <strong>scale=1.0</strong>, <strong>size=None</strong>)</li></ul><p>loc：float</p><p>此概率分布的均值（对应着整个分布的中心centre）</p><p>scale：float</p><p>此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）</p><p>size：int or tuple of ints</p><p>输出的shape，默认为None，只输出一个值</p><ul><li>np.random.standard_normal(<em>size=None</em>)</li></ul><p>返回指定形状的标准正态分布的数组</p><p>举例<strong>1</strong>：生成均值为<strong>1.75</strong>，标准差为<strong>1</strong>的正态分布数据，<strong>100000000</strong>个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1 = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x1 = np.random.normal(<span class="number">1.75</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x1, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/posts/90e03a8a.htm/Vmware/bin\正态分布.png" style="zoom:67%;"></p><p>举例<strong>2</strong>：随机生成<strong>4</strong>支股票<strong>1</strong>周的交易日涨幅数据</p><p>4支股票，一周<strong>(5</strong>天<strong>)</strong>的涨跌幅数据，如何获取？</p><p>随机生成涨跌幅在某个正态分布内，比如均值0，方差1</p><p>股票涨跌幅数据的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建符合正态分布的4只股票5天的涨跌幅数据</span></span><br><span class="line">stock_change = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">stock_change</span><br></pre></td></tr></table></figure><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><ul><li>np.random.rand(<em>d0</em>, <em>d1</em>, <em>…</em>, <em>dn</em>)<ul><li>返回<strong>[0.0</strong>，<strong>1.0)</strong>内的一组均匀分布的数。</li></ul></li><li><strong>np.random.uniform(</strong>low=0.0<strong>,</strong>high=1.0<strong>,</strong> <strong>size=None</strong>)<ul><li>功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含low，不包含high.</li><li>参数介绍:<ul><li>low: 采样下界，float类型，默认值为0；</li><li>high: 采样上界，float类型，默认值为1；</li><li>size: 输出样本数目，为int或元组(tuple)类型，例如，size=(m,n,k), 则输出m<em>n</em>k个样本，缺省时输出1个值。</li></ul></li><li>返回值：ndarray类型，其形状和参数size中描述一致。</li></ul></li><li>np.random.randint(<em>low</em>, <em>high=None</em>, <em>size=None</em>, <em>dtype=’l’</em>)<ul><li>从一个均匀分布中随机采样，生成一个整数或N维整数数组，</li><li>取数范围：若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x2 = np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br></pre></td></tr></table></figure><p>画图看分布状况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成均匀分布的随机数</span></span><br><span class="line">x2 = np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">100000000</span>)</span><br><span class="line"><span class="comment"># 画图看分布状况</span></span><br><span class="line"><span class="comment"># 1）创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2）绘制直方图</span></span><br><span class="line">plt.hist(x=x2, bins=<span class="number">1000</span>) <span class="comment"># x代表要使用的数据，bins表示要划分区间数</span></span><br><span class="line"><span class="comment"># 3）显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401231732974.png" style="zoom:67%;"></p><h2 id="数组的索引、切片"><a href="#数组的索引、切片" class="headerlink" title="数组的索引、切片"></a>数组的索引、切片</h2><p>一维、二维、三维的数组如何索引？</p><ul><li>直接进行索引,切片</li><li>对象[:, :] — 先行后列</li></ul><p>二维数组索引方式：</p><ul><li>举例：获取第一个股票的前3个交易日的涨跌幅数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维的数组，两个维度</span></span><br><span class="line">stock_change[<span class="number">0</span>, <span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>三维数组索引方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三维</span></span><br><span class="line">a1 = np.array([ [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">12</span>,<span class="number">3</span>,<span class="number">34</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">array([[[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</span><br><span class="line">[[<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>],</span><br><span class="line">[ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]])</span><br><span class="line"><span class="comment"># 索引、切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure><h2 id="形状修改"><a href="#形状修改" class="headerlink" title="形状修改"></a>形状修改</h2><h3 id="ndarray-reshape-shape-order"><a href="#ndarray-reshape-shape-order" class="headerlink" title="ndarray.reshape(shape, order)"></a>ndarray.reshape(shape, order)</h3><ul><li><p>返回一个具有相同数据域，但shape不一样的视图</p></li><li><p>行、列不进行互换</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在转换形状的时候，一定要注意数组的元素匹配</span></span><br><span class="line">stock_change.reshape([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">stock_change.reshape([-<span class="number">1</span>,<span class="number">10</span>]) <span class="comment"># 数组的形状被修改为: (2, 10), -1: 表示通过待计算</span></span><br></pre></td></tr></table></figure><h3 id="ndarray-resize-new-shape"><a href="#ndarray-resize-new-shape" class="headerlink" title="ndarray.resize(new_shape)"></a>ndarray.resize(new_shape)</h3><ul><li>修改数组本身的形状（需要保持元素个数前后相同）</li><li>行、列不进行互换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stock_change.resize([<span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 查看修改后结果</span></span><br><span class="line"></span><br><span class="line">stock_change.shape</span><br><span class="line">(<span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="ndarray-T"><a href="#ndarray-T" class="headerlink" title="ndarray.T"></a><strong>ndarray.T</strong></h3><p>数组的转置</p><ul><li>将数组的行、列进行互换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_change.T.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="类型修改"><a href="#类型修改" class="headerlink" title="类型修改"></a>类型修改</h2><h3 id="ndarray-astype-type"><a href="#ndarray-astype-type" class="headerlink" title="ndarray.astype(type)"></a>ndarray.astype(type)</h3><ul><li>返回修改了类型之后的数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_change.astype(np.int32)</span><br></pre></td></tr></table></figure><h3 id="ndarray-tostring-order-或者ndarray-tobytes-order"><a href="#ndarray-tostring-order-或者ndarray-tobytes-order" class="headerlink" title="ndarray.tostring([order])或者ndarray.tobytes([order])"></a><strong>ndarray.tostring([order])</strong>或者<strong>ndarray.tobytes([order])</strong></h3><ul><li>构造包含数组中原始数据字节的Python字节</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]]])</span><br><span class="line">arr.tostring()</span><br></pre></td></tr></table></figure><h2 id="数组的去重"><a href="#数组的去重" class="headerlink" title="数组的去重"></a>数组的去重</h2><h3 id="np-unique"><a href="#np-unique" class="headerlink" title="np.unique()"></a><strong>np.unique()</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.unique(temp)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><h2 id="ndarray运算"><a href="#ndarray运算" class="headerlink" title="ndarray运算"></a><strong>ndarray</strong>运算</h2><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成10名同学，5门功课的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>score = np.random.randint(<span class="number">40</span>, <span class="number">100</span>, (<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 取出最后4名同学的成绩，用于逻辑判断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_score = score[<span class="number">6</span>:, <span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 逻辑判断, 如果成绩大于60就标记为True 否则为False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_score &gt; <span class="number">60</span></span><br><span class="line">array([[ <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>],</span><br><span class="line">[ <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>],</span><br><span class="line">[ <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>],</span><br><span class="line">[<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>]])</span><br><span class="line"><span class="comment"># BOOL赋值, 将满足条件的设置为指定的值-布尔索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_score[test_score &gt; <span class="number">60</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_score</span><br><span class="line">array([[ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">52</span>, <span class="number">1</span>],</span><br><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">59</span>, <span class="number">1</span>],</span><br><span class="line">[ <span class="number">1</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">44</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">59</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><h3 id="通用判断函数"><a href="#通用判断函数" class="headerlink" title="通用判断函数"></a>通用判断函数</h3><ul><li>np.all()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断前两名同学的成绩[0:2, :]是否全及格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">all</span>(score[<span class="number">0</span>:<span class="number">2</span>, :] &gt; <span class="number">60</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>np.any()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断前两名同学的成绩[0:2, :]是否有大于90分的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">any</span>(score[<span class="number">0</span>:<span class="number">2</span>, :] &gt; <span class="number">80</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="np-where（三元运算符）"><a href="#np-where（三元运算符）" class="headerlink" title="np.where（三元运算符）"></a><strong>np.where</strong>（三元运算符）</h3><p>通过使用np.where能够进行更加复杂的运算</p><ul><li>np.where()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0</span></span><br><span class="line">temp = score[:<span class="number">4</span>, :<span class="number">4</span>]</span><br><span class="line">np.where(temp &gt; <span class="number">60</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>复合逻辑需要结合np.logical_and和np.logical_or使用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0</span></span><br><span class="line">np.where(np.logical_and(temp &gt; <span class="number">60</span>, temp &lt; <span class="number">90</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0</span></span><br><span class="line">np.where(np.logical_or(temp &gt; <span class="number">90</span>, temp &lt; <span class="number">60</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h2><p>如果想要知道学生成绩最大的分数，或者做小分数应该怎么做？</p><h3 id="统计指标"><a href="#统计指标" class="headerlink" title="统计指标"></a>统计指标</h3><p>在数据挖掘/机器学习领域，统计指标的值也是我们分析问题的一种方式。常用的指标如下：</p><ul><li>min(a, axis)<ul><li>Return the minimum of an array or minimum along an axis.</li></ul></li><li>max(a, axis])<ul><li>Return the maximum of an array or maximum along an axis.</li></ul></li><li>median(a, axis)<ul><li>Compute the median along the specified axis.</li></ul></li><li>mean(a, axis, dtype)<ul><li>Compute the arithmetic mean along the specified axis.</li></ul></li><li>std(a, axis, dtype)<ul><li>Compute the standard deviation along the specified axis.</li></ul></li><li>var(a, axis, dtype)<ul><li>Compute the variance along the specified axis.</li></ul></li></ul><h3 id="案例：学生成绩统计运算"><a href="#案例：学生成绩统计运算" class="headerlink" title="案例：学生成绩统计运算"></a>案例：学生成绩统计运算</h3><p>进行统计的时候，<strong>axis</strong> 轴的取值并不一定，<strong>Numpy</strong>中不同的<strong>API</strong>轴的值都不一样，在这里，<strong>axis 0</strong>代表列<strong>, axis 1</strong>代表行去进行统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接下来对于前四名学生,进行一些统计运算</span></span><br><span class="line"><span class="comment"># 指定列 去统计</span></span><br><span class="line"></span><br><span class="line">temp = score[:<span class="number">4</span>, <span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前四名学生,各科成绩的最大分：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.<span class="built_in">max</span>(temp, axis=<span class="number">0</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前四名学生,各科成绩的最小分：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.<span class="built_in">min</span>(temp, axis=<span class="number">0</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前四名学生,各科成绩波动情况：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.std(temp, axis=<span class="number">0</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前四名学生,各科成绩的平均分：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.mean(temp, axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前四名学生,各科成绩的最大分：[<span class="number">96</span> <span class="number">97</span> <span class="number">72</span> <span class="number">98</span> <span class="number">89</span>]</span><br><span class="line">前四名学生,各科成绩的最小分：[<span class="number">55</span> <span class="number">57</span> <span class="number">45</span> <span class="number">76</span> <span class="number">77</span>]</span><br><span class="line">前四名学生,各科成绩波动情况：[<span class="number">16.25576821</span> <span class="number">14.92271758</span> <span class="number">10.40432602</span> <span class="number">8.0311892</span> <span class="number">4.32290412</span>]</span><br><span class="line">前四名学生,各科成绩的平均分：[<span class="number">78.5</span> <span class="number">75.75</span> <span class="number">62.5</span> <span class="number">85.</span> <span class="number">82.25</span>]</span><br></pre></td></tr></table></figure><p>如果需要统计出某科最高分对应的是哪个同学？</p><ul><li><p>np.argmax(temp, axis=)</p></li><li><p>np.argmin(temp, axis=)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前四名学生，各科成绩最高分对应的学生下标：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(np.argmax(temp, axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前四名学生，各科成绩最高分对应的学生下标：[0 2 0 0 1]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习—numpy&quot;&gt;&lt;a href=&quot;#机器学习—numpy&quot; class=&quot;headerlink&quot; title=&quot;机器学习—numpy&quot;&gt;&lt;/a&gt;机器学习—numpy&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubuserconten</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--Matplotlib</title>
    <link href="https://rozen12123.github.io/posts/b6993a5e.html"/>
    <id>https://rozen12123.github.io/posts/b6993a5e.html</id>
    <published>2024-01-18T13:48:24.000Z</published>
    <updated>2024-01-26T15:05:46.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习—Matplotlib"><a href="#机器学习—Matplotlib" class="headerlink" title="机器学习—Matplotlib"></a>机器学习—Matplotlib</h1><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>详细教程：<a href="https://www.runoob.com/matplotlib/matplotlib-tutorial.html">Matplotlib 教程 | 菜鸟教程 (runoob.com)</a></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182149375.png" alt="image-20240118214913326"></p><ul><li>是专门用于开发2D图表(包括3D图表)</li><li>以渐进、交互式方式实现数据可视化</li></ul><h2 id="简单的Matplotlib画图-—-以折线图为例"><a href="#简单的Matplotlib画图-—-以折线图为例" class="headerlink" title="简单的Matplotlib画图 — 以折线图为例"></a>简单的<strong>Matplotlib</strong>画图 <strong>—</strong> 以折线图为例</h2><h3 id="matplotlib-pyplot模块"><a href="#matplotlib-pyplot模块" class="headerlink" title="matplotlib.pyplot模块"></a>matplotlib.pyplot模块</h3><p>matplotlib.pytplot包含了一系列类似于matlab的画图函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h3 id="图形绘制流程："><a href="#图形绘制流程：" class="headerlink" title="图形绘制流程："></a>图形绘制流程：</h3><p>1.创建画布 — plt.figure()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(), dpi=)</span><br><span class="line">figsize:指定图的长宽</span><br><span class="line">dpi:图像的清晰度</span><br><span class="line">返回fig对象</span><br></pre></td></tr></table></figure><p>2.绘制图像 — plt.plot(x, y)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以折线图为例</span><br></pre></td></tr></table></figure><p>3.显示图像 — plt.show()</p><h3 id="折线图绘制与显示"><a href="#折线图绘制与显示" class="headerlink" title="折线图绘制与显示"></a>折线图绘制与显示</h3><p>举例：展现上海一周的天气<strong>,</strong>比如从星期一到星期日的天气温度如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2.绘制折线图</span></span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>], [<span class="number">17</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">13</span>])</span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182154835.png" alt="image-20240118215428683" style="zoom: 67%;"></p><h3 id="Matplotlib图像结构"><a href="#Matplotlib图像结构" class="headerlink" title="Matplotlib图像结构"></a><strong>Matplotlib</strong>图像结构</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182155335.png" alt="image-20240118215512281"></p><h2 id="例子：一个完整的流程"><a href="#例子：一个完整的流程" class="headerlink" title="例子：一个完整的流程"></a>例子：一个完整的流程</h2><p>我们通过天气温度变化的绘图来融合所有的基础API使用</p><p>需求：画出某城市<strong>11</strong>点到<strong>12</strong>点<strong>1</strong>小时内每分钟的温度变化折线图，温度范围在<strong>15</strong>度<strong>~18</strong>度效果：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182156176.png" alt="image-20240118215640044" style="zoom:80%;"></p><h3 id="准备数据并画出初始折线图"><a href="#准备数据并画出初始折线图" class="headerlink" title="准备数据并画出初始折线图"></a>准备数据并画出初始折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 画出温度变化图</span></span><br><span class="line"><span class="comment"># 0.准备x, y坐标的数据</span></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">60</span>)</span><br><span class="line">y_shanghai = [random.uniform(<span class="number">15</span>, <span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line"><span class="comment"># 2.绘制折线图</span></span><br><span class="line">plt.plot(x, y_shanghai)</span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182157260.png" alt="image-20240118215720144"></p><h3 id="添加自定义x-y刻度"><a href="#添加自定义x-y刻度" class="headerlink" title="添加自定义x,y刻度"></a>添加自定义<strong>x,y</strong>刻度</h3><ul><li>plt.xticks(x, **kwargs)<ul><li>x:要显示的刻度值</li></ul></li><li>plt.yticks(y, **kwargs)<ul><li>y:要显示的刻度值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加以下两行代码</span></span><br><span class="line"><span class="comment"># 构造x轴刻度标签</span></span><br><span class="line">x_ticks_label = [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment"># 构造y轴刻度</span></span><br><span class="line">y_ticks = <span class="built_in">range</span>(<span class="number">40</span>)</span><br><span class="line"><span class="comment"># 修改x,y轴坐标的刻度显示</span></span><br><span class="line">plt.xticks(x[::<span class="number">5</span>], x_ticks_label[::<span class="number">5</span>])</span><br><span class="line">plt.yticks(y_ticks[::<span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182158265.png" alt="image-20240118215825132"></p><p>==ps:如果没有解决过中文问题的话，会显示这个样子：==</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182158851.png" alt="image-20240118215858767" style="zoom:80%;"></p><h3 id="中文显示问题解决"><a href="#中文显示问题解决" class="headerlink" title="中文显示问题解决"></a>中文显示问题解决</h3><p>解决方案一：</p><p>下载中文字体（黑体，看准系统版本）</p><ul><li>步骤一：下载 SimHei 字体（或者其他的支持中文显示的字体也行）</li></ul><p>步骤二：安装字体</p><p>linux下：拷贝字体到 usr/share/fonts 下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ~/SimHei.ttf /usr/share/fonts/SimHei.ttf</span><br></pre></td></tr></table></figure><p>windows和mac下：双击安装    </p><p>步骤三：删除~/.matplotlib中的缓存文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.matplotlib</span><br><span class="line">rm -r *</span><br></pre></td></tr></table></figure><p>步骤四：修改配置文件matplotlibrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.matplotlib/matplotlibrc</span><br></pre></td></tr></table></figure><p>将文件内容修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">font.family : sans-serif</span><br><span class="line">font.sans-serif : SimHei</span><br><span class="line">axes.unicode_minus : False</span><br></pre></td></tr></table></figure><p>解决方案二：</p><p>在Python脚本中动态设置matplotlibrc,这样也可以避免由于更改配置文件而造成的麻烦，具体代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pylab import mpl</span><br><span class="line">\# 设置显示中文字体</span><br><span class="line">mpl.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;]</span><br></pre></td></tr></table></figure><p>有时候，字体更改后，会导致坐标轴中的部分字符无法正常显示，此时需要更改axes.unicode_minus参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置正常显示符号</span></span><br><span class="line">mpl.rcParams[&quot;axes.unicode_minus&quot;] = False</span><br></pre></td></tr></table></figure><h3 id="添加网格显示"><a href="#添加网格显示" class="headerlink" title="添加网格显示"></a>添加网格显示</h3><p>为了更加清楚地观察图形对应的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182202027.png" alt="image-20240118220230960" style="zoom:80%;"></p><h3 id="添加描述信息"><a href="#添加描述信息" class="headerlink" title="添加描述信息"></a>添加描述信息</h3><p>添加x轴、y轴描述信息及标题</p><ul><li>通过fontsize参数可以修改图像中字体的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;中午11点0分到12点之间的温度变化图示&quot;</span>, fontsize=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182203392.png" alt="image-20240118220308250"></p><h3 id="图像保存"><a href="#图像保存" class="headerlink" title="图像保存"></a>图像保存</h3><p># 保存图片到指定路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&quot;test.png&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意：plt.show()会释放figure资源，如果在显示图像之后保存图片将只能保存空图片。</p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"></span><br><span class="line"><span class="number">52</span><span class="comment"># 设置显示中文字体</span></span><br><span class="line"></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line">\<span class="comment"># 设置正常显示符号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line">\<span class="comment"># 0.准备数据</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">60</span>)</span><br><span class="line">y_shanghai = [random.uniform(<span class="number">15</span>, <span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line">\<span class="comment"># 2.绘制图像</span></span><br><span class="line">plt.plot(x, y_shanghai)</span><br><span class="line">\<span class="comment"># 2.1 添加x,y轴刻度</span></span><br><span class="line">\<span class="comment"># 构造x,y轴刻度标签</span></span><br><span class="line">x_ticks_label = [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y_ticks = <span class="built_in">range</span>(<span class="number">40</span>)</span><br><span class="line">\<span class="comment"># 刻度显示</span></span><br><span class="line">plt.xticks(x[::<span class="number">5</span>], x_ticks_label[::<span class="number">5</span>])</span><br><span class="line">plt.yticks(y_ticks[::<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 2.2 添加网格显示</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&quot;--&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 2.3 添加描述信息</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;中午11点--12点某城市温度变化图&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 2.4 图像保存</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 3.图像显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="例子：在一个坐标系中绘制多个图像"><a href="#例子：在一个坐标系中绘制多个图像" class="headerlink" title="例子：在一个坐标系中绘制多个图像"></a>例子：在一个坐标系中绘制多个图像</h2><h3 id="多次plot"><a href="#多次plot" class="headerlink" title="多次plot"></a>多次<strong>plot</strong></h3><p>需求：再添加一个城市的温度变化</p><p>收集到北京当天温度变化情况，温度在1度到3度。怎么去添加另一个在同一坐标系当中的不同图形，其实很简单只需要再次<strong>plot</strong>即可，但是需要区分线条，如下显示：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182206579.png" alt="image-20240118220602425"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加北京的温度数据</span></span><br><span class="line">y_beijing = [random.uniform(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment"># 绘制折线图</span></span><br><span class="line">plt.plot(x, y_shanghai)</span><br><span class="line"><span class="comment"># 使用多次plot可以画多个折线</span></span><br><span class="line">plt.plot(x, y_beijing, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们仔细观察，用到了两个新的地方，一个是对于不同的折线展示效果，一个是添加图例。</p><h3 id="设置图形风格"><a href="#设置图形风格" class="headerlink" title="设置图形风格"></a>设置图形风格</h3><p>颜色和线的类型</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色标记</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘r’</td><td style="text-align:left">红色</td></tr><tr><td style="text-align:left">‘g’</td><td style="text-align:left">绿色</td></tr><tr><td style="text-align:left">‘b’</td><td style="text-align:left">蓝色</td></tr><tr><td style="text-align:left">‘c’</td><td style="text-align:left">青色</td></tr><tr><td style="text-align:left">‘m’</td><td style="text-align:left">品红</td></tr><tr><td style="text-align:left">‘y’</td><td style="text-align:left">黄色</td></tr><tr><td style="text-align:left">‘k’</td><td style="text-align:left">黑色</td></tr><tr><td style="text-align:left">‘w’</td><td style="text-align:left">白色</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">简写</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">‘solid’ (默认)</td><td style="text-align:left">‘-‘</td><td style="text-align:left">实线</td></tr><tr><td style="text-align:left">‘dotted’</td><td style="text-align:left">‘:’</td><td style="text-align:left">点虚线</td></tr><tr><td style="text-align:left">‘dashed’</td><td style="text-align:left">‘—‘</td><td style="text-align:left">破折线</td></tr><tr><td style="text-align:left">‘dashdot’</td><td style="text-align:left">‘-.’</td><td style="text-align:left">点划线</td></tr><tr><td style="text-align:left">‘None’</td><td style="text-align:left">‘’ 或 ‘ ‘</td><td style="text-align:left">不画线</td></tr></tbody></table></div><h3 id="显示图例"><a href="#显示图例" class="headerlink" title="显示图例"></a>显示图例</h3><p>注意：如果只在plt.plot()中设置label还不能最终显示出图例，还需要通过plt.legend()将图例显示出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制折线图</span></span><br><span class="line">plt.plot(x, y_shanghai, label=<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">\<span class="comment"># 使用多次plot可以画多个折线</span></span><br><span class="line">plt.plot(x, y_beijing, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 显示图例</span></span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0.准备数据</span></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">60</span>)</span><br><span class="line">y_shanghai = [random.uniform(<span class="number">15</span>, <span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y_beijing = [random.uniform(<span class="number">1</span>,<span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 2.绘制图像</span></span><br><span class="line">plt.plot(x, y_shanghai, label=<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">plt.plot(x, y_beijing, color=<span class="string">&quot;r&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line"><span class="comment"># 2.1 添加x,y轴刻度</span></span><br><span class="line"><span class="comment"># 构造x,y轴刻度标签</span></span><br><span class="line">x_ticks_label = [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y_ticks = <span class="built_in">range</span>(<span class="number">40</span>)</span><br><span class="line"><span class="comment"># 刻度显示</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line">plt.xticks(x[::<span class="number">5</span>], x_ticks_label[::<span class="number">5</span>])</span><br><span class="line">plt.yticks(y_ticks[::<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 2.2 添加网格显示</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&quot;--&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 2.3 添加描述信息</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;中午11点--12点某城市温度变化图&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 2.4 图像保存</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test.png&quot;</span>)</span><br><span class="line"><span class="comment"># 2.5 添加图例</span></span><br><span class="line">plt.legend(loc=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 3.图像显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="例子：多个坐标系显示—-plt-subplots-面向对象的画图方法"><a href="#例子：多个坐标系显示—-plt-subplots-面向对象的画图方法" class="headerlink" title="例子：多个坐标系显示— plt.subplots(面向对象的画图方法)"></a>例子：多个坐标系显示<strong>— plt.subplots(</strong>面向对象的画图方法<strong>)</strong></h2><p>如果我们想要将上海和北京的天气图显示在同一个图的不同坐标系当中，效果如下：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182214639.png" alt="image-20240118221403417"></p><p>可以通过subplots函数实现(旧的版本中有subplot，使用起来不方便)，推荐subplots函数</p><ul><li>matplotlib.pyplot.subplots(nrows=1, ncols=1, **fig_kw) 创建一个带有多个axes(坐标系/绘图区)的图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parameters:</span><br><span class="line">nrows, ncols : 设置有几行几列坐标系</span><br><span class="line"><span class="built_in">int</span>, optional, default: <span class="number">1</span>, Number of rows/columns of the subplot grid.</span><br><span class="line"></span><br><span class="line">Returns:</span><br><span class="line">fig : 图对象</span><br><span class="line">axes : 返回相应数量的坐标系</span><br><span class="line"></span><br><span class="line">设置标题等方法不同：</span><br><span class="line">set_xticks</span><br><span class="line">set_yticks</span><br><span class="line">set_xlabel</span><br><span class="line">set_ylabel</span><br></pre></td></tr></table></figure><p>关于axes子坐标系的更多方法：参考<a href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes">https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes</a></p><p>注意：<strong>plt.</strong>函数名<strong>()</strong>相当于面向过程的画图方法，<strong>axes.set_</strong>方法名<strong>()</strong>相当于面向对象的画图方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0.准备数据</span></span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">60</span>)</span><br><span class="line">y_shanghai = [random.uniform(<span class="number">15</span>, <span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y_beijing = [random.uniform(<span class="number">1</span>, <span class="number">5</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line"><span class="comment"># plt.figure(figsize=(20, 8), dpi=100)</span></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.绘制图像</span></span><br><span class="line"><span class="comment"># plt.plot(x, y_shanghai, label=&quot;上海&quot;)</span></span><br><span class="line"><span class="comment"># plt.plot(x, y_beijing, color=&quot;r&quot;, linestyle=&quot;--&quot;, label=&quot;北京&quot;)</span></span><br><span class="line">axes[<span class="number">0</span>].plot(x, y_shanghai, label=<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].plot(x, y_beijing, color=<span class="string">&quot;r&quot;</span>, linestyle=<span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;北京&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 添加x,y轴刻度</span></span><br><span class="line"><span class="comment"># 构造x,y轴刻度标签</span></span><br><span class="line">x_ticks_label = [<span class="string">&quot;11点&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">y_ticks = <span class="built_in">range</span>(<span class="number">40</span>)</span><br><span class="line"><span class="comment"># 刻度显示</span></span><br><span class="line"><span class="comment"># plt.xticks(x[::5], x_ticks_label[::5])</span></span><br><span class="line"><span class="comment"># plt.yticks(y_ticks[::5])</span></span><br><span class="line">axes[<span class="number">0</span>].set_xticks(x[::<span class="number">5</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_yticks(y_ticks[::<span class="number">5</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_xticklabels(x_ticks_label[::<span class="number">5</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_xticks(x[::<span class="number">5</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_yticks(y_ticks[::<span class="number">5</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_xticklabels(x_ticks_label[::<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 添加网格显示</span></span><br><span class="line"><span class="comment"># plt.grid(True, linestyle=&quot;--&quot;, alpha=0.5)</span></span><br><span class="line">axes[<span class="number">0</span>].grid(<span class="literal">True</span>, linestyle=<span class="string">&quot;--&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">axes[<span class="number">1</span>].grid(<span class="literal">True</span>, linestyle=<span class="string">&quot;--&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 添加描述信息</span></span><br><span class="line"><span class="comment"># plt.xlabel(&quot;时间&quot;)</span></span><br><span class="line"><span class="comment"># plt.ylabel(&quot;温度&quot;)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20)</span></span><br><span class="line">axes[<span class="number">0</span>].set_xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;中午11点--12点某城市温度变化图&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_xlabel(<span class="string">&quot;时间&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_ylabel(<span class="string">&quot;温度&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;中午11点--12点某城市温度变化图&quot;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 2.4 图像保存</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 2.5 添加图例</span></span><br><span class="line"><span class="comment"># plt.legend(loc=0)</span></span><br><span class="line">axes[<span class="number">0</span>].legend(loc=<span class="number">0</span>)</span><br><span class="line">axes[<span class="number">1</span>].legend(loc=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.图像显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="折线图的应用场景"><a href="#折线图的应用场景" class="headerlink" title="折线图的应用场景"></a>折线图的应用场景</h2><ul><li>呈现公司产品(不同区域)每天活跃用户数</li><li>呈现app每天下载数量</li><li>呈现产品新功能上线后,用户点击次数随时间的变化</li><li>拓展：画各种数学函数图像<ul><li>注意：plt.plot()除了可以画折线图，也可以用于画各种数学函数图像</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182216857.png" alt="image-20240118221623760" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 0.准备数据</span></span><br><span class="line">x = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.绘制函数图像</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 2.1 添加网格显示</span></span><br><span class="line">plt.grid()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>添加x,y轴刻度<ul><li>plt.xticks()</li><li>plt.yticks()</li><li>注意<strong>:</strong>在传递进去的第一个参数必须是数字<strong>,</strong>不能是字符串<strong>,</strong>如果是字符串吗<strong>,</strong>需要进行替换操作</li></ul></li><li>添加网格显示<ul><li>plt.grid(linestyle=”—“, alpha=0.5)</li></ul></li><li>添加描述信息<ul><li>plt.xlabel()</li><li>plt.ylabel()</li><li>plt.title()</li></ul></li><li>图像保存<ul><li>plt.savefig(“路径”)</li></ul></li><li>多次plot<ul><li>直接进行添加就OK</li></ul></li><li>显示图例<ul><li>plt.legend(loc=”best”)</li><li>注意<strong>:</strong>一定要在<strong>plt.plot()</strong>里面设置一个<strong>label,</strong>如果不设置<strong>,</strong>没法显示</li></ul></li><li>多个坐标系显示<ul><li>plt.subplots(nrows=, ncols=)</li></ul></li><li>折线图的应用<ul><li>1.应用于观察数据的变化</li><li>2.可是画出一些数学函数图像</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习—Matplotlib&quot;&gt;&lt;a href=&quot;#机器学习—Matplotlib&quot; class=&quot;headerlink&quot; title=&quot;机器学习—Matplotlib&quot;&gt;&lt;/a&gt;机器学习—Matplotlib&lt;/h1&gt;&lt;h2 id=&quot;Matplotlib&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--jupyter notebook的使用</title>
    <link href="https://rozen12123.github.io/posts/afe89f5c.html"/>
    <id>https://rozen12123.github.io/posts/afe89f5c.html</id>
    <published>2024-01-18T13:12:47.000Z</published>
    <updated>2024-01-26T15:06:37.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习—jupyter-notebook的使用"><a href="#机器学习—jupyter-notebook的使用" class="headerlink" title="机器学习—jupyter notebook的使用"></a>机器学习—jupyter notebook的使用</h1><p>Jupyter项目是一个非盈利的开源项目，源于2014年的ipython项目，因为它逐渐发展为支持跨所有编程语言的交互式数据科学和科学计算</p><p>Jupyter Notebook，原名IPython Notbook，是IPython的加强网页版，一个开源Web应用程序</p><p>名字源自Julia、Python 和 R（数据科学的三种开源语言）</p><p>是一款程序员和科学工作者的编程<strong>/</strong>文档<strong>/</strong>笔记<strong>/</strong>展示软件</p><p><strong>.ipynb</strong>文件格式是用于计算型叙述的<strong>JSON</strong>文档格式的正式规范</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182116444.png" alt="image-20240118211659271"></p><ul><li>传统软件开发：工程／目标明确<ul><li>需求分析，设计架构，开发模块，测试</li></ul></li><li>数据挖掘：艺术／目标不明确<ul><li>目的是具体的洞察目标，而不是机械的完成任务</li><li>通过执行代码来理解问题</li><li>迭代式地改进代码来改进解决方法</li></ul></li></ul><p>实时运行的代码、叙事性的文本和可视化被整合在一起，方便使用代码和数据来讲述故事</p><h2 id="相关库和jupyter的安装"><a href="#相关库和jupyter的安装" class="headerlink" title="相关库和jupyter的安装"></a>相关库和jupyter的安装</h2><p>看这个：<a href="https://www.cnblogs.com/chjxbt/p/10517952.html">Python虚拟环境的搭建 - chjxbt - 博客园 (cnblogs.com)</a>搭建好python的虚拟环境。</p><p>逐行在命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv ai</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br><span class="line">pip install numpy</span><br><span class="line">pip install pandas</span><br><span class="line">pip install tables</span><br><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><h2 id="jupyter-启动！"><a href="#jupyter-启动！" class="headerlink" title="jupyter 启动！"></a>jupyter 启动！</h2><p>环境搭建好后，本机输入jupyter notebook命令，会自动弹出浏览器窗口打开Jupyter Notebook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入虚拟环境</span></span><br><span class="line">workon ai</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入命令</span></span><br><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><ul><li><p>命令模式：按ESC进入</p><ul><li>Y ，cell切换到Code模式</li><li>M ，cell切换到Markdown模式</li><li>A ，在当前cell的上面添加cell</li><li>B ，在当前cell的下面添加cell</li></ul></li><li><p>两种模式通用快捷键</p><ul><li><strong>Shift+Enter</strong> ，执行本单元代码，并跳转到下一单元</li><li><strong>Ctrl+Enter</strong> ，执行本单元代码，留在本单元</li></ul></li></ul><p>同时，其他小工具请安装jupyter_contrib_nbextensions库</p><p>安装该库的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install jupyter_contrib_nbextensions</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter contrib nbextension install --user --skip-running-check</span><br></pre></td></tr></table></figure><p>在原来的基础上勾选： “Table of Contents” 以及 “Hinterland”</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401182145611.png" alt="image-20240118214521386"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习—jupyter-notebook的使用&quot;&gt;&lt;a href=&quot;#机器学习—jupyter-notebook的使用&quot; class=&quot;headerlink&quot; title=&quot;机器学习—jupyter notebook的使用&quot;&gt;&lt;/a&gt;机器学习—jupyter n</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能概述</title>
    <link href="https://rozen12123.github.io/posts/4743dd5a.html"/>
    <id>https://rozen12123.github.io/posts/4743dd5a.html</id>
    <published>2024-01-18T10:21:33.000Z</published>
    <updated>2024-01-26T15:06:04.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工智能概述"><a href="#人工智能概述" class="headerlink" title="人工智能概述"></a>人工智能概述</h1><p>入门人工智能，了解人工智能是什么。为啥发展起来，用途是什么，是最重要也是最关键的事情。大致有以下思路。</p><ol><li>人工智能发展历程</li><li>机器学习定义以及应用场景</li><li>监督学习，无监督学习</li><li>监督学习中的分类、回归特点</li><li>知道机器学习的开发流程</li></ol><h2 id="人工智能发展历程"><a href="#人工智能发展历程" class="headerlink" title="人工智能发展历程"></a>人工智能发展历程</h2><ul><li>人工智能在现实生活中的应用</li><li>人工智能发展必备三要素</li><li>人工智能和机器学习、深度学习三者之间的关系</li></ul><h3 id="人工智能在现实生活中的应用"><a href="#人工智能在现实生活中的应用" class="headerlink" title="人工智能在现实生活中的应用"></a>人工智能在现实生活中的应用</h3><p>虽然人工智能在今天可能是一个流行词，但在明天，它可能会成为我们日常生活的标准一部分。事实上，它已经在这里了。</p><p>例如，自动驾驶汽车，学校门禁的人脸识别系统，手机语音助手，以及我们在各个平台上看视频的首页推荐。都是用到人工智能的。</p><h3 id="人工智能发展必备三要素"><a href="#人工智能发展必备三要素" class="headerlink" title="人工智能发展必备三要素"></a>人工智能发展必备三要素</h3><ul><li>数据</li><li>算法</li><li>计算力<ul><li>CPU,GPU,TPU</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181832641.png" alt="image-20240118183206567"></p><ul><li><p>计算力之CPU、GPU对比：</p><ul><li><p>CPU主要适合I\O密集型的任务</p></li><li><p>GPU主要适合计算密集型任务</p></li></ul></li></ul><p>CPU和GPU的区别：</p><p><a href="http://www.sohu.com/a/201309334_468740">http://www.sohu.com/a/201309334_468740</a></p><h3 id="人工智能、机器学习和深度学习"><a href="#人工智能、机器学习和深度学习" class="headerlink" title="人工智能、机器学习和深度学习"></a>人工智能、机器学习和深度学习</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181834296.png" alt="image-20240118183437094"></p><ul><li>人工智能和机器学习，深度学习的关系<ul><li>机器学习是人工智能的一个实现途径</li><li>深度学习是机器学习的一个方法发展而来</li></ul></li></ul><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><h4 id="图灵测试"><a href="#图灵测试" class="headerlink" title="图灵测试"></a>图灵测试</h4><p>测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。多次测试（一般为<strong>5min</strong>之内），如果有超过<strong>30%</strong>的测试者不能确定被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能.</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181837161.png" alt="image-20240118183738033"></p><p>人工智能主要分支</p><ul><li>计算机视觉</li><li>语音识别</li><li>文本挖掘/分类</li><li>机器翻译</li><li>机器人</li></ul><h2 id="机器学习定义以及应用场景"><a href="#机器学习定义以及应用场景" class="headerlink" title="机器学习定义以及应用场景"></a>机器学习定义以及应用场景</h2><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p>机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181840056.png" alt="image-20240118184021941"></p><h3 id="机器学习工作流程"><a href="#机器学习工作流程" class="headerlink" title="机器学习工作流程"></a>机器学习工作流程</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181841120.png" alt="image-20240118184109788"></p><ul><li>机器学习工作流程总结<ul><li><strong>1.</strong>获取数据</li><li><strong>2.</strong>数据基本处理</li><li><strong>3.</strong>特征工程</li><li><strong>4.</strong>机器学习<strong>(</strong>模型训练<strong>)</strong></li><li><strong>5.</strong>模型评估</li></ul></li></ul><p>结果达到要求，上线服务</p><p>没有达到要求，重新上面步骤</p><h3 id="获取到的数据集介绍"><a href="#获取到的数据集介绍" class="headerlink" title="获取到的数据集介绍"></a>获取到的数据集介绍</h3><ul><li>数据简介</li></ul><p>在数据集中一般：</p><p>一行数据我们称为一个<strong>样本</strong></p><p>一列数据我们成为一个<strong>特征</strong></p><p>有些数据有目标值（标签值），有些数据没有目标值</p><ul><li>数据类型构成：</li></ul><p>数据类型一：特征值+目标值（目标值是连续的和离散的）</p><p>数据类型二：只有特征值，没有目标值</p><p>数据分割：</p><ul><li>机器学习一般的数据集会划分为两个部分：<ul><li>训练数据：用于训练，构建模型</li><li>测试数据：在模型检验时使用，用于评估模型是否有效</li></ul></li><li>划分比例<ul><li>训练集：70% 80% 75%</li><li>测试集：30% 20% 25%</li></ul></li></ul><h4 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h4><p>特征工程是使用专业背景知识和技巧处理数据，使得特征能在机器学习算法上发挥更好的作用的过程。</p><p>意义：会直接影响机器学习的效果</p><ul><li>注：业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</li></ul><p>特征工程包含内容</p><ul><li>特征提取</li><li>特征预处理</li><li>特征降维</li></ul><p>特征提取：例如将文字变成机器可以识别的语言</p><p>特征预处理：通过一些转换函数将特征数据转换成更加适合算法模型的特征数据过程</p><p>特征降维：指在某些限定条件下，降低随机变量<strong>(</strong>特征<strong>)</strong>个数，得到一组<strong>“</strong>不相关<strong>”</strong>主变量的过程。；例如将3D图像变换成2D图像的过程。</p><h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><p>根据数据集组成不同，可以把机器学习算法分为：</p><ul><li>监督学习</li><li>无监督学习</li><li>半监督学习</li><li>强化学习</li></ul><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><ul><li>输入数据是由输入特征值和目标值所组成。<ul><li>函数的输出可以是一个连续的值(称为回归），</li><li>或是输出是有限个离散值（称作分类）。</li></ul></li></ul><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><p>例如：预测房价，根据样本集拟合出一条连续曲线。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181857822.png" alt="image-20240118185708552"></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>例如：根据肿瘤特征判断良性还是恶性，得到的是结果是“良性”或者“恶性”，是离散的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181857180.png" alt="image-20240118185726060"></p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><ul><li>输入数据是由输入特征值组成，没有目标值<ul><li>输入数据没有被标记，也没有确定的结果。样本数据类别未知；</li><li>需要根据样本间的相似性对样本集进行类别划分。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181858613.png" alt="image-20240118185828504"></p><h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>训练集同时包含有标记样本数据和未标记样本数据。</p><p>他与监督学习，无监督学习的区别就是模型在训练时需要人工标注的标签信息，监督学习利用大量的标注数据来训练模型，使模型最终学习到输入和输出标签之间的相关性；半监督学习利用少量有标签的数据和大量无标签的数据来训练网络；而无监督学习不依赖任何标签值，通过对数据内在特征的挖掘，找到样本间的关系，比如聚类。</p><p>监督学习：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181901832.png" alt="image-20240118190114710"></p><p>半监督学习：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181901225.png" alt="image-20240118190135101"></p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>实质是make decisions 问题，即<strong>自动进行决策</strong>，并且可以<strong>做连续决策</strong>。</p><p>举例：（学下棋）</p><p>小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。</p><p>小孩就是 <strong>agent</strong>，他试图通过采取行动（即行走）来操纵环境（行走的表面），并且从一个状态转变到另一个状态（即他走的每一步），当他</p><p>完成任务的子任务（即走了几步）时，孩子得到奖励（给巧克力吃），并且当他不能走路时，就不会给巧克力。</p><p>主要包含五个元素：agent, action, reward, environment, observation；</p><p>强化学习的目标就是获得最多的累计奖励。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202401181903389.png" alt="image-20240118190330019"></p><div class="table-container"><table><thead><tr><th></th><th>监督学习</th><th>强化学习</th></tr></thead><tbody><tr><td>反馈映射</td><td>输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。</td><td>输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。</td></tr><tr><td>反馈时间</td><td>做了比较坏的选择会立刻反馈给算法。</td><td>结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。</td></tr><tr><td>输入特征</td><td>输入是独立同分布的。</td><td>面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。</td></tr></tbody></table></div><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>模型评估是模型开发过程不可或缺的一部分。它有助于发现表达数据的最佳模型和所选模型将来工作的性能如何。</p><p>按照数据集的目标值不同，可以把模型评估分为分类模型评估和回归模型评估。</p><ul><li>准确率<ul><li>预测正确的数占样本总数的比例。</li></ul></li><li>其他评价指标：精确率、召回率、<strong>F1-score</strong>、<strong>AUC</strong>指标等</li></ul><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><p>模型评估用于评价训练好的的模型的表现效果，其表现效果大致可以分为两类：过拟合、欠拟合。</p><p>在训练过程中，你可能会遇到如下问题：</p><p>训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？</p><p>当算法在某个数据集当中出现这种情况，可能就出现了拟合问题。</p><p>欠拟合：模型学习的太过粗糙，连训练集中的样本数据特征关系都没有学出来。</p><p>过拟合：所建的机器学习模型或者是深度学习模型在训练样本中表现得过于优越，导致在测试数据集中表现不佳。</p><h2 id="Azure机器学习模型搭建实验"><a href="#Azure机器学习模型搭建实验" class="headerlink" title="Azure机器学习模型搭建实验"></a><strong>Azure</strong>机器学习模型搭建实验</h2><p>可以进行很简便的图形化训练。</p><p>Azure Machine Learning（简称“AML”）是微软在其公有云Azure上推出的基于Web使用的一项机器学习服务，机器学习属人工智能的一个分支，它技术借助算法让电脑对大量流动数据集进行识别。这种方式能够通过历史数据来预测未来事件和行为，其实现方式明显优于传统的商业智能形式。</p><p>微软的目标是简化使用机器学习的过程，以便于开发人员、业务分析师和数据科学家进行广泛、便捷地应用。</p><p>这款服务的目的在于“将机器学习动力与云计算的简单性相结合”。</p><p>AML目前在微软的Global Azure云服务平台提供服务，用户可以通过站点：<strong><a href="https://studio.azureml.net/">https://studio.azureml.net/</a></strong> 申请免费试用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人工智能概述&quot;&gt;&lt;a href=&quot;#人工智能概述&quot; class=&quot;headerlink&quot; title=&quot;人工智能概述&quot;&gt;&lt;/a&gt;人工智能概述&lt;/h1&gt;&lt;p&gt;入门人工智能，了解人工智能是什么。为啥发展起来，用途是什么，是最重要也是最关键的事情。大致有以下思路。&lt;/p</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://rozen12123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rozen12123.github.io/posts/0.html"/>
    <id>https://rozen12123.github.io/posts/0.html</id>
    <published>2023-12-17T13:32:51.962Z</published>
    <updated>2023-12-19T08:14:21.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络可以计算任何函数的可视化证明"><a href="#神经网络可以计算任何函数的可视化证明" class="headerlink" title="神经网络可以计算任何函数的可视化证明"></a>神经网络可以计算任何函数的可视化证明</h1><p>对于神经网络，一个显著的事实就是它可以计算任何函数。</p><p>如下：不管该函数如何，总有神经网络能够对任何可能的输入x，输出值f（x）</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172051164.png" alt="image-20231217205116099" style="zoom:67%;"></p><p>即使函数有很多输入和输出，$f=f(x_1,\cdots,x_m)$，结果也是成立的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172040247.png" alt="image-20231217204027194"></p><p>结果表明神经网络具有一种普遍性，无论我们想计算什么函数，都能用神经网络实现。</p><p>普遍性定理在计算机科学领域中特别常见，我们几乎可以将生活中的任何过程看作函数的计算，例如基于一段音乐识别曲目，其实也能将其视为计算一个函数，或者将中文翻译成英文”，又或者根据一个mp4视频文件生成对电影情节的描述并讨论表演水平。</p><p>普遍性指神经网络可以做各种事情。本质上就是通过一定的规律由a变b的性质。</p><p>&nbsp;</p><h2 id="两个预先声明"><a href="#两个预先声明" class="headerlink" title="两个预先声明"></a>两个预先声明</h2><p>在解释为什么普遍性成立之前，需要给“神经网络可以计算任意函数”两个预先声明。</p><p>第一点，<code>这句话不是说神经网络可用于准确计算任何函数，而是说可以获得不错的近似</code>。可以通过增加隐藏神经元的数量来提升近似的准确度。</p><p>例如一个网络中含有五个隐藏神经元的话肯定比含有3个隐藏神经元更好得近似结果。</p><p>第二点，可以按照上述方式近似的函数其实是连续函数。<code>如果函数不是连续的，即会有突然的“跳跃”，那么通常无法使用一个神经网络进行近似</code>。</p><p>这并不意外，因为神经网络计算的是输人的连续函数。然而，即使那些需要计算的函数是不连续的，连续的近似一般也足够好了。这样的话，就可以用神经网络来近似了。实践中，这通常不是一个严重的限制。</p><p>总结一下，关于普遍性定理，更加准确的表述是：==包含隐藏层的神经网络可按照任意给定的准确度来近似任何连续函数。==</p><p>&nbsp;</p><h2 id="一个输入和一个输出的普遍性"><a href="#一个输入和一个输出的普遍性" class="headerlink" title="一个输入和一个输出的普遍性"></a>一个输入和一个输出的普遍性</h2><p>为了理解如何构造一个神经网络来计算了，先从只包含一个隐藏层的神经网络开始，它有两个隐藏神经元，以及由单个输出神经元形成的输出层。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172041876.png" alt="image-20231217204132828" style="zoom:67%;"></p><p>为了理解神经网络组件的工作机制，下面着重研究顶部的隐藏神经元。了解顶部隐藏神经元的权重w、偏置b和输出曲线的关系。思考如何通过顶部隐藏神经元的变化计算函数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172041491.png" alt="image-20231217204145422" style="zoom:67%;"></p><p>如前所述，隐藏神经元计算的是$\sigma(wx+b)$，其中$\sigma(z)\equiv1/(1+\mathrm{e}^{-z})$是sigmoid函数。前面频繁使用这个代数形式，这里为了证明普遍性会完全忽略其代数性质，而会在图像中调整并观察形状来获得更多认识。<br>一开始增大偏置b的值。当偏置增加时，图形向左移动，但是形状保持不变。<br>接着减小偏置。当偏置减小时，图形向右移动，但形状仍没有变化。</p><p>然后将权重减小到大约2或3.当权重减小时，曲线向两边拉宽了。可以通过改变偏置让曲线保持在框内。<br>最后，把权重增加到超过100.这会使得曲线变得越来越陡，最终看上去像阶跃函数。尝试调整偏置，使得阶跃位置靠近x=0.3.</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172042343.png" alt="image-20231217204200291" style="zoom:67%;"></p><p>你能给权重增加很⼤的值来简化我们的分析，使得输出实际上是个⾮常接近的阶跃函数。下⾯我画出了当权重为 <em>w</em> = 999 时从顶部隐藏神经元的输出。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172042604.png" alt="image-20231217204258538" style="zoom: 67%;"></p><p>实际上处理阶跃函数⽐⼀般的 S 型函数更加容易。很显然相比于思考把⼀串 S 形状的曲线加起来是什么，我们只考虑在输出层我们把所有隐藏神经元的贡献值加在⼀起，分析⼀串阶跃函数的和是很容易的。</p><p>所以假设我们的隐藏神经元输出阶跃函数会使事情更容易。更具体些，我们把权重 <em>w</em> 固定在⼀个⼤的值，然后通过修改偏置设置阶跃函数的位置。</p><p>当然，把输出作为⼀个阶跃函数处理只是⼀个近似，但是它是⼀个⾮常好的近似，现在我们把它看作是精确的。</p><p>&nbsp;</p><p><em>x</em> 取何值时阶跃会发⽣呢？换种⽅式，阶跃的位置如何取决于权重和偏置？</p><p>得出的结论是：阶跃的位置和 <em>b</em> 成正⽐，和 <em>w</em> 成反⽐。</p><p>实际上，阶跃发⽣在$ s = −b/w $的位置，正如图中通过修改权重和偏置看到的：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172056203.png" alt="image-20231217205626143" style="zoom:67%;"></p><p>这将⽤仅仅⼀个参数 <em>s</em> 来极⼤简化我们描述隐藏神经元的⽅式，这就是阶跃位置，$s = −b/w$</p><p>试着修改下图中的 <em>s</em>:<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172057169.png" alt="image-20231217205728098" style="zoom:67%;"></p><p>正如上⾯注意到的，我们隐式地设置输⼊上的权重 <em>w</em> 为⼀些⼤的值 —— ⼤到阶跃函数能够很好地近似。通过选择偏置 $b = -ws$，我们能很容易地将⼀个以这种⽅式参数化的神经元转换回常⽤的模型。</p><p>我们假设隐藏神经元在计算以阶跃点$ s_1 $（顶部神经元）和$ s_2 $（底部神经元）参数化的节约函数。它们各⾃有输出权重 $w_1 $和$w_2$。是这样的⽹络：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172100809.png" alt="image-20231217210044744" style="zoom:67%;"></p><p>右边的绘图是隐藏层的<strong>加权输出</strong> $w_{1}a_{1}+w_{2}a_{2}.$。(注意：整个网络输出是$\sigma(w_{1}a_{1}+w_{2}a_{2}+b)$)这⾥ <em>a</em>1 和 <em>a</em>2 各⾃是顶部和底部神经元的输出。这些输出由 <em>a</em> 表⽰，是因为它们通常被称为神经元的<strong>激活值（activations）</strong>。</p><p>试着增加和减⼩顶部隐藏神经元的阶跃点 <em>s</em>1。感受下这如何改变隐藏层的加权输出。尤其值得去理解当 <em>s</em>1 经过 <em>s</em>2 时发⽣了什么。你会看到这时图形发⽣了变化，因为我们从顶部隐藏神经元先被激活的情况变成了底部隐藏神经元先被激活的情况。</p><p>类似地，试着操作底部隐藏神经元的阶跃点 <em>s</em>2，感受下这如何改变隐藏神经元混合后的输出。</p><p>尝试增加和减少每⼀个输出权重。注意，这如何调整从各⾃的隐藏神经元的贡献值。当⼀个权重是 0 时会发⽣什么？</p><p>最后，试着设置 <em>w</em>1 为 0<em>.</em>8，<em>w</em>2 为 <em>−</em>0<em>.</em>8。你得到⼀个“凸起”的函数，它从点 <em>s</em>1 开始，到点<em>s</em>2 结束，⾼为 0<em>.</em>8。例如，加权后的输出可能看起来像这样：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172106307.png" alt="image-20231217210626243" style="zoom:67%;"></p><p>当然，我们可以调整为任意的凸起⾼度。让我们⽤⼀个参数，<em>h</em>，来表⽰⾼度。为了减少混乱我也会移除“<em>s</em>1 = <em>. . .</em>”和“<em>w</em>1 = <em>. . .</em>”的标记。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172108563.png" alt="image-20231217210840492" style="zoom:67%;"></p><p>试着将 <em>h</em> 值改⼤或改⼩，看看凸起的⾼度如何改变。试着把⾼度值改为负数，观察发⽣了什么。并且试着改变阶跃点来看看如何改变凸起的形状。</p><p>顺便提⼀下，你会注意到，我们⽤神经元的⽅式，可以认为不只是在图形的⻆度，⽽且是更传统的编程形式，作为 if-then-else 的⼀种声明，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">input</span> &gt;= step point:</span><br><span class="line">add <span class="number">1</span> to the weighted output</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">add <span class="number">0</span> to the weighted output</span><br></pre></td></tr></table></figure><p>对于⼤部分内容，我将坚持以图形的考虑⻆度。但在接下来的内容中，你有时可能会发现交换考虑⻆度是有帮助的，并且考虑 if-then-else 的形式。</p><p>我们可以⽤凸起制作的技巧来得到两个凸起，通过把两对隐藏神经元⼀起填充进同⼀个⽹络：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172111773.png" alt="image-20231217211158712" style="zoom:67%;"></p><p>这⾥我抑制了权重，只是简单地在每对隐藏神经元上写了 <em>h</em> 的值。</p><p>更普遍地，我们可以利⽤这个思想来取得我们想要的任何⾼度的峰值。尤其，我们可以把间隔 [0<em>,</em> 1] 分成⼤量的⼦区间，⽤ <em>N</em> 表⽰，并利⽤ <em>N</em> 对隐藏神经元来设置任意期望⾼度的峰值。让我们看看 <em>N</em> = 5 这如何⼯作。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172115966.png" alt="image-20231217211500877" style="zoom:67%;"></p><p>让我们回想在最开始绘制出的函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172133339.png" alt="image-20231217213351283" style="zoom:67%;"></p><p>这个函数其实是：</p><p>$f(x)=0.2+0.4x^2+0.3x\sin(15x)+0.05\cos(50x)$</p><p><em>x</em> 取值范围从 0 到 1，<em>y</em> 轴取值为 0 到 1。</p><p>我们再试着用神经网络的方法去估计它。</p><p>在我们上⾯的⽹络中，我们已经分析了隐藏神经元输出的加权组合$\sum_jw_ja_j$。我们现在知道如何在这个量上获得⼤量的控制。但是，正如我前⾯所指出的，这个量不是⽹络的输出。⽹络输出的是$\sigma(\sum_{j}w_{j}a_{j}+b)$，其中 <em>b</em> 是在输出神经元的偏置。有什么办法可以实现对⽹络的实际输出控制吗？</p><p>解决⽅案是设计⼀个神经⽹络，它的隐藏层有⼀个加权输出 $\sigma^{-1}\circ f(x)$，其中 $\sigma^{-1}$ 是 $\sigma$ 函数的倒数。也就是说，我们希望从隐藏层的加权输出是：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172136984.png" alt="image-20231217213630926" style="zoom:67%;"></p><p>根据图形的需求我们大概可以调整到如下地步：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172138018.png" alt="image-20231217213853926" style="zoom:67%;"></p><p>在已经解决了所有⽹络的必要元素来近似计算函数 <em>f</em>(<em>x</em>)！这只是⼀个粗略的近似，但我们可以很容易地做得更好，仅仅通过增加隐藏神经元对的数量，分配更多的凹凸形状。</p><p>于此我们已经理解了如何通过提⾼隐层神经元的数⽬来提⾼近似的质量。</p><p>&nbsp;</p><h2 id="多个输入变量"><a href="#多个输入变量" class="headerlink" title="多个输入变量"></a>多个输入变量</h2><p>我们从考虑当⼀个神经元有两个输⼊会发⽣什么开始：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172151293.png" alt="image-20231217215128242" style="zoom:80%;"></p><p>这⾥，我们有输⼊ <em>x</em> 和 <em>y</em>，分别对应于权重 <em>w</em>1 和 <em>w</em>2，以及⼀个神经元上的偏置 <em>b</em>。让我们把权重 <em>w</em>2 设置为 0，然后反复琢磨第⼀个权重 <em>w</em>1 和偏置 <em>b</em>，看看他们如何影响神经元的输出：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172152201.png" alt="image-20231217215203128" style="zoom:67%;"></p><p>为当我们增加权重 <em>w</em>1 到 <em>w</em>1 = 100，同时 <em>w</em>2 保持 0 不变时会发⽣什么？</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172154978.png" alt="image-20231217215408880"></p><p>正如我们前⾯讨论的那样，随着输⼊权重变⼤，输出接近⼀个阶跃函数。不同的是，现在的阶跃函数是在三个维度。也如以前⼀样，我们可以通过改变偏置的位置来移动阶跃点的位置。阶跃点的实际位置是 $s_x\equiv-b/w_1$。</p><p>让我们⽤阶跃点位置作为参数重绘上⾯的阶跃函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172156193.png" alt="image-20231217215648115" style="zoom:67%;"></p><p>当然，通过使得 <em>y</em> 输⼊上的权重取⼀个⾮常⼤的值（例如，<em>w</em>2 = 1000），<em>x</em> 上的权重等于 0，即 <em>w</em>1 = 0，来得到⼀个 <em>y</em></p><p>轴⽅向的阶跃函数也是可⾏的，</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172157903.png" alt="image-20231217215751828" style="zoom:67%;"></p><p>再⼀次，神经元上的数字是阶跃点，在这个情况下数字上的⼩ <em>y</em> 提醒我们阶跃是在 <em>y</em> 轴⽅向。我本来可以明确把权重标记在 <em>x</em> 和 <em>y</em> 输⼊上，但是决定不这么做，因为这会把图⽰弄得有些杂乱。但是记住⼩ <em>y</em> 标记含蓄地告诉我们 <em>y</em> 权重是个⼤的值，<em>x</em> 权重为 0。</p><p>我们可以⽤我们刚刚构造的阶跃函数来计算⼀个三维的凹凸函数。为此，我们使⽤两个神经元，每个计算⼀个 <em>x</em> ⽅向的阶跃函数。然后我们⽤相应的权重 <em>h</em> 和 <em>−h</em> 将这两个阶跃函数混合，这⾥ <em>h</em> 是凸起的期望⾼度。所有这些在下⾯图⽰中说明：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172159780.png" alt="image-20231217215932698" style="zoom:67%;"></p><p>同理，使用y方向实现结果如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172201042.png" alt="image-20231217220139940" style="zoom:67%;"></p><p>让我们考虑当我们叠加两个凹凸函数时会发⽣什么，⼀个沿 <em>x</em> ⽅向，另⼀个沿 <em>y</em> ⽅向，两者都有⾼度 <em>h</em>：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172203442.png" alt="image-20231217220318359" style="zoom:67%;"></p><p>试着改变参数 <em>h</em>。正如你能看到，这引起输出权重的变化，以及 <em>x</em> 和 <em>y</em> 上凹凸函数的⾼度。</p><p>我们构建的有点像是⼀个塔型函数：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172206807.png" alt="image-20231217220637737" style="zoom:67%;"></p><p>如果我们能构建这样的塔型函数，那么我们能使⽤它们来近似任意的函数，仅仅通过在不同位置累加许多不同⾼度的塔：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172207361.png" alt="image-20231217220733289" style="zoom:67%;"></p><p>当然，我们还没有解决如何构建⼀个塔型函数。我们已经构建的看起来像⼀个中⼼塔，⾼度为 2<em>h</em>，周围由⾼原包围，⾼度为 <em>h</em>。</p><p>但是我们能制造⼀个塔型函数。记得前⾯我们看到神经元能被⽤来实现⼀个 if-then-else 的声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">input</span> &gt;= threshold:</span><br><span class="line">output <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">output <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是⼀个只有单个输⼊的神经元。我们想要的是将⼀个类似的想法应⽤到隐藏神经元的组合输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> combined output <span class="keyword">from</span> hidden neurons &gt;= threshold:</span><br><span class="line">output <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">output <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果我们选择适当的阈值 —— ⽐如，3<em>h/</em>2，这是⾼原的⾼度和中央塔的⾼度中间的值——我们可以把⾼原下降到零，并且依旧矗⽴着塔。</p><p>请注意，我们现在正在绘制整个⽹络的输出，⽽不是只从隐藏层的加权输出。这意味着我们增加了⼀个偏置项到隐藏层的加权输出，并应⽤ S 型函数。</p><p>你能找到 <em>h</em> 和 <em>b</em> 的值，能产⽣⼀个塔型吗？这有点难，所以如果你想了⼀会⼉还是困住，这是有两个提⽰：</p><p>（1）为了让输出神经元显⽰正确的 if-then-else ⾏为，我们需要输⼊的权重（所有 <em>h</em> 或 <em>−h</em>）变得很⼤；</p><p>（2）<em>b</em> 的值决定了 if-then-else 阈值的⼤⼩。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172210615.png" alt="image-20231217221020530" style="zoom:67%;"></p><p>在初始参数时，输出看起来像⼀个前⾯图形在它的塔型和⾼原上的平坦的版本。为了得到期望的⾏为，我们增加参数 <em>h</em> 直到它变得很⼤。这就给出了 if-then-else 做阈值的⾏为。其次，为了得到正确的阈值，我们选择 <em>b</em> <em>≈ −</em>3<em>h/</em>2。尝试⼀下，看看它是如何⼯作的！这是它看起来的样⼦，我们使⽤ <em>h</em> = 10：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172211959.png" alt="image-20231217221155867" style="zoom:67%;"></p><p>甚⾄对于这个相对适中的 <em>h</em> 值，我们得到了⼀个相当好的塔型函数。当然，我们可以通过更进⼀步增加 <em>h</em> 并保持偏置 <em>b</em> = <em>−</em>3<em>h/</em>2 来使它如我们所希望的那样。</p><p>让我们尝试将两个这样的⽹络组合在⼀起，来计算两个不同的塔型函数。为了使这两个⼦⽹络更清楚，我把它们放在如下所⽰的分开的⽅形区域：每个⽅块计算⼀个塔型函数，使⽤上⾯描述的技术。右边的图上显⽰了第⼆个隐藏层的加权输出，即，它是⼀个加权组合的塔型函数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172214667.png" alt="image-20231217221401557" style="zoom:67%;"></p><p>尤其你能看到通过修改最终层的权重能改变输出塔型的⾼度。</p><p>同样的想法可以⽤在计算我们想要的任意多的塔型。我们也可以让它们变得任意细，任意⾼。结果，我们可以确保第⼆个隐藏层的加权输出近似与任意期望的⼆元函数：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172214421.png" alt="image-20231217221436349" style="zoom:67%;"></p><p>尤其通过使第⼆个隐藏层的加权输出为 $\sigma^{-1}\circ f$ 的近似，我们可以确保⽹络的输出可以是任意期望函数 <em>f</em> 的近似。</p><p>超过两个变量的函数会怎样？让我们试试三个变量 <em>x</em>1<em>, x</em>2<em>, x</em>3。下⾯的⽹络可以⽤来计算⼀个四维的塔型函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172215902.png" alt="image-20231217221525831" style="zoom:67%;"></p><p>这⾥，<em>x</em>1<em>, x</em>2<em>, x</em>3 表⽰⽹络的输⼊。<em>s</em>1<em>, t</em>1 等等是神经元的阶跃点 —— 即，第⼀层中所有的权重是很⼤的，⽽偏置被设置为给出阶跃点 <em>s</em>1<em>, t</em>1<em>, s</em>2<em>, . . .</em>。第⼆层中的权重交替设置为 +<em>h,</em> <em>−h</em>，其中 <em>h</em> 是⼀个⾮常⼤的数。输出偏置为 <em>−</em>5<em>h/</em>2。</p><p>这个⽹络计算这样⼀个函数，当三个条件满⾜时：<em>x</em>1 在 <em>s</em>1 和 <em>t</em>1 之间；<em>x</em>2 在 <em>s</em>2 和 <em>t</em>2 之间；<em>x</em>3 在 <em>s</em>3 和 <em>t</em>3 之间，输出为 1。其它情况⽹络输出为 0。即，这个塔型在输⼊空间的⼀个⼩的区域输出为 1，其它情况输出 0。</p><p>通过组合许多个这样的⽹络我们能得到任意多的塔型，如此可近似⼀个任意的三元函数。对于 <em>m</em> 维可⽤完全相同的思想。唯⼀需要改变的是将输出偏置设为 (<em>−m</em> + 1<em>/</em>2)<em>h</em>，为了得到正确的夹在中间的⾏为来弄平⾼原。</p><p>好了，所以现在我们知道如何⽤神经⽹络来近似⼀个多元的实值函数。对于$f(x_{1},\ldots,x_{m})\in R^n $的向量函数怎么样？当然，这样⼀个函数可以被视为 <em>n</em> 个单独的实值函数：，$\begin{aligned}f^1(x_1,\ldots,x_m)\end{aligned}$,$f^2(x_1,\ldots,x_m)$ 等等。所以我们创建⼀个⽹络来近似 $ f^1$，另⼀个来近似$f^2$，如此等等。然后简单地把这些⽹络都组合起来。所以这也很容易应付。</p><p>&nbsp;</p><h2 id="S-型神经元的延伸"><a href="#S-型神经元的延伸" class="headerlink" title="S 型神经元的延伸"></a>S 型神经元的延伸</h2><p>我们已经证明了由 S 型神经元构成的⽹络可以计算任何函数。回想下在⼀个 S 型神经元中，输⼊ <em>x</em>1<em>, x</em>2<em>, . . .</em> 导致输出$\sigma(\sum_jw_jx_j+b)$，这⾥$W_j$是权重，<em>b</em> 是偏置，⽽ <em>σ</em> 是 S 型函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172221399.png" alt="image-20231217222128326" style="zoom:67%;"></p><p>如果我们考虑⼀个不同类型的神经元，它使⽤其它激活函数，⽐如如下的 <em>s</em>(<em>z</em>)，会怎样？</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172221694.png" alt="image-20231217222144628" style="zoom:67%;"></p><p>更确切地说，我们假定如果神经元有输⼊ <em>x</em>1<em>, x</em>2<em>, . . .</em>，权重 w<em>1</em>, w<em>2</em>, . . . 和偏置 b<em>，那么输出</em>$s(\sum_jw_jx_j+b)$。我们可以使⽤这个激活函数来得到⼀个阶跃函数，正如⽤ S 型函数做过的⼀样。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172223601.png" alt="image-20231217222306503" style="zoom:67%;"></p><p>试着加⼤上图中的权重，⽐如 <em>w</em> = 100，你将得到：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172223147.png" alt="image-20231217222321066" style="zoom:67%;"></p><p>正如使⽤ S 型函数的时候，这导致激活函数收缩，并最终变成⼀个阶跃函数的很好的近似。试着改变偏置，然后你能看到我们可以设置我们想要的阶跃位置。所以我们能使⽤所有和前⾯相同的技巧来计算任何期望的函数。</p><p><em>s</em>(<em>z</em>) 需要什么样的性质来满⾜这样的结果呢？我们确实需要假定 <em>s</em>(<em>z</em>) 在$s(z)\text{ 在 }z\to-\infty\text{ 和 }z\to\infty $时是定义明确的。这两个界限是在我们的阶跃函数上取的两个值。我们也需要假定这两个界限彼此不同。如果它们不是这样，就没有阶跃，只是⼀个简单的平坦图形！但是如果激活函数 <em>s</em>(<em>z</em>)满⾜这些性质，基于这样⼀个激活函数的神经元可普遍⽤于计算。</p><p>&nbsp;</p><h2 id="修补阶跃函数"><a href="#修补阶跃函数" class="headerlink" title="修补阶跃函数"></a>修补阶跃函数</h2><p>⽬前为⽌，我们假定神经元可以准确⽣成阶跃函数。这是⼀个⾮常好的近似，但也仅仅是近似。实际上，会有⼀个很窄的故障窗⼝，如下图说明，在这⾥函数会表现得和阶跃函数⾮常不同。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172224759.png" alt="image-20231217222453686" style="zoom:67%;"></p><p>在这些故障窗⼝中我给出的普遍性的解释会失败。</p><p>现在，它不是⼀个很严重的故障。通过使得输⼊到神经元的权重为⼀个⾜够⼤的值，我们能把这些故障窗⼝变得任意⼩。当然，我们可以把故障窗⼝窄过我在上⾯显⽰的 —— 窄得我们的眼睛都看不到。所以也许我们可以不⽤过于担⼼这个问题。</p><p>尽管如此，有⼀些⽅法解决问题是很好的。</p><p>实际上，这个问题很容易解决。让我们看看只有⼀个输⼊和⼀个输出的神经⽹络如何修补其计算函数。同样的想法也可以解决有更多输⼊和输出的问题。</p><p>特别地，假设我们想要我们的⽹络计算函数 <em>f</em>。和以前⼀样，我们试着设计我们的⽹络，使得隐藏神经元的加权输出是 $\sigma^{-1}\circ f(x)$：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172225637.png" alt="image-20231217222547571" style="zoom:67%;"></p><p>如果我们要使⽤前⾯描述的技术做到这⼀点，我们会使⽤隐藏神经元产⽣⼀系列的凹凸函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172226765.png" alt="image-20231217222605698" style="zoom:67%;"></p><p>再说⼀下，我夸⼤了图上的故障窗⼝⼤⼩，好让它们更容易看到。很明显如果我们把所有这些凹凸函数加起来，我们最终会得到⼀个合理的 $\sigma^{-1}\circ f(x)$的近似，除了那些故障窗⼝。</p><p>假设我们使⽤⼀系列隐藏神经元来计算我们最初的⽬标函数的⼀半，即 $\sigma^{-1}\circ f(x) /2$，⽽不是使⽤刚刚描述的近似。当然，这看上去就像上⼀个图像的缩⼩的版本：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172226469.png" alt="image-20231217222658380" style="zoom:67%;"></p><p>并且假设我们使⽤另⼀系列隐藏神经元来计算⼀个 $\sigma^{-1}\circ f(x) /2$ 的近似，但是⽤将凹凸图形偏移⼀半宽度：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172227304.png" alt="image-20231217222720230" style="zoom:67%;"></p><p>现在我们有两个不同的$\sigma^{-1}\circ f(x) /2$ 的近似。如果我们把这两个近似图形加起来，我们会得到⼀个 $\sigma^{-1}\circ f(x) $ 的整体近似。这个整体的近似仍然在⼀些⼩窗⼝的地⽅有故障。但是问题⽐以前要⼩很多。原因是在⼀个近似中的故障窗⼝的点，不会在另⼀个的故障窗⼝中。所以在这些窗⼝中，近似会有 2 倍的因素更好。</p><p>我们甚⾄能通过加⼊⼤量的，⽤ <em>M</em> 表⽰，重叠的近似$\sigma^{-1}\circ f(x) /M$  来做得更好。假设故障窗⼝已经⾜够窄了，其中的点只会在⼀个故障窗⼝中。并且假设我们使⽤⼀个 <em>M</em> ⾜够⼤的重叠近似，结果会是⼀个⾮常好的整体近似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;神经网络可以计算任何函数的可视化证明&quot;&gt;&lt;a href=&quot;#神经网络可以计算任何函数的可视化证明&quot; class=&quot;headerlink&quot; title=&quot;神经网络可以计算任何函数的可视化证明&quot;&gt;&lt;/a&gt;神经网络可以计算任何函数的可视化证明&lt;/h1&gt;&lt;p&gt;对于神经网络</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="https://rozen12123.github.io/posts/7ca31f7.html"/>
    <id>https://rozen12123.github.io/posts/7ca31f7.html</id>
    <published>2023-12-17T12:17:25.000Z</published>
    <updated>2023-12-19T08:14:21.216Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LCD接口</title>
    <link href="https://rozen12123.github.io/posts/216a0b1f.html"/>
    <id>https://rozen12123.github.io/posts/216a0b1f.html</id>
    <published>2023-12-06T09:55:26.000Z</published>
    <updated>2023-12-19T08:14:21.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCD接口（附8051LCD1602显示：源码＋原理图）"><a href="#LCD接口（附8051LCD1602显示：源码＋原理图）" class="headerlink" title="LCD接口（附8051LCD1602显示：源码＋原理图）"></a>LCD接口（附8051LCD1602显示：源码＋原理图）</h1><p>工程源码及原理图：链接：<a href="https://pan.baidu.com/s/1KgmiGkFdl_sFE5GTm5MSsQ?pwd=l1gp">https://pan.baidu.com/s/1KgmiGkFdl_sFE5GTm5MSsQ?pwd=l1gp</a><br>提取码：l1gp </p><p>LCD（Liquid Crystal Display）：又称液晶显示器</p><h2 id="LCD引脚"><a href="#LCD引脚" class="headerlink" title="LCD引脚"></a>LCD引脚</h2><p>LCD一共有14个引脚，如下图：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061758088.png" alt="image-20231206175851955"></p><p>以LCD1602为例：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061800402.png" alt="image-20231206180044336"></p><p>以下我们对引脚进行逐个解释：</p><h3 id="VSS，VDD，VO"><a href="#VSS，VDD，VO" class="headerlink" title="VSS，VDD，VO"></a>VSS，VDD，VO</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>VSS</td><td>地</td></tr><tr><td>VDD</td><td>电源正极（4.5~5.5V）</td></tr><tr><td>VO</td><td>对比度调节电压（一般接在可变电阻上以调节电压）</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="RS-寄存器选择"><a href="#RS-寄存器选择" class="headerlink" title="RS(寄存器选择)"></a>RS(寄存器选择)</h3><p>数据/指令选择，1为数据，0为指令</p><p>若RS=0，选择==指令代码寄存器==，允许用户发送指令，如清屏，使光标返回初始位置。</p><p>若RS=1，选择==数据寄存器==，允许用户发送数据显示在LCD上</p><p>&nbsp;</p><h3 id="RW-read-write"><a href="#RW-read-write" class="headerlink" title="RW(read/write)"></a>RW(read/write)</h3><p>读/写选择，1为读，0为写</p><h3 id="E-使能"><a href="#E-使能" class="headerlink" title="E(使能)"></a>E(使能)</h3><p>使能，1为数据有效，下降沿执行命令</p><h3 id="D0-D7"><a href="#D0-D7" class="headerlink" title="D0~D7"></a>D0~D7</h3><p>数据输入/输出</p><h3 id="A-K"><a href="#A-K" class="headerlink" title="A/K"></a>A/K</h3><p>A:背光灯电源正极</p><p>K:背光灯电源负极</p><p>&nbsp;</p><p>其内部结构图如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061813744.png" alt="image-20231206181354663"></p><p>数据显示在屏幕上的流程：</p><p>数据——&gt;DDRAM——&gt;字模库——&gt;屏幕</p><p>DDRAM比屏幕显示内存更多以便实现滚动字符等的效果。</p><p>&nbsp;</p><h2 id="LCD1602指令集"><a href="#LCD1602指令集" class="headerlink" title="LCD1602指令集"></a>LCD1602指令集</h2><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061821398.png" alt></p><h3 id="1-清屏指令（-0000-0001-）"><a href="#1-清屏指令（-0000-0001-）" class="headerlink" title="1.清屏指令（ 0000 0001 ）"></a>1.清屏指令（ 0000 0001 ）</h3><p>1.清除液晶显示器，即将DDRAM的内容全部清除。<br>2.光标回到液晶屏左上方。<br>3.地址计数器（AC）的值设置为0。</p><h3 id="2-光标归位指令（0000-001x）"><a href="#2-光标归位指令（0000-001x）" class="headerlink" title="2.光标归位指令（0000 001x）"></a>2.光标归位指令（0000 001x）</h3><p>1.把光标返回到液晶屏左上方。<br>2.把地址计数器（AC）的值设置为0。<br>3.保持DDRAM的内容不变。</p><h3 id="3-模式设置指令（0000-01-I-D-S）"><a href="#3-模式设置指令（0000-01-I-D-S）" class="headerlink" title="3.模式设置指令（0000 01 I/D S）"></a>3.模式设置指令（0000 01 I/D S）</h3><p>设定每次写入一位数据后光标的移动方向，并且设定每次写入一个字符是否移动。<br>I/D：0写入新数据后光标左移，1写入新数据后光标右移。<br>S ：0写入新数据后显示屏不移动，1写入新数据后显示屏整体右移一个字符。</p><h3 id="4-显示开关控制指令（0000-1-D-C-B）"><a href="#4-显示开关控制指令（0000-1-D-C-B）" class="headerlink" title="4.显示开关控制指令（0000 1 D C B）"></a>4.显示开关控制指令（0000 1 D C B）</h3><p>D：0显示关，1显示开。<br>C：0无光标，1有光标。<br>B：0光标不闪烁，1光标闪烁。</p><h3 id="5-设定显示屏或光标移动方向指令（000-1-S-C-R-L-x-x）"><a href="#5-设定显示屏或光标移动方向指令（000-1-S-C-R-L-x-x）" class="headerlink" title="5.设定显示屏或光标移动方向指令（000 1 S/C R/L x x）"></a>5.设定显示屏或光标移动方向指令（000 1 S/C R/L x x）</h3><p>S/C R/L<br>0 0 光标左移一格，且AC减一。<br>0 1 光标右移一格，且AC加一。<br>1 0 显示器字符全部左移一格，光标不动。<br>1 1 显示器字符全部右移一格，光标不动。</p><h3 id="6-功能设定指令（00-1-DL-N-F-x-x）"><a href="#6-功能设定指令（00-1-DL-N-F-x-x）" class="headerlink" title="6.功能设定指令（00 1 DL N F x x）"></a>6.功能设定指令（00 1 DL N F x x）</h3><p>DL：0数据总线为4位，1数据总线为8位。<br>N： 0显示 1 行，1显示 2 行。<br>F： 0 5<em>8字符点阵，1 5</em>10字符点阵。</p><h3 id="7-设定CGRAM地址指令（01-aaaaaa）6位地址"><a href="#7-设定CGRAM地址指令（01-aaaaaa）6位地址" class="headerlink" title="7.设定CGRAM地址指令（01 aaaaaa）6位地址"></a>7.设定CGRAM地址指令（01 aaaaaa）6位地址</h3><h3 id="8-设定DDRAM地址指令（1-aaaaaaa）7位地址"><a href="#8-设定DDRAM地址指令（1-aaaaaaa）7位地址" class="headerlink" title="8.设定DDRAM地址指令（1 aaaaaaa）7位地址"></a>8.设定DDRAM地址指令（1 aaaaaaa）7位地址</h3><h3 id="9-读取忙信号或AC地址指令（BF-aaaaaaa）"><a href="#9-读取忙信号或AC地址指令（BF-aaaaaaa）" class="headerlink" title="9.读取忙信号或AC地址指令（BF aaaaaaa）"></a>9.读取忙信号或AC地址指令（BF aaaaaaa）</h3><p>BF：0空闲，1忙。<br>aaaaaaa：读取AC地址。</p><h3 id="10-数据写入DDRAM或CGRAM指令"><a href="#10-数据写入DDRAM或CGRAM指令" class="headerlink" title="10.数据写入DDRAM或CGRAM指令"></a>10.数据写入DDRAM或CGRAM指令</h3><h3 id="11-从DDRAM或CGRAM读出数据指令"><a href="#11-从DDRAM或CGRAM读出数据指令" class="headerlink" title="11.从DDRAM或CGRAM读出数据指令"></a>11.从DDRAM或CGRAM读出数据指令</h3><p>&nbsp;</p><p>&nbsp;</p><h2 id="函数功能实现"><a href="#函数功能实现" class="headerlink" title="函数功能实现"></a>函数功能实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>发送指令0x38    //八位数据接口，两行显示，5*7点阵    </p><p>发送指令0x0C    //显示开，光标关，闪烁关    </p><p>发送指令0x06    //数据读写操作后，光标自动加一，画面不动    </p><p>发送指令0x01    //清屏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="LCD1602写命令"><a href="#LCD1602写命令" class="headerlink" title="LCD1602写命令"></a>LCD1602写命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">0</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Command;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD1602写数据"><a href="#LCD1602写数据" class="headerlink" title="LCD1602写数据"></a>LCD1602写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">1</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Data;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD1602设置光标位置"><a href="#LCD1602设置光标位置" class="headerlink" title="LCD1602设置光标位置"></a>LCD1602设置光标位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Line==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始显示所给字符串"><a href="#在LCD1602指定位置开始显示所给字符串" class="headerlink" title="在LCD1602指定位置开始显示所给字符串"></a>在LCD1602指定位置开始显示所给字符串</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>String 要显示的字符串</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始显示所给数字"><a href="#在LCD1602指定位置开始显示所给数字" class="headerlink" title="在LCD1602指定位置开始显示所给数字"></a>在LCD1602指定位置开始显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2<ul><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~65535</li><li>Length 要显示数字的长度，范围：1~5</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以有符号十进制显示所给数字"><a href="#在LCD1602指定位置开始以有符号十进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以有符号十进制显示所给数字"></a>在LCD1602指定位置开始以有符号十进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：-32768~32767</li><li>Length 要显示数字的长度，范围：1~5</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Number1;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">if</span>(Number&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">Number1=Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">Number1=-Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number1/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以十六进制显示所给数字"><a href="#在LCD1602指定位置开始以十六进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以十六进制显示所给数字"></a>在LCD1602指定位置开始以十六进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~0xFFFF</li><li>Length 要显示数字的长度，范围：1~4</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SingleNumber;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">SingleNumber=Number/LCD_Pow(<span class="number">16</span>,i<span class="number">-1</span>)%<span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span>(SingleNumber&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+SingleNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;A&#x27;</span>+SingleNumber<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以二进制显示所给数字"><a href="#在LCD1602指定位置开始以二进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以二进制显示所给数字"></a>在LCD1602指定位置开始以二进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2<ul><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~1111 1111 1111 1111</li><li>Length 要显示数字的长度，范围：1~16</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">2</span>,i<span class="number">-1</span>)%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="在LCD1602显示姓名学号"><a href="#在LCD1602显示姓名学号" class="headerlink" title="在LCD1602显示姓名学号"></a>在LCD1602显示姓名学号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit LCD_RS=P2^<span class="number">0</span>;</span><br><span class="line">sbit LCD_RW=P2^<span class="number">1</span>;</span><br><span class="line">sbit LCD_E=P2^<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DataPort P0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> Char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();<span class="comment">//LCD初始化</span></span><br><span class="line"></span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;yourname&quot;</span>);<span class="comment">//第一行第一列开始显示名字</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">12138</span>,<span class="number">5</span>);<span class="comment">//第二行第一列显示12138</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">6</span>,<span class="number">12138</span>,<span class="number">5</span>);<span class="comment">//第二行第六列开始显示12138</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay</span><span class="params">()</span><span class="comment">//@12.000MHz 1ms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">1</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Data;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Line==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> Char)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line">LCD_WriteData(Char);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">0</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Command;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">int</span> X,<span class="type">int</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">int</span> Result=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Y;i++)</span><br><span class="line">&#123;</span><br><span class="line">Result*=X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Number1;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">if</span>(Number&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">Number1=Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">Number1=-Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number1/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SingleNumber;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">SingleNumber=Number/LCD_Pow(<span class="number">16</span>,i<span class="number">-1</span>)%<span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span>(SingleNumber&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+SingleNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;A&#x27;</span>+SingleNumber<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">2</span>,i<span class="number">-1</span>)%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312062139022.png" alt="image-20231206213916889"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LCD接口（附8051LCD1602显示：源码＋原理图）&quot;&gt;&lt;a href=&quot;#LCD接口（附8051LCD1602显示：源码＋原理图）&quot; class=&quot;headerlink&quot; title=&quot;LCD接口（附8051LCD1602显示：源码＋原理图）&quot;&gt;&lt;/a&gt;LC</summary>
      
    
    
    
    
    <category term="单片机" scheme="https://rozen12123.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>电磁场总结</title>
    <link href="https://rozen12123.github.io/posts/aef64dc0.html"/>
    <id>https://rozen12123.github.io/posts/aef64dc0.html</id>
    <published>2023-10-03T08:56:55.000Z</published>
    <updated>2023-10-18T09:06:47.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场原理"><a href="#电磁场原理" class="headerlink" title="电磁场原理"></a>电磁场原理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场原理&quot;&gt;&lt;a href=&quot;#电磁场原理&quot; class=&quot;headerlink&quot; title=&quot;电磁场原理&quot;&gt;&lt;/a&gt;电磁场原理&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>单片机</title>
    <link href="https://rozen12123.github.io/posts/7f705d57.html"/>
    <id>https://rozen12123.github.io/posts/7f705d57.html</id>
    <published>2023-09-19T09:25:44.000Z</published>
    <updated>2023-10-26T14:29:25.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h1><h2 id="进制转换及其加减法，补码"><a href="#进制转换及其加减法，补码" class="headerlink" title="进制转换及其加减法，补码"></a>进制转换及其加减法，补码</h2><p>2，4，88，10，16进制之间的相互转化，具体内容见逻辑设计</p><h2 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h2><ol><li><p>数据大小</p><ol><li><p>储存容量是衡量微机内部储存器能储存二进制（Bit）信息量大小的一个技术指标</p></li><li><p>8位二进制数据称为一个字节（Byte）——最基本的计量单位，记为1B</p></li><li><p>16位二级制数据称为一个字（word）</p></li><li><p>32位二进制数据称为一个双字（Dword）</p><script type="math/tex; mode=display">2^{10}B=1KB,2^{10}KB=1MB,2^{10}MB=1GB,2^{10}GB=1TB</script></li></ol></li><li><p>只读存储器（ROM）</p><p>ROM是一种掉电后不丢失信息的储存器。由于这个原因，ROM也成为非易失性存储器。</p><p>&nbsp;</p><p>结构和容量</p><p>给定储存器芯片有12个地址引脚和4个数据引脚，此储存芯片有4096个位置（$2^{12}=4096$），每个位置能储存4位数据，所以<code>结构</code>就是4096×4，也常用4K×4表示。其<code>容量</code>是16Kb，因为总共是4K个位置，每个位置能保存4位数据</p><p>&nbsp;</p><p>一个容量是512K储存器芯片有8个数据引脚，请找出：（a）组织结构；（b）这个储存芯片的地址引脚数</p><p>（a）8个数据引脚可以保存8位数据，为了找出这个储存器芯片的位置数，需要用数据引脚数去除容量。512K/8=64K；所以储存芯片的组织结构是64K×8</p><p>（b）芯片有16根地址线，因为$2^{16}=64K$</p></li><li><p>随机访问储存器（RAM）</p><p>储存计算机运行中暂停的项目，当电脑关机时数据会丢失</p></li><li><p>总线设计</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306714.png" alt="image-20231019221602733"></p><ol><li><p>地址总线</p><p>cpu地址总线的数目决定了能与cpu进行通信的位置数，位置数通常等于$2^x$，x是地址线的数目。</p><p>每个位置最多可以有一个字节的数据，不用考虑数据总线的大小。</p><p>地址总线是单向的。</p><p>地址总线使用得越多，外设使用越多。</p></li><li><p>数据总线</p><p>数据总线是双向的，因为CPU需要使用它们接收和发送数据。使用的数据总线越多，CPU效率越高。</p></li><li><p>控制总线</p><p>向设备提供读取或写入信号，以提示CPU是否正在请求信息。</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVR0,#66H</span><br><span class="line">MOVR3,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH0</span><br><span class="line">PUSH3</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR3,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP3</span><br><span class="line">POP7</span><br><span class="line">POP0</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>pop代表把栈顶的值赋值给r几</p><p>例如pop 3就是把栈顶的值赋值给R3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVSP,#70H</span><br><span class="line">MOVR5,#66H</span><br><span class="line">MOVR2,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH5</span><br><span class="line">PUSH2</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR2,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP7</span><br><span class="line">POP2</span><br><span class="line">POP5</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>&amp;nbsp</p><h2 id="8051系统概述"><a href="#8051系统概述" class="headerlink" title="8051系统概述"></a>8051系统概述</h2><h3 id="8051控制器的内部框图"><a href="#8051控制器的内部框图" class="headerlink" title="8051控制器的内部框图"></a>8051控制器的内部框图</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306716.png" alt="image-20231019213820890"></p><h3 id="8501的主要特性"><a href="#8501的主要特性" class="headerlink" title="8501的主要特性"></a>8501的主要特性</h3><div class="table-container"><table><thead><tr><th>特性</th><th>数量</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td></tr><tr><td>RAM</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td></tr><tr><td>串行端口</td><td>1</td></tr><tr><td>中断源</td><td>6</td></tr></tbody></table></div><h3 id="8051及其成员对比"><a href="#8051及其成员对比" class="headerlink" title="8051及其成员对比"></a>8051及其成员对比</h3><div class="table-container"><table><thead><tr><th>特性</th><th>8051</th><th>8052</th><th>8031</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td><td>8K</td><td>0K</td></tr><tr><td>RAM</td><td>128KB</td><td>256KB</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td><td>3</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td><td>32</td><td>32</td></tr><tr><td>串行端口</td><td>1</td><td>1</td><td>1</td></tr><tr><td>中断源</td><td>6</td><td>8</td><td>6</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><p>大多数的8051单片机的寄存器是8位的，所以也叫8051为8位单片机</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306717.png" alt="image-20231019195634248" style="zoom:67%;"></p><p>8051中常用的寄存器有A（累加器）、B、RO、R1、R2、R3、R4、R5、R6、R7、DPTR（数据指针）以及PC（程序计数器）寄存器。除DPTR和程序计数器是16位外，以上寄存器都是8位。</p><p>&nbsp;</p><h3 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV 目的操作数，源操作数</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306718.png" alt="image-20231019200313361"></p><p>1.可直接将数值装载到A、B或R0~R7的任意意一个寄存器当中。然而，为表示装载的是立即数，必须在数值前加上符号（#），如下：</p><p>2.如果将0～F的值装载到8位寄存器中，则其余的位就默认为0.例如，对于指今MOV&ensp; A，#5”而言，结果是A=05，用二进制表示就是A=00000101。</p><p>3.装载太大的值到寄存器中时会出错。（装载的值超过八位）</p><p>4.将数值装载到寄存器中时，必须在数值前加上符号（#），否则就表示装载的是存储器中的数。例如，MOV &ensp;A，17H”指令代表的就是将存储单元17H中的数装载到A中，结果就是任意值。</p><p>&nbsp;</p><h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD A,源操作数；</span><br></pre></td></tr></table></figure><p>指令中的源操作数即可以是寄存器，也可以是立即数；</p><p>寄存器A必须存在于任何的算数运算中，但其只能是任何算术运算中的目的操作数而不能是源操作数。</p><p>&nbsp;</p><h3 id="8051汇编语言简介"><a href="#8051汇编语言简介" class="headerlink" title="8051汇编语言简介"></a>8051汇编语言简介</h3><p>1.汇编语言程序由一连串的汇编指令组成</p><p>2.一条汇编指令由4个字段组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[标签:]  助记符  [操作数]  [;注释] </span><br></pre></td></tr></table></figure><p>助记符即为指令</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306719.png" alt="image-20231019201422708" style="zoom:67%;"></p><p>3.方框号代表里面的字段是可选的，不是每条指令都必须包含</p><p>4.ADD和MOV就是助记符，即产生操作码的部分。ORG和END就是伪代码（指示符），这些指示符不产生任何机器代码（操作码），仅供汇编使用。</p><p>&nbsp;</p><p>8051中的程序计数器和ROM空间</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306720.png" alt="image-20231019202019120" style="zoom:67%;"></p><p>1.编写汇编语言需要将汇编程序写好写入asm文件中</p><p>2.asm源文件被送入8051汇编器，汇编器将指令换成机器代码，然后产生目标文件（obj）和列表（lst）文件</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306721.png" alt="image-20231019202418301" style="zoom:67%;"></p><p>3.汇编器的第三步是链接：链接程序接受一个或多个目标文件并生成带有扩展名”abs”的绝对目标文件</p><p>4.将“abs”文件送入名为”OH”的程序（目标文件转16进制）中,从而产生即将烧入ROM中的扩展名位”hex”的文件。</p><ul><li>DOS EDIT编辑器产生asm文件</li><li>8051编译器产生obj和lst文件</li><li>链接器程序产生abs文件</li><li>OH程序产生HEX文件</li></ul><p>&nbsp;</p><h3 id="8051中的程序计数器和ROM空间"><a href="#8051中的程序计数器和ROM空间" class="headerlink" title="8051中的程序计数器和ROM空间"></a>8051中的程序计数器和ROM空间</h3><h4 id="8051中的程序计数器（PC）"><a href="#8051中的程序计数器（PC）" class="headerlink" title="8051中的程序计数器（PC）"></a>8051中的程序计数器（PC）</h4><ol><li>程序计数器指向下一条将执行指令的地址。</li><li>当CPU从程序ROM中得到操作码时，程序计数器就会自动增加并指向下一条指令</li><li>8051中的程序计数器为16位，能访问的程序地址范围是0000H～FFFFH，共64KB代码。</li></ol><h4 id="上电8051唤醒的位置"><a href="#上电8051唤醒的位置" class="headerlink" title="上电8051唤醒的位置"></a>上电8051唤醒的位置</h4><ol><li>当上电后，8051程序计数器中的值就是0000，就表示第一个操作码存储在ROM地址0000H中。</li><li>8051系统中，第一个操作码就必须烧人程序ROM的存储位置0000H中，因为这是启动后它寻找第一条指令的位置。</li></ol><p>&nbsp;</p><h3 id="8051数据类型和指令"><a href="#8051数据类型和指令" class="headerlink" title="8051数据类型和指令"></a>8051数据类型和指令</h3><h4 id="BD"><a href="#BD" class="headerlink" title="BD"></a>BD</h4><p>DB指令是汇编器中使用最广泛的数据指示符之一，它用于定义8位数据。</p><p>十进制后面的D是可选的，但是二进制的B和十六进制的H是必须加的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306722.png" alt="image-20231019204830206"></p><h4 id="汇编指示符"><a href="#汇编指示符" class="headerlink" title="汇编指示符"></a>汇编指示符</h4><p>1.ORG：用于ROM中表示起始地址</p><p>2.EQU：用于定义常量，但是不占用系统空间</p><p>3.END：告诉汇编器源文件（asm）末尾所处的位置。END指令是8051程序的最后一位，意味着END指令之后的源代码都会被汇编器忽略。</p><p>&nbsp;</p><h3 id="8051标志位和PSW寄存器"><a href="#8051标志位和PSW寄存器" class="headerlink" title="8051标志位和PSW寄存器"></a>8051标志位和PSW寄存器</h3><p>8051中也有表示算数运算状态的标志寄存器，如<code>进位标志</code>。</p><p>8051中的标志寄存器叫做<code>程序状态字（PSW）寄存器</code></p><h4 id="PSW（程序状态字）寄存器"><a href="#PSW（程序状态字）寄存器" class="headerlink" title="PSW（程序状态字）寄存器"></a>PSW（程序状态字）寄存器</h4><p>PSW寄存器是一个8位寄存器，也叫标志寄存器，但是在8051中，PSW只用了6位，剩余两位是用户自定义标志位。</p><p>6为中有4位是<code>状态标志位</code>也就是一些指令执行后的结果状态，分别是CY（进位）、AC（辅助进位）、P（奇偶校验位）以及OV（溢出位）</p><p>PSW.3和PSW.4位被分别设计为了RS0和RS1，用于选择组寄存器。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306723.png" alt="image-20231019210419646"></p><p>PSW.5和PSW.1是通用状态标志位，供程序员使用。</p><div class="table-container"><table><thead><tr><th>名称</th><th>位置</th><th>解释</th></tr></thead><tbody><tr><td>CY</td><td>PSW.7</td><td>进位标志</td></tr><tr><td>AC</td><td>PSW.6</td><td>辅助进位标志</td></tr><tr><td>F0</td><td>PSW.5</td><td>可用于用户的通用目的</td></tr><tr><td>RS1</td><td>PSW.4</td><td>寄存器组选择器位1</td></tr><tr><td>RS0</td><td>PSW.3</td><td>寄存器组选择器位0</td></tr><tr><td>OV</td><td>PSW.2</td><td>溢出标志</td></tr><tr><td>—</td><td>PSW.1</td><td>用户可定义位</td></tr><tr><td>P</td><td>PSW.0</td><td>奇偶标志。通过硬件每条指令周期设置/清0                     来指明是累加器中的奇/偶位数。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306724.png" alt="image-20231019210748792"></p><p>&nbsp;</p><h4 id="ADD指令和PSW"><a href="#ADD指令和PSW" class="headerlink" title="ADD指令和PSW"></a>ADD指令和PSW</h4><p>分析ADD指令对PSW寄存器中CY、AC以及P标志位的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV A,#38H</span><br><span class="line">MOV A,#2FH</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201518418.png" alt="image-20231020151833345"></p><p>相加之后：CY=0，因为D7位没有进位。</p><p>AC=1，因为有来自D3到D4位的进位</p><p>P=1，因为累加器有奇数个1（5个1）</p><p>&nbsp;</p><h3 id="8051寄存器组和栈"><a href="#8051寄存器组和栈" class="headerlink" title="8051寄存器组和栈"></a>8051寄存器组和栈</h3><p>8051微控制器中共有128个字节的RAM</p><h4 id="8051中的RAM存储分配"><a href="#8051中的RAM存储分配" class="headerlink" title="8051中的RAM存储分配"></a>8051中的RAM存储分配</h4><p>8051中有128个字节的RAM（一些成员，如8052，有256个字节的RAM），其所分配的地址范围是00~7FH。它们可直接作为存储器位置进行访问。这128个字节可分成如下三部分：</p><ol><li>从00至1F（十六进制）共有32个字节用于寄存器组和栈</li><li>从20H至2FH共有16个字节用于位可寻址读/写存储器。</li><li>从30H至7FH共有80个字节用于读/写存储，也通常称为高速暂存器（scratch pad）。这80个RAM位置被8051程序员广泛应用于存储数据以及相关参数中。</li></ol><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201525443.png" alt="image-20231020152516334" style="zoom:67%;"></p><p>第一组寄存器与栈使用的是同样的RAM空间。这点在8051编程时尤其要注意，要么回避使用第第一组寄存器，要要么分配另一块RAM区域给栈。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201528790.png" alt="image-20231020152841693" style="zoom:67%;"></p><p>&nbsp;</p><h4 id="默认寄存器组"><a href="#默认寄存器组" class="headerlink" title="默认寄存器组"></a>默认寄存器组</h4><p>如果RAM位置00～1F地址被用于四个寄存器组，那么上电后可以访问的R0～R7的寄存器组就是<code>寄存器组0</code>也就是说，当编写8051程序时，RAM位置0、1、2、3、4、5、6和7分别被名字为R0、R1、R2、R3、R4、R5、R6以及R7的符号进行访问。使用R0、R1等名字来访问RAM位置地址相比于用存储器位置访问容易得多。</p><p>&nbsp;</p><h4 id="如何切换寄存器组"><a href="#如何切换寄存器组" class="headerlink" title="如何切换寄存器组"></a>如何切换寄存器组</h4><p>8051上电后，默认寄存器组的是寄存器组0.但我们可以通过使用PSW寄存器切换到其他的寄存器组。PSW的D4位和D3位用于选择需要的寄存器组.。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306724.png" alt="image-20231019210748792"></p><p>&nbsp;</p><h4 id="8051中的堆"><a href="#8051中的堆" class="headerlink" title="8051中的堆"></a>8051中的堆</h4><p>栈是RAM中的一段空间，为CPU暂时存储信息。这些信息可以是数据或是地址。CPU需要该存储区域是因为寄存器数目有限。</p><p>&nbsp;</p><h4 id="8051如何访问栈"><a href="#8051如何访问栈" class="headerlink" title="8051如何访问栈"></a>8051如何访问栈</h4><p>​    如果栈是RAM的一段空间，CPU中就必须有指向这段空间的寄存器。用于访问栈的寄存器称为<code>SP（栈指针）寄存器</code>。8051中的栈指针仅8位宽，这就意味能得到的值的范围是00～FFH。</p><p>​    当8051上电后，SP寄存器的值是07(因为默认寄存器组1的第一位为8)，就意味着RAM位置08是8051栈的第一个位置。</p><p>​    将CPU寄存器中的值存人栈称为PUSH（压栈），从栈中取出值放入寄存器中称为POP（出栈），也就是说，一个寄存器被压人栈中就是保存数据，而从栈中弹出则是重新得到该数据。当进行压栈和出栈的操作时，SP的作用很重要。</p><p>&nbsp;</p><h4 id="压栈（push）"><a href="#压栈（push）" class="headerlink" title="压栈（push）"></a>压栈（push）</h4><p>在8051中，栈指针指向栈的最后一个位置。如果将数据压入栈中，栈指针就自增1。</p><p>例如：PUSH&ensp;1；就是将R1中的数据压入堆栈中（第一次位置为08，压入后的位置是09）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVR6，#25H</span><br><span class="line">MOVR1，#12H</span><br><span class="line">MOVR4，#0F3H</span><br><span class="line">PUSH6</span><br><span class="line">PUSH1</span><br><span class="line">PUSH4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201543123.png" alt="image-20231020154319025"></p><h4 id="出栈（POP）"><a href="#出栈（POP）" class="headerlink" title="出栈（POP）"></a>出栈（POP）</h4><p>​    每次弹出时，栈顶的字节会压入到所写寄存器中，同时栈指针自减一次。</p><p>​    例如：POP&emsp;3；就是将栈顶指针对应的字节压入R3中。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201545056.png" alt="image-20231020154538961"></p><p>&nbsp;</p><h4 id="栈上限"><a href="#栈上限" class="headerlink" title="栈上限"></a>栈上限</h4><p>​    8051的RAM位置地址范围08～1F用于栈，这是因为RAM位置地址20-2FH只能用于位可寻址存储，而不能用于栈。</p><p>​    如果某程序需要大于24字节（08～1FH=24字节）的栈，则可以改变SP指向RAM中30~7FH的位置。完成此操作的指令是：MOV &emsp;SP,#xx</p><p>&nbsp;</p><h4 id="栈和寄存器组1的冲突"><a href="#栈和寄存器组1的冲突" class="headerlink" title="栈和寄存器组1的冲突"></a>栈和寄存器组1的冲突</h4><p>默认的寄存器组为寄存器0，默认栈的起始点为寄存器1的R0。</p><p>寄存器组1和栈使用的是同样的存储空间。如果一个程序需要使用寄存器组1和组2时，就必须重新分配RAM空间给栈。例如，可分配RAMM位置地址60H甚至更高的位置地址给栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOVSP,#5FH;RAM位置地址60H,即栈的第一个位置</span><br><span class="line"></span><br><span class="line">MOVR2,#25H</span><br><span class="line">MOVR1,#12H</span><br><span class="line">MOVR4,#0F3H</span><br><span class="line">PUSH2</span><br><span class="line">PUSH1</span><br><span class="line">PUSH4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201602225.png" alt="image-20231020160228129" style="zoom:67%;"></p><h4 id="提高CPU效率的方法"><a href="#提高CPU效率的方法" class="headerlink" title="提高CPU效率的方法"></a>提高CPU效率的方法</h4><p>微处理器设计者可使用三种方法来提高CPU的处理效率。</p><ol><li>增加芯片的时钟频率。这种方法的缺点是：频率越高，则功耗和热损耗就越大，功耗和散热对掌上型设备尤其是大问题。</li><li>.通过增加导线成为哈佛体系结构，从而将更多的信息（代码和数据）装载到CPU中处理。而在x86和一些通用微处理器中，哈佛体系结构价格昂贵且不切实际，但是在今天的单芯片计算机中（微控制器），这已不是问题。</li><li>改变CPU的内部结构，使用RISC结构。</li></ol><p>&nbsp;</p><h2 id="跳转、循环和调用指令"><a href="#跳转、循环和调用指令" class="headerlink" title="跳转、循环和调用指令"></a>跳转、循环和调用指令</h2><h3 id="8051中的循环"><a href="#8051中的循环" class="headerlink" title="8051中的循环"></a>8051中的循环</h3><p>​    在8051中，循环操作通过指令“DJNZ &emsp;reg,label”来实现。该指令中，寄存器递减，如果非零，则跳转至标签所示的目标地址。在循环开始之前，寄存器预存人循环次数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201646151.png" alt="image-20231020164656061" style="zoom:67%;"></p><p>上诉代码所实现的功能为：</p><ol><li>累加器清零</li><li>将3加入累加器中10次</li></ol><p>注意：上述代码以R2为累加器，而R2为8位寄存器，它能储存的最大值为FHH（十进制的255），因此每次循环的最多次数也为256，如需更多的循环则需要进行循环的嵌套。</p><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201651505.png" alt="image-20231020165110399"></p><p>上述代码实现的功能：</p><ol><li>将数55H存入累加器ACC中</li><li>对累加器ACC执行700次取补码。</li></ol><p>&nbsp;</p><h4 id="其他条件跳转指令"><a href="#其他条件跳转指令" class="headerlink" title="其他条件跳转指令"></a>其他条件跳转指令</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201652828.png" alt="image-20231020165231702"></p><p>注意：重点记忆<code>JZ</code>和<code>JNC</code></p><p>&nbsp;</p><h4 id="所有的条件跳转指令都是短跳转指令"><a href="#所有的条件跳转指令都是短跳转指令" class="headerlink" title="所有的条件跳转指令都是短跳转指令"></a>所有的条件跳转指令都是短跳转指令</h4><p>​    必须指出，所有的条件跳转指令都是短跳转指令，也就是说，跳转指令的目标地址必须在程序计数器（PC）的-128~+127字节之内。</p><p>&nbsp;</p><h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p>无条件跳转指令是一种不需要任何条件，程序就可以跳转到目标地址的指令。</p><p>在8051中，这样的指令有两种：长跳转（LJMP）指令和短跳转（SJMP）指令</p><h5 id="LJMP（长跳转指令）"><a href="#LJMP（长跳转指令）" class="headerlink" title="LJMP（长跳转指令）"></a>LJMP（长跳转指令）</h5><p>它是一个3字节指令，其中第一个字节是操作码，第二个和第三个字节表示16位目标地址。2字节的目标地址允许程序在存储单元00000H~FFFFH中任意跳转。</p><h5 id="SJMP（短跳转指令）"><a href="#SJMP（短跳转指令）" class="headerlink" title="SJMP（短跳转指令）"></a>SJMP（短跳转指令）</h5><p>它是一个2字节指令，第一个字节是操作码，第二个字节是目标地址的相对跳转地址。相对跳转地址的范围为00H~FFH，相对跳转地址又分为前向跳转地址和后向跳转地址，即在相对于当前PC地址的-128～+127字节存储器范围内。如果是前向跳转地址，则目标地址可以在距当前PC的127字节范围内；如果是后向跳转地址，则目标地址可以在距当前PC的-128字节范围内。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h3><p>​    另一个控制跳转指令是CALL指令，该指令用于调用子程序。子程序常用于完成经常实现的任务。这样做不仅可以节省存储器空间，而且让程序更加结构化。在8051系列中，有两种调用指令：长调用（LCALL）指令及绝对调用（ACALL）指令。</p><h4 id="LCALL-长调用指令"><a href="#LCALL-长调用指令" class="headerlink" title="LCALL(长调用指令)"></a>LCALL(长调用指令)</h4><p>它是一个3字节指令，其中第一个字节是操作码，第二个和第三个字节是子程序人口地址。因此，长调用指令可以调用存放在8051中64KB程序存储器任意位置的子程序。</p><p>为保证8051在调用子程序执行结束后能够知道返回到哪里并继续执行，处理器自动将长跳转指令的下一条指令地址保存到栈中。当一个子程序被调用时，控制器跳转到该子程序，并且处理器将PC值保存到栈中，同时开始获取一条新的指令地址。当子程序执行结束时，返回指令RET将控制器返回到调用位置。</p><p>==每一个子程序都需要一条返回指令作为结束。==</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201709397.png" alt="image-20231020170936284"></p><p>RET指令的功能是将地址从栈中弹出并放入程序计数器中，从而恢复执行在CALL指令之后的指令。</p><p>&nbsp;</p><h4 id="ACALL-绝对调用指令"><a href="#ACALL-绝对调用指令" class="headerlink" title="ACALL(绝对调用指令)"></a>ACALL(绝对调用指令)</h4><p>由于ACALL是2字节指令，子程序的目标地址就必须在2KB字节范围内，这是因为2字节中只有11位表示地址。</p><p>&nbsp;</p><h3 id="8051芯片的延时"><a href="#8051芯片的延时" class="headerlink" title="8051芯片的延时"></a>8051芯片的延时</h3><h4 id="8051的机器周期"><a href="#8051的机器周期" class="headerlink" title="8051的机器周期"></a>8051的机器周期</h4><p>​    CPU执行指令时须花费一定的时钟周期，8051系列中，这些时钟周期就叫做机器周期（machine cycle,MC）。</p><p>​    最原始的8051中，1个机器周期可占用12个振荡器（时钟）周期。因此，要想计算8051的机器周期，我们采用1/12的晶振频率，然后再取倒数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201718902.png" alt="image-20231020171851810"></p><p>在一个时钟周期内，能运行的机器周期越多，当然效率就越高，如上图，从上到下机器运行的效率是逐渐增加的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201720110.png" alt="image-20231020172032002"></p><p>&nbsp;</p><h4 id="8051的延时计算"><a href="#8051的延时计算" class="headerlink" title="8051的延时计算"></a>8051的延时计算</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201723498.png" alt="image-20231020172335390"></p><p>DELAY的子程序一般由两部分构成：</p><ol><li>计数器设置</li><li>延时</li></ol><p>增加延时时间的一种方式是在循环中使用NOP指令。NOP表示“空操作”，简单地浪费时间。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201726403.png" alt="image-20231020172624264"></p><h4 id="循环内套用循环延时"><a href="#循环内套用循环延时" class="headerlink" title="循环内套用循环延时"></a>循环内套用循环延时</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201730434.png" alt="image-20231020173008270"></p><h4 id="关于各种IC的延时计算"><a href="#关于各种IC的延时计算" class="headerlink" title="关于各种IC的延时计算"></a>关于各种IC的延时计算</h4><ol><li>根据时钟周期与机器周期的比计算出，结合晶振频率计算出运行一个机器周期所需要的时间</li><li>计算延时函数中所运行机器周期的个数</li><li>如果是单个循环，则计算出的时间=循环所需的时间＋循环外的指令运行时间；如果是嵌套循环，延时时间=内循环时间＋外循环时间。它与所有其他延时循环一样，对它的延时计算只是约数，因为忽略了子程序的第一条及最后一条指令所产生的延时。</li></ol><p>&nbsp;</p><h4 id="使用-符号和SSJMP表示跳转到自身"><a href="#使用-符号和SSJMP表示跳转到自身" class="headerlink" title="使用$符号和SSJMP表示跳转到自身"></a>使用$符号和SSJMP表示跳转到自身</h4><p>如果芯片中不存在要监视的程序，就需要使用跳转到自身指令使得微控制器不处于空闲状态。简单的做法是在JUMP后面写上$符号，代表跳转的位置也就是如下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HERE:SJMPHERE</span><br></pre></td></tr></table></figure><p>也可以如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SJMP$</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="8051的I-O端口编程"><a href="#8051的I-O端口编程" class="headerlink" title="8051的I/O端口编程"></a>8051的I/O端口编程</h2><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201812908.png" alt="image-20231020181205765"></p><p>8051中一共有4个端口可以进行I/O操作，即P0-P3，每个端口有8个引脚。</p><p>8051有40个引脚，其中32个引脚属于4个端口，余下的引脚分别是$V_{cc}$​,GND，XTAL1，XTAL2，RST，EA，ALE/PROG和PSEN。</p><p>&nbsp;</p><h3 id="I-O端口引脚及其功能"><a href="#I-O端口引脚及其功能" class="headerlink" title="I/O端口引脚及其功能"></a>I/O端口引脚及其功能</h3><p>所有端口在RESET（复位）时都配置成输入，并准备用作输入。</p><p>当第一个0写入某端口时，该端口便成为输出。若将该端口重新配置成输入，则必须将1送入该端口。若想将任何端口用做输入端口，则必须编程。</p><p>&nbsp;</p><h3 id="将个位读入进位标志"><a href="#将个位读入进位标志" class="headerlink" title="将个位读入进位标志"></a>将个位读入进位标志</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310261952404.png" alt="image-20231026195225266"></p><h4 id="读取输出端口锁存内容"><a href="#读取输出端口锁存内容" class="headerlink" title="读取输出端口锁存内容"></a>读取输出端口锁存内容</h4><p>有些指令读取的是内部端口锁存内容而不是外部引脚的状态。如“ANL &amp;&emsp;P1，A”，执行该指令时会产生如下一系列的动作：</p><p>1.读取端口内部锁存内容，并将该数据传送给CPU。</p><p>2.将这些数据与寄存器A中的内容相与。</p><p>3.结果写入端口锁存。<br>4.端口引脚数据改变，内容与端口锁存内容一致。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="80511寻址方式"><a href="#80511寻址方式" class="headerlink" title="80511寻址方式"></a>80511寻址方式</h2><p>​    CPU可使用多种方式访问数据。数据可存放在寄存器、存储器中，或者以立即数的形式存在。访问这些数据的不同方法称为寻址方式（addressing&emsp;modes)。</p><p>8051共提供5种寻址方式，如下:</p><p>1.立即寻址方式；<br>2.寄存器寻址方式；<br>3.直接寻址方式；<br>4.寄存器间接寻址方式；<br>5.变址寻址方式</p><p>&nbsp;</p><h3 id="立即寻址方式"><a href="#立即寻址方式" class="headerlink" title="立即寻址方式"></a>立即寻址方式</h3><p>直接将源操作数加载至任意寄存器，注意：立即数必须加前缀“#”</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262002698.png" alt="image-20231026200259601"></p><h3 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h3><p>寄存器寻址方式是将寄存器中的内容加载到另一个寄存器中，而不是操作数本身。如下所示：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262004330.png" alt="image-20231026200404238"></p><p>&nbsp;</p><h3 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><p>1.RAM地址00～1FH分配给寄存器组和栈。</p><p>2.RAM地址20-2FH用于位可寻址空间保存单点数据。</p><p>3.RAM地址30~7FH用于保存字节数据。</p><p>使用直接寻址方式可以访问RAM的128字节，但通常情况下它只访问RAM地址30～7FH空间，这是因为寄存器组位置由名为RO～R7的寄存器访问，而RAM中除了寄存器空间之外再没有对应的名字。</p><p>在直接寻址方式中，存放在RAM存储器中的数据对应的地址就是指令中给出的地址。而在立即寻址方式中，指令执行的数据就是操作数本身。是否有前缀“#”是两种寻址方式的主要区别。如下例所示（注意没有百“#标志）:</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262006324.png" alt="image-20231026200609232"></p><p>&nbsp;</p><h4 id="SFR寄存器"><a href="#SFR寄存器" class="headerlink" title="SFR寄存器"></a>SFR寄存器</h4><p>在8051单片机中，寄存器A、B、PSW和DPTR通常称为SFR（特殊功能寄存器）</p><p>关于SFR地址，需注意以下两点:<br>1.特殊功能寄存器地址范围是80H～FFH。地址大于80H的原因是00H～7FH地址属于8051内部RAM。<br>2.不是80H～FFH范围中的所有地址都用于SFR。未使用的保留，且不可被8051程序员使用。</p><p>&nbsp;</p><h3 id="寄存器间接寻址方式"><a href="#寄存器间接寻址方式" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h3><p>在寄存器间接寻址方式中，寄存器可作为数据指针。若数据存在于CPU内部，则只能使用寄存器R0或R1将数据取出。当R0和R1用作指针保存RAM中的数据地址时，则须加上前级“@标志，如下所示:</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262009654.png" alt="image-20231026200946568"></p><p>简单解释是将一个寄存器中数据的地址加载到另一个寄存器中。而不是数据本身。</p><p>如上，我们如果不佳@，那么就会将后面寄存器中的数据进行操作，而不是地址。</p><p>&nbsp;</p><h3 id="变址寻址方式"><a href="#变址寻址方式" class="headerlink" title="变址寻址方式"></a>变址寻址方式</h3><p>​    变址寻址方式广泛用于访间8051单片机的ROM空间的查找表入口数据，指令是“MOVC &emsp;A，@A+DPTR”。16位的寄存器DPTR和寄存器A存放在片上ROM中的数据元素地址，因为数据元素存放在8051ROM代码区，所以使用指令MOV&emsp;C，而不是MOV。“C”指代码。该指令将寄存器A中的内容与16位寄存器DPTR中的内容相加，形成所需数据的16位地址,如下所示：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262016423.png" alt="image-20231026201652253"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262019170.png" alt="image-20231026201946030"></p><p>&nbsp;</p><h3 id="算术逻辑指令与程序"><a href="#算术逻辑指令与程序" class="headerlink" title="算术逻辑指令与程序"></a>算术逻辑指令与程序</h3><p>在8051中，为了将数值相加，就必须使用累加器（寄存器A），ADD指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD A，源操作数;A = A + 源操作数</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="ADD指令-1"><a href="#ADD指令-1" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD指令的功能是将两个操作数相加，通常，目的操作数是寄存器A中的内容，而源操作数可以是立即数、寄存器中的内容或存储器中的内容。请记住，在8051汇编算术操作中不允许存储器-存储器式的操作。指令的执行将影响标志位AC、CY和P，这取决于执行的操作数。溢出标志位OV只有带符号数运算时才受影响。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262117746.png" alt="image-20231026211723672"></p><p>&nbsp;</p><h3 id="ADDC以及16位数加法"><a href="#ADDC以及16位数加法" class="headerlink" title="ADDC以及16位数加法"></a>ADDC以及16位数加法</h3><p>当两个16位的操作数相加时，需注意进位。指令ADDC（带进位加法指令）自的功能就是把源操作数的内容和进位标志CY都加入累加器A中。如下是3CE7H+3B8DH的相加操作：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262120484.png" alt="image-20231026212033413"></p><p>&nbsp;</p><h3 id="DA指令"><a href="#DA指令" class="headerlink" title="DA指令"></a>DA指令</h3><p>8051中的DA（十进制加法调整）指令用于解决两个BCD码相加不是BCD码的问题。助记符有一个操作数，就是累加器“A当有必要时，DA指令将6加入低位或高位，否则就不干涉结果。如下所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262127068.png" alt="image-20231026212758013"></p><h4 id="DA操作总结"><a href="#DA操作总结" class="headerlink" title="DA操作总结"></a>DA操作总结</h4><p>只能在ADD或ADDC指令执行之后才能执行。<br>1.若低位（4位）大于9，或AC=1，就将0110加入低4位。<br>2.若高位（4位）大于9，或CY=1，就将0110加入高4位。<br>事实上，AC（辅助进位）标志位除了用于纠正BCD加法之外，并无其他用处。例如，相加29H和18H，结果是41H，但这对于BDC码来说是错误的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262128952.png" alt="image-20231026212846867"></p><h3 id="无符号数相减"><a href="#无符号数相减" class="headerlink" title="无符号数相减"></a>无符号数相减</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBB A，源操作数;A = A - 源操作数 -CY</span><br></pre></td></tr></table></figure><h4 id="SUBB（带借位减法），CY-0"><a href="#SUBB（带借位减法），CY-0" class="headerlink" title="SUBB（带借位减法），CY=0"></a>SUBB（带借位减法），CY=0</h4><p>算术减法中，8051微处理器（几乎涵盖所有的CPU）采用的是补码的方法。每个CPU中都包含加法电路，而因为减法电路的设计复杂（占用太多晶体管），因此8051使用加法电路来实现减法。如果8051执行减法指令时，须预设置CY=0。CPU硬件执行SUBB无符号数减法指令的步骤如下。<br>1.得到减数源操作数的补码。<br>2.将值与被减数（A）相加。<br>3.进位反相。</p><h3 id="无符号数乘法和除法"><a href="#无符号数乘法和除法" class="headerlink" title="无符号数乘法和除法"></a>无符号数乘法和除法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL AB    ;AXB，将16位结果分别放入B和A</span><br></pre></td></tr></table></figure><p>字节乘法中，其中一个操作数须放人寄存器A中，而另一个操作数则须放在寄存器B中，相乘后，结果分别放人寄存器A和B中，寄存器A保存低位字节，寄存器B保存高位字节。如下所示：225H与65H相乘的结果是16位数据，分别存入寄存器A和B中，如表所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262209071.png" alt="image-20231026220940002"></p><p>&nbsp;</p><h4 id="无符号数相除"><a href="#无符号数相除" class="headerlink" title="无符号数相除"></a>无符号数相除</h4><p>字节相除时，分子必须放在寄存器A中，分母放在寄存器B中。除法指令完成之后，商存放入寄存器A中，余数存人寄存器B中。如下列代码和表6-3所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262211631.png" alt="image-20231026221104566"></p><p>&nbsp;</p><h3 id="CPL-A（累加器取反）"><a href="#CPL-A（累加器取反）" class="headerlink" title="CPL A（累加器取反）"></a>CPL A（累加器取反）</h3><p>此指令将寄存器内容的1变成0，反之亦然，所以称为取反（1’scomplement）。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262228183.png" alt="image-20231026222810134"></p><p>&nbsp;</p><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>8051中含有比较指令。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CJNE 目的操作数,源操作数,相对地址</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单片机&quot;&gt;&lt;a href=&quot;#单片机&quot; class=&quot;headerlink&quot; title=&quot;单片机&quot;&gt;&lt;/a&gt;单片机&lt;/h1&gt;&lt;h2 id=&quot;进制转换及其加减法，补码&quot;&gt;&lt;a href=&quot;#进制转换及其加减法，补码&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>电磁场原理</title>
    <link href="https://rozen12123.github.io/posts/a3afa0e4.html"/>
    <id>https://rozen12123.github.io/posts/a3afa0e4.html</id>
    <published>2023-09-18T08:11:44.000Z</published>
    <updated>2023-09-25T09:16:34.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场"><a href="#电磁场" class="headerlink" title="电磁场"></a>电磁场</h1><h2 id="矢量的基本概念"><a href="#矢量的基本概念" class="headerlink" title="矢量的基本概念"></a>矢量的基本概念</h2><h3 id="1-矢量的表示"><a href="#1-矢量的表示" class="headerlink" title="1.矢量的表示"></a>1.矢量的表示</h3><ol><li><p>图形表示</p></li><li><p>数学表示</p><script type="math/tex; mode=display">\vec{A}= \vec{a_A}\left | \vec{A} \right | = \vec{a_A}A</script></li><li><p>坐标分量表示法</p></li></ol><script type="math/tex; mode=display">\vec{A}= \vec{a_x}A_x(x,y,z)+\vec{a_y}A_y(x,y,z)+\vec{a_z}A_z(x,y,z)</script><p>$a_A$是沿A的方向且大小等于1的无量纲的单位矢量</p><p>&nbsp;</p><h3 id="2-矢量的加减"><a href="#2-矢量的加减" class="headerlink" title="2.矢量的加减"></a>2.矢量的加减</h3><p><img src="/posts/a3afa0e4.htm/image-20230918162802552.png" alt="image-20230918162802552" style="zoom:50%;"></p><p>矢量的运算规则（Operation rules）</p><p>1.加减运算</p><script type="math/tex; mode=display">\begin{array}{ll}a.&A+B=B+A\\ \\ b.&A+B+C=(A+B)+C=A+(B+C)\\ \\ c.&A-B=A+(-B)\end{array}</script><script type="math/tex; mode=display">d  .\quad \begin{array}{r l}{if \quad A=\boldsymbol{a}_{x}A_{x}(x,y,z)+\boldsymbol{a}_{y}A_{y}(x,y,z)+\boldsymbol{a}_{z}A_{z}(x,y,z)}\\ {B=\boldsymbol{a}_{x}B_{x}(x,y;z)+\boldsymbol{a}_{y}B_{y}(x,y,z)+\boldsymbol{a}_{z}B_{z}(x,y,z)}\\ \end{array}</script><p>then</p><script type="math/tex; mode=display">\begin{array}{l}A\pm B=\boldsymbol a_x(A_x\pm B_x)+\boldsymbol a_y(A_y\pm B_y)+\boldsymbol a_z(A_z\pm B_z)\\ cA=\boldsymbol a_x(cA_y)+\boldsymbol a_y(cA_y)+\boldsymbol a_z(cA_z)\end{array}</script><p>2.点乘运算</p><script type="math/tex; mode=display">A \bullet B = AB \cos \theta (\theta \leq \pi)</script><script type="math/tex; mode=display">\theta=\cos^{-1}\frac{A\bullet B}{AB}=\cos^{-1}\frac{A_{x}B_{x}+A_{y}B_{y}+A_{z}B_{z}}{AB}</script><p>3.叉乘运算（vector or cross product）</p><script type="math/tex; mode=display">C=|A\times B|=AB\sin\theta</script><p><img src="/posts/a3afa0e4.htm/image-20230918170905521.png" alt="image-20230918170905521" style="zoom:50%;"></p><p>注意：叉乘有顺序，不可以使用交换律</p><p>方向：右手定则</p><p><img src="/posts/a3afa0e4.htm/image-20230918170845402.png" alt="image-20230918170845402" style="zoom:50%;"></p><script type="math/tex; mode=display">A\times B=a_{x}(A_{y}B_{z}-A_{z}B_{y})+a_{y}(A_{z}B_{x}-A_{x}B_{z})+a_{z}(A_{x}B_{y}-A_{y}B_{x})=\begin{vmatrix}\boldsymbol{a}_x&\boldsymbol{a}_y&\boldsymbol{a}_z\\ A_x&A_y&A_z\\ B_x&B_y&B_z\end{vmatrix}</script><script type="math/tex; mode=display">\theta=\sin^{-1}\frac{\left|A\times B\right|}{A B}</script><p>4.三个矢量相乘</p><ol><li>模的几何意义是六面体的体积<script type="math/tex; mode=display">\mathbf{A}\bullet(\mathbf{B}\times\mathbf{C})=\mathbf{B}\bullet(\mathbf{C}\times\mathbf{A})=\mathbf{C}\bullet(\mathbf{A}\times\mathbf{B})</script></li></ol><ol><li>遵从Back-cab rule</li></ol><script type="math/tex; mode=display">\begin{array}{l}\textbf{A}\times(\textbf{B}\times\textbf{C})=\textbf{B}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{C})-\textbf{C}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{B})\\  \textbf{D}=\textbf{B}\times\textbf{C}\qquad\textbf{F}=\textbf{A}\times(\textbf{B}\times\textbf{C})\end{array}</script><script type="math/tex; mode=display">\begin{aligned}F_x&=A_y D_z-A_z D_y\\ &=A_y(B_x C_y-B_y C_z)-A_z(B_z C_x-B_x C_z)\\ &=B_x(A_y C_y+A_zC_z)-C_x(A_y B_y+A_z B_z)\\ &=B_x(\textbf{A}\textbf{C})-C_x(\textbf{A}\textbf{B})\end{aligned}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="正交坐标系及其微分元（Orhogonal-coordinate-systems）"><a href="#正交坐标系及其微分元（Orhogonal-coordinate-systems）" class="headerlink" title="正交坐标系及其微分元（Orhogonal coordinate systems）"></a>正交坐标系及其微分元（Orhogonal coordinate systems）</h2><p>常用的正交曲线坐标系</p><ol><li>直角坐标系</li><li>圆柱坐标系</li><li>球坐标系</li></ol><p>坐标线（轴）：三个正交曲面两两相交而成的曲线</p><p>坐标原点（基准点）:三条坐标系的焦点</p><p>坐标单位矢量：空间任意一点与坐标线相切且指向变量增加方向的三个单位矢量</p><p>&nbsp;</p><h3 id="正交坐标系的微分元"><a href="#正交坐标系的微分元" class="headerlink" title="正交坐标系的微分元"></a>正交坐标系的微分元</h3><script type="math/tex; mode=display">\text{d}l=\left[(\text{d}l_1)^2+(\text{d}l_2)^2+(\text{d}l_3)^2\right]^{1/2}\\ =\left[(h_1\text{d}u_1)^2+(h_2\text{d}u_2)^2+(h_3\text{d}u_3)^2\right]^{1/2}</script><ol><li>Differential directed distance</li></ol><script type="math/tex; mode=display">   d\mathbf{1}=\mathbf{a}_{u1}dl_1+\mathbf{a}_{u2}dl_2+\mathbf{a}_{u3}dl_3</script><ol><li>Differential area<script type="math/tex; mode=display">\begin{aligned}ds_1&=dl_2dl_3&=h_2h_3ah_2dt_3\\ ds_2&=dl_1dl_3&=h_1h_3dh_1du_3\\ ds_3&=dl_1dl_2&=h_1h_2du_1du_2\end{aligned}</script></li></ol><ol><li>Differential volume</li></ol><script type="math/tex; mode=display">dv=h_1h_2h_3du_1du_2du_3</script><h4 id="1-直角坐标系（Cartesian-coordinates）"><a href="#1-直角坐标系（Cartesian-coordinates）" class="headerlink" title="1.直角坐标系（Cartesian coordinates）"></a>1.直角坐标系（Cartesian coordinates）</h4><script type="math/tex; mode=display">\text{(u}_1,\text{u}_2,\text{u}_3\text{)=(x,y,z)}</script><ol><li>线元<script type="math/tex; mode=display">\begin{matrix}d\vec{l}_x=dx\vec{a}_x\\ {d}\vec{l}_y={dy}\vec{a}_y\\ {d}\vec{l}_z={dz}\vec{a}_z\\d\vec{l}=dx\vec{a}_x+dy\vec{a}_y+d{z}\vec{a}_z\end{matrix}</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{matrix}d\vec{S}_x=dy dz\vec{a_x}\\ d\vec{S}_y=dx dz \vec{a_y}\\ d\vec{S}_z=dx dy\vec{a}_z\end{matrix}</script></li></ol><ol><li>体元<script type="math/tex; mode=display">dV=dx dy dz</script></li></ol><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><p>已知一个线的矢量表达式A，求</p><ol><li>若B与A平行，那么求B的单位矢量表达式</li><li>若B垂直于A，且B处于x平面，求B的单位矢量表达式</li></ol><p>1.A×B=0 带入求解</p><p>2.A·B=0 带入求解</p><h4 id="2-圆柱坐标系（Cylindrical-coordinates）"><a href="#2-圆柱坐标系（Cylindrical-coordinates）" class="headerlink" title="2.圆柱坐标系（Cylindrical coordinates）"></a>2.圆柱坐标系（Cylindrical coordinates）</h4><script type="math/tex; mode=display">\left(\mathrm{u}_1,\mathrm{u}_2,\mathrm{u}_3\right)=\left(\mathrm{r},\mathrm{\varphi ,z}\right)</script><ol><li><p>线元</p><script type="math/tex; mode=display">\text{d}\vec{l}=\text{d}r\vec{a}_r+r\text{d}\varphi\vec{a}_\varphi+\text{d}z\vec{a}_z</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{aligned}\text{d}\vec{S}_r=r\text{d}\varphi\text{d}z\vec{a}_r\\ \text{d}\vec{S}_\varphi=\text{d}r\text{d}z\vec{a}_\varphi\\ \text{d}\vec{S}_z=r\text{d}\varphi\text{d}r\vec{a}_z\end{aligned}</script></li></ol><ol><li>体元</li></ol><script type="math/tex; mode=display">\text{d}V=r\text{d}r\text{d}\varphi\text{d}z</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场&quot;&gt;&lt;a href=&quot;#电磁场&quot; class=&quot;headerlink&quot; title=&quot;电磁场&quot;&gt;&lt;/a&gt;电磁场&lt;/h1&gt;&lt;h2 id=&quot;矢量的基本概念&quot;&gt;&lt;a href=&quot;#矢量的基本概念&quot; class=&quot;headerlink&quot; title=&quot;矢量的基本概念</summary>
      
    
    
    
    
    <category term="电磁场" scheme="https://rozen12123.github.io/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性控制系统</title>
    <link href="https://rozen12123.github.io/posts/b9875b9f.html"/>
    <id>https://rozen12123.github.io/posts/b9875b9f.html</id>
    <published>2023-09-16T11:26:32.000Z</published>
    <updated>2023-12-19T08:21:31.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动控制原理"><a href="#自动控制原理" class="headerlink" title="自动控制原理"></a>自动控制原理</h1><p>​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统</p><p>​    控制系统中的操纵器：控制器（contriller）/补偿器（compensator）[重点在于控制参数与结构]</p><p>控制器需要考虑的三大性能</p><ol><li>稳定性（Stability）：有界输入对应有界输出（BIBO）</li><li>瞬时响应（Transient response）：指标：响应速度</li><li>稳态响应（Steady-state response）</li></ol><p>&nbsp;</p><p>控制目标：</p><ol><li>稳定不稳定的系统</li><li>提高系统的稳定性；使得系统具有更好的稳定性。等效于改善系统的瞬时响应：更快的响应，较小的超调量，减小振荡</li><li>精准跟踪输入命令：减少/消除特定类型输入的稳态误差</li></ol><p>&nbsp;</p><p>判断微分方程，线性或非线性，时变或定长</p><p>是否为线性：如果每一项都是c(t),r(t),高阶导数，则为线性。但是如果出现平方线与单常数x则为非线性。</p><p>时变与非时变：c(t),r(t)的系数全是常数，不存在变量t</p><p>&nbsp;</p><h2 id="传递方程（transfer-function）"><a href="#传递方程（transfer-function）" class="headerlink" title="传递方程（transfer function）"></a>传递方程（transfer function）</h2><script type="math/tex; mode=display">a_{n}\frac{d^{n}c(t)}{dt^{n}}+a_{n-1}\frac{d^{n-1}c(t)}{dt^{n-1}}+\cdots+a_{0}c(t)=b_{m}\frac{d^{m}r(t)}{dt^{m}}+b_{m-1}\frac{d^{m-1}r(t)}{dt^{m-1}}+\cdots+b_{0}r(t)</script><p>左右两边分别进行拉氏变换，我们假设其初始状态为0可得：</p><script type="math/tex; mode=display">(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)C(s)=(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)R(s)</script><script type="math/tex; mode=display">\frac{C(s)}{R(s)}=G(s)=\frac{(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)}{(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)}</script><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447490.png" alt="image-20231007193012932"></p><p>解题步骤：</p><ol><li><p>Replace passive element values with their impedances.</p></li><li><p>Replace all sources and time variables with their Laplace transform.</p></li><li><p>Assume a transform current and a current direction in each mesh.</p></li><li><p>Write Kirchhoff’s voltage law around each mesh.</p></li><li><p>Solve the simultaneous equations for the output.</p></li><li><p>Form the transfer function</p></li><li><p>将无源元件值替换为其阻抗。</p></li><li><p>将所有源和时间变量替换为其拉普拉斯变换。</p></li><li><p>假设每个网格中存在变换电流和当前方向。</p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p></li><li><p>求解联立方程以获得输出。</p></li><li><p>形成传递函数</p></li></ol><p>例题如下：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447493.png" alt="image-20231007193359608" style="zoom:67%;"></p><p>寻找其传递方程${I_2(s)/V(s)}$</p><ol><li><p>将无源元件值替换为其阻抗,并进行拉氏变换同时设定好电流在网格中的流动方向。<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447494.png" alt="image-20231007193625340"></p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p><script type="math/tex; mode=display">(R_1+Ls)I_1(s)&-LsI_2(s)=V(s)\\-LsI_1(s)+\left(Ls+R_2+\frac{1}{Cs}\right)I_2(s)&=0</script></li><li><p>求解联立方程以获得输出。（一般情况下使用克莱姆法则）</p><script type="math/tex; mode=display">I_{2}(s)=\frac{\left|\begin{array}{cc}\left(R_{1}+L s\right) & V(s) \\-L s & 0\end{array}\right|}{\Delta}=\frac{L s V(s)}{\Delta}</script><script type="math/tex; mode=display">\left.\Delta=\left|\begin{matrix}(R_1+Ls)&-Ls\\\\-Ls&\left(Ls+R_2+\frac{1}{Cs}\right)\end{matrix}\right.\right|</script></li><li><p>整理可得传递方程为</p><script type="math/tex; mode=display">G(s)=\frac{I_{2}(s)}{V(s)}=\frac{Ls}{\Delta}=\frac{LCs^{2}}{(R_{1}+R_{2})LCs^{2}+(R_{1}R_{2}C+L)s+R_{1}}</script></li></ol><p>利用拉普拉斯变换解微分方程的步骤如下：</p><p>①对方程两侧同时进行拉普拉斯变换，其中的F(s)就是我们要求的原函数经过拉普拉斯变换的结果；</p><p>②带入初值条件；</p><p>③把要求的原函数F(s)用关于s的表达式g(s)表达；</p><p>④对③中得到的F(s)=g(s)两侧进行拉普拉斯逆变换即可得到微分方程的解。</p><p>微分的拉式变换</p><p>一次微分$L[f’(t)]=sF(s)-f(0)$</p><p>二次微分$L[f’’(t)]=s^2F(s)-sf(0)-f’(0)$</p><p>三次微分$L[f’’’(t)]=s^3F(s)-s^2f(0)-sf’(0)-f’’(0)$</p><script type="math/tex; mode=display">L[f^{\prime}(t)]=\int_{0}^{\infty}e^{-s t}[e^{a t}f(t)]d t=e^{-s t}f(t)|\begin{array}{c}\\ 0\end{array}+s\int_{0}^{\infty}e^{-s t}f(t)d t=s F(s)=f(0)</script><h3 id="直线机械系统的传递函数（Translational-Mechanical-System）"><a href="#直线机械系统的传递函数（Translational-Mechanical-System）" class="headerlink" title="直线机械系统的传递函数（Translational Mechanical System）"></a>直线机械系统的传递函数（Translational Mechanical System）</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447495.png" alt="image-20231007195252596" style="zoom:80%;"></p><h3 id="旋转机械系统的传递函数（Rotational-Mechanical-System）"><a href="#旋转机械系统的传递函数（Rotational-Mechanical-System）" class="headerlink" title="旋转机械系统的传递函数（Rotational Mechanical System）"></a>旋转机械系统的传递函数（Rotational Mechanical System）</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447497.png" alt="image-20231007195402243" style="zoom:80%;"></p><h2 id="梅森公式"><a href="#梅森公式" class="headerlink" title="梅森公式"></a>梅森公式</h2><p>计算<strong>任意</strong>输入节点到输出节点的传递函数的梅森增益公式为：</p><script type="math/tex; mode=display">P=\frac{1}{\Delta}\sum_{k=1}^{n}P_{k}\Delta_{k}</script><p>其中$\Delta$为系统的特征多项式，其计算公式为：</p><script type="math/tex; mode=display">\Delta=1-\sum L_a+\sum L_bL_c-\sum L_dL_eL_f+\cdots</script><p>其中:</p><p> $\sum L_a$为所有不同回路增益之和；</p><p>$\sum L_bL_c$为所有两两不接触回路增益之和；</p><p>$\sum L_dL_eL_f+\cdots$ 为所有互不接触的回路中，每次取其中三个回路的增益乘积之和；</p><p>后面的以此类推。n为从输入节点到输出节点的前向通路条数</p><p>$P_k$ 为从输入节点到输出节点的第k条前向通路的总增益；<br>$\Delta_{k}$ 为第k条前向通路的余子式，即把特征式$\Delta$中与该前向通道相接触的回路增益置零后剩余的部分。</p><p>在做题中一共分为4步：</p><ol><li><p>先找出所有的闭环回路，即为 $\sum L_a$，再找出两两不相邻回路，即为$\sum L_bL_c$，依次类推直到找全,求出整个系统的特征式</p></li><li><p>接着找出系统的前向通路，即为$ \sum P_{k}$</p></li><li><p>找到每一项的余子式，各回路均与前向通路如果有接触，其余子式为1；如果相互没有接触<br>，其余子式为$1-其闭环回路$</p></li><li><p>带入即可求得其传递函数</p></li></ol><h2 id="一阶系统分析"><a href="#一阶系统分析" class="headerlink" title="一阶系统分析"></a>一阶系统分析</h2><p>一阶系统的传递函数标准形式为：$G(s)=\frac{C(s)}{R(s)}=\frac{1}{Ts+1}$</p><p>以输入信号为单位脉冲响应举例，单位脉冲信号的拉式变换为1，即$R(s)=1$其拉氏变换应为其自身的拉式变换。化简s的系数为1可得：$G(s)=\frac{1}{Ts+1}=\frac{1}{T}\cdot\frac{1}{s+1/T}$</p><p>进行拉氏变换：$c(t)=\mathscr{L}^{\prime}\bigl[G(s)\bigr]=\frac{1}{T}\cdot\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>有例题如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447498.png" alt="image-20231018171501486"></p><p>根据框图可以求得其传递函数为：$\frac{C(s)}{R(s)}=\frac{K_{h}G(s)}{1+K_{f}G(s)}=\frac{10K_{h}}{1+10K_{f}}\cdot\frac{1}{\frac{0.2}{1+10K_{f}}s+1}$</p><p>改变题目给定的传递时间由0.2变为0.02</p><p>可得：$\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}\cdot\frac1{\frac{0.2}{1+10K_\mathrm{f}}s+1}=\frac{10}{0.02s+1}$</p><p>列式可得：$\left.\left\{\begin{array}{cc}\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}=10\\\\\frac{0.2}{1+10K_\mathrm{f}}=0.02\\\end{array}\right.\right.$</p><p>解:$K_{f}=0.9,K_{h}=10$</p><p>&nbsp;</p><h2 id="劳斯判据"><a href="#劳斯判据" class="headerlink" title="劳斯判据"></a>劳斯判据</h2><p>可以根据<code>闭环传递函数的特征方程</code>如下表格对应写拉斯表</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447499.png" alt="image-20231018172507370"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447500.png" alt="image-20231018172512271"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447501.png" alt="image-20231018172520189"></p><p>举例:<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447502.png" alt="image-20231018172543560"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447503.png" alt="image-20231018172633894" style="zoom:67%;"></p><p>由于第一列的系数不全为正，因此系统不稳定。</p><p>例题：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447504.png" alt="image-20231018172732060"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447505.png" alt="image-20231018172746303" style="zoom:67%;"></p><p>由于第一列的系数都大于零，所以该系统稳定。</p><h3 id="劳斯判据中的特殊情况"><a href="#劳斯判据中的特殊情况" class="headerlink" title="劳斯判据中的特殊情况"></a>劳斯判据中的特殊情况</h3><p>（1）在计算中，第一列有零出现。</p><p>出现这种情况时，可以用一个很小的正数代替，继续完成计算。如果第一列中的元素除了出现的零值外，其余全部大于零，则说明系统有临界稳定的特征根。</p><p>（2）第一列的系数出现变号：改变符号（正负相互转化）的次数，即不稳定根的个数。</p><p>举例：$s^{3}-3s+2=0$</p><p>其劳斯表为：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447506.png" alt="image-20231018173756661" style="zoom:67%;"></p><p>这个变号的次数即为不稳定跟的个数。</p><p>（3）出现零行（即劳斯表的每一行都是0），则存在大小相等，方向相反的根。</p><p>$s^{5}+2s^{4}+24s^{3}+48s^{2}-25s-50=0$</p><p>劳斯表计算中出现零行时，可用零行的前一行作辅助多项式$P（s）$，然后由$\frac{dP(s)}{ds}$的系数行代替零行，完成劳斯表的计算，如下面例题所示。<br><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447507.png" alt="image-20231018174115812"><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447508.png" alt="image-20231018174123715" style="zoom:67%;"></p><p>&nbsp;</p><p>例题：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447509.png" alt="image-20231018174402971" style="zoom:80%;"></p><p>根据框图可以得到其闭环传递函数为：$G_c(s)=\frac{\frac{10}{s(s+2)}}{1+(1+10s)\frac{10}{s(s+2)}}=\frac{10}{s^2+102s+10}$</p><p>闭环特征方程为：$s^2+102s+10=0$</p><p>据此列劳斯表易，其系数全部为正，即方程稳定。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="二阶系统分析"><a href="#二阶系统分析" class="headerlink" title="二阶系统分析"></a>二阶系统分析</h2><p>二阶系统的结构图如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447510.png" alt="image-20231018174729779"></p><p>其开环传递函数为：</p><script type="math/tex; mode=display">G_{_{o}}(s)=\frac{\omega_{n}^{2}}{s(s+2\zeta\omega_{_{n}})}</script><p>闭环传递函数：</p><script type="math/tex; mode=display">G_{c}(s)=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{n}s+\omega_{n}^{2}}</script><p>闭环传递函数的分母多项式等于零的代数方程称为二阶系统的闭环特征方程，即</p><script type="math/tex; mode=display">s^{2}+2\zeta\omega_{_n}s+\omega_{_n}^{2}=0</script><p>闭环特征方程的两个根称为二阶系统的特征根，即</p><script type="math/tex; mode=display">s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}</script><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>量纲</th></tr></thead><tbody><tr><td>$\zeta$</td><td>二阶系统的阻尼比</td><td>1</td></tr><tr><td>$ \omega_{_n}$</td><td>无阻尼振荡频率</td><td>rad/s</td></tr></tbody></table></div><p>根据$\zeta$的值范围的不同，一共有如下物种情况：</p><div class="table-container"><table><thead><tr><th>范围</th><th>特征根位置</th><th>系统响应情况</th></tr></thead><tbody><tr><td>$\zeta &gt; 1$</td><td>特征根为一对不相等的负实根，位于s平面的负实轴上</td><td>过阻尼</td></tr><tr><td>$\zeta = 1$</td><td>特征根为一对相等的负实根；也是位于s平面的负实轴上</td><td>临界阻尼</td></tr><tr><td>$0&lt; \zeta &lt;1$</td><td>特征根为一对带有负实部的共钜复数根，位于s平面的左半平面上</td><td>欠阻尼</td></tr><tr><td>$\zeta = 0$</td><td>特征根为一对纯虚根，位于s平面的虚轴上</td><td>无阻尼</td></tr><tr><td>$\zeta &lt; 0$</td><td>特征根位于s平面的右半平面上</td><td>发散</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447511.png" alt="image-20231018175617105" style="zoom:80%;"></p><h3 id="二阶系统的性能指标计算"><a href="#二阶系统的性能指标计算" class="headerlink" title="二阶系统的性能指标计算"></a>二阶系统的性能指标计算</h3><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>计算式</th></tr></thead><tbody><tr><td>$\omega_{\mathrm{d}}$</td><td>阻尼振荡频率（rad/s）</td><td>$\omega_{\mathrm{d}}=\omega_{_n}\sqrt{1-\xi^{2}}$</td></tr><tr><td>$t_r$</td><td>上升时间</td><td>$t_{_r}=\frac{\pi-\beta}{\omega_{_\mathrm{d}}}$</td></tr><tr><td>$t_p$</td><td>峰值时间</td><td>$t_{_p}=\frac{\pi}{\omega_{_d}}$</td></tr><tr><td>$M_p$</td><td>超调量</td><td>$M_p=\mathrm{e}^{-\frac\zeta{\sqrt{1-\zeta^2}}\pi}\times100\%$</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>依照一阶系统调节时间的计算公式可以近似估算二阶欠阻尼系统的调节时间为:</p><p>$t_{_s}=3T={\frac{3}{\zeta\omega_{_n}}},\pm5\%\text{误差带宽度时}$</p><p>$t_{_s}=4T=\frac{4}{\zeta\omega_{_n}},\pm2\%\text{误差带宽度时}$</p><p>&nbsp;</p><p>有例题如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447512.png" alt="image-20231018180846066"></p><p>根据框图易得其开环传递函数如下：</p><script type="math/tex; mode=display">G_{_o}(s)=\frac{5K}{s(s+34.5)}</script><p>（1）闭环传递函数：</p><script type="math/tex; mode=display">G_{_c}(s)=\frac{G_{_s}(s)}{1+G_{_s}(s)}=\frac{\frac{5K}{s(s+34.5)}}{1+\frac{5K}{s(s+34.5)}}=\frac{5K}{s^{2}+34.5s+5K}=\frac{1000}{s^{2}+34.5s+1000}</script><p>带入标准二阶传递函数形式，可得特征根参数：</p><script type="math/tex; mode=display">G_{\mathrm{c}}(s)=\frac{1}{s^{2}+34.5s+1000}=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{n}s+\omega_{n}^{2}}</script><script type="math/tex; mode=display">\begin{gathered}2\zeta\omega_{n}=34.5,\omega_{n}^{2}=1000 \\\omega_{n}=31.6\mathrm{rad/s} \\\zeta=0.545 \end{gathered}</script><p>峰值时间：<script type="math/tex">t_{_p}=\frac{\pi}{\omega_{_d}}=\frac{\pi}{\omega_{_n}\sqrt{1-\zeta^{^2}}}=0.12\mathrm{s}</script></p><p>超调量：$M_{_p}=\mathrm{e}^{-\frac{\zeta}{\sqrt{1-\zeta^{2}}}\pi}\times100\%=0.13\times100\%=13\%$</p><p>调节时间：$\begin{aligned}t_{s}&amp;=\frac{3}{\zeta\omega_{n}}=0.17\mathrm{s}(\pm5\%)\\t_{s}&amp;=\frac{4}{\zeta\omega_{n}}=0.23\mathrm{s}(\pm2\%)\end{aligned}$</p><p>（2）讨论K=1500和K=13.5时，对系统动态性能的影响。</p><p>当K=1500时，闭环传递函数为：$G_{_{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{7500}{s^{2}+34.5s+7500}$</p><p>特征参数：$\omega_{n}=86.6\mathrm{rad/s},\zeta=0.2$</p><p>性能指标：$t_{_p}=0.037s,M_{_p}=52.7\%,t_{_s}=0.17s$</p><p>可得其阻尼振荡频率：$\omega_{\mathrm{d}}=\omega_{\mathrm{n}}\sqrt{1-\zeta^{2}}=86.6\sqrt{1-0.2^{2}}\mathrm{rad/s=84.85rad/s}$</p><p>&nbsp;</p><p>当K=13.5时，闭环传递函数为:</p><p>$G_{\mathrm{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{67.5}{s^{2}+34.5s+67.5}$</p><p>对应特征参数为：$\omega_{_n}=8.22\mathrm{rad/s}$</p><p>$\zeta=2.1$</p><p>此时，系统为过阻尼的，没有超调量，曲线上升很慢。由近似计算可求得调节时间为：$t_{s}\approx3T_{1}=1.44\mathrm{s}$</p><h4 id="过阻尼情况下的调节时间"><a href="#过阻尼情况下的调节时间" class="headerlink" title="过阻尼情况下的调节时间"></a>过阻尼情况下的调节时间</h4><p>过阻尼系统的阻尼系数比：$\zeta&gt;1$</p><p>特征根为两个不相等的负实根：$s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}$</p><p>闭环传递函数为：$G_{c}\left(s\right)=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{_{n}}s+\omega_{n}^{2}}=\frac{\frac{1}{T_{1}T_{2}}}{\left(s+\frac{1}{T_{1}}\right)\left(s+\frac{1}{T_{2}}\right)}$</p><p>注意到在时间响应$ c（t）$的表达式中，当$T_2&lt;&lt;T_1$时，因为第三项极快地衰减到零。忽略该项后，时间响应$c(t)$可以近似为一阶系统的时间响应</p><p>$c(t)\approx1-\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>因此，一阶系统的调节时间$t_s$用一阶系统的时间常数T作为参变量表示为:</p><p>$t_s=3T,\text{取误差带宽度为}\pm5\%\text{时}$</p><p>$t_s=4T,\text{取误差带宽度为}\pm2\%\text{时}$</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447513.png" alt="image-20231018182939773" style="zoom:50%;"></p><p>&nbsp;</p><h3 id="二阶系统响应特性的改善"><a href="#二阶系统响应特性的改善" class="headerlink" title="二阶系统响应特性的改善"></a><strong>二阶系统响应特性的改善</strong></h3><h4 id="1-误差信号的比例微分控制（PD控制）"><a href="#1-误差信号的比例微分控制（PD控制）" class="headerlink" title="1.误差信号的比例微分控制（PD控制）"></a>1.误差信号的比例微分控制（PD控制）</h4><p>在原典型二阶系统的前向通路上增加误差信号的速度分量并联通路。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211605259.png" alt="image-20231021160559090"></p><p>2.输出量的速度反馈控制（SF控制）<br>在原典型二阶系统的反馈通路上增加输出信号的速度分量反馈信号。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211606436.png" alt="image-20231021160638285"></p><p>例题：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211607774.png" alt="image-20231021160743574"></p><p>易知上图的闭环传递函数为：</p><script type="math/tex; mode=display">G_{c}(s)=\frac{\frac{K}{s(s+1)}}{1+\frac{K}{s(s+1)}(1+K_{fs})}=\frac{K}{s^{2}+(1+KK_{f})s+K}</script><p>比较二阶系统的标准式有：</p><script type="math/tex; mode=display">\omega_{n}^{2}=K</script><script type="math/tex; mode=display">2\zeta\omega_{n}=1+KK_{f}</script><p>给定的性能指标为：</p><script type="math/tex; mode=display">M_{_p}=20\%,\text{和}t_{_p}=1\mathrm{s}</script><p>通过：${M_{_p}=\mathrm{e}^{-\frac{\zeta}{\sqrt{1-\zeta^{2}}}\pi}\times100\%=20\%}$</p><p>$ {t_{_p}=\frac{\pi}{\omega_{_d}}=\frac{\pi}{\omega_{_n}\sqrt{1-\zeta^{2}}}=1\mathrm{s} }$</p><p>解得：$\begin{array}{c}{\zeta=0.456}\\{\omega_{n}=3.53}\\\end{array}$</p><p>所以：$\begin{array}{c}{K=\omega_{n}^{2}=3.53^{2}=12.5}\\{K_{f}=\frac{2\sqrt{K}\zeta-1}{K}=0.178}\\\end{array}$</p><p>当K=12.5，$K_f = 0.178$时，可得：</p><script type="math/tex; mode=display">\begin{aligned}G_{e}(s)&=\frac{12.5}{s^{2}+s+12.5}\\\\\xi&=\frac{1}{2\sqrt{K}}=0.14\\\\\\M_{_p}&=\mathrm{e}^{-\frac{\xi}{\sqrt{1-\epsilon^2}}\pi}\times100\%=64\%\end{aligned}</script><h3 id="控制系统的稳态误差分析"><a href="#控制系统的稳态误差分析" class="headerlink" title="控制系统的稳态误差分析"></a>控制系统的稳态误差分析</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211619265.png" alt="image-20231021161910919"></p><p>稳态误差系数类型：</p><p>1.当输入为单位阶跃信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_p$，表示为：</p><p>$K_{_p}=\operatorname*{lim}_{s\to0}G_{_0}(s)$</p><p>其稳态误差：$e_{ss}=\frac{1}{1+K_{_p}}$</p><p>2.当输入为单位斜坡信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_v$，表示为：</p><p>$K_{v}=\lim_{s\rightarrow0}s\cdot G_{_{o}}(s)$</p><p>其稳态误差：$e_{ss}=\frac{1}{K_{v}}$</p><p>3.当输入为加速度信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_a$，表示为：</p><p>$K_{a}=\lim_{s\rightarrow0}s^{2}G_{_0}(s)$</p><p>其稳态误差：$e_{_{\mathrm{ss}}}=\frac{1}{K_{_{a}}}$</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211627804.png" alt="image-20231021162714529"></p><p>&nbsp;</p><h2 id="根轨迹法"><a href="#根轨迹法" class="headerlink" title="根轨迹法"></a>根轨迹法</h2><h3 id="绘制负反馈系统的9条法则"><a href="#绘制负反馈系统的9条法则" class="headerlink" title="绘制负反馈系统的9条法则"></a>绘制负反馈系统的9条法则</h3><p>1.连续性；</p><p>2.对称性；</p><p>3.根轨迹的分支数；</p><p>根轨迹的分支数等于系统的阶数</p><p>4.根轨迹的起点和终点；</p><p>$\frac{\prod_{j=1}^{m}\left(s+z_{j}\right)}{\prod_{i=1}^{n}\left(s+p_{i}\right)}=-\frac{1}{K_{g}}$</p><p>当$K_g = 0$是根轨迹的起点，分母等于零即为系统的开环极点</p><p>当$K_g = \infty$是根轨迹的起点，分子等于零即为系统的开环零点</p><p>5.实轴上的根轨迹；</p><p>在实轴上选取实验点$s_i$，如果实验点$s_i$的右方实轴上的开环零点数和极点数的总和为奇数，则实验点$s_i$所在的实验段是根轨迹，否则该实验段不是根轨迹。</p><p>6.根轨迹的会合点与分离点；</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211642610.png" alt="image-20231021164241432" style="zoom:67%;"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211642538.png" alt="image-20231021164256350" style="zoom:67%;"></p><p>计算分离点或汇合点：</p><p>$N’(s)D(s)-N(s)D’(s)=0$</p><p>PS：其中N(s)为变量s的分子多项式，D(s)为变量s的分母多项式。</p><p>7.根轨迹的渐近线（与实轴交点；倾斜角）</p><p>与实轴交点：$-\sigma=-\frac{a_{n-1}-b_{m-1}}{n-m}=-\frac{\sum_{i=1}^{n}p_{i}-\sum_{j=1}^{m}z_{j}}{n-m}$</p><p>倾斜角：$\theta=\frac{\pm180^{\circ}(2k+1)}{n-m}$</p><p>8.与虚轴交点；</p><p>根轨迹可能与虚轴相交，交点坐标的$\omega $值及相应的$K_g$值可由劳斯判据求得，也可在特征方程中令s=j$\omega$ ，然后使特征方程的实部和虚部分别为零求得。</p><p>9.出射角与入射角</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211648637.png" alt="image-20231021164835441" style="zoom:67%;"></p><p>幅角条件为:$\sum_{j=1}^{n}\arg[s+z_{j}]-\sum_{i=1}^{n}\arg[s+p_{i}]\Bigg|_{s = s_g}=\pm180^{\circ}(2k+1)$</p><p>令$\left.\theta_{j}=\arg\left[\begin{array}{c}{s+z_{j}}\\\end{array}\right.\right],\varphi_{i}=\arg\left[\begin{array}{c}{s+p_{i}}\\\end{array}\right]$</p><p>出射角：$\varphi_{k}=\mp180^{\circ}(2k+1)+\sum_{j=1}^{m}\theta_{j}-\sum_{i=1;i\ne k}^{n}\varphi_{i}\Bigg|_{s=p_{k}}$</p><p>入射角：$\theta_{l}=\pm180^{\circ}(2k+1)-\sum_{j=1\atop j\neq l}^{m}\theta_{j}+\sum_{i=1}^{n}\varphi_{i}\Bigg|_{s=z_{i}}$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动控制原理&quot;&gt;&lt;a href=&quot;#自动控制原理&quot; class=&quot;headerlink&quot; title=&quot;自动控制原理&quot;&gt;&lt;/a&gt;自动控制原理&lt;/h1&gt;&lt;p&gt;​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>结构化数字设计</title>
    <link href="https://rozen12123.github.io/posts/3c5c3e03.html"/>
    <id>https://rozen12123.github.io/posts/3c5c3e03.html</id>
    <published>2023-09-13T02:38:58.000Z</published>
    <updated>2023-09-26T08:49:50.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字化结构设计"><a href="#数字化结构设计" class="headerlink" title="数字化结构设计"></a>数字化结构设计</h1><h2 id="层次建模的概念"><a href="#层次建模的概念" class="headerlink" title="层次建模的概念"></a>层次建模的概念</h2><h3 id="设计方法学"><a href="#设计方法学" class="headerlink" title="设计方法学"></a>设计方法学</h3><p>两种基本的设计方法：<code>自底向上</code>和<code>自顶向下</code>设计</p><p>1.自底向上</p><p>2.自顶向下</p><p>通常情况下，两种方法混合使用。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>​     Verilog使用模块（module）的概念来代表一个基本的功能块。</p><p>​    一个模块可以是一个元件，也可以是低层次模块的组合</p><h3 id="1-模块声明"><a href="#1-模块声明" class="headerlink" title="1.模块声明"></a>1.模块声明</h3><p>​    在Verilog中，模块声明是由关键字module开始，关键字endmodule必须出现在模块定义的结尾。每个模块必须有一个模块名，由它唯一的标志这个模块。模块的端口列表则描述这个模块的输入和输出端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;模块名&gt;(&lt;模块端口列表&gt;);</span><br><span class="line">...</span><br><span class="line">&lt;模块的内容&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>例如在脉动进位计数器的例子中，T触发器可以定义为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> T_FF (q, clock ,reset);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;T触发器的功能描述&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>​    使用Verilog可以在每个模块内4个抽象层次进行描述，定义如下：</p><ol><li>行为或算法级：注重实现的算法，并不注重硬件实现的细节</li><li>数据流级：说明数据的流程对模块进行描述，数据如何在各个寄存器之间流动，以及如何处理这些数据。</li><li>门级：从组成电路的逻辑门及其之间的相互关系的角度设计模块。</li><li>开关级：通过开关，储存节点及其互连关系来设计模块。</li></ol><p>&nbsp;</p><h3 id="2-模块实例"><a href="#2-模块实例" class="headerlink" title="2.模块实例"></a>2.模块实例</h3><p>​    模块声明类似于一个模板，使用这个模板就可以创建实际的对象。当一个模块被调用的时候，Verilog会根据模板创建一个唯一的模块对象，每个对象都有其各自的名字、变量、参数和输入/输出（I/O）接口。</p><p>​    从模板创建对象的过程称为<code>实例化</code>（instantiation），创建的对象称为<code>实例</code>（instance）</p><p>&nbsp;</p><p>​    在Verilog中，不允许在模块声明中嵌套模块，也就是在模块声明的module和endmodule关键字之间不能再包含模块声明。模块之间的相互调用是通过实例引用来完成的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它引用了4个触发器。它们之间的连接参见2.2节</span></span><br><span class="line"><span class="comment">//定义名为ripple_carry_counter（脉动进位计数器）的模块</span></span><br><span class="line"><span class="keyword">module</span> ripple_carry_counter(q,clk,reget);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>]q;<span class="comment">//输人输出端口的信号和向量声明，以后会讲解</span></span><br><span class="line"><span class="keyword">input</span> clk,reset；<span class="comment">//输入/输出端口的信号声明，以后会讲解</span></span><br><span class="line"><span class="comment">//生成了4个触发器TEF的实例，每个实例都有自己的名字，每个实例都传递一组信号</span></span><br><span class="line"><span class="comment">//注意每个实例都是FF模块的副本</span></span><br><span class="line">    TFF tff0 (q[<span class="number">0</span>]，clk,reset);</span><br><span class="line">    TFF tff1 (q[<span class="number">1</span>]，q[<span class="number">0</span>]，reset);</span><br><span class="line">    TFF tff2 (q&#123;<span class="number">2</span>&#125;，q[<span class="number">1</span>]，reset);</span><br><span class="line">    TFF tff3 (q[<span class="number">3</span>]，q[<span class="number">2</span>]，reset);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//定义名为TFF（触发器）的模块。它引用了一个D触发器。我们在本模块中假设</span></span><br><span class="line"><span class="comment">//D触发器（DEF）已经在该设计中的别处定义了，参见图2.4，看它们之间的互相连接</span></span><br><span class="line">moaule TFF (q,clk,reset);</span><br><span class="line"><span class="comment">//以后将对下列语句做进一步的解释</span></span><br><span class="line"><span class="keyword">output</span> q;<span class="number">0</span></span><br><span class="line"><span class="keyword">input</span> clk,reset;</span><br><span class="line"><span class="keyword">wire</span> d;</span><br><span class="line">DFF dff0（q,d,clk,reset）;<span class="comment">//调用（实例引用）DFF，取名为dffo</span></span><br><span class="line"><span class="keyword">not</span> n1（d,q）;<span class="comment">//非门（not）是veri1og语言的内部原语部件（primitive），以后会讲解</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>ps:关键字必须是小写字母</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Verilog中的基本词法约定与c语言类似。</p><h3 id="数字声明"><a href="#数字声明" class="headerlink" title="数字声明"></a>数字声明</h3><ol><li><p>指明位数的数字</p><p>指明位数的数字表现形式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;size&gt;&#x27;&lt;base format&gt;&lt;number&gt;</span><br></pre></td></tr></table></figure><p>$<size>$用来指明数字的宽度（二级制的个数），只能用十进制表示。Base format表示用什么进制</size></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1111</span><span class="comment">//这是一个4位的二进制数</span></span><br><span class="line"><span class="number">12&#x27;habc</span><span class="comment">//这是一个12位的十六进制数</span></span><br><span class="line"><span class="number">16&#x27;d255</span><span class="comment">//这是一个16位的十进制数</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>不指明位数的数字</p><p>没有指定基数默认为十进制数。如果没有指定宽度，则默认为32位</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">234566</span><span class="comment">//这是一个32位的十进制数</span></span><br><span class="line"><span class="number">&#x27;hc3</span><span class="comment">//这是一个32位的十六进制数</span></span><br><span class="line"><span class="number">&#x27;o21</span><span class="comment">//这是一个32位的八进制数</span></span><br></pre></td></tr></table></figure></li><li><p>X和Z值</p><p>x表示不确定值，z表示高阻值；不区分x，y的大小写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;h13x</span><span class="comment">//这是一个12位的十六进制数，四个最低位不确定6&#x27;hx//这是一个6位的十六进制数，所有位都不确定</span></span><br><span class="line"><span class="number">32&#x27;bz</span><span class="comment">//这是一个32位的高阻值</span></span><br></pre></td></tr></table></figure><p>​    16进制为基数的表示中x或z表示4位，在8进制，x，z表示3位，在2进制中x，z代表1位。如果某数的最高位是0，x或z，verilog语言约定将分别使用0，x，z自动对这个数进行扩展，填满余下的更高位。如果最高位是1，余下的更高位用0来扩展。</p></li><li><p>复数</p><p>对于常数，我们可以通过在表示位宽的数字前面增加一个减号来表示它是一个负数，因为表示大小的常数总是正的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d3</span><span class="comment">//这是一个6位的用二进制补码形式存储的十进制数3，表示负数</span></span><br><span class="line">-<span class="number">6</span>&#x27;sd3<span class="comment">//这是一个6位的用于带符号算术运算的负数</span></span><br><span class="line"><span class="number">4</span>&#x27;d-<span class="number">2</span><span class="comment">//非法说明</span></span><br></pre></td></tr></table></figure></li><li><p>下划线和问号</p><p>除了第一个字符，下划线可以出现在数字中的任何位置，它的作用只是提高可读性，在编译阶段会被忽略，？是z的另一种表示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;b1111_0000_1010</span><span class="comment">//用下划线符号来提高可读性4&#x27;b10??//相当于4&#x27;b10zz</span></span><br></pre></td></tr></table></figure></li><li><p>转义标识符</p><p>转义标识符以反斜线“\”开始，以空白符（空格、制表符和换行符）结束。Verilog将反斜线和空白符之间的字符逐个进行处理。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\a+b-C <span class="comment">//译者注：与a+b-c等同</span></span><br><span class="line">\**my_name** <span class="comment">//译者注：如果作为标识符则与**my_name**等同</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>值的种类</p><p>Verilog使用四值逻辑和八种信号强度来对实际的硬件电路建模。</p><p>| 值的级别 | 硬件电路中的条件 |<br>| ———— | ———————— |<br>| 0        | 逻辑0，条件为假  |<br>| 1        | 逻辑0，条件为假  |<br>| x        | 逻辑值不确定     |<br>| z        | 高阻，浮动状态   |</p><p>| 强度等级 | 类型 | 程度 |<br>| ———— | —— | —— |<br>| supply   | 驱动 | 最强 |<br>| strong   | 驱动 |      |<br>| pull     | 驱动 |      |<br>| large    | 储存 |      |<br>| weak     | 驱动 |      |<br>| medium   | 储存 |      |<br>| small    | 储存 |      |<br>| highz    | 高阻 | 最弱 |</p></li><li><p>线网</p><ol><li><p>线网（net：代表了一类数据类型，包括wire，wand，wor，tri，trireg等）标识硬件单元之间的连接。</p></li><li><p>就像在真实的电路中一样，线网由其连接器件的输出连续驱动。</p></li><li><p>线网一般使用关键字wire进行声明。如果没有明显说明向量，则默认线网的位宽为1</p></li><li><p>线网的默认值为z（trireg类型的线网例外，其默认值为x），线网的值由驱动源确定，如果没有驱动源，则线网的值为z</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//声明上面的电路中a是wrie（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> b,c;<span class="comment">//声明上面的电路中b和c也是wire（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> d = <span class="number">1&#x27;b0</span>;<span class="comment">//连线d在声明时，d被赋值为逻辑值0</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><ol><li><p>寄存器用来表示储存元件，它保持原有的树脂，直到被改写。</p></li><li><p>寄存器数据类型一般通过关键字reg来声明，默认值为X</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> reset;<span class="comment">//声明能保持数值的变量reset</span></span><br><span class="line">initia1 <span class="comment">//这个结构将在以后讨论</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">reset = <span class="number">1&#x27;b1</span>;<span class="comment">//把reset初始化为1，使数字电路复位</span></span><br><span class="line">#<span class="number">100</span> reset=<span class="number">1&#x27;b0</span>;<span class="comment">//经过100个时间单位后，reset置逻辑0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>向量</p><ol><li><p>线网和寄存器类型的数据均可以声明为向量（位宽大于1）。若在声明中没有指定位宽，则默认为标量（1位）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//标量线网变量，默认</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] bus;<span class="comment">//8位的总线</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] busA,busB,busC;<span class="comment">//3条32位宽的总线</span></span><br><span class="line"><span class="keyword">reg</span> clock;<span class="comment">//标量寄存器，默认</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">40</span>] virtual_addr;<span class="comment">//向量寄存器，41位宽的虚拟地址</span></span><br></pre></td></tr></table></figure><ol><li><p>向量域选择</p><p>对于上面例子中声明的向量，我们可以指定它的某一位或若干个相邻位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">busA[<span class="number">7</span>] <span class="comment">//向量busA的第7位</span></span><br><span class="line">bus[<span class="number">2</span>:<span class="number">0</span>]<span class="comment">//向量bus的最低3位</span></span><br><span class="line"><span class="comment">//如果写成bus[0:2]是非法的，因为高位应该写在范围说明的左侧</span></span><br><span class="line">virtual_addr[<span class="number">0</span>:<span class="number">1</span>]<span class="comment">//向量virtual_addr的两个最高位</span></span><br></pre></td></tr></table></figure></li><li><p>可变的向量域选择</p><p>[<startingbit>+：width]：从起始位开始递增，位宽为width。</startingbit></p><p>[<startingbit>-：width]：从起始位开始递减，位宽为width。</startingbit></p></li></ol></li></ol><p>起始位可以是一个变量，但是位宽必须是一个常量。下面的例子说明了可变的向量域选择的使用方法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">255</span>:<span class="number">0</span>]data1;<span class="comment">//data1【255】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>:<span class="number">255</span>]data2;<span class="comment">//data2【0】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>]<span class="keyword">byte</span>;</span><br><span class="line"><span class="comment">//用变量选择向量的一部分</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data131:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data1【31:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data2【24:31】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data2【24:311//超始位可以是变量，但宽度必须是常数。因此可以通过可变域选择，//用循环语句选取一个很长的向量的所有位</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">32</span>;j=j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">byte</span>=data1[(j*<span class="number">8</span>)+<span class="number">8</span>];<span class="comment">//次序是【7:0】，【15:81..【255:248】</span></span><br><span class="line"><span class="comment">//用于初始化向量的一个域</span></span><br><span class="line">data1[(byteNum*<span class="number">8</span>)+:<span class="number">8</span>] = <span class="number">8&#x27;b0</span>;<span class="comment">//如果byteNum=1，共有8位被清零，【15:8】</span></span><br></pre></td></tr></table></figure></li><li><p>数字，实数和时间寄存器的数据类型</p><p>除reg类型之外，Verilog还支持integer,real和time寄存器数据类型。</p><ol><li><p>整数</p><p>用关键字integer进行声明，虽然可以用reg类型的寄存器作为通用变量，但声明一个整体类型的变量来完成计数会更为方便。</p><p>整数默认位宽为宿主机的字的位数，最小应为32位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> counter;<span class="comment">//一般用途的变量，作为计数器initial</span></span><br><span class="line">coumter=-<span class="number">1</span>;<span class="comment">//把-1存储到计数器中</span></span><br></pre></td></tr></table></figure></li><li><p>实数</p><p>用real来声明，实数声明不能带有范围，默认值为0。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> delta;<span class="comment">//定义一个名为delta的实型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">delta = <span class="number">4</span>e10;<span class="comment">//delta被赋值，用科学记数法表示</span></span><br><span class="line">delta = <span class="number">2</span><span class="variable">.13</span>;<span class="comment">//delta被赋值为2.13</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;<span class="comment">//定义一个名为的整型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">i = delta;<span class="comment">//1得到值2（2.13取整数部分）</span></span><br></pre></td></tr></table></figure></li><li><p>时间寄存器</p><p>仿真是按仿真时间进行的，其宽度与具体实现有关，最小为64位。用time来声明。通过调用系统函数$time可以得到当前的仿真时间。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span> save_simtime;<span class="comment">//定义时间类型的变量savesim time initial</span></span><br><span class="line">save sim <span class="keyword">time</span>=<span class="built_in">$time</span>;<span class="comment">//把当前的仿真时间记录下来</span></span><br></pre></td></tr></table></figure></li><li><p>数组</p><p>在Verilog中允许声明reg,integer,time,real,realtime及其向量类型的数组，对数组的维数没有限制。</p><p>形如&lt;数组名&gt;&lt;下标&gt;。对于多维数组来讲，用户需要说明其每一维的索引。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> count[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个计数变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> boo1[<span class="number">31</span>:<span class="number">0</span>];<span class="comment">//由32个1位的布尔（boolean）寄存器变量组成的数组</span></span><br><span class="line"><span class="keyword">time</span> chk_point[<span class="number">1</span>:<span class="number">100</span>];<span class="comment">//由100个时间检查变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] port_id[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个端口标识变量组成的数组，端口变量的位宽为5</span></span><br><span class="line"><span class="keyword">integer</span> matrix[<span class="number">4</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>];<span class="comment">//二维的整数型数组</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">63</span>:<span class="number">0</span>] array_4d[<span class="number">15</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//四维64位寄存器型数组</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] w_array2[<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明8位向量的数组</span></span><br><span class="line"><span class="keyword">wire</span> w_array1[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明1位线型变量的二维数组</span></span><br></pre></td></tr></table></figure><p>不要将数组和线网或寄存器向量混淆起来，向量是一个单独的元件，它的位宽是n；数组由多个元件组成，其中每个元件元素的赋值位n或1。</p><p>下面的例子显示了对数组元素的赋值：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count[<span class="number">5</span>]=<span class="number">0</span>;<span class="comment">//把count数组中的第5个整数型单元（32位）复位</span></span><br><span class="line">chk_point[<span class="number">100</span>]=<span class="number">0</span>;<span class="comment">//把chk_point数组中的第100个时间型单元（64位）复位</span></span><br><span class="line">port_id[<span class="number">3</span>]=<span class="number">0</span>;<span class="comment">//把port_id数组中的第3个寄存器型单元（5位）复位</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">33559</span>;<span class="comment">//把数组中第1行第0列的整数型单元（32位）置为33559</span></span><br><span class="line">array_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//把四维数组中索引号为【o】【O】【0】【O】的寄存器型单元</span></span><br><span class="line"><span class="comment">//的0-15位都置为0</span></span><br><span class="line">port_id=<span class="number">0</span>;<span class="comment">//非法，企图写整个数组</span></span><br><span class="line">matrix[<span class="number">1</span>] = <span class="number">0</span>；<span class="comment">//非法，企图写数组的整个第2行，即从matrix【1】【0】直到matrix【1】【255】</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><p>在数字电路仿真中，需要对寄存器文件ROM和RAM建模。如果需要访问储存器中的一个特定字，可以将字的地址作为数组的下标来完成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> memibit[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的1位存储器mem1bit</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] membyte[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的字节（8位）存储器membyte </span></span><br><span class="line">membyte[<span class="number">511</span>]<span class="comment">//取出存储器membyte中地址511处所存的字节</span></span><br></pre></td></tr></table></figure></li><li><p>参数</p><p>Verilog允许使用关键字parameter在模块内定义常数。参数代表常数，不能像变量那样赋值，但是每个模块实例的参数值可以在编译阶段被重载。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> port_id=<span class="number">5</span>;<span class="comment">//定义常数portid为5</span></span><br><span class="line"><span class="keyword">parameter</span> cache_1ine_width=<span class="number">256</span>;<span class="comment">//定义高速缓冲器总线宽度为常数256</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">signed</span>[<span class="number">15</span>:<span class="number">0</span>] WIDTH;<span class="comment">//把参数WIDTH规定为有正负号，宽度为16位</span></span><br></pre></td></tr></table></figure><p>Verilog中的局部参数使用关键字localparam来定义，其作用等同于参数，区别在于它的值不能改变。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>  state1 = <span class="number">4&#x27;b0001</span>,</span><br><span class="line">state2 = <span class="number">4&#x27;b0010</span>,</span><br><span class="line">state3 = <span class="number">4&#x27;b0100</span>,</span><br><span class="line">state4 = <span class="number">4&#x27;b1000</span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><ol><li><p>字符串保存在reg类型的变量中，每个字符占用8位（一个字节），因此寄存器变量的宽度应足够大。</p></li><li><p>如果寄存器变量的宽度大于字符串的大小，则Verilog使用0来填充左边的空余位；如果寄存器变量的宽度小于字符串的大小，则Verilog截去字符串最左边的位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">8</span>*<span class="number">18</span>:<span class="number">1</span>] string_value;<span class="comment">//声明变量string_vaiue，其宽度为18个字节</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">string_value = <span class="string">&quot;Hello Verilog World&quot;</span>;<span class="comment">//字符串可以存储在变量中</span></span><br></pre></td></tr></table></figure></li><li><p>有一些特殊字符在显示字符串时有特定的意义，例如换行符，制表符和显示参数值。如果需要在字符串中显示这些特殊字符，则必须加前缀转义字符。</p></li></ol></li></ol><div class="table-container"><table><thead><tr><th>转义字符</th><th>显示的字符</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>tab（制表空格）</td></tr><tr><td>%%</td><td>%</td></tr><tr><td>\\\</td><td>\\</td></tr><tr><td>\\”</td><td>“</td></tr><tr><td>\000</td><td>1到3个八进制数字字符</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><h2 id="系统任务和编译指令"><a href="#系统任务和编译指令" class="headerlink" title="系统任务和编译指令"></a>系统任务和编译指令</h2><h3 id="系统任务"><a href="#系统任务" class="headerlink" title="系统任务"></a>系统任务</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字化结构设计&quot;&gt;&lt;a href=&quot;#数字化结构设计&quot; class=&quot;headerlink&quot; title=&quot;数字化结构设计&quot;&gt;&lt;/a&gt;数字化结构设计&lt;/h1&gt;&lt;h2 id=&quot;层次建模的概念&quot;&gt;&lt;a href=&quot;#层次建模的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="课程" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子信息科学与技术攻略</title>
    <link href="https://rozen12123.github.io/posts/69d7a7f9.html"/>
    <id>https://rozen12123.github.io/posts/69d7a7f9.html</id>
    <published>2023-09-06T14:46:37.000Z</published>
    <updated>2023-09-18T02:42:04.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电子信息科学与技术攻略"><a href="#电子信息科学与技术攻略" class="headerlink" title="电子信息科学与技术攻略"></a>电子信息科学与技术攻略</h1><p>亲爱的学弟学妹们：</p><p>  首先，我要热烈欢迎你们加入电子信息科学与技术专业！恭喜你们顺利踏上了大学的征程，这将是一个充满挑战和成长的旅程。我是电子信息科学与技术专业的一名本科生，非常高兴能在这里与你们分享一些有关入学和大学生活的经验。</p><p>  在你们即将开始的学术和生活冒险中，我相信你们会遇到各种新的机会和挑战。作为学长，我们愿意与你们分享我们的经验，帮助你们更快地适应大学生活。不管你们面临什么问题，都请放心来寻求帮助，我们将竭尽全力支持你们。</p><p>  接下来，让我们一起探讨一些入学后关于学习的一些建议。无论你们有什么疑问或需要，都可以随时私信我。</p><h2 id="关于电子信息科学信息与技术"><a href="#关于电子信息科学信息与技术" class="headerlink" title="关于电子信息科学信息与技术"></a>关于电子信息科学信息与技术</h2><p>  在刚入学时我也对这个专业充满疑问，根本不知道这个专业是什么，要学什么，可以用来干什么。</p><p>  简单来说，电子信息科学与技术是一门涵盖电子工程、计算机科学和信息技术的跨学科领域。它关注的是如何处理、传输和管理信息，以及如何使用电子设备和计算机系统来解决实际问题。</p><p>  具体来说，这个领域包括了以下重要方面：</p><ol><li><strong>电子工程：</strong> 电子信息科学与技术涉及设计、开发和维护各种电子设备和系统，如电路、通信设备、传感器和嵌入式系统。这些技术在现代社会中无处不在，用于各种应用，从智能手机到医疗设备。</li><li><strong>计算机科学：</strong> 这个领域强调计算机系统的设计、编程和软件开发。学生将学习如何编写代码、开发应用程序，并理解计算机硬件和软件之间的相互作用。</li><li><strong>通信技术：</strong> 电子信息科学与技术还涉及到数据通信和网络技术，包括互联网、移动通信和无线传感器网络。这是现代社会中信息传递的关键组成部分。</li><li><strong>信息处理：</strong> 学生将学习如何处理和分析数据，以从中提取有用的信息。这包括数据挖掘、人工智能和机器学习等技术，这些技术在商业、科学和许多其他领域中都有广泛的应用。</li></ol><p>当然如果只这么说的话还是会有些抽象，不过不用担心，接下来的文章里我会对我们的专业做更加详细的解释。</p><p>​    这是一门涉及知识很广的学科，但你不得不说也是一门非常有趣的学科。我最开始知道这个专业并且对此感兴趣是在B站上看到的一个视频。是<strong>稚晖君</strong>做的一个小电视，我当时就被深深得吸引了，如此小的一个小电视上个怎么可以实现这么多功能，完全都可以当作一个电脑来使用。</p><p><a href="https://www.bilibili.com/video/BV1jE41137eu/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【自制】技术宅UP耗时三个月，自制B站最强小电视！【硬核】【3分钟从草图到实物】_哔哩哔哩_bilibili</a></p><p>​    随后，我又在B站发现了更多电子信息专业可以做的很多东西。</p><p><a href="https://www.bilibili.com/video/BV1BW41147kC/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">基于Arduino的十个可以DIY的炫酷项目_哔哩哔哩_bilibili</a></p><p>​    这对还没有开始学习大学知识的你来说可能就像魔法一样，我最开始刚进入大学的时候也是感觉这一切都是那么迷茫，不知道怎办开始，怎么学习才能做出来像这些视频里一样的diy项目。</p><p>​    但是经过一个学期的学习，我在大一上学期结束的那个寒假也用自己所学的东西，做了一个很简易的流水灯，虽然现在看起来是很简单的一个小制作，但是在当时把流水灯点亮的那一刻，心里的成就感是很强烈得，足够开心很久很久。</p><p><a href="https://www.bilibili.com/video/BV1uR4y1u7z5/?spm_id_from=333.999.0.0">做了个流水灯_哔哩哔哩_bilibili</a></p><p>希望你也可以在之后的学习中，做出一些很有趣的小制作。</p><p>&nbsp;</p><h2 id="电子信息科学与技术课程设置及其相关资料"><a href="#电子信息科学与技术课程设置及其相关资料" class="headerlink" title="电子信息科学与技术课程设置及其相关资料"></a>电子信息科学与技术课程设置及其相关资料</h2><h3 id="大一（Freshman-Year）"><a href="#大一（Freshman-Year）" class="headerlink" title="大一（Freshman Year）"></a><strong>大一（Freshman Year）</strong></h3><h4 id="第一学期课程（Curriculum-in-First-Semester）："><a href="#第一学期课程（Curriculum-in-First-Semester）：" class="headerlink" title="第一学期课程（Curriculum in First Semester）："></a>第一学期课程（Curriculum in First Semester）：</h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（一）College Physical Education I</p><p>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</p><p>l 线性代数导论（Introduction to Linear Algebra）</p><p>l 大学物理Ⅰ（University Physics Ⅰ）</p><p>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</p><p>l 编程导论（Introduction to Programming）</p><h4 id="第二学期课程（Curriculum-in-Second-Semester）："><a href="#第二学期课程（Curriculum-in-Second-Semester）：" class="headerlink" title="第二学期课程（Curriculum in Second Semester）："></a><strong>第二学期课程（Curriculum in Second Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（二）College Physical Education II</p><p>l 微积分Ⅱ和III（Calculus Ⅱ and III）</p><p>l 大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</p><p>l 工程学导论Ⅱ（Introduction to Engineering Ⅱ）</p><p>l 电路原理及实验（Electrical Circuit Theory and Lab）</p><h3 id="大二（Sophomore-Year）"><a href="#大二（Sophomore-Year）" class="headerlink" title="大二（Sophomore Year）"></a><strong>大二（Sophomore Year）</strong></h3><h4 id="第三学期课程（Curriculum-in-Third-Semester）："><a href="#第三学期课程（Curriculum-in-Third-Semester）：" class="headerlink" title="第三学期课程（Curriculum in Third Semester）："></a><strong>第三学期课程（Curriculum in Third Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（三）College Physical Education III</p><p>l 常微分方程导论（Introduction to Ordinary Differential）</p><p>l 大学物理III及实验（University Physics III and Lab）</p><p>l 数据结构（Data Structures）</p><p>l 电子学Ⅰ及实验（Electronics Ⅰ and Lab）</p><h4 id="第四学期课程（Curriculum-in-Forth-Semester）"><a href="#第四学期课程（Curriculum-in-Forth-Semester）" class="headerlink" title="第四学期课程（Curriculum in Forth Semester）"></a><strong>第四学期课程（Curriculum in Forth Semester）</strong></h4><p>l 大学体育（四）（College Physical Education IV）</p><p>l 工程概率基础（Introduction to Engineering Probability）</p><p>l 信号与系统（Circuits，Signals and System）</p><p>l 逻辑设计（Logic Design）</p><p>l 数字设计实验（Digital Design Lab）</p><p>l 电子学Ⅱ和实验（Electronics Ⅱ and Lab）</p><p>l 微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</p><p>l 电子电路CAD （Electronic Circuit CAD）</p><h3 id="大三（Junior-Year）"><a href="#大三（Junior-Year）" class="headerlink" title="大三（Junior Year）"></a><strong>大三（Junior Year）</strong></h3><h4 id="第五学期课程（Curriculum-in-Fifth-Semester）"><a href="#第五学期课程（Curriculum-in-Fifth-Semester）" class="headerlink" title="第五学期课程（Curriculum in Fifth Semester）"></a><strong>第五学期课程（Curriculum in Fifth Semester）</strong></h4><p>l 离散时间信号与系统（Discrete-Time Signals and Systems）</p><p>l 电磁场原理（Electromagnetic Field Theory）</p><p>l 固态电子学（Solid-State Electronics）</p><p>l 单片机原理（MCU Principle）</p><p>l 结构化数字设计（含FPGA）Structured Digital Design</p><p>l 创新项目实践（一）Practice of Innovation Project I</p><h4 id="第六学期课程（Curriculum-in-Sixth-Semester）"><a href="#第六学期课程（Curriculum-in-Sixth-Semester）" class="headerlink" title="第六学期课程（Curriculum in Sixth Semester）"></a><strong>第六学期课程（Curriculum in Sixth Semester）</strong></h4><p>l 嵌入式微处理系统设计（Embedded Microprocessor System Design）</p><p>l 通信系统（Communication Systems）</p><p>l 线性控制系统（Linear Control Systems）</p><p>l 电力电子（Power Electronics）</p><p>l VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</p><p>l 模拟集成电路（Analog Integrated Circuit）</p><p>l 创新项目实践（二）Practice of Innovation Project II</p><h3 id="大四（Senior-Year）"><a href="#大四（Senior-Year）" class="headerlink" title="大四（Senior Year）"></a><strong>大四（Senior Year）</strong></h3><h4 id="第七学期课程（Curriculum-in-Seventh-Semester）"><a href="#第七学期课程（Curriculum-in-Seventh-Semester）" class="headerlink" title="第七学期课程（Curriculum in Seventh Semester）"></a><strong>第七学期课程（Curriculum</strong> <strong>in Seventh Semester）</strong></h4><p>l 数字图像处理（Introduction to Digital Image Processing）</p><p>l 现场可编程逻辑阵列（Field programmable logic array）</p><p>l 高级项目设计（Advanced project design）</p><p>l 集成电路EDA（Integrated circuit EDA）</p><p>l 版图设计（Layout design）</p><p>l 专业实习（Internship）</p><h4 id="第八学期课程（Curriculum-in-Eighth-Semester）"><a href="#第八学期课程（Curriculum-in-Eighth-Semester）" class="headerlink" title="第八学期课程（Curriculum in Eighth Semester）"></a><strong>第八学期课程（Curriculum in Eighth Semester）</strong></h4><p>l 毕业设计（Senior Project）</p><p>&nbsp;</p><p>关于大学期间所有能用到得课本已经全部整理出来，链接就放到下面。</p><p>链接：<a href="https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg">https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg</a> 提取码：2038</p><p>​    这一部分要感谢一名学长，将我们所有的文档归纳起来并且分享给大家，我也把这位学长的原博客链接放到下面。这篇博客里还有所有对于我们课程的相关资料的推荐，我个人也是这篇博客的受益者。</p><p><a href="https://y006.github.io/2022/03/23/15-24-59/">电子专业资料共享计划 | Blog (y006.github.io)</a></p><p>​    如果打不开上面的博客，可能是因为博客的地址在GitHub，而你的电脑又没有开vpn。</p><p>关于vpn是什么，怎么使用，你可以去看这个视频。</p><p><a href="https://www.bilibili.com/video/BV1LX4y1E7AS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【科普】VPN到底是什么，你还敢用吗_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="课程部分"><a href="#课程部分" class="headerlink" title="课程部分"></a>课程部分</h2><p>​    大家最关心的莫过于自己将要学习的课程以及如何去学好他们，接下来我将对此讲一些自己的看法，如果你有更好的建议或者发现了错误也希望你及时联系我。</p><p>​    但是大学的知识学习不等同于高中，高中的一贯学习套路是：</p><ol><li>先学会基础知识，了解最基本的概念</li><li>反复练习简单题，中档题及压轴题</li><li>将练习后的题目分类总结，总结成一套自己的方法，直到考试碰到此类问题可以立即有思路，很快地解出题目。</li></ol><p>​    但是在大学如果你仍然按高中的学习方法明显是很吃力的，因为对于三年学习六门科目的学习方法去应对一学期学十几门课的实际情况，明显是不可能的。</p><p>​    我就对大一第一学期的课程做一些简单的介绍。我把课程分为三类，<code>基础类</code>，<code>导论类</code>，<code>应用类</code></p><h3 id="基础类：工程微积分，线性代数导论，大学物理"><a href="#基础类：工程微积分，线性代数导论，大学物理" class="headerlink" title="基础类：工程微积分，线性代数导论，大学物理"></a><em>基础类</em>：工程微积分，线性代数导论，大学物理</h3><p>​    基础类的课程设计了很多的基础概念，公式，和思想。学习这类课程需要你对自己学习过的知识有一个清晰的框架，以至于自己学习完这门课后知道自己都学习了什么内容。</p><p>​    例如你想去做一个平衡车，你学习完这些知识之后你要很清楚知道，微积分中的PID算法可以用来解决调节平衡角度的问题，大学物理的角动量可以让你更加了解平衡的机械部分是如何实现的。</p><h3 id="导论类：工程学导论，编程导论"><a href="#导论类：工程学导论，编程导论" class="headerlink" title="导论类：工程学导论，编程导论"></a><em>导论类</em>：工程学导论，编程导论</h3><p>​    导论类课程一般会带你们使用一种新的技术解决一个问题，这类课程不需要你像基础列课程学习得那么细致，对概念那么精通，你只需要知道这么课大概都讲了什么，用到了什么工具。</p><p>​    例如现在需要你在图纸上画出一个很标准的心形，或者一个零件。这时候你知道，自己在工程学导论中使用CAD可以用来解决这个问题，这个过程中，你不知道软件的工具在哪里，怎么使用，或者使用什么方案，这些都不要紧，你只需要知道有这些工具，并且这些工具可以解决什么问题就可以了。</p><p>​    当然，这也并不代表你就可以只是听故事一样听完整门课程就可以了，上课的例题，或者作业题也需要你去实践一下。</p><p>​    在编程导论中你知道用编程可以解决很多实际问题，它可以帮你计算，管理系统，等等。那你知道这些功能以后去自己写一个学生成绩管理系统是不是也是一个比较有趣的事情</p><p>&nbsp;</p><h3 id="实践类：编程导论"><a href="#实践类：编程导论" class="headerlink" title="实践类：编程导论"></a><em>实践类</em>：编程导论</h3><p>​    大多的实践类课程就是在你有一定的学习基础后，可以用这些基础的知识结合硬件去做一些项目。我们学习的编程导论虽然是一门导论课，但是编程在我们之后的学习生活中是不可或缺的一部分，这门课重要到即使它是一门导论课，也值得我们去把他当作一门实践类课程去学习。</p><p>​    你可以在学习了解完基础知识以后，写一个简单的猜数字游戏，学生成绩管理系统等等。</p><p>​    &nbsp;</p><p>​    或许对于还没有开始上课的你来说看这些内容还有些懵，但是在之后的学习生活中你会对此有更加深刻的体会。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>​    大一的课程是整个大学的基础，十分重要，其中的微积分，线性代数，大学物理，编程导论等也是之后很多课程的基础。</p><p>​    比如：大二你们要学习的常微分的基础就是微积分与线性代数，如果这两门你在最开始就没有学好，那在之后的学习中是很头疼的一件事情，你仍然要返回去学习这些基础课程。所以，希望同学们在最开始的时候就好好学习这些课程。</p><h4 id="l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）"><a href="#l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）" class="headerlink" title="l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）"></a>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</h4><p>微积分一中，主要的大方面学习分几部分</p><ol><li><p>对极限的理解</p></li><li><p>导数的进阶应用</p></li><li><p>微积分中重要思想———积分</p></li><li><p>积分方法的学习</p></li></ol><h5 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h5><p>在第二章极限的学习中，相较于初等数学，了解到了极限与无穷的概念，在图形中分析计算垂直与水平渐近线可以加深对与极限的理解。</p><p>要学会对连续性进行判断，从而判断出任意点的类型（如可去间断点，跳跃间断点等）</p><p>其次，在极限式子的计算中，多数较难的式子均可以最终化简为两个重要极限的形式。</p><script type="math/tex; mode=display">\lim _{x \rightarrow 0} \frac{\sin x}{x}=1 \quad \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e</script><p>由此，对于两个总要的极限的应用就显得及其重要，当然在极限中，熟练运用洛必达法则也是必不可少的</p><p>&nbsp; </p><h5 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h5><p>在高数开始接触导数便移入了很多新的概念，在导数中，很重要的一点就是加深对链法则的理解，这个对以后学习各类积分微分知识都是帮助很大的。</p><p>如果对链法则的理解加深了，关于隐函数求导，符合函数求导，三角函数求导中的一系列问题都可以迎刃而解。</p><p>如果可以，多用导数的概念定义式进行积分的运算，会加深对于极限的理解。</p><p>在导数中有一系列相关的应用问题</p><ol><li><p>求最大最小值</p></li><li><p>求极大极小值</p></li><li><p>凹度与拐点</p></li></ol><p>这些问题无非都是通过1.函数的一阶导2.函数的二阶导3.临界点进行求值</p><p>三个方面进行分析，从而就可以对上诉三个问题进行求解</p><p>熟练理解中值定理，并可以对简单的式子进行推导</p><p> &nbsp;</p><h5 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h5><p>在积分的学习中我也认为是本书中最重要的一个概念，对积分的理解不应该只是会算出各种各样的积分形式，我们当然会学习很多各种各样的积分方法，不限于:<code>分部积分法</code>，<code>三角积分法</code>，<code>三角换元法</code>，<code>分布分式法</code>……..这些方法在大量的练习中我们可以熟练地去解出各种类型的式子，配合506页的公式表，当然效果肯定会更棒。</p><p>对<code>反函数</code>，<code>对数指数</code>模型，<code>反三角函数</code>，在推导过一遍可以对公式进行记背。</p><p>在微积分的应用中，我们不应该仅仅停留在解出图形的<code>面积</code>，<code>体积</code>。</p><p>深刻理解微积分，把整个要计算的图形，分为极限趋向0的无数个点，由点去积分成线，再将由无数的线与一定区间进行积分，可以得到面，对面再积分可以得到体积。这是从一维到三维，我们都是很容易理解的。</p><p>但到四维呢？如果我们对于每个点再赋予一个维度的含义，那么这个式子就可以表达整个图形的质量。</p><p>这样去深刻理解每个维度之间的积分关系，就显得非常奇妙。</p><p>对于中间一些题型呢，如下</p><ol><li><p>求面积</p></li><li><p>求体积</p></li><li><p>求弧长</p></li></ol><p>&nbsp;</p><p>但是总得来说，上述只是对基础知识点的一个概述，微积分在我们的生活中可谓是应用广泛，比如在音乐播放器使用微积分来调整音频信号的音量和频率，以确保音乐听起来和谐而流畅；在电梯系统使用微积分来计算电梯的速度和位置，以便顺利地将你从一楼带到其他楼层；在电子游戏中的物理引擎使用微积分来模拟物体的运动和碰撞，以使游戏更加真实。</p><p>对于微积分，在你学完相关内容后你可以去看这些内容，可以更加加深你对知识的理解。</p><p><a href="https://www.bilibili.com/video/BV1qW411N7FU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【官方双语/合集】微积分的本质 - 系列合集_哔哩哔哩_bilibili</a></p><p>宋浩老师的视频也很适合你去进行预习或者打基础</p><p><a href="https://www.bilibili.com/video/BV1UW411k7Jv/?spm_id_from=333.337.search-card.all.click">《微积分》《高等数学》全程教学视频—宋浩老师_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-线性代数导论（Introduction-to-Linear-Algebra）"><a href="#l-线性代数导论（Introduction-to-Linear-Algebra）" class="headerlink" title="l 线性代数导论（Introduction to Linear Algebra）"></a>l 线性代数导论（Introduction to Linear Algebra）</h4><p>​    线性代数是一门数学分支，它主要研究向量、向量空间和线性变换等概念。它在电子信息科学与技术领域中具有关键作用，因为它提供了处理多维数据和解决复杂问题的数学工具。</p><p>​    注意，这门线性代数是一个数学工具，就好比你学习了方程以后就可以用使用方程来解决一些数学问题，而同样的，当你学习过线性代数以后，你也可以通过线性代数来解决一些数学或者工程上的问题。</p><ol><li><strong>向量和向量空间：</strong> 线性代数的核心概念之一是向量。向量可以用来表示多维数据，如在图像处理、信号处理和数据分析中常见的数据结构。线性代数还研究了向量空间，这是一组满足特定性质的向量的集合。向量空间理论为我们提供了处理和分析数据的框架。</li><li><strong>线性变换：</strong> 另一个重要的概念是线性变换，它描述了如何将一个向量空间映射到另一个向量空间。线性变换在图像处理、信号处理和控制系统等领域中广泛应用。例如，在通信系统中，线性变换可以用来描述信号的传输和变换。</li><li><strong>矩阵：</strong> 矩阵是线性代数中的另一个核心概念，它用于表示线性变换和解决线性方程组。在电子信息科学与技术中，矩阵常常用于描述电路、信号处理滤波器和数据转换等。</li></ol><p>​    我也在知乎上发现了一篇十分详细的知识点，链接在下方。</p><p><a href="https://zhuanlan.zhihu.com/p/453305373">【数学】线性代数知识点总结（精炼版） - 知乎 (zhihu.com)</a></p><p>​    宋浩老师的视频也是相当经典。</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.337.search-card.all.click">《线性代数》高清教学视频 “惊叹号”系列 宋浩老师_哔哩哔哩_bilibili</a></p><p>​    如果在学习完基础内容，会解一些基本题型后，你可以去看3Blue1Brown的视频，相信你在看完之后会对线性代数有更加深刻的认识。</p><p><a href="https://www.bilibili.com/video/BV1ib411t7YR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">-UP主汉语配音-【线性代数的本质】合集-转载于3Blue1Brown官方双语】_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-大学物理Ⅰ（University-Physics-Ⅰ）"><a href="#l-大学物理Ⅰ（University-Physics-Ⅰ）" class="headerlink" title="l 大学物理Ⅰ（University Physics Ⅰ）"></a>l 大学物理Ⅰ（University Physics Ⅰ）</h4><p>​    大学物理Ⅰ的大部分内容其实我们已经在高中学习过了，但要注意的是，大学的物理相较与初中的物理更贴合实际，更具有普遍性。解决这部分实际问题就需要结合微积分知识和大学物理把很多过程微分成很多很小的过程，然后在把这很多很小的过程累积在一起。</p><p>​    例如下面这个图片</p><p>​    在小球从O到A的过程中，弹簧的力一直在发生变化，如果我们需要求在原点O到A点弹簧的弹性势能，用中学的知识，我们可以用图像法分析出</p><script type="math/tex; mode=display">E = \frac{1}{2} k x ^2</script><p>​    在大学学习了微积分以后我们就可以将每一个微小过程中的做的功微分后积分在一起，结果是一样的</p><script type="math/tex; mode=display">E = \int_{0}^{x} kx dx</script><p>​    </p><p>​    但是假设k的值不是恒定的，用高中的知识就无法解决了，但是我们可以用二重积分来解决这个问题，这也就是为什么大学里解决的问题更具有普遍性的例子。也希望大家在学习物理的过程不要只局限与写题，而是多去思考这个过程。</p><p>​    学习大学物理你可以去看东北大学马文蔚老师的物理课。</p><p><a href="https://www.bilibili.com/video/BV1qW411H7UX/?spm_id_from=333.337.search-card.all.click">【大学物理】东北大学-马文蔚_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）"><a href="#l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）" class="headerlink" title="l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）"></a>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</h4><p>​    工程学导论的主要目标是引导你们进入电子信息科学与技术领域。它将帮助你们了解电子技术、通信系统、计算机科学和信息处理等方面的基本概念。</p><p>​    我们将介绍CAD（计算机辅助设计）工具、MATLAB和C++编程，这些工具在电子信息科学与技术领域中非常重要。</p><p>​    大家在课上认真听讲，积极完成老师布置的课下作业，如果你还有精力，那你可以去B站，谷歌，GitHub去了解更多的内容，这门课不是重点也不是难点，你们只需要知道了解我们上课学习的内容即可。</p><p>&nbsp;</p><h4 id="l-编程导论（Introduction-to-Programming）"><a href="#l-编程导论（Introduction-to-Programming）" class="headerlink" title="l 编程导论（Introduction to Programming）"></a>l 编程导论（Introduction to Programming）</h4><p>​    最开始我对编程的感觉就是黑客在都是黑色的屏幕上敲命令行，感觉就像是拥有魔法一样，敲几行代码就可以实现一些不可思议的功能。后来我开始接触编程，还很清楚得记得我在学习完if和for语句做出一个猜数字的游戏后激动的心情。</p><p>​    包括我之前做的那款心形流水灯也是用c语言进行编程的，学会了编程语言就好比你有了一把利器，解决之前不敢想象的问题。</p><p>​    如果你是刚刚入门，我希望你去看翁恺老师的c语言程序设计，这可谓是大家编程梦开始的地方。</p><p><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click">浙江大学翁恺教你C语言程序设计！C语言基础入门！_哔哩哔哩_bilibili</a></p><p>​    如果你已经开始了c++语言的学习，那我推荐你去看黑马程序员的视频，这个视频用很简单的语言就可以解释清楚复杂的知识点，也希望你尽可能得把所有视频上的程序都自己敲写一遍。</p><p><a href="https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></p><p>​    工欲善其事必先利其器，当然学习编程你就需要一款好的编译器，我推荐编程小白使用Visual Studio，这一款编译软件不要配置复杂的编译环境，可谓是上手即用，而且关于其的学习资料还比较多。下载方式如下。</p><p><a href="https://www.bilibili.com/video/BV1Xt411g7jT/?spm_id_from=333.337.search-card.all.click">vs2022(Visual Studio 2022)权威指南&amp;&amp;C语言&amp;&amp;软件工程开发的方向&amp;&amp;技巧要领_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>​    很明显，如果我们只学习课堂上教授的这部分内容，我们并没有办法去完成自己的diy项目或者小制作。我在最开始也有着这个疑问，不知道怎么样去动手实践，但是在之后摸索了很多方法之后，我认为初学者去学习arduino入门是很可行的一个道路。</p><p>​    Arduino是一款便捷灵活、方便上手的开源电子原型平台。很多重来没有接触过电子知识的创客也可用通过arduino来制作自己的小发明，更不用说我们这些科班出身的大学生。</p><p>​    你完全可用自己去淘宝买一套arduino的学习套件，跟着<code>太极创客</code>中的视频模仿，一步一步体会自己动手去做出来一个实物的快乐。</p><p><a href="https://www.bilibili.com/video/BV164411J7GE/?spm_id_from=333.337.search-card.all.click">【太极创客】零基础入门学用Arduino 第一部分 合辑_哔哩哔哩_bilibili</a></p><p>​    希望你一定不要把这作为自己的学习任务，自己去制作小发明就好比自己在拼乐高，去给玩偶涂色等等。是激动人心的一件事。我曾寒假在家就碰到了一个问题，屋子的灯只有一个开关，而我每次睡觉前关灯都需要爬下床去关灯然后抹黑爬回床上。于是我就花了一个下午的时间用蓝牙加舵机使用arduino的开发板制作了一个简易的智能开关。</p><p><a href="https://www.bilibili.com/video/BV1JF411r78p/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">arduino➕舵机➕蓝牙智能灯_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="竞赛部分"><a href="#竞赛部分" class="headerlink" title="竞赛部分"></a>竞赛部分</h2><p>​    我非常建议大一的新生去参加蓝桥杯的单片机赛道，虽然正常情况下大家在大三才会学到单片机的使用，可能在学习中你们并不知道138译码器，与非门等等这些概念，甚至设计功能都不知道这其中的原理是什么，但是这并不妨碍我们先去学习，去接触。</p><p>​    推荐你先去看江科大的单片机以后再去针对比赛看小蜜蜂的比赛视频，蓝桥杯在每年年末报名，次年的四五月份进行比赛。无论如何，只要付出了，这对你绝对是一段很宝贵的学习经历，而且这个比赛的获奖率也是很高的，每年的大一小白参加最后也是有很多获得了省奖。</p><p><a href="https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click">51单片机入门教程-2020版 程序全程纯手打 从零开始入门_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Bt41187hw/?spm_id_from=333.337.search-card.all.click">【小蜜蜂笔记】蓝桥杯大赛-单片机设计与开发基础技能与进阶强化教程_哔哩哔哩_bilibili</a></p><p>​    </p><p>&nbsp;</p><h2 id="寻找资源"><a href="#寻找资源" class="headerlink" title="寻找资源"></a>寻找资源</h2><p>​    大学的学习不同于高中，在高中针对固定的学科学校会统一给同学们发很多教辅，卷子，资料。</p><p>​    但是大学中并不会这样，甚至有些学科你甚至没有课本，电子版课本老师没有发给你的话，你可能上课连课本都没有了。这就需要你有一定的资源检索能力，对于想要学习的内容可以找到对应的学习资料或者网站。</p><p>​    下面会向大家介绍一些资源和网站。</p><h3 id="Chatgpt"><a href="#Chatgpt" class="headerlink" title="Chatgpt"></a>Chatgpt</h3><p>​    我把这个重量级的大模型放在第一位，是因为chatgpt是2022年底发布的，是人类最新技术的应用，强大到令人惊叹。</p><p>​    我曾经在2021年入学的时候遇到过很多问题，我想参加竞赛，想要在有限的时间内学好十几门课程，当了解到单片机，微处理器想去学习，但是会发现很难很难找到老师，去给你解答各种各样的问题，为你答疑解惑制定具体的学习方案。</p><p>​    直到Chatgpt的出现，我发现这个大模型就好像是一个无所不知的老师，你可以去问他任何你已有的疑问，甚至不限于学习，生活，情感，等等等。关于Chatgpt具体是什么，你可以看下面这个视频。</p><p><img src="/posts/69d7a7f9.htm/image-20230916201601406.png" alt="image-20230916201601406" style="zoom:100%;"></p><p><a href="https://www.bilibili.com/video/BV11m4y1B7ur/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">ChatGPT是什么？两分钟带你了解! （中英熟肉字幕）_哔哩哔哩_bilibili</a></p><p>​    当然你也需要找到正确使用它的方式，以至他可以更好理解你的问题并且为你回答，你可以看下面这个网站总结了如何对Chatgpt进行有效提问。</p><p><a href="https://flowus.cn/flowus101/share/f0601ddc-72e5-4b4e-ab17-0af2cce98732">GitHub - PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南 (flowus.cn)</a></p><p>Chatgpt的网址放在下方，你可以去某宝购买一个账号，开vpn登录即可使用（vpn的地址最好是非亚州区，挂在美国更好）</p><p><a href="https://chat.openai.com/auth/login">ChatGPT (openai.com)</a></p><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h3><p>​    bilibili大家号称B站大学，B站上可谓是有着无数的学习资源，通常找一个课程，一个编程项目，去B站搜索这些资源链接都会出现在评论区的第一条或者视频的介绍中，点击链接下载即可。</p><p>​    B站也有着更种各样的优秀课程，宋浩老师的高数系列，3blue1brown等等，上课没听懂不用去担心，B站大学为你兜底。</p><p>​    你同样也可以在B站学习如何去寻找资源。</p><p><a href="https://www.bilibili.com/video/BV17P4y187Kw/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道能帮你找到所有想要资源！！！第2期_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Db4y1a7sa/?vd_source=db4533a45f532ba6c1133faafbf7f171">收藏血赚！3分钟大学逆袭，各专业最有用资源大合集！_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1TN411d7FL/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道，能帮你找到所有想要资源！第1期_哔哩哔哩_bilibili</a></p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>​    如果你想参加一个比赛，一个项目，去知乎搜索相关内容，它会给到你更加客观的答案（现在可能会对各种事情的看法会更加现实和消极）</p><p>​    如果你是想听听大家对一个事件，一个学科或者是各种各样问题的看法或者意见，那欢迎你来到知乎。</p><p>&nbsp;</p><h3 id="CDSN"><a href="#CDSN" class="headerlink" title="CDSN"></a>CDSN</h3><p>​    <em>CSDN</em>是全球知名中文IT技术交流平台，如果你是在学习编程语言，机器学习，各种各样的技术知识，这绝对是你绕不开的一个平台，去互联网上去寻找响应的代码，你很有可能就是在csdn上找到答案。</p><p>​    比如你正在学习数据结构的链表，但是你上课有没有太听懂，你就可以去csdn搜索链表，会出现各种各样关于链表的总结，其中可能就会点进我的主页（悄悄安利自己一波）</p><p><a href="https://blog.csdn.net/u011146203/article/details/127587997?spm=1001.2014.3001.5501">（数据结构）链表_指针怎么取数据域_江江江江江江江江江的博客-CSDN博客</a></p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>​    在开始学习编程的时候，经常会遇到编译错误的问题，但是这也可能是之前别人学习时也碰到的问题，把错误复制下来输入到搜索引擎，一般情况下你也会在其中找到你想要的答案。</p><p><a href="https://www.baidu.com/">百度一下，你就知道 (baidu.com)</a></p><p>&nbsp;</p><h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>​    去旅游想知道那里有什么好吃的，生了xx要怎么处理，想要去学习做个什么饭等等这些生活中的问题小红书会给你答案，（我也经常会去小红书上大家安利的美食店）。但毕竟是社交平台，还有微博，知乎这些，关于大家对事情都有自己的看法，保持正确三观，遵从内心的想法，不要别人说风就是雨。有时候看太多一些社会，工作还是情感上的内容会平添很多焦虑。希望大家可以自由愉快地享受大学生活。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>因为我目前也只是一名刚进入大三的本科生，很多想法见解可能在之后的学习过程中也会有不同的体验，如果你有更好的建议或者发现了一些错误请及时私信我，本文档将持续进行更新……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电子信息科学与技术攻略&quot;&gt;&lt;a href=&quot;#电子信息科学与技术攻略&quot; class=&quot;headerlink&quot; title=&quot;电子信息科学与技术攻略&quot;&gt;&lt;/a&gt;电子信息科学与技术攻略&lt;/h1&gt;&lt;p&gt;亲爱的学弟学妹们：&lt;/p&gt;
&lt;p&gt;  首先，我要热烈欢迎你们加入电子</summary>
      
    
    
    
    
    <category term="学习攻略" scheme="https://rozen12123.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>cpu制作</title>
    <link href="https://rozen12123.github.io/posts/68d8d011.html"/>
    <id>https://rozen12123.github.io/posts/68d8d011.html</id>
    <published>2023-08-22T10:15:33.000Z</published>
    <updated>2023-10-11T08:54:28.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu的制作"><a href="#cpu的制作" class="headerlink" title="cpu的制作"></a>cpu的制作</h1><p>cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可完成搭建。</p><p>而且自己制作cpu是一件非常有趣的一件事情，去理解身边的电脑，手机等等的一些运作的底层原理。</p><p>那么现在，我们就从最开始最简单的电路开始搭建吧。</p><h2 id="电路搭建"><a href="#电路搭建" class="headerlink" title="电路搭建"></a>电路搭建</h2><h3 id="与或非门，同或异或门"><a href="#与或非门，同或异或门" class="headerlink" title="与或非门，同或异或门"></a>与或非门，同或异或门</h3><p><img src="/posts/68d8d011.htm/image-20231010180429855.png" alt="image-20231010180429855" style="zoom:67%;"></p><p>与或非是计算机逻辑门的最基础的部件，其他任意的部件都可以通过与或非三种门来表示。</p><h3 id="八位加法器"><a href="#八位加法器" class="headerlink" title="八位加法器"></a>八位加法器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> eight_bit_full_adder  (</span><br><span class="line">  <span class="keyword">input</span> A,</span><br><span class="line">  <span class="keyword">input</span> B,</span><br><span class="line">  <span class="keyword">output</span> S,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> S = (A ^ B);</span><br><span class="line">  <span class="keyword">assign</span> C = (A &amp; B);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> DIG_Add</span><br><span class="line">#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">input</span> c_i,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">    <span class="keyword">output</span> c_o</span><br><span class="line">);</span><br><span class="line">   <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">   <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> \?????  (</span><br><span class="line">  <span class="keyword">input</span> A1,</span><br><span class="line">  <span class="keyword">input</span> B1,</span><br><span class="line">  <span class="keyword">input</span> A2,</span><br><span class="line">  <span class="keyword">input</span> B2,</span><br><span class="line">  <span class="keyword">input</span> A3,</span><br><span class="line">  <span class="keyword">input</span> B3,</span><br><span class="line">  <span class="keyword">input</span> A4,</span><br><span class="line">  <span class="keyword">input</span> B4,</span><br><span class="line">  <span class="keyword">input</span> A5,</span><br><span class="line">  <span class="keyword">input</span> B5,</span><br><span class="line">  <span class="keyword">input</span> A6,</span><br><span class="line">  <span class="keyword">input</span> B6,</span><br><span class="line">  <span class="keyword">input</span> A7,</span><br><span class="line">  <span class="keyword">input</span> B7,</span><br><span class="line">  <span class="keyword">input</span> A0,</span><br><span class="line">  <span class="keyword">input</span> B0,</span><br><span class="line">  <span class="keyword">output</span> S0,</span><br><span class="line">  <span class="keyword">output</span> S1,</span><br><span class="line">  <span class="keyword">output</span> S2,</span><br><span class="line">  <span class="keyword">output</span> S3,</span><br><span class="line">  <span class="keyword">output</span> S4,</span><br><span class="line">  <span class="keyword">output</span> S5,</span><br><span class="line">  <span class="keyword">output</span> S6,</span><br><span class="line">  <span class="keyword">output</span> S7,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> s8;</span><br><span class="line">  <span class="keyword">wire</span> s9;</span><br><span class="line">  <span class="keyword">wire</span> s10;</span><br><span class="line">  <span class="keyword">wire</span> s11;</span><br><span class="line">  <span class="keyword">wire</span> s12;</span><br><span class="line">  <span class="keyword">wire</span> s13;</span><br><span class="line">  <span class="keyword">wire</span> s14;</span><br><span class="line">  \???  \???_i0 (</span><br><span class="line">    <span class="variable">.A</span>( A0 ),</span><br><span class="line">    <span class="variable">.B</span>( B0 ),</span><br><span class="line">    <span class="variable">.S</span>( S0 ),</span><br><span class="line">    <span class="variable">.C</span>( s8 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i1 (</span><br><span class="line">    <span class="variable">.a</span>( s8 ),</span><br><span class="line">    <span class="variable">.b</span>( A1 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B1 ),</span><br><span class="line">    <span class="variable">.s</span>( S1 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s9 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i2 (</span><br><span class="line">    <span class="variable">.a</span>( A2 ),</span><br><span class="line">    <span class="variable">.b</span>( s9 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B2 ),</span><br><span class="line">    <span class="variable">.s</span>( S2 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s10 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i3 (</span><br><span class="line">    <span class="variable">.a</span>( s10 ),</span><br><span class="line">    <span class="variable">.b</span>( A3 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B3 ),</span><br><span class="line">    <span class="variable">.s</span>( S3 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s11 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i4 (</span><br><span class="line">    <span class="variable">.a</span>( s11 ),</span><br><span class="line">    <span class="variable">.b</span>( A4 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B4 ),</span><br><span class="line">    <span class="variable">.s</span>( S4 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s12 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i5 (</span><br><span class="line">    <span class="variable">.a</span>( s12 ),</span><br><span class="line">    <span class="variable">.b</span>( A5 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B5 ),</span><br><span class="line">    <span class="variable">.s</span>( S5 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s13 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i6 (</span><br><span class="line">    <span class="variable">.a</span>( s13 ),</span><br><span class="line">    <span class="variable">.b</span>( A6 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B6 ),</span><br><span class="line">    <span class="variable">.s</span>( S6 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s14 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i7 (</span><br><span class="line">    <span class="variable">.a</span>( s14 ),</span><br><span class="line">    <span class="variable">.b</span>( A7 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B7 ),</span><br><span class="line">    <span class="variable">.s</span>( S7 ),</span><br><span class="line">    <span class="variable">.c_o</span>( C )</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h3><p>与门可以存储下来0，或门可以存储下来1，我们把与门和或门进行一个组合，就能做出来第一个有用的电路结构。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> latch  (</span><br><span class="line">  <span class="keyword">input</span> Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">output</span> Out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> Out_temp;</span><br><span class="line">  <span class="keyword">assign</span> Out_temp = ((Out_temp | (Din &amp; WE)) &amp; ~ (~ Din &amp; WE));</span><br><span class="line">  <span class="keyword">assign</span> Out = Out_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器=8位锁存器/16/32位</p><p>一次可以存储8位数据。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><p><img src="/posts/68d8d011.htm/image-20231011105654618.png" alt="image-20231011105654618" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="带边缘触发的锁存器"><a href="#带边缘触发的锁存器" class="headerlink" title="带边缘触发的锁存器"></a>带边缘触发的锁存器</h3><h4 id="为什么需要时钟"><a href="#为什么需要时钟" class="headerlink" title="为什么需要时钟"></a>为什么需要时钟</h4><p>大家都见过划船的，划船需要一个喊口号的主要原因是为了保证协调。通过喊口号，船员们可以同步动作，确保船在平稳且有效率地前进。<br>CPU需要clock来同步内部操作，如执行指令、进行数据传输等。Clock提供了精确的时间控制，确保每个内部操作在正确的顺序与速度内执行，从而确保CPU的正常工作。另外，Clock还与CPU的频率相关，通过控制Clock频率，可以控制CPU的速度。</p><h4 id="时钟信号是什么"><a href="#时钟信号是什么" class="headerlink" title="时钟信号是什么"></a>时钟信号是什么</h4><p>时钟信号就是周期性的高低电平变化的信号<br>我们可以用两个普通的寄存器加上一个非门，组成一个带有边缘触发的寄存器。<br>在按钮按下的一瞬间，电压从低电平到高电平的一瞬间，Din的数据被存储起来。</p><p>&nbsp;</p><h3 id="寄存器REG"><a href="#寄存器REG" class="headerlink" title="寄存器REG"></a>寄存器REG</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th><th></th></tr></thead><tbody><tr><td>D</td><td>数据输入</td><td></td></tr><tr><td>C</td><td>时钟信号</td><td></td></tr><tr><td>en</td><td>使能端口，高电平工作</td></tr></tbody></table></div><p>存储器-寄存器</p><blockquote><p>可以做的扩展，增加输入使能WE和输出使能OE<br>寄存器访问速度快，因为寄存器的每一条数据线都是直接接出来的。</p></blockquote><p>&nbsp;</p><h3 id="十六位的内存"><a href="#十六位的内存" class="headerlink" title="十六位的内存"></a>十六位的内存</h3><p>内存地址：从并行到串行<br>内存单元格要自己自己在哪一行和哪一列，需要有row和column<br>内存单元要有ld（load）读的控制<br>内存单元要有str（store）有存的控制<br>内存单元要有数据的输入</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>row&amp;column</td><td>确定需要储存的地址</td></tr><tr><td>ld（load）</td><td>读的控制</td></tr><tr><td>str（store）</td><td>存的控制</td></tr></tbody></table></div><p>内存地址：从并行到串行<br>内存地址的作用主要是为了节省数据线，简化电路数量有了内存地址的概念后，输入和输出只需要1条数据线了先选中需要读写的内存单元，再输入输出</p><p>&nbsp;</p><h3 id="8位的寄存器"><a href="#8位的寄存器" class="headerlink" title="8位的寄存器"></a>8位的寄存器</h3><p>设计8位（bit）的寄存器，用于CPU存储的临时计算的数据</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DIG_Register_BUS #(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> C,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]D,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]Q</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] state = <span class="number">&#x27;h0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Q = state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> C) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (en)</span><br><span class="line">        state &lt;= D;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="number">8_</span>REG  (</span><br><span class="line">  <span class="keyword">input</span> Clock,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data_temp;</span><br><span class="line">  DIG_Register_BUS #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Register_BUS_i0 (</span><br><span class="line">    <span class="variable">.D</span>( Din ),</span><br><span class="line">    <span class="variable">.C</span>( Clock ),</span><br><span class="line">    <span class="variable">.en</span>( WE ),</span><br><span class="line">    <span class="variable">.Q</span>( Stored_Data_temp )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( Stored_Data_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> Stored_Data = Stored_Data_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>基于上面的原理图，我们分别设计4位和8位的寄存器4位的寄存器用于程序计数器（PC）和MAR（内存地址寄存器）<br>8位的寄存器用于指令寄存器（IR），CPU通用临时寄存器（RegA）（RegB），内存缓存寄存器（MBR）等。分别测试4位和8位的寄存器。</p><p><img src="/posts/68d8d011.htm/image-20231011154050156.png" alt="image-20231011154050156" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="逻辑和算数运算单元（ALU）"><a href="#逻辑和算数运算单元（ALU）" class="headerlink" title="逻辑和算数运算单元（ALU）"></a>逻辑和算数运算单元（ALU）</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>RegA</td><td>8位的寄存器数据</td></tr><tr><td>RegB</td><td>8位的寄存器数据</td></tr><tr><td>OE</td><td>输出允许</td></tr><tr><td>ALUResult</td><td>ALU内部计算结果，方便观察调试</td></tr><tr><td>Carry</td><td>溢出位引出1位信号线</td></tr><tr><td>Dout</td><td>输出数据8位，默认高阻态</td></tr></tbody></table></div><p><img src="/posts/68d8d011.htm/image-20231011155356141.png" alt="image-20231011155356141" style="zoom:80%;"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">module</span> DIG_Add</span><br><span class="line">  #(</span><br><span class="line">  <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">  )</span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">  <span class="keyword">input</span> c_i,</span><br><span class="line">  <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">  <span class="keyword">output</span> c_o</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">  <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line">  <span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegA,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegB,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result,</span><br><span class="line">  <span class="keyword">output</span> Carry</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result_temp;</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i0 (</span><br><span class="line">    <span class="variable">.a</span>( RegA ),</span><br><span class="line">    <span class="variable">.b</span>( RegB ),</span><br><span class="line">    <span class="variable">.c_i</span>( <span class="number">1&#x27;b0</span> ),</span><br><span class="line">    <span class="variable">.s</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.c_o</span>( Carry )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> ALU_Result = ALU_Result_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="CPU框架搭建"><a href="#CPU框架搭建" class="headerlink" title="CPU框架搭建"></a>CPU框架搭建</h3><p><img src="/posts/68d8d011.htm/image-20231011161355384.png" alt="image-20231011161355384" style="zoom:80%;"></p><p><img src="/posts/68d8d011.htm/image-20231011165424214.png" alt="image-20231011165424214" style="zoom:80%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpu的制作&quot;&gt;&lt;a href=&quot;#cpu的制作&quot; class=&quot;headerlink&quot; title=&quot;cpu的制作&quot;&gt;&lt;/a&gt;cpu的制作&lt;/h1&gt;&lt;p&gt;cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单cpu的内部结构</title>
    <link href="https://rozen12123.github.io/posts/dee20e4.html"/>
    <id>https://rozen12123.github.io/posts/dee20e4.html</id>
    <published>2023-08-09T16:14:36.000Z</published>
    <updated>2023-10-10T08:16:20.615Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>verilog基础语法</title>
    <link href="https://rozen12123.github.io/posts/20b3f144.html"/>
    <id>https://rozen12123.github.io/posts/20b3f144.html</id>
    <published>2023-08-07T10:56:38.000Z</published>
    <updated>2023-08-09T15:51:29.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="verilog基础语法"><a href="#verilog基础语法" class="headerlink" title="verilog基础语法"></a>verilog基础语法</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Verilog 是区分大小写的。</p><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><p>标识符（identifier）可以是任意一组字母、数字、<strong>$</strong> 符号和 <strong>_</strong>(下划线)符号的合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元符开始。</p><p>关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。</p><p>Verilog 中关键字全部为小写。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter ; <span class="comment">//reg 为关键字， counter 为标识符</span></span><br><span class="line"><span class="keyword">input</span> clk; <span class="comment">//input 为关键字，clk 为标识符</span></span><br><span class="line"><span class="keyword">input</span> CLK; <span class="comment">//CLK 与 clk是 2 个不同的标识符</span></span><br></pre></td></tr></table></figure><p>Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：</p><ul><li>0：逻辑 0 或 “假”</li><li>1：逻辑 1 或 “真”</li><li>x 或 X：未知</li><li>z 或 Z：高阻</li></ul><p><strong>x</strong> 意味着信号数值的不确定，即在实际电路里，信号可能为 1，也可能为 0。</p><p><strong>z</strong> 意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 pad 的 input 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0 。</p><h3 id="整数数值表示方法"><a href="#整数数值表示方法" class="headerlink" title="整数数值表示方法"></a>整数数值表示方法</h3><p>数字声明时，合法的基数格式有 4 种，包括：十进制(‘d 或 ‘D)，十六进制(‘h 或 ‘H)，二进制（’b 或 ‘B），八进制（’o 或 ‘O）。数值可指明位宽，也可不指明位宽。</p><p><strong>指明位宽：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1011</span>         <span class="comment">// 4bit 数值</span></span><br><span class="line"><span class="number">32&#x27;h3022_c0de</span>   <span class="comment">// 32bit 的数值</span></span><br></pre></td></tr></table></figure><p><strong>不指明位宽:</strong></p><p>一般直接写数字时，默认为十进制表示，例如下面的 3 种写法是等效的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">&#x27;d100</span> ; <span class="comment">//一般会根据编译器自动分频位宽，常见的为32bit</span></span><br><span class="line">counter = <span class="number">100</span> ;</span><br><span class="line">counter = <span class="number">32&#x27;h64</span> ;</span><br></pre></td></tr></table></figure><p><code>位宽就是**内存或显存一次能传输的数据量**。 简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。</code></p><p><strong>负数表示</strong></p><p>通常在表示位宽的数字前面加一个减号来表示负数。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d15</span>  </span><br><span class="line">-<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="实数表示方法"><a href="#实数表示方法" class="headerlink" title="实数表示方法"></a>实数表示方法</h3><p>实数表示方法主要有两种方式：</p><p><strong>科学计数法：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="variable">.2e4</span>         <span class="comment">//大小为12000</span></span><br><span class="line"><span class="number">1_0001</span>e4      <span class="comment">//大小为100010000</span></span><br><span class="line"><span class="number">1</span>E-<span class="number">3</span>          <span class="comment">//大小为0.001</span></span><br></pre></td></tr></table></figure><h3 id="字符串表示方法"><a href="#字符串表示方法" class="headerlink" title="字符串表示方法"></a>字符串表示方法</h3><p>字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含<code>回车符</code>。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。例如，为存储字符串 “www.runoob.com”, 需要 14*8bit 的存储单元。例如：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;<span class="comment">//先定义字符串的大小14*8bit </span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="Verilog的数据类型"><a href="#Verilog的数据类型" class="headerlink" title="Verilog的数据类型"></a>Verilog的数据类型</h2><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p><h3 id="线网（wire）"><a href="#线网（wire）" class="headerlink" title="线网（wire）"></a>线网（wire）</h3><p>wire 类型表示硬件单元之间的<code>物理连线</code>，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>   interrupt ;</span><br><span class="line"><span class="keyword">wire</span>   flag1, flag2 ;</span><br><span class="line"><span class="keyword">wire</span>   gnd = <span class="number">1&#x27;b0</span> ;</span><br></pre></td></tr></table></figure><p>线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。</p><h3 id="寄存器（reg）"><a href="#寄存器（reg）" class="headerlink" title="寄存器（reg）"></a>寄存器（reg）</h3><p>寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>    clk_temp;</span><br><span class="line"><span class="keyword">reg</span>    flag1, flag2 ;</span><br></pre></td></tr></table></figure><p>例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rstn ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rstn = <span class="number">1&#x27;b0</span> ;</span><br><span class="line">    #<span class="number">100</span> ;</span><br><span class="line">    rstn = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>当位宽大于 1 时，wire 或 reg 即可声明为向量的形式。例如：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]      counter ;    <span class="comment">//声明4bit位宽的寄存器counter</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>-<span class="number">1</span>:<span class="number">0</span>]  gpio_data;   <span class="comment">//声明32bit位宽的线型变量gpio_data</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">2</span>]     addr ;       <span class="comment">//声明7bit位宽的线型变量addr，位宽范围为8:2</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">31</span>]     data ;       <span class="comment">//声明32bit位宽的寄存器变量data, 最高有效位为0</span></span><br></pre></td></tr></table></figure><p>对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如：</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>]     data_low = data[<span class="number">0</span>:<span class="number">9</span>] ;</span><br><span class="line">addr_temp[<span class="number">3</span>:<span class="number">2</span>] = addr[<span class="number">8</span>:<span class="number">7</span>] + <span class="number">1&#x27;b1</span> ;</span><br></pre></td></tr></table></figure><p>Verilog 支持可变的向量域选择，例如：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]     data1 ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]      byte1 [<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">integer</span> j ;</span><br><span class="line"><span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=<span class="number">3</span>;j=j+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        byte1[j] = data1[(j+<span class="number">1</span>)*<span class="number">8</span>-<span class="number">1</span> : j*<span class="number">8</span>]; </span><br><span class="line">        <span class="comment">//把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。</strong></p><ul><li><strong>[bit+: width]</strong> : 从起始 bit 位开始递增，位宽为 width。</li><li><strong>[bit-: width]</strong> : 从起始 bit 位开始递减，位宽为 width。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">A = data1[<span class="number">31</span>-: <span class="number">8</span>] ;</span><br><span class="line">A = data1[<span class="number">31</span>:<span class="number">24</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">B = data1[<span class="number">0</span>+ : <span class="number">8</span>] ;</span><br><span class="line">B = data1[<span class="number">0</span>:<span class="number">7</span>] ;</span><br></pre></td></tr></table></figure><p><strong>对信号重新进行组合成新的向量时，需要借助大括号。例如：</strong></p><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]    temp1, temp2 ;</span><br><span class="line"><span class="keyword">assign</span> temp1 = &#123;byte1[<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>], data1[<span class="number">31</span>:<span class="number">8</span>]&#125;;  <span class="comment">//数据拼接</span></span><br><span class="line"><span class="keyword">assign</span> temp2 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//赋值32位的数值0</span></span><br></pre></td></tr></table></figure><h2 id="整数，实数，时间寄存器变量"><a href="#整数，实数，时间寄存器变量" class="headerlink" title="整数，实数，时间寄存器变量"></a>整数，实数，时间寄存器变量</h2><p>整数，实数，时间等数据类型实际也属于寄存器类型。</p><p><strong>整数（integer）</strong>(相当于int)</p><p>整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。例如：</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reg [31:0]      data1 ;</span><br><span class="line">reg [3:0]       byte1 [7:0]; //数组变量，后续介绍</span><br><span class="line">integer j ;  //整型变量，用来辅助生成数字电路</span><br><span class="line">always@* begin</span><br><span class="line">    for (j=0; j&lt;=3;j=j+1) begin</span><br><span class="line">        byte1[j] = data1[(j+1)*8-1 : j*8]; </span><br><span class="line">        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>此例中，integer 信号 j 作为辅助信号，将 data1 的数据依次赋值给数组 byte1。综合后实际电路里并没有 j 这个信号，j 只是辅助生成相应的硬件电路。</p><p><code>always@* begin</code>：</p><ul><li>这是一个组合逻辑块的定义，<code>always@*</code>表示该组合逻辑块会在任何输入变化时执行。</li></ul><p><strong>时序逻辑</strong>：</p><ul><li><code>always @ (posedge clk)</code> 表示在时钟上升沿触发的时序逻辑。</li><li>在时钟上升沿触发时，将执行<code>begin</code>和<code>end</code>之间的代码块。</li></ul><p><strong>实数（real）</strong></p><p>实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。例如：</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>        data1 ;</span><br><span class="line"><span class="keyword">integer</span>     temp ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    data1 = <span class="number">2</span>e3 ;</span><br><span class="line">    data1 = <span class="number">3</span><span class="variable">.75</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    temp = data1 ; <span class="comment">//temp 值的大小为3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>时间（time）</strong></p><p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time$ 获取当前仿真时间。例如：</p><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span>       current_time ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">       #<span class="number">100</span> ;</span><br><span class="line">       current_time = <span class="built_in">$time</span> ; <span class="comment">//current_time 的大小为 100</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。</p><p>数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：<strong>&lt;数组名&gt;[&lt;下标&gt;]</strong>。对于多维数组来讲，用户需要说明其每一维的索引。例如：</p><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>          flag [<span class="number">7</span>:<span class="number">0</span>] ; <span class="comment">//8个整数组成的数组</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       counter [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个4bit计数器组成的数组</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]       addr_bus [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个8bit wire型变量组成的数组</span></span><br><span class="line"><span class="keyword">wire</span>             data_bit[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>] ; <span class="comment">//声明1bit wire型变量的二维数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]       data_4d[<span class="number">11</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>] ; <span class="comment">//声明4维的32bit数据变量数组</span></span><br></pre></td></tr></table></figure><p>下面显示了对数组元素的赋值操作：</p><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag [<span class="number">1</span>]   = <span class="number">32&#x27;d0</span> ; <span class="comment">//将flag数组中第二个元素赋值为32bit的0值</span></span><br><span class="line">counter[<span class="number">3</span>] = <span class="number">4&#x27;hF</span> ;  <span class="comment">//将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4&#x27;hF，即可省略宽度; </span></span><br><span class="line"><span class="keyword">assign</span> addr_bus[<span class="number">0</span>]        = <span class="number">8&#x27;b0</span> ; <span class="comment">//将数组addr_bus中第一个元素的值赋值为0</span></span><br><span class="line"><span class="keyword">assign</span> data_bit[<span class="number">0</span>][<span class="number">1</span>]     = <span class="number">1&#x27;b1</span>;  <span class="comment">//将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1&#x27;b1; 是非法的。</span></span><br><span class="line">data_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] = <span class="number">15&#x27;d3</span> ;  <span class="comment">//将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3</span></span><br></pre></td></tr></table></figure><p>虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1。它们在结构的定义上就有所区别。</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。例如：</p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>               membit[<span class="number">0</span>:<span class="number">255</span>] ;  <span class="comment">//256bit的1bit存储器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]        mem[<span class="number">0</span>:<span class="number">1023</span>] ;    <span class="comment">//1Kbyte存储器，位宽8bit</span></span><br><span class="line">mem[<span class="number">511</span>] = <span class="number">8&#x27;b0</span> ;                  <span class="comment">//令第512个8bit的存储单元值为0</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>      data_width = <span class="number">10&#x27;d32</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      mem_size = data_width * <span class="number">10</span> ;</span><br></pre></td></tr></table></figure><p>但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。</p><p>局部参数用 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 localparam 来说明。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p><p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”, 需要 14*8bit 的存储单元：</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;run.runoob.com&quot;</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>有一些特殊字符在显示字符串中有特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前面加前缀转义字符 <strong>\</strong> 。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">显示字符</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">%</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">1到3个8进制数字字符</td></tr></tbody></table></div><p>其实，在 SystemVerilog（主要用于 Verilog 仿真的编程语言）语言中，已经可以直接用关键字 string 来表示字符串变量类型，这为 Verilog 的仿真带来了极大的便利。有兴趣的学者可以简单学习下 SystemVerilog。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a^b ;          <span class="comment">//a与b进行异或操作</span></span><br><span class="line">address[<span class="number">9</span>:<span class="number">0</span>] + <span class="number">10&#x27;b1</span> ;  <span class="comment">//地址累加</span></span><br><span class="line">flag1 &amp;&amp; flag2 ;  <span class="comment">//逻辑与操作</span></span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。</p><p>操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。</p><h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//实数</span></span><br><span class="line"><span class="keyword">real</span> a, b, c;</span><br><span class="line">c = a + b ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       cprmu_1, cprmu_2 ;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cprmu_2 = cprmu_1 ^ cprmu_2 ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">reg</span>  flag1 ;</span><br><span class="line">flag = calculate_result(A, B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//非法操作数</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]         res;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]        temp;</span><br><span class="line"><span class="keyword">always</span>@ （*）<span class="keyword">begin</span></span><br><span class="line">    res    = cprmu_2 – cprmu_1 ;</span><br><span class="line">    <span class="comment">//temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。</p><p>大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 2 种写法都是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自右向左关联，两种写法等价</span></span><br><span class="line">A+B-C ;</span><br><span class="line">(A+B）-C ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span><br><span class="line">A ? B : C ? D : F ;</span><br><span class="line">A ? B : (C ? D : F) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法不等价</span></span><br><span class="line">(A ? B : C) ? D : F ;  <span class="comment">//结果 D 或 F</span></span><br><span class="line">A ? B : C ? D : F ; <span class="comment">//结果为 B、D 或 F</span></span><br></pre></td></tr></table></figure><p>不同操作符之间，优先级是不同的。下表列出了操作符优先级从高至低的排列顺序。当没有圆括号时，Verilog 会根据操作符优先级对表达式进行计算。为了避免由操作符优先级导致的计算混乱，在不确定优先级时，建议用圆括号将表达式区分开来。</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">操作符号</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">单目运算</td><td style="text-align:left">+ - ! ~</td><td style="text-align:left">最高</td></tr><tr><td style="text-align:left">乘、除、取模</td><td style="text-align:left">* / %</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt;  &gt;&gt;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">等价</td><td style="text-align:left">== != === !===</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">归约</td><td style="text-align:left">&amp; ~&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">^ ~^</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">~\</td><td></td><td></td></tr><tr><td style="text-align:left">逻辑</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td></td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">最低</td></tr></tbody></table></div><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>算术操作符包括单目操作符和双目操作符。</p><p>双目操作符对 2 个操作数进行算术运算，包括乘（<em>）、除（/）、加（+）、减（-）、求幂（*</em>）、取模（%）。</p><h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  a, b;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]  c ;</span><br><span class="line">a = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">b = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">c = a+b;        <span class="comment">//结果为c=b&#x27;b1011</span></span><br><span class="line">c = a/b;          <span class="comment">//结果为c=4，取整</span></span><br></pre></td></tr></table></figure><p>如果操作数某一位为 X，则计算结果也会全部出现 X。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">4&#x27;b100x</span> ;</span><br><span class="line">c = a+b ;       <span class="comment">//结果为c=4&#x27;bxxxx</span></span><br></pre></td></tr></table></figure><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。否则，高位将被截断，导致结果高位丢失。无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]        mula ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]        mulb;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>]        res ;</span><br><span class="line">mula = <span class="number">4&#x27;he</span>   ;</span><br><span class="line">mulb = <span class="number">2&#x27;h3</span>   ;</span><br><span class="line">res  = mula * mulb ; <span class="comment">//结果为res=6&#x27;h2a, 数据结果没有丢失位数</span></span><br></pre></td></tr></table></figure><p>+ 和 - 也可以作为单目操作符来使用，表示操作数的正负性。此类操作符优先级最高。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">4</span>  <span class="comment">//表示负4</span></span><br><span class="line">+<span class="number">3</span>  <span class="comment">//表示正3</span></span><br></pre></td></tr></table></figure><p>负数表示时，可以直接在十进制数字前面增加一个减号 <strong>-</strong>，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mula = -<span class="number">4&#x27;d4</span> ;</span><br><span class="line">mulb = <span class="number">2</span> ;</span><br><span class="line">res = mula * mulb ;      <span class="comment">//计算结果为res=-6&#x27;d8, 即res=6&#x27;h38，正常</span></span><br><span class="line">res = mula * (-<span class="number">&#x27;d4</span>) ;    <span class="comment">//(4的32次幂-4) * 2, 结果异常</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符有大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=）。</p><p>关系操作符的正常结果有 2 种，真（1）或假（0）。</p><p>如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">3</span> ;</span><br><span class="line">X = <span class="number">3&#x27;b1xx</span> ;</span><br><span class="line">    </span><br><span class="line">A &gt; B     <span class="comment">//为真</span></span><br><span class="line">A &lt;= B    <span class="comment">//为假</span></span><br><span class="line">A &gt;= Z    <span class="comment">//为X，不确定</span></span><br></pre></td></tr></table></figure><h3 id="等价操作符"><a href="#等价操作符" class="headerlink" title="等价操作符"></a>等价操作符</h3><p>等价操作符包括逻辑相等（ == ） ，逻辑不等（!=），全等（ ===  ），非全等（  !  ）。</p><p>等价操作符的正常结果有 2 种：为真（1）或假（0）。</p><p>逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。</p><p>全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">8&#x27;h04</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bxxxx</span> ;</span><br><span class="line">D = <span class="number">4&#x27;hx</span> ;</span><br><span class="line">A == B        <span class="comment">//为真</span></span><br><span class="line">A == (B + <span class="number">1</span>)  <span class="comment">//为假</span></span><br><span class="line">A == C        <span class="comment">//为X，不确定</span></span><br><span class="line">A === C       <span class="comment">//为假，返回值为0</span></span><br><span class="line">C === D       <span class="comment">//为真，返回值为1</span></span><br></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）。</p><p>逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。</p><p>如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。</p><p>如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。</p><p>逻辑操作符的操作数可以为变量，也可以为表达式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">3</span>; </span><br><span class="line">B = <span class="number">0</span>; </span><br><span class="line">C = <span class="number">2&#x27;b1x</span> ;</span><br><span class="line">    </span><br><span class="line">A &amp;&amp; B    <span class="comment">//     为假</span></span><br><span class="line">A || B    <span class="comment">//     为真</span></span><br><span class="line">! A       <span class="comment">//     为假</span></span><br><span class="line">! B       <span class="comment">//     为真</span></span><br><span class="line">A &amp;&amp; C    <span class="comment">//     为X，不确定</span></span><br><span class="line">A || C    <span class="comment">//     为真，因为A为真</span></span><br><span class="line">(A==<span class="number">2</span>) &amp;&amp; (! B)  <span class="comment">//为真，此时第一个操作数为表达式</span></span><br></pre></td></tr></table></figure><h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><p>按位操作符包括：取反（~），与（&amp;），或（|），异或（^），同或（~^）。</p><p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作。</p><p>如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p><p>取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p><p>下图给出了按位操作符的逻辑规则。</p><div class="table-container"><table><thead><tr><th style="text-align:left">&amp;(与）</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">\</th><th style="text-align:left">(或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th>x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">^(异或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">~^(同或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr></tbody></table></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b0101</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bx010</span> ;</span><br><span class="line">    </span><br><span class="line">~A        <span class="comment">//4&#x27;b1010</span></span><br><span class="line">A &amp; B     <span class="comment">//4&#x27;b0001</span></span><br><span class="line">A | B     <span class="comment">//4&#x27;b1101</span></span><br><span class="line">A^B       <span class="comment">//4&#x27;b1100</span></span><br><span class="line">A ~^ B    <span class="comment">//4&#x27;b0011</span></span><br><span class="line">B | C     <span class="comment">//4&#x27;b1011</span></span><br><span class="line">B&amp;C       <span class="comment">//4&#x27;bx000</span></span><br></pre></td></tr></table></figure><h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（~&amp;），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。</p><p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p><p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">&amp;A ;      <span class="comment">//结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#x27;b0，可用来判断变量A是否全1</span></span><br><span class="line">~|A ;     <span class="comment">//结果为 ~(1 | 0 | 1 | 0) = 1&#x27;b0, 可用来判断变量A是否为全0</span></span><br><span class="line">^A ;      <span class="comment">//结果为 1 ^ 0 ^ 1 ^ 0 = 1&#x27;b0</span></span><br></pre></td></tr></table></figure><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>算术左移和逻辑左移时，右边低位会补 0。</p><p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1100</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">A = A &gt;&gt; <span class="number">2</span> ;        <span class="comment">//结果为 4&#x27;b0011</span></span><br><span class="line">A = A &lt;&lt; <span class="number">1</span>;         <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">A = A &lt;&lt;&lt; <span class="number">1</span> ;       <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">C = B + (A&gt;&gt;&gt;<span class="number">2</span>);    <span class="comment">//结果为 2 + (-4/4) = 1, 4&#x27;b0001</span></span><br></pre></td></tr></table></figure><h3 id="拼接操作符"><a href="#拼接操作符" class="headerlink" title="拼接操作符"></a>拼接操作符</h3><p>拼接操作符用大括号 <strong>{，}</strong> 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。</p><p>拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">B = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">Y1 = &#123;B, A[<span class="number">3</span>:<span class="number">2</span>], A[<span class="number">0</span>], <span class="number">4&#x27;h3</span> &#125;;  <span class="comment">//结果为Y1=&#x27;b1100_0011</span></span><br><span class="line">Y2 = &#123;<span class="number">4</span>&#123;B&#125;, <span class="number">3&#x27;d4</span>&#125;;  <span class="comment">//结果为 Y2=7&#x27;b111_1100</span></span><br><span class="line">Y3 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值</span></span><br></pre></td></tr></table></figure><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件表达式有 3 个操作符，结构描述如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition_expression ? true_expression : false_expression</span><br></pre></td></tr></table></figure><p>计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> hsel    = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b0</span>) ? hsel_p1 : hsel_p2 ;</span><br><span class="line"><span class="comment">//当信号 addr 高 2bit 为 0 时，hsel 赋值为 hsel_p1; 否则，将 hsel_p2 赋值给 hsel。</span></span><br></pre></td></tr></table></figure><p>其实，条件表达式类似于 2 路（或多路）选择器，其描述方式完全可以用 if-else 语句代替。</p><p>当然条件操作符也能进行嵌套，完成一个多次选择的逻辑。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>   hsel = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b00</span>) ? hsel_p1 : </span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b01</span>) ? hsel_p2 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b10</span>) ? hsel_p3 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b11</span>) ? hsel_p4 ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;verilog基础语法&quot;&gt;&lt;a href=&quot;#verilog基础语法&quot; class=&quot;headerlink&quot; title=&quot;verilog基础语法&quot;&gt;&lt;/a&gt;verilog基础语法&lt;/h1&gt;&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilog</title>
    <link href="https://rozen12123.github.io/posts/ffaf1e77.html"/>
    <id>https://rozen12123.github.io/posts/ffaf1e77.html</id>
    <published>2023-08-07T09:51:42.000Z</published>
    <updated>2023-08-09T15:51:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartus"><a href="#Quartus" class="headerlink" title="Quartus"></a>Quartus</h1><h3 id="使用—全加器"><a href="#使用—全加器" class="headerlink" title="使用—全加器"></a>使用—全加器</h3><h3 id="原理图方式（而输入或门）"><a href="#原理图方式（而输入或门）" class="headerlink" title="原理图方式（而输入或门）"></a>原理图方式（而输入或门）</h3><p><img src="/posts/ffaf1e77.htm/image-20230807180738812.png" alt="image-20230807180738812" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181223960.png" alt="image-20230807181223960" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181408224.png" alt="image-20230807181408224" style="zoom:50%;"></p><p>然后完成一个2选1的原理图</p><p><img src="/posts/ffaf1e77.htm/image-20230807181746258.png" alt="image-20230807181746258" style="zoom:50%;"></p><p>然后点击new选择University Program VWF</p><p><img src="/posts/ffaf1e77.htm/image-20230807181829430.png" alt="image-20230807181829430" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181944693.png" alt="image-20230807181944693" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807182059221.png" alt="image-20230807182059221" style="zoom:50%;"></p><p>将其全部移入</p><p><img src="/posts/ffaf1e77.htm/image-20230807182228594.png" alt="image-20230807182228594" style="zoom:50%;"></p><p>选择器件然后点击设置时间。</p><p><img src="/posts/ffaf1e77.htm/image-20230807182426708.png" alt="image-20230807182426708" style="zoom:50%;"></p><h3 id="用verilog进行电路设计"><a href="#用verilog进行电路设计" class="headerlink" title="用verilog进行电路设计"></a>用verilog进行电路设计</h3><p><img src="/posts/ffaf1e77.htm/image-20230807183308472.png" alt="image-20230807183308472" style="zoom:50%;"></p><p>右击选择Insert Template</p><p><img src="/posts/ffaf1e77.htm/image-20230807183728558.png" alt="image-20230807183728558" style="zoom:50%;"></p><p>！！Verilog HDL要求module描述的实例名称必须与储存文件名一致，我们将程序性稍做修改</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quartus II Verilog Template</span></span><br><span class="line"><span class="comment">// Signed adder/subtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder_sub</span><br><span class="line">#(<span class="keyword">parameter</span> WIDTH=<span class="number">16</span>)</span><br><span class="line">(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] datab,</span><br><span class="line"><span class="keyword">input</span> add_sub,  <span class="comment">// if this is 1, add; else subtract</span></span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (add_sub)</span><br><span class="line">result &lt;= dataa + datab;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result &lt;= dataa - datab;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>Verilog HDL程序是以module为基本单位的，形式上以$module<name>$开头,以$endmodule$结尾，模块名称$name$可以由设计者自定，并要求和文件存储名称一致。</name></p></li><li><p>$module<name>$和$endmodule$之间成为<code>模块实体</code>，其包括输入输出端口及数据类型描述，接下来是实际语句体描述。输入输出端口数据名称和类型的描述，要放在模块名称后面，并且用括号括起来。</name></p></li><li><p>输入/输出/双向端口变量描述一般以如下形式，不同端口之间要用逗号<code>，</code>隔开</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="comment">//output 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line"><span class="comment">//bidir 变量宽度 变量名称</span></span><br></pre></td></tr></table></figure></li><li><p>Verilog HDL中主要有两种类型<code>导线型</code>$wire$和<code>寄存器型</code>$reg$。在端口变量描述中$wire$可以省略。</p><p>各种类型容纳变量都是容纳的二进制数，他们能够纳二进制数的位数称之为<code>线宽</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如[7:0],表示有8位宽度的向量，内部的二进制数或存放二进制数的位置编号是7，6，5，4，3，2，1，0</span></span><br></pre></td></tr></table></figure></li><li><p>形参要用parameter保留字来定义，形式为：$parameter 形参名称 = 常数$，大多数情况下形参都用大写字母来表示</p></li><li><p>$lways @ (posedge clk)$是一个结构体语句的头，有多个语句时要用$begin … end$语句括起来，其代表只要clk上升沿到来，该$begin … end$语句体的内容就会被执行一遍。always语句括号内的变量成为敏感变量，多个敏感变量同时存在，用<code>or</code>或者<code>，</code>分开。$posedge$和$negedge$必须在每个敏感变量之前修饰，如果下降沿有效则用$negedge$修饰。</p></li><li><p>$always$中的语句都是按顺序执行的。</p></li><li><p>这个Add_Sub程序中设计了一个16位的加减法运算器，输入输出端口有两个16位的数据导线$dataa$和$datab$一个时钟输入导线$clk$，一个控制选择加减法运算的导线Sub，输出端口是一个16位的寄存器$result$。每当时钟上升沿到来的时刻，依据Sub为0还是1进行加法或者减法运算，并且将结果送到$result$寄存器。</p></li></ol><p>&nbsp;</p><p><img src="/posts/ffaf1e77.htm/image-20230807220923070.png" alt="image-20230807220923070" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartus&quot;&gt;&lt;a href=&quot;#Quartus&quot; class=&quot;headerlink&quot; title=&quot;Quartus&quot;&gt;&lt;/a&gt;Quartus&lt;/h1&gt;&lt;h3 id=&quot;使用—全加器&quot;&gt;&lt;a href=&quot;#使用—全加器&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>acfly飞控</title>
    <link href="https://rozen12123.github.io/posts/a4e8942.html"/>
    <id>https://rozen12123.github.io/posts/a4e8942.html</id>
    <published>2023-07-29T13:25:07.000Z</published>
    <updated>2023-08-09T15:51:29.039Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
