<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小江的博客</title>
  
  <subtitle>想成为一个温暖而有趣的人</subtitle>
  <link href="https://rozen12123.github.io/atom.xml" rel="self"/>
  
  <link href="https://rozen12123.github.io/"/>
  <updated>2023-12-19T08:14:21.219Z</updated>
  <id>https://rozen12123.github.io/</id>
  
  <author>
    <name>小江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://rozen12123.github.io/posts/0.html"/>
    <id>https://rozen12123.github.io/posts/0.html</id>
    <published>2023-12-17T13:32:51.962Z</published>
    <updated>2023-12-19T08:14:21.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络可以计算任何函数的可视化证明"><a href="#神经网络可以计算任何函数的可视化证明" class="headerlink" title="神经网络可以计算任何函数的可视化证明"></a>神经网络可以计算任何函数的可视化证明</h1><p>对于神经网络，一个显著的事实就是它可以计算任何函数。</p><p>如下：不管该函数如何，总有神经网络能够对任何可能的输入x，输出值f（x）</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172051164.png" alt="image-20231217205116099" style="zoom:67%;"></p><p>即使函数有很多输入和输出，$f=f(x_1,\cdots,x_m)$，结果也是成立的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172040247.png" alt="image-20231217204027194"></p><p>结果表明神经网络具有一种普遍性，无论我们想计算什么函数，都能用神经网络实现。</p><p>普遍性定理在计算机科学领域中特别常见，我们几乎可以将生活中的任何过程看作函数的计算，例如基于一段音乐识别曲目，其实也能将其视为计算一个函数，或者将中文翻译成英文”，又或者根据一个mp4视频文件生成对电影情节的描述并讨论表演水平。</p><p>普遍性指神经网络可以做各种事情。本质上就是通过一定的规律由a变b的性质。</p><p>&nbsp;</p><h2 id="两个预先声明"><a href="#两个预先声明" class="headerlink" title="两个预先声明"></a>两个预先声明</h2><p>在解释为什么普遍性成立之前，需要给“神经网络可以计算任意函数”两个预先声明。</p><p>第一点，<code>这句话不是说神经网络可用于准确计算任何函数，而是说可以获得不错的近似</code>。可以通过增加隐藏神经元的数量来提升近似的准确度。</p><p>例如一个网络中含有五个隐藏神经元的话肯定比含有3个隐藏神经元更好得近似结果。</p><p>第二点，可以按照上述方式近似的函数其实是连续函数。<code>如果函数不是连续的，即会有突然的“跳跃”，那么通常无法使用一个神经网络进行近似</code>。</p><p>这并不意外，因为神经网络计算的是输人的连续函数。然而，即使那些需要计算的函数是不连续的，连续的近似一般也足够好了。这样的话，就可以用神经网络来近似了。实践中，这通常不是一个严重的限制。</p><p>总结一下，关于普遍性定理，更加准确的表述是：==包含隐藏层的神经网络可按照任意给定的准确度来近似任何连续函数。==</p><p>&nbsp;</p><h2 id="一个输入和一个输出的普遍性"><a href="#一个输入和一个输出的普遍性" class="headerlink" title="一个输入和一个输出的普遍性"></a>一个输入和一个输出的普遍性</h2><p>为了理解如何构造一个神经网络来计算了，先从只包含一个隐藏层的神经网络开始，它有两个隐藏神经元，以及由单个输出神经元形成的输出层。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172041876.png" alt="image-20231217204132828" style="zoom:67%;"></p><p>为了理解神经网络组件的工作机制，下面着重研究顶部的隐藏神经元。了解顶部隐藏神经元的权重w、偏置b和输出曲线的关系。思考如何通过顶部隐藏神经元的变化计算函数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172041491.png" alt="image-20231217204145422" style="zoom:67%;"></p><p>如前所述，隐藏神经元计算的是$\sigma(wx+b)$，其中$\sigma(z)\equiv1/(1+\mathrm{e}^{-z})$是sigmoid函数。前面频繁使用这个代数形式，这里为了证明普遍性会完全忽略其代数性质，而会在图像中调整并观察形状来获得更多认识。<br>一开始增大偏置b的值。当偏置增加时，图形向左移动，但是形状保持不变。<br>接着减小偏置。当偏置减小时，图形向右移动，但形状仍没有变化。</p><p>然后将权重减小到大约2或3.当权重减小时，曲线向两边拉宽了。可以通过改变偏置让曲线保持在框内。<br>最后，把权重增加到超过100.这会使得曲线变得越来越陡，最终看上去像阶跃函数。尝试调整偏置，使得阶跃位置靠近x=0.3.</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172042343.png" alt="image-20231217204200291" style="zoom:67%;"></p><p>你能给权重增加很⼤的值来简化我们的分析，使得输出实际上是个⾮常接近的阶跃函数。下⾯我画出了当权重为 <em>w</em> = 999 时从顶部隐藏神经元的输出。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172042604.png" alt="image-20231217204258538" style="zoom: 67%;"></p><p>实际上处理阶跃函数⽐⼀般的 S 型函数更加容易。很显然相比于思考把⼀串 S 形状的曲线加起来是什么，我们只考虑在输出层我们把所有隐藏神经元的贡献值加在⼀起，分析⼀串阶跃函数的和是很容易的。</p><p>所以假设我们的隐藏神经元输出阶跃函数会使事情更容易。更具体些，我们把权重 <em>w</em> 固定在⼀个⼤的值，然后通过修改偏置设置阶跃函数的位置。</p><p>当然，把输出作为⼀个阶跃函数处理只是⼀个近似，但是它是⼀个⾮常好的近似，现在我们把它看作是精确的。</p><p>&nbsp;</p><p><em>x</em> 取何值时阶跃会发⽣呢？换种⽅式，阶跃的位置如何取决于权重和偏置？</p><p>得出的结论是：阶跃的位置和 <em>b</em> 成正⽐，和 <em>w</em> 成反⽐。</p><p>实际上，阶跃发⽣在$ s = −b/w $的位置，正如图中通过修改权重和偏置看到的：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172056203.png" alt="image-20231217205626143" style="zoom:67%;"></p><p>这将⽤仅仅⼀个参数 <em>s</em> 来极⼤简化我们描述隐藏神经元的⽅式，这就是阶跃位置，$s = −b/w$</p><p>试着修改下图中的 <em>s</em>:<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172057169.png" alt="image-20231217205728098" style="zoom:67%;"></p><p>正如上⾯注意到的，我们隐式地设置输⼊上的权重 <em>w</em> 为⼀些⼤的值 —— ⼤到阶跃函数能够很好地近似。通过选择偏置 $b = -ws$，我们能很容易地将⼀个以这种⽅式参数化的神经元转换回常⽤的模型。</p><p>我们假设隐藏神经元在计算以阶跃点$ s_1 $（顶部神经元）和$ s_2 $（底部神经元）参数化的节约函数。它们各⾃有输出权重 $w_1 $和$w_2$。是这样的⽹络：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172100809.png" alt="image-20231217210044744" style="zoom:67%;"></p><p>右边的绘图是隐藏层的<strong>加权输出</strong> $w_{1}a_{1}+w_{2}a_{2}.$。(注意：整个网络输出是$\sigma(w_{1}a_{1}+w_{2}a_{2}+b)$)这⾥ <em>a</em>1 和 <em>a</em>2 各⾃是顶部和底部神经元的输出。这些输出由 <em>a</em> 表⽰，是因为它们通常被称为神经元的<strong>激活值（activations）</strong>。</p><p>试着增加和减⼩顶部隐藏神经元的阶跃点 <em>s</em>1。感受下这如何改变隐藏层的加权输出。尤其值得去理解当 <em>s</em>1 经过 <em>s</em>2 时发⽣了什么。你会看到这时图形发⽣了变化，因为我们从顶部隐藏神经元先被激活的情况变成了底部隐藏神经元先被激活的情况。</p><p>类似地，试着操作底部隐藏神经元的阶跃点 <em>s</em>2，感受下这如何改变隐藏神经元混合后的输出。</p><p>尝试增加和减少每⼀个输出权重。注意，这如何调整从各⾃的隐藏神经元的贡献值。当⼀个权重是 0 时会发⽣什么？</p><p>最后，试着设置 <em>w</em>1 为 0<em>.</em>8，<em>w</em>2 为 <em>−</em>0<em>.</em>8。你得到⼀个“凸起”的函数，它从点 <em>s</em>1 开始，到点<em>s</em>2 结束，⾼为 0<em>.</em>8。例如，加权后的输出可能看起来像这样：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172106307.png" alt="image-20231217210626243" style="zoom:67%;"></p><p>当然，我们可以调整为任意的凸起⾼度。让我们⽤⼀个参数，<em>h</em>，来表⽰⾼度。为了减少混乱我也会移除“<em>s</em>1 = <em>. . .</em>”和“<em>w</em>1 = <em>. . .</em>”的标记。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172108563.png" alt="image-20231217210840492" style="zoom:67%;"></p><p>试着将 <em>h</em> 值改⼤或改⼩，看看凸起的⾼度如何改变。试着把⾼度值改为负数，观察发⽣了什么。并且试着改变阶跃点来看看如何改变凸起的形状。</p><p>顺便提⼀下，你会注意到，我们⽤神经元的⽅式，可以认为不只是在图形的⻆度，⽽且是更传统的编程形式，作为 if-then-else 的⼀种声明，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">input</span> &gt;= step point:</span><br><span class="line">add <span class="number">1</span> to the weighted output</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">add <span class="number">0</span> to the weighted output</span><br></pre></td></tr></table></figure><p>对于⼤部分内容，我将坚持以图形的考虑⻆度。但在接下来的内容中，你有时可能会发现交换考虑⻆度是有帮助的，并且考虑 if-then-else 的形式。</p><p>我们可以⽤凸起制作的技巧来得到两个凸起，通过把两对隐藏神经元⼀起填充进同⼀个⽹络：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172111773.png" alt="image-20231217211158712" style="zoom:67%;"></p><p>这⾥我抑制了权重，只是简单地在每对隐藏神经元上写了 <em>h</em> 的值。</p><p>更普遍地，我们可以利⽤这个思想来取得我们想要的任何⾼度的峰值。尤其，我们可以把间隔 [0<em>,</em> 1] 分成⼤量的⼦区间，⽤ <em>N</em> 表⽰，并利⽤ <em>N</em> 对隐藏神经元来设置任意期望⾼度的峰值。让我们看看 <em>N</em> = 5 这如何⼯作。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172115966.png" alt="image-20231217211500877" style="zoom:67%;"></p><p>让我们回想在最开始绘制出的函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172133339.png" alt="image-20231217213351283" style="zoom:67%;"></p><p>这个函数其实是：</p><p>$f(x)=0.2+0.4x^2+0.3x\sin(15x)+0.05\cos(50x)$</p><p><em>x</em> 取值范围从 0 到 1，<em>y</em> 轴取值为 0 到 1。</p><p>我们再试着用神经网络的方法去估计它。</p><p>在我们上⾯的⽹络中，我们已经分析了隐藏神经元输出的加权组合$\sum_jw_ja_j$。我们现在知道如何在这个量上获得⼤量的控制。但是，正如我前⾯所指出的，这个量不是⽹络的输出。⽹络输出的是$\sigma(\sum_{j}w_{j}a_{j}+b)$，其中 <em>b</em> 是在输出神经元的偏置。有什么办法可以实现对⽹络的实际输出控制吗？</p><p>解决⽅案是设计⼀个神经⽹络，它的隐藏层有⼀个加权输出 $\sigma^{-1}\circ f(x)$，其中 $\sigma^{-1}$ 是 $\sigma$ 函数的倒数。也就是说，我们希望从隐藏层的加权输出是：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172136984.png" alt="image-20231217213630926" style="zoom:67%;"></p><p>根据图形的需求我们大概可以调整到如下地步：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172138018.png" alt="image-20231217213853926" style="zoom:67%;"></p><p>在已经解决了所有⽹络的必要元素来近似计算函数 <em>f</em>(<em>x</em>)！这只是⼀个粗略的近似，但我们可以很容易地做得更好，仅仅通过增加隐藏神经元对的数量，分配更多的凹凸形状。</p><p>于此我们已经理解了如何通过提⾼隐层神经元的数⽬来提⾼近似的质量。</p><p>&nbsp;</p><h2 id="多个输入变量"><a href="#多个输入变量" class="headerlink" title="多个输入变量"></a>多个输入变量</h2><p>我们从考虑当⼀个神经元有两个输⼊会发⽣什么开始：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172151293.png" alt="image-20231217215128242" style="zoom:80%;"></p><p>这⾥，我们有输⼊ <em>x</em> 和 <em>y</em>，分别对应于权重 <em>w</em>1 和 <em>w</em>2，以及⼀个神经元上的偏置 <em>b</em>。让我们把权重 <em>w</em>2 设置为 0，然后反复琢磨第⼀个权重 <em>w</em>1 和偏置 <em>b</em>，看看他们如何影响神经元的输出：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172152201.png" alt="image-20231217215203128" style="zoom:67%;"></p><p>为当我们增加权重 <em>w</em>1 到 <em>w</em>1 = 100，同时 <em>w</em>2 保持 0 不变时会发⽣什么？</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172154978.png" alt="image-20231217215408880"></p><p>正如我们前⾯讨论的那样，随着输⼊权重变⼤，输出接近⼀个阶跃函数。不同的是，现在的阶跃函数是在三个维度。也如以前⼀样，我们可以通过改变偏置的位置来移动阶跃点的位置。阶跃点的实际位置是 $s_x\equiv-b/w_1$。</p><p>让我们⽤阶跃点位置作为参数重绘上⾯的阶跃函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172156193.png" alt="image-20231217215648115" style="zoom:67%;"></p><p>当然，通过使得 <em>y</em> 输⼊上的权重取⼀个⾮常⼤的值（例如，<em>w</em>2 = 1000），<em>x</em> 上的权重等于 0，即 <em>w</em>1 = 0，来得到⼀个 <em>y</em></p><p>轴⽅向的阶跃函数也是可⾏的，</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172157903.png" alt="image-20231217215751828" style="zoom:67%;"></p><p>再⼀次，神经元上的数字是阶跃点，在这个情况下数字上的⼩ <em>y</em> 提醒我们阶跃是在 <em>y</em> 轴⽅向。我本来可以明确把权重标记在 <em>x</em> 和 <em>y</em> 输⼊上，但是决定不这么做，因为这会把图⽰弄得有些杂乱。但是记住⼩ <em>y</em> 标记含蓄地告诉我们 <em>y</em> 权重是个⼤的值，<em>x</em> 权重为 0。</p><p>我们可以⽤我们刚刚构造的阶跃函数来计算⼀个三维的凹凸函数。为此，我们使⽤两个神经元，每个计算⼀个 <em>x</em> ⽅向的阶跃函数。然后我们⽤相应的权重 <em>h</em> 和 <em>−h</em> 将这两个阶跃函数混合，这⾥ <em>h</em> 是凸起的期望⾼度。所有这些在下⾯图⽰中说明：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172159780.png" alt="image-20231217215932698" style="zoom:67%;"></p><p>同理，使用y方向实现结果如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172201042.png" alt="image-20231217220139940" style="zoom:67%;"></p><p>让我们考虑当我们叠加两个凹凸函数时会发⽣什么，⼀个沿 <em>x</em> ⽅向，另⼀个沿 <em>y</em> ⽅向，两者都有⾼度 <em>h</em>：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172203442.png" alt="image-20231217220318359" style="zoom:67%;"></p><p>试着改变参数 <em>h</em>。正如你能看到，这引起输出权重的变化，以及 <em>x</em> 和 <em>y</em> 上凹凸函数的⾼度。</p><p>我们构建的有点像是⼀个塔型函数：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172206807.png" alt="image-20231217220637737" style="zoom:67%;"></p><p>如果我们能构建这样的塔型函数，那么我们能使⽤它们来近似任意的函数，仅仅通过在不同位置累加许多不同⾼度的塔：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172207361.png" alt="image-20231217220733289" style="zoom:67%;"></p><p>当然，我们还没有解决如何构建⼀个塔型函数。我们已经构建的看起来像⼀个中⼼塔，⾼度为 2<em>h</em>，周围由⾼原包围，⾼度为 <em>h</em>。</p><p>但是我们能制造⼀个塔型函数。记得前⾯我们看到神经元能被⽤来实现⼀个 if-then-else 的声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">input</span> &gt;= threshold:</span><br><span class="line">output <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">output <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是⼀个只有单个输⼊的神经元。我们想要的是将⼀个类似的想法应⽤到隐藏神经元的组合输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> combined output <span class="keyword">from</span> hidden neurons &gt;= threshold:</span><br><span class="line">output <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">output <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果我们选择适当的阈值 —— ⽐如，3<em>h/</em>2，这是⾼原的⾼度和中央塔的⾼度中间的值——我们可以把⾼原下降到零，并且依旧矗⽴着塔。</p><p>请注意，我们现在正在绘制整个⽹络的输出，⽽不是只从隐藏层的加权输出。这意味着我们增加了⼀个偏置项到隐藏层的加权输出，并应⽤ S 型函数。</p><p>你能找到 <em>h</em> 和 <em>b</em> 的值，能产⽣⼀个塔型吗？这有点难，所以如果你想了⼀会⼉还是困住，这是有两个提⽰：</p><p>（1）为了让输出神经元显⽰正确的 if-then-else ⾏为，我们需要输⼊的权重（所有 <em>h</em> 或 <em>−h</em>）变得很⼤；</p><p>（2）<em>b</em> 的值决定了 if-then-else 阈值的⼤⼩。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172210615.png" alt="image-20231217221020530" style="zoom:67%;"></p><p>在初始参数时，输出看起来像⼀个前⾯图形在它的塔型和⾼原上的平坦的版本。为了得到期望的⾏为，我们增加参数 <em>h</em> 直到它变得很⼤。这就给出了 if-then-else 做阈值的⾏为。其次，为了得到正确的阈值，我们选择 <em>b</em> <em>≈ −</em>3<em>h/</em>2。尝试⼀下，看看它是如何⼯作的！这是它看起来的样⼦，我们使⽤ <em>h</em> = 10：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172211959.png" alt="image-20231217221155867" style="zoom:67%;"></p><p>甚⾄对于这个相对适中的 <em>h</em> 值，我们得到了⼀个相当好的塔型函数。当然，我们可以通过更进⼀步增加 <em>h</em> 并保持偏置 <em>b</em> = <em>−</em>3<em>h/</em>2 来使它如我们所希望的那样。</p><p>让我们尝试将两个这样的⽹络组合在⼀起，来计算两个不同的塔型函数。为了使这两个⼦⽹络更清楚，我把它们放在如下所⽰的分开的⽅形区域：每个⽅块计算⼀个塔型函数，使⽤上⾯描述的技术。右边的图上显⽰了第⼆个隐藏层的加权输出，即，它是⼀个加权组合的塔型函数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172214667.png" alt="image-20231217221401557" style="zoom:67%;"></p><p>尤其你能看到通过修改最终层的权重能改变输出塔型的⾼度。</p><p>同样的想法可以⽤在计算我们想要的任意多的塔型。我们也可以让它们变得任意细，任意⾼。结果，我们可以确保第⼆个隐藏层的加权输出近似与任意期望的⼆元函数：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172214421.png" alt="image-20231217221436349" style="zoom:67%;"></p><p>尤其通过使第⼆个隐藏层的加权输出为 $\sigma^{-1}\circ f$ 的近似，我们可以确保⽹络的输出可以是任意期望函数 <em>f</em> 的近似。</p><p>超过两个变量的函数会怎样？让我们试试三个变量 <em>x</em>1<em>, x</em>2<em>, x</em>3。下⾯的⽹络可以⽤来计算⼀个四维的塔型函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172215902.png" alt="image-20231217221525831" style="zoom:67%;"></p><p>这⾥，<em>x</em>1<em>, x</em>2<em>, x</em>3 表⽰⽹络的输⼊。<em>s</em>1<em>, t</em>1 等等是神经元的阶跃点 —— 即，第⼀层中所有的权重是很⼤的，⽽偏置被设置为给出阶跃点 <em>s</em>1<em>, t</em>1<em>, s</em>2<em>, . . .</em>。第⼆层中的权重交替设置为 +<em>h,</em> <em>−h</em>，其中 <em>h</em> 是⼀个⾮常⼤的数。输出偏置为 <em>−</em>5<em>h/</em>2。</p><p>这个⽹络计算这样⼀个函数，当三个条件满⾜时：<em>x</em>1 在 <em>s</em>1 和 <em>t</em>1 之间；<em>x</em>2 在 <em>s</em>2 和 <em>t</em>2 之间；<em>x</em>3 在 <em>s</em>3 和 <em>t</em>3 之间，输出为 1。其它情况⽹络输出为 0。即，这个塔型在输⼊空间的⼀个⼩的区域输出为 1，其它情况输出 0。</p><p>通过组合许多个这样的⽹络我们能得到任意多的塔型，如此可近似⼀个任意的三元函数。对于 <em>m</em> 维可⽤完全相同的思想。唯⼀需要改变的是将输出偏置设为 (<em>−m</em> + 1<em>/</em>2)<em>h</em>，为了得到正确的夹在中间的⾏为来弄平⾼原。</p><p>好了，所以现在我们知道如何⽤神经⽹络来近似⼀个多元的实值函数。对于$f(x_{1},\ldots,x_{m})\in R^n $的向量函数怎么样？当然，这样⼀个函数可以被视为 <em>n</em> 个单独的实值函数：，$\begin{aligned}f^1(x_1,\ldots,x_m)\end{aligned}$,$f^2(x_1,\ldots,x_m)$ 等等。所以我们创建⼀个⽹络来近似 $ f^1$，另⼀个来近似$f^2$，如此等等。然后简单地把这些⽹络都组合起来。所以这也很容易应付。</p><p>&nbsp;</p><h2 id="S-型神经元的延伸"><a href="#S-型神经元的延伸" class="headerlink" title="S 型神经元的延伸"></a>S 型神经元的延伸</h2><p>我们已经证明了由 S 型神经元构成的⽹络可以计算任何函数。回想下在⼀个 S 型神经元中，输⼊ <em>x</em>1<em>, x</em>2<em>, . . .</em> 导致输出$\sigma(\sum_jw_jx_j+b)$，这⾥$W_j$是权重，<em>b</em> 是偏置，⽽ <em>σ</em> 是 S 型函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172221399.png" alt="image-20231217222128326" style="zoom:67%;"></p><p>如果我们考虑⼀个不同类型的神经元，它使⽤其它激活函数，⽐如如下的 <em>s</em>(<em>z</em>)，会怎样？</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172221694.png" alt="image-20231217222144628" style="zoom:67%;"></p><p>更确切地说，我们假定如果神经元有输⼊ <em>x</em>1<em>, x</em>2<em>, . . .</em>，权重 w<em>1</em>, w<em>2</em>, . . . 和偏置 b<em>，那么输出</em>$s(\sum_jw_jx_j+b)$。我们可以使⽤这个激活函数来得到⼀个阶跃函数，正如⽤ S 型函数做过的⼀样。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172223601.png" alt="image-20231217222306503" style="zoom:67%;"></p><p>试着加⼤上图中的权重，⽐如 <em>w</em> = 100，你将得到：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172223147.png" alt="image-20231217222321066" style="zoom:67%;"></p><p>正如使⽤ S 型函数的时候，这导致激活函数收缩，并最终变成⼀个阶跃函数的很好的近似。试着改变偏置，然后你能看到我们可以设置我们想要的阶跃位置。所以我们能使⽤所有和前⾯相同的技巧来计算任何期望的函数。</p><p><em>s</em>(<em>z</em>) 需要什么样的性质来满⾜这样的结果呢？我们确实需要假定 <em>s</em>(<em>z</em>) 在$s(z)\text{ 在 }z\to-\infty\text{ 和 }z\to\infty $时是定义明确的。这两个界限是在我们的阶跃函数上取的两个值。我们也需要假定这两个界限彼此不同。如果它们不是这样，就没有阶跃，只是⼀个简单的平坦图形！但是如果激活函数 <em>s</em>(<em>z</em>)满⾜这些性质，基于这样⼀个激活函数的神经元可普遍⽤于计算。</p><p>&nbsp;</p><h2 id="修补阶跃函数"><a href="#修补阶跃函数" class="headerlink" title="修补阶跃函数"></a>修补阶跃函数</h2><p>⽬前为⽌，我们假定神经元可以准确⽣成阶跃函数。这是⼀个⾮常好的近似，但也仅仅是近似。实际上，会有⼀个很窄的故障窗⼝，如下图说明，在这⾥函数会表现得和阶跃函数⾮常不同。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172224759.png" alt="image-20231217222453686" style="zoom:67%;"></p><p>在这些故障窗⼝中我给出的普遍性的解释会失败。</p><p>现在，它不是⼀个很严重的故障。通过使得输⼊到神经元的权重为⼀个⾜够⼤的值，我们能把这些故障窗⼝变得任意⼩。当然，我们可以把故障窗⼝窄过我在上⾯显⽰的 —— 窄得我们的眼睛都看不到。所以也许我们可以不⽤过于担⼼这个问题。</p><p>尽管如此，有⼀些⽅法解决问题是很好的。</p><p>实际上，这个问题很容易解决。让我们看看只有⼀个输⼊和⼀个输出的神经⽹络如何修补其计算函数。同样的想法也可以解决有更多输⼊和输出的问题。</p><p>特别地，假设我们想要我们的⽹络计算函数 <em>f</em>。和以前⼀样，我们试着设计我们的⽹络，使得隐藏神经元的加权输出是 $\sigma^{-1}\circ f(x)$：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172225637.png" alt="image-20231217222547571" style="zoom:67%;"></p><p>如果我们要使⽤前⾯描述的技术做到这⼀点，我们会使⽤隐藏神经元产⽣⼀系列的凹凸函数：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172226765.png" alt="image-20231217222605698" style="zoom:67%;"></p><p>再说⼀下，我夸⼤了图上的故障窗⼝⼤⼩，好让它们更容易看到。很明显如果我们把所有这些凹凸函数加起来，我们最终会得到⼀个合理的 $\sigma^{-1}\circ f(x)$的近似，除了那些故障窗⼝。</p><p>假设我们使⽤⼀系列隐藏神经元来计算我们最初的⽬标函数的⼀半，即 $\sigma^{-1}\circ f(x) /2$，⽽不是使⽤刚刚描述的近似。当然，这看上去就像上⼀个图像的缩⼩的版本：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172226469.png" alt="image-20231217222658380" style="zoom:67%;"></p><p>并且假设我们使⽤另⼀系列隐藏神经元来计算⼀个 $\sigma^{-1}\circ f(x) /2$ 的近似，但是⽤将凹凸图形偏移⼀半宽度：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312172227304.png" alt="image-20231217222720230" style="zoom:67%;"></p><p>现在我们有两个不同的$\sigma^{-1}\circ f(x) /2$ 的近似。如果我们把这两个近似图形加起来，我们会得到⼀个 $\sigma^{-1}\circ f(x) $ 的整体近似。这个整体的近似仍然在⼀些⼩窗⼝的地⽅有故障。但是问题⽐以前要⼩很多。原因是在⼀个近似中的故障窗⼝的点，不会在另⼀个的故障窗⼝中。所以在这些窗⼝中，近似会有 2 倍的因素更好。</p><p>我们甚⾄能通过加⼊⼤量的，⽤ <em>M</em> 表⽰，重叠的近似$\sigma^{-1}\circ f(x) /M$  来做得更好。假设故障窗⼝已经⾜够窄了，其中的点只会在⼀个故障窗⼝中。并且假设我们使⽤⼀个 <em>M</em> ⾜够⼤的重叠近似，结果会是⼀个⾮常好的整体近似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;神经网络可以计算任何函数的可视化证明&quot;&gt;&lt;a href=&quot;#神经网络可以计算任何函数的可视化证明&quot; class=&quot;headerlink&quot; title=&quot;神经网络可以计算任何函数的可视化证明&quot;&gt;&lt;/a&gt;神经网络可以计算任何函数的可视化证明&lt;/h1&gt;&lt;p&gt;对于神经网络</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="https://rozen12123.github.io/posts/7ca31f7.html"/>
    <id>https://rozen12123.github.io/posts/7ca31f7.html</id>
    <published>2023-12-17T12:17:25.000Z</published>
    <updated>2023-12-19T08:14:21.216Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>LCD接口</title>
    <link href="https://rozen12123.github.io/posts/216a0b1f.html"/>
    <id>https://rozen12123.github.io/posts/216a0b1f.html</id>
    <published>2023-12-06T09:55:26.000Z</published>
    <updated>2023-12-19T08:14:21.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCD接口（附8051LCD1602显示：源码＋原理图）"><a href="#LCD接口（附8051LCD1602显示：源码＋原理图）" class="headerlink" title="LCD接口（附8051LCD1602显示：源码＋原理图）"></a>LCD接口（附8051LCD1602显示：源码＋原理图）</h1><p>工程源码及原理图：链接：<a href="https://pan.baidu.com/s/1KgmiGkFdl_sFE5GTm5MSsQ?pwd=l1gp">https://pan.baidu.com/s/1KgmiGkFdl_sFE5GTm5MSsQ?pwd=l1gp</a><br>提取码：l1gp </p><p>LCD（Liquid Crystal Display）：又称液晶显示器</p><h2 id="LCD引脚"><a href="#LCD引脚" class="headerlink" title="LCD引脚"></a>LCD引脚</h2><p>LCD一共有14个引脚，如下图：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061758088.png" alt="image-20231206175851955"></p><p>以LCD1602为例：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061800402.png" alt="image-20231206180044336"></p><p>以下我们对引脚进行逐个解释：</p><h3 id="VSS，VDD，VO"><a href="#VSS，VDD，VO" class="headerlink" title="VSS，VDD，VO"></a>VSS，VDD，VO</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>VSS</td><td>地</td></tr><tr><td>VDD</td><td>电源正极（4.5~5.5V）</td></tr><tr><td>VO</td><td>对比度调节电压（一般接在可变电阻上以调节电压）</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="RS-寄存器选择"><a href="#RS-寄存器选择" class="headerlink" title="RS(寄存器选择)"></a>RS(寄存器选择)</h3><p>数据/指令选择，1为数据，0为指令</p><p>若RS=0，选择==指令代码寄存器==，允许用户发送指令，如清屏，使光标返回初始位置。</p><p>若RS=1，选择==数据寄存器==，允许用户发送数据显示在LCD上</p><p>&nbsp;</p><h3 id="RW-read-write"><a href="#RW-read-write" class="headerlink" title="RW(read/write)"></a>RW(read/write)</h3><p>读/写选择，1为读，0为写</p><h3 id="E-使能"><a href="#E-使能" class="headerlink" title="E(使能)"></a>E(使能)</h3><p>使能，1为数据有效，下降沿执行命令</p><h3 id="D0-D7"><a href="#D0-D7" class="headerlink" title="D0~D7"></a>D0~D7</h3><p>数据输入/输出</p><h3 id="A-K"><a href="#A-K" class="headerlink" title="A/K"></a>A/K</h3><p>A:背光灯电源正极</p><p>K:背光灯电源负极</p><p>&nbsp;</p><p>其内部结构图如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061813744.png" alt="image-20231206181354663"></p><p>数据显示在屏幕上的流程：</p><p>数据——&gt;DDRAM——&gt;字模库——&gt;屏幕</p><p>DDRAM比屏幕显示内存更多以便实现滚动字符等的效果。</p><p>&nbsp;</p><h2 id="LCD1602指令集"><a href="#LCD1602指令集" class="headerlink" title="LCD1602指令集"></a>LCD1602指令集</h2><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312061821398.png" alt></p><h3 id="1-清屏指令（-0000-0001-）"><a href="#1-清屏指令（-0000-0001-）" class="headerlink" title="1.清屏指令（ 0000 0001 ）"></a>1.清屏指令（ 0000 0001 ）</h3><p>1.清除液晶显示器，即将DDRAM的内容全部清除。<br>2.光标回到液晶屏左上方。<br>3.地址计数器（AC）的值设置为0。</p><h3 id="2-光标归位指令（0000-001x）"><a href="#2-光标归位指令（0000-001x）" class="headerlink" title="2.光标归位指令（0000 001x）"></a>2.光标归位指令（0000 001x）</h3><p>1.把光标返回到液晶屏左上方。<br>2.把地址计数器（AC）的值设置为0。<br>3.保持DDRAM的内容不变。</p><h3 id="3-模式设置指令（0000-01-I-D-S）"><a href="#3-模式设置指令（0000-01-I-D-S）" class="headerlink" title="3.模式设置指令（0000 01 I/D S）"></a>3.模式设置指令（0000 01 I/D S）</h3><p>设定每次写入一位数据后光标的移动方向，并且设定每次写入一个字符是否移动。<br>I/D：0写入新数据后光标左移，1写入新数据后光标右移。<br>S ：0写入新数据后显示屏不移动，1写入新数据后显示屏整体右移一个字符。</p><h3 id="4-显示开关控制指令（0000-1-D-C-B）"><a href="#4-显示开关控制指令（0000-1-D-C-B）" class="headerlink" title="4.显示开关控制指令（0000 1 D C B）"></a>4.显示开关控制指令（0000 1 D C B）</h3><p>D：0显示关，1显示开。<br>C：0无光标，1有光标。<br>B：0光标不闪烁，1光标闪烁。</p><h3 id="5-设定显示屏或光标移动方向指令（000-1-S-C-R-L-x-x）"><a href="#5-设定显示屏或光标移动方向指令（000-1-S-C-R-L-x-x）" class="headerlink" title="5.设定显示屏或光标移动方向指令（000 1 S/C R/L x x）"></a>5.设定显示屏或光标移动方向指令（000 1 S/C R/L x x）</h3><p>S/C R/L<br>0 0 光标左移一格，且AC减一。<br>0 1 光标右移一格，且AC加一。<br>1 0 显示器字符全部左移一格，光标不动。<br>1 1 显示器字符全部右移一格，光标不动。</p><h3 id="6-功能设定指令（00-1-DL-N-F-x-x）"><a href="#6-功能设定指令（00-1-DL-N-F-x-x）" class="headerlink" title="6.功能设定指令（00 1 DL N F x x）"></a>6.功能设定指令（00 1 DL N F x x）</h3><p>DL：0数据总线为4位，1数据总线为8位。<br>N： 0显示 1 行，1显示 2 行。<br>F： 0 5<em>8字符点阵，1 5</em>10字符点阵。</p><h3 id="7-设定CGRAM地址指令（01-aaaaaa）6位地址"><a href="#7-设定CGRAM地址指令（01-aaaaaa）6位地址" class="headerlink" title="7.设定CGRAM地址指令（01 aaaaaa）6位地址"></a>7.设定CGRAM地址指令（01 aaaaaa）6位地址</h3><h3 id="8-设定DDRAM地址指令（1-aaaaaaa）7位地址"><a href="#8-设定DDRAM地址指令（1-aaaaaaa）7位地址" class="headerlink" title="8.设定DDRAM地址指令（1 aaaaaaa）7位地址"></a>8.设定DDRAM地址指令（1 aaaaaaa）7位地址</h3><h3 id="9-读取忙信号或AC地址指令（BF-aaaaaaa）"><a href="#9-读取忙信号或AC地址指令（BF-aaaaaaa）" class="headerlink" title="9.读取忙信号或AC地址指令（BF aaaaaaa）"></a>9.读取忙信号或AC地址指令（BF aaaaaaa）</h3><p>BF：0空闲，1忙。<br>aaaaaaa：读取AC地址。</p><h3 id="10-数据写入DDRAM或CGRAM指令"><a href="#10-数据写入DDRAM或CGRAM指令" class="headerlink" title="10.数据写入DDRAM或CGRAM指令"></a>10.数据写入DDRAM或CGRAM指令</h3><h3 id="11-从DDRAM或CGRAM读出数据指令"><a href="#11-从DDRAM或CGRAM读出数据指令" class="headerlink" title="11.从DDRAM或CGRAM读出数据指令"></a>11.从DDRAM或CGRAM读出数据指令</h3><p>&nbsp;</p><p>&nbsp;</p><h2 id="函数功能实现"><a href="#函数功能实现" class="headerlink" title="函数功能实现"></a>函数功能实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>发送指令0x38    //八位数据接口，两行显示，5*7点阵    </p><p>发送指令0x0C    //显示开，光标关，闪烁关    </p><p>发送指令0x06    //数据读写操作后，光标自动加一，画面不动    </p><p>发送指令0x01    //清屏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="LCD1602写命令"><a href="#LCD1602写命令" class="headerlink" title="LCD1602写命令"></a>LCD1602写命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">0</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Command;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD1602写数据"><a href="#LCD1602写数据" class="headerlink" title="LCD1602写数据"></a>LCD1602写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">1</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Data;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCD1602设置光标位置"><a href="#LCD1602设置光标位置" class="headerlink" title="LCD1602设置光标位置"></a>LCD1602设置光标位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Line==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始显示所给字符串"><a href="#在LCD1602指定位置开始显示所给字符串" class="headerlink" title="在LCD1602指定位置开始显示所给字符串"></a>在LCD1602指定位置开始显示所给字符串</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>String 要显示的字符串</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始显示所给数字"><a href="#在LCD1602指定位置开始显示所给数字" class="headerlink" title="在LCD1602指定位置开始显示所给数字"></a>在LCD1602指定位置开始显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2<ul><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~65535</li><li>Length 要显示数字的长度，范围：1~5</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以有符号十进制显示所给数字"><a href="#在LCD1602指定位置开始以有符号十进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以有符号十进制显示所给数字"></a>在LCD1602指定位置开始以有符号十进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：-32768~32767</li><li>Length 要显示数字的长度，范围：1~5</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Number1;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">if</span>(Number&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">Number1=Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">Number1=-Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number1/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以十六进制显示所给数字"><a href="#在LCD1602指定位置开始以十六进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以十六进制显示所给数字"></a>在LCD1602指定位置开始以十六进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2</li><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~0xFFFF</li><li>Length 要显示数字的长度，范围：1~4</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SingleNumber;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">SingleNumber=Number/LCD_Pow(<span class="number">16</span>,i<span class="number">-1</span>)%<span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span>(SingleNumber&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+SingleNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;A&#x27;</span>+SingleNumber<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在LCD1602指定位置开始以二进制显示所给数字"><a href="#在LCD1602指定位置开始以二进制显示所给数字" class="headerlink" title="在LCD1602指定位置开始以二进制显示所给数字"></a>在LCD1602指定位置开始以二进制显示所给数字</h3><ul><li>Line 起始行位置，范围：1~2<ul><li>Column 起始列位置，范围：1~16</li><li>Number 要显示的数字，范围：0~1111 1111 1111 1111</li><li>Length 要显示数字的长度，范围：1~16</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">2</span>,i<span class="number">-1</span>)%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="在LCD1602显示姓名学号"><a href="#在LCD1602显示姓名学号" class="headerlink" title="在LCD1602显示姓名学号"></a>在LCD1602显示姓名学号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit LCD_RS=P2^<span class="number">0</span>;</span><br><span class="line">sbit LCD_RW=P2^<span class="number">1</span>;</span><br><span class="line">sbit LCD_E=P2^<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DataPort P0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> Char)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();<span class="comment">//LCD初始化</span></span><br><span class="line"></span><br><span class="line">LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;yourname&quot;</span>);<span class="comment">//第一行第一列开始显示名字</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">12138</span>,<span class="number">5</span>);<span class="comment">//第二行第一列显示12138</span></span><br><span class="line">LCD_ShowNum(<span class="number">2</span>,<span class="number">6</span>,<span class="number">12138</span>,<span class="number">5</span>);<span class="comment">//第二行第六列开始显示12138</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay</span><span class="params">()</span><span class="comment">//@12.000MHz 1ms</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = <span class="number">239</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (--j);</span><br><span class="line">&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">1</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Data;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Line==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteCommand(<span class="number">0x80</span>|(Column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> Char)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line">LCD_WriteData(Char);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_RS=<span class="number">0</span>;</span><br><span class="line">LCD_RW=<span class="number">0</span>;</span><br><span class="line">LCD_DataPort=Command;</span><br><span class="line">LCD_E=<span class="number">1</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">LCD_E=<span class="number">0</span>;</span><br><span class="line">LCD_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">int</span> X,<span class="type">int</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">int</span> Result=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Y;i++)</span><br><span class="line">&#123;</span><br><span class="line">Result*=X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Number1;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">if</span>(Number&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">Number1=Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">Number1=-Number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number1/LCD_Pow(<span class="number">10</span>,i<span class="number">-1</span>)%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> SingleNumber;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">SingleNumber=Number/LCD_Pow(<span class="number">16</span>,i<span class="number">-1</span>)%<span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span>(SingleNumber&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+SingleNumber);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;A&#x27;</span>+SingleNumber<span class="number">-10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Line,<span class="type">unsigned</span> <span class="type">char</span> Column,<span class="type">unsigned</span> <span class="type">int</span> Number,<span class="type">unsigned</span> <span class="type">char</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">LCD_SetCursor(Line,Column);</span><br><span class="line"><span class="keyword">for</span>(i=Length;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WriteData(<span class="string">&#x27;0&#x27;</span>+Number/LCD_Pow(<span class="number">2</span>,i<span class="number">-1</span>)%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202312062139022.png" alt="image-20231206213916889"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LCD接口（附8051LCD1602显示：源码＋原理图）&quot;&gt;&lt;a href=&quot;#LCD接口（附8051LCD1602显示：源码＋原理图）&quot; class=&quot;headerlink&quot; title=&quot;LCD接口（附8051LCD1602显示：源码＋原理图）&quot;&gt;&lt;/a&gt;LC</summary>
      
    
    
    
    
    <category term="单片机" scheme="https://rozen12123.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>电磁场总结</title>
    <link href="https://rozen12123.github.io/posts/aef64dc0.html"/>
    <id>https://rozen12123.github.io/posts/aef64dc0.html</id>
    <published>2023-10-03T08:56:55.000Z</published>
    <updated>2023-10-18T09:06:47.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场原理"><a href="#电磁场原理" class="headerlink" title="电磁场原理"></a>电磁场原理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场原理&quot;&gt;&lt;a href=&quot;#电磁场原理&quot; class=&quot;headerlink&quot; title=&quot;电磁场原理&quot;&gt;&lt;/a&gt;电磁场原理&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>单片机</title>
    <link href="https://rozen12123.github.io/posts/7f705d57.html"/>
    <id>https://rozen12123.github.io/posts/7f705d57.html</id>
    <published>2023-09-19T09:25:44.000Z</published>
    <updated>2023-10-26T14:29:25.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h1><h2 id="进制转换及其加减法，补码"><a href="#进制转换及其加减法，补码" class="headerlink" title="进制转换及其加减法，补码"></a>进制转换及其加减法，补码</h2><p>2，4，88，10，16进制之间的相互转化，具体内容见逻辑设计</p><h2 id="数学基础知识"><a href="#数学基础知识" class="headerlink" title="数学基础知识"></a>数学基础知识</h2><ol><li><p>数据大小</p><ol><li><p>储存容量是衡量微机内部储存器能储存二进制（Bit）信息量大小的一个技术指标</p></li><li><p>8位二进制数据称为一个字节（Byte）——最基本的计量单位，记为1B</p></li><li><p>16位二级制数据称为一个字（word）</p></li><li><p>32位二进制数据称为一个双字（Dword）</p><script type="math/tex; mode=display">2^{10}B=1KB,2^{10}KB=1MB,2^{10}MB=1GB,2^{10}GB=1TB</script></li></ol></li><li><p>只读存储器（ROM）</p><p>ROM是一种掉电后不丢失信息的储存器。由于这个原因，ROM也成为非易失性存储器。</p><p>&nbsp;</p><p>结构和容量</p><p>给定储存器芯片有12个地址引脚和4个数据引脚，此储存芯片有4096个位置（$2^{12}=4096$），每个位置能储存4位数据，所以<code>结构</code>就是4096×4，也常用4K×4表示。其<code>容量</code>是16Kb，因为总共是4K个位置，每个位置能保存4位数据</p><p>&nbsp;</p><p>一个容量是512K储存器芯片有8个数据引脚，请找出：（a）组织结构；（b）这个储存芯片的地址引脚数</p><p>（a）8个数据引脚可以保存8位数据，为了找出这个储存器芯片的位置数，需要用数据引脚数去除容量。512K/8=64K；所以储存芯片的组织结构是64K×8</p><p>（b）芯片有16根地址线，因为$2^{16}=64K$</p></li><li><p>随机访问储存器（RAM）</p><p>储存计算机运行中暂停的项目，当电脑关机时数据会丢失</p></li><li><p>总线设计</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306714.png" alt="image-20231019221602733"></p><ol><li><p>地址总线</p><p>cpu地址总线的数目决定了能与cpu进行通信的位置数，位置数通常等于$2^x$，x是地址线的数目。</p><p>每个位置最多可以有一个字节的数据，不用考虑数据总线的大小。</p><p>地址总线是单向的。</p><p>地址总线使用得越多，外设使用越多。</p></li><li><p>数据总线</p><p>数据总线是双向的，因为CPU需要使用它们接收和发送数据。使用的数据总线越多，CPU效率越高。</p></li><li><p>控制总线</p><p>向设备提供读取或写入信号，以提示CPU是否正在请求信息。</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVR0,#66H</span><br><span class="line">MOVR3,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH0</span><br><span class="line">PUSH3</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR3,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP3</span><br><span class="line">POP7</span><br><span class="line">POP0</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>pop代表把栈顶的值赋值给r几</p><p>例如pop 3就是把栈顶的值赋值给R3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ORG0</span><br><span class="line">MOVSP,#70H</span><br><span class="line">MOVR5,#66H</span><br><span class="line">MOVR2,#7FH</span><br><span class="line">MOVR7,#5DH</span><br><span class="line">PUSH5</span><br><span class="line">PUSH2</span><br><span class="line">PUSH7</span><br><span class="line">CLRA</span><br><span class="line">MOVR2,A</span><br><span class="line">MOVR7,A</span><br><span class="line">POP7</span><br><span class="line">POP2</span><br><span class="line">POP5</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>&amp;nbsp</p><h2 id="8051系统概述"><a href="#8051系统概述" class="headerlink" title="8051系统概述"></a>8051系统概述</h2><h3 id="8051控制器的内部框图"><a href="#8051控制器的内部框图" class="headerlink" title="8051控制器的内部框图"></a>8051控制器的内部框图</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306716.png" alt="image-20231019213820890"></p><h3 id="8501的主要特性"><a href="#8501的主要特性" class="headerlink" title="8501的主要特性"></a>8501的主要特性</h3><div class="table-container"><table><thead><tr><th>特性</th><th>数量</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td></tr><tr><td>RAM</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td></tr><tr><td>串行端口</td><td>1</td></tr><tr><td>中断源</td><td>6</td></tr></tbody></table></div><h3 id="8051及其成员对比"><a href="#8051及其成员对比" class="headerlink" title="8051及其成员对比"></a>8051及其成员对比</h3><div class="table-container"><table><thead><tr><th>特性</th><th>8051</th><th>8052</th><th>8031</th></tr></thead><tbody><tr><td>ROM</td><td>4KB</td><td>8K</td><td>0K</td></tr><tr><td>RAM</td><td>128KB</td><td>256KB</td><td>128KB</td></tr><tr><td>定时器</td><td>2</td><td>3</td><td>2</td></tr><tr><td>I/O引脚</td><td>32</td><td>32</td><td>32</td></tr><tr><td>串行端口</td><td>1</td><td>1</td><td>1</td></tr><tr><td>中断源</td><td>6</td><td>8</td><td>6</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><p>大多数的8051单片机的寄存器是8位的，所以也叫8051为8位单片机</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306717.png" alt="image-20231019195634248" style="zoom:67%;"></p><p>8051中常用的寄存器有A（累加器）、B、RO、R1、R2、R3、R4、R5、R6、R7、DPTR（数据指针）以及PC（程序计数器）寄存器。除DPTR和程序计数器是16位外，以上寄存器都是8位。</p><p>&nbsp;</p><h3 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV 目的操作数，源操作数</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306718.png" alt="image-20231019200313361"></p><p>1.可直接将数值装载到A、B或R0~R7的任意意一个寄存器当中。然而，为表示装载的是立即数，必须在数值前加上符号（#），如下：</p><p>2.如果将0～F的值装载到8位寄存器中，则其余的位就默认为0.例如，对于指今MOV&ensp; A，#5”而言，结果是A=05，用二进制表示就是A=00000101。</p><p>3.装载太大的值到寄存器中时会出错。（装载的值超过八位）</p><p>4.将数值装载到寄存器中时，必须在数值前加上符号（#），否则就表示装载的是存储器中的数。例如，MOV &ensp;A，17H”指令代表的就是将存储单元17H中的数装载到A中，结果就是任意值。</p><p>&nbsp;</p><h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD A,源操作数；</span><br></pre></td></tr></table></figure><p>指令中的源操作数即可以是寄存器，也可以是立即数；</p><p>寄存器A必须存在于任何的算数运算中，但其只能是任何算术运算中的目的操作数而不能是源操作数。</p><p>&nbsp;</p><h3 id="8051汇编语言简介"><a href="#8051汇编语言简介" class="headerlink" title="8051汇编语言简介"></a>8051汇编语言简介</h3><p>1.汇编语言程序由一连串的汇编指令组成</p><p>2.一条汇编指令由4个字段组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[标签:]  助记符  [操作数]  [;注释] </span><br></pre></td></tr></table></figure><p>助记符即为指令</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306719.png" alt="image-20231019201422708" style="zoom:67%;"></p><p>3.方框号代表里面的字段是可选的，不是每条指令都必须包含</p><p>4.ADD和MOV就是助记符，即产生操作码的部分。ORG和END就是伪代码（指示符），这些指示符不产生任何机器代码（操作码），仅供汇编使用。</p><p>&nbsp;</p><p>8051中的程序计数器和ROM空间</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306720.png" alt="image-20231019202019120" style="zoom:67%;"></p><p>1.编写汇编语言需要将汇编程序写好写入asm文件中</p><p>2.asm源文件被送入8051汇编器，汇编器将指令换成机器代码，然后产生目标文件（obj）和列表（lst）文件</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306721.png" alt="image-20231019202418301" style="zoom:67%;"></p><p>3.汇编器的第三步是链接：链接程序接受一个或多个目标文件并生成带有扩展名”abs”的绝对目标文件</p><p>4.将“abs”文件送入名为”OH”的程序（目标文件转16进制）中,从而产生即将烧入ROM中的扩展名位”hex”的文件。</p><ul><li>DOS EDIT编辑器产生asm文件</li><li>8051编译器产生obj和lst文件</li><li>链接器程序产生abs文件</li><li>OH程序产生HEX文件</li></ul><p>&nbsp;</p><h3 id="8051中的程序计数器和ROM空间"><a href="#8051中的程序计数器和ROM空间" class="headerlink" title="8051中的程序计数器和ROM空间"></a>8051中的程序计数器和ROM空间</h3><h4 id="8051中的程序计数器（PC）"><a href="#8051中的程序计数器（PC）" class="headerlink" title="8051中的程序计数器（PC）"></a>8051中的程序计数器（PC）</h4><ol><li>程序计数器指向下一条将执行指令的地址。</li><li>当CPU从程序ROM中得到操作码时，程序计数器就会自动增加并指向下一条指令</li><li>8051中的程序计数器为16位，能访问的程序地址范围是0000H～FFFFH，共64KB代码。</li></ol><h4 id="上电8051唤醒的位置"><a href="#上电8051唤醒的位置" class="headerlink" title="上电8051唤醒的位置"></a>上电8051唤醒的位置</h4><ol><li>当上电后，8051程序计数器中的值就是0000，就表示第一个操作码存储在ROM地址0000H中。</li><li>8051系统中，第一个操作码就必须烧人程序ROM的存储位置0000H中，因为这是启动后它寻找第一条指令的位置。</li></ol><p>&nbsp;</p><h3 id="8051数据类型和指令"><a href="#8051数据类型和指令" class="headerlink" title="8051数据类型和指令"></a>8051数据类型和指令</h3><h4 id="BD"><a href="#BD" class="headerlink" title="BD"></a>BD</h4><p>DB指令是汇编器中使用最广泛的数据指示符之一，它用于定义8位数据。</p><p>十进制后面的D是可选的，但是二进制的B和十六进制的H是必须加的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306722.png" alt="image-20231019204830206"></p><h4 id="汇编指示符"><a href="#汇编指示符" class="headerlink" title="汇编指示符"></a>汇编指示符</h4><p>1.ORG：用于ROM中表示起始地址</p><p>2.EQU：用于定义常量，但是不占用系统空间</p><p>3.END：告诉汇编器源文件（asm）末尾所处的位置。END指令是8051程序的最后一位，意味着END指令之后的源代码都会被汇编器忽略。</p><p>&nbsp;</p><h3 id="8051标志位和PSW寄存器"><a href="#8051标志位和PSW寄存器" class="headerlink" title="8051标志位和PSW寄存器"></a>8051标志位和PSW寄存器</h3><p>8051中也有表示算数运算状态的标志寄存器，如<code>进位标志</code>。</p><p>8051中的标志寄存器叫做<code>程序状态字（PSW）寄存器</code></p><h4 id="PSW（程序状态字）寄存器"><a href="#PSW（程序状态字）寄存器" class="headerlink" title="PSW（程序状态字）寄存器"></a>PSW（程序状态字）寄存器</h4><p>PSW寄存器是一个8位寄存器，也叫标志寄存器，但是在8051中，PSW只用了6位，剩余两位是用户自定义标志位。</p><p>6为中有4位是<code>状态标志位</code>也就是一些指令执行后的结果状态，分别是CY（进位）、AC（辅助进位）、P（奇偶校验位）以及OV（溢出位）</p><p>PSW.3和PSW.4位被分别设计为了RS0和RS1，用于选择组寄存器。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306723.png" alt="image-20231019210419646"></p><p>PSW.5和PSW.1是通用状态标志位，供程序员使用。</p><div class="table-container"><table><thead><tr><th>名称</th><th>位置</th><th>解释</th></tr></thead><tbody><tr><td>CY</td><td>PSW.7</td><td>进位标志</td></tr><tr><td>AC</td><td>PSW.6</td><td>辅助进位标志</td></tr><tr><td>F0</td><td>PSW.5</td><td>可用于用户的通用目的</td></tr><tr><td>RS1</td><td>PSW.4</td><td>寄存器组选择器位1</td></tr><tr><td>RS0</td><td>PSW.3</td><td>寄存器组选择器位0</td></tr><tr><td>OV</td><td>PSW.2</td><td>溢出标志</td></tr><tr><td>—</td><td>PSW.1</td><td>用户可定义位</td></tr><tr><td>P</td><td>PSW.0</td><td>奇偶标志。通过硬件每条指令周期设置/清0                     来指明是累加器中的奇/偶位数。</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306724.png" alt="image-20231019210748792"></p><p>&nbsp;</p><h4 id="ADD指令和PSW"><a href="#ADD指令和PSW" class="headerlink" title="ADD指令和PSW"></a>ADD指令和PSW</h4><p>分析ADD指令对PSW寄存器中CY、AC以及P标志位的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV A,#38H</span><br><span class="line">MOV A,#2FH</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201518418.png" alt="image-20231020151833345"></p><p>相加之后：CY=0，因为D7位没有进位。</p><p>AC=1，因为有来自D3到D4位的进位</p><p>P=1，因为累加器有奇数个1（5个1）</p><p>&nbsp;</p><h3 id="8051寄存器组和栈"><a href="#8051寄存器组和栈" class="headerlink" title="8051寄存器组和栈"></a>8051寄存器组和栈</h3><p>8051微控制器中共有128个字节的RAM</p><h4 id="8051中的RAM存储分配"><a href="#8051中的RAM存储分配" class="headerlink" title="8051中的RAM存储分配"></a>8051中的RAM存储分配</h4><p>8051中有128个字节的RAM（一些成员，如8052，有256个字节的RAM），其所分配的地址范围是00~7FH。它们可直接作为存储器位置进行访问。这128个字节可分成如下三部分：</p><ol><li>从00至1F（十六进制）共有32个字节用于寄存器组和栈</li><li>从20H至2FH共有16个字节用于位可寻址读/写存储器。</li><li>从30H至7FH共有80个字节用于读/写存储，也通常称为高速暂存器（scratch pad）。这80个RAM位置被8051程序员广泛应用于存储数据以及相关参数中。</li></ol><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201525443.png" alt="image-20231020152516334" style="zoom:67%;"></p><p>第一组寄存器与栈使用的是同样的RAM空间。这点在8051编程时尤其要注意，要么回避使用第第一组寄存器，要要么分配另一块RAM区域给栈。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201528790.png" alt="image-20231020152841693" style="zoom:67%;"></p><p>&nbsp;</p><h4 id="默认寄存器组"><a href="#默认寄存器组" class="headerlink" title="默认寄存器组"></a>默认寄存器组</h4><p>如果RAM位置00～1F地址被用于四个寄存器组，那么上电后可以访问的R0～R7的寄存器组就是<code>寄存器组0</code>也就是说，当编写8051程序时，RAM位置0、1、2、3、4、5、6和7分别被名字为R0、R1、R2、R3、R4、R5、R6以及R7的符号进行访问。使用R0、R1等名字来访问RAM位置地址相比于用存储器位置访问容易得多。</p><p>&nbsp;</p><h4 id="如何切换寄存器组"><a href="#如何切换寄存器组" class="headerlink" title="如何切换寄存器组"></a>如何切换寄存器组</h4><p>8051上电后，默认寄存器组的是寄存器组0.但我们可以通过使用PSW寄存器切换到其他的寄存器组。PSW的D4位和D3位用于选择需要的寄存器组.。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310192306724.png" alt="image-20231019210748792"></p><p>&nbsp;</p><h4 id="8051中的堆"><a href="#8051中的堆" class="headerlink" title="8051中的堆"></a>8051中的堆</h4><p>栈是RAM中的一段空间，为CPU暂时存储信息。这些信息可以是数据或是地址。CPU需要该存储区域是因为寄存器数目有限。</p><p>&nbsp;</p><h4 id="8051如何访问栈"><a href="#8051如何访问栈" class="headerlink" title="8051如何访问栈"></a>8051如何访问栈</h4><p>​    如果栈是RAM的一段空间，CPU中就必须有指向这段空间的寄存器。用于访问栈的寄存器称为<code>SP（栈指针）寄存器</code>。8051中的栈指针仅8位宽，这就意味能得到的值的范围是00～FFH。</p><p>​    当8051上电后，SP寄存器的值是07(因为默认寄存器组1的第一位为8)，就意味着RAM位置08是8051栈的第一个位置。</p><p>​    将CPU寄存器中的值存人栈称为PUSH（压栈），从栈中取出值放入寄存器中称为POP（出栈），也就是说，一个寄存器被压人栈中就是保存数据，而从栈中弹出则是重新得到该数据。当进行压栈和出栈的操作时，SP的作用很重要。</p><p>&nbsp;</p><h4 id="压栈（push）"><a href="#压栈（push）" class="headerlink" title="压栈（push）"></a>压栈（push）</h4><p>在8051中，栈指针指向栈的最后一个位置。如果将数据压入栈中，栈指针就自增1。</p><p>例如：PUSH&ensp;1；就是将R1中的数据压入堆栈中（第一次位置为08，压入后的位置是09）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVR6，#25H</span><br><span class="line">MOVR1，#12H</span><br><span class="line">MOVR4，#0F3H</span><br><span class="line">PUSH6</span><br><span class="line">PUSH1</span><br><span class="line">PUSH4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201543123.png" alt="image-20231020154319025"></p><h4 id="出栈（POP）"><a href="#出栈（POP）" class="headerlink" title="出栈（POP）"></a>出栈（POP）</h4><p>​    每次弹出时，栈顶的字节会压入到所写寄存器中，同时栈指针自减一次。</p><p>​    例如：POP&emsp;3；就是将栈顶指针对应的字节压入R3中。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201545056.png" alt="image-20231020154538961"></p><p>&nbsp;</p><h4 id="栈上限"><a href="#栈上限" class="headerlink" title="栈上限"></a>栈上限</h4><p>​    8051的RAM位置地址范围08～1F用于栈，这是因为RAM位置地址20-2FH只能用于位可寻址存储，而不能用于栈。</p><p>​    如果某程序需要大于24字节（08～1FH=24字节）的栈，则可以改变SP指向RAM中30~7FH的位置。完成此操作的指令是：MOV &emsp;SP,#xx</p><p>&nbsp;</p><h4 id="栈和寄存器组1的冲突"><a href="#栈和寄存器组1的冲突" class="headerlink" title="栈和寄存器组1的冲突"></a>栈和寄存器组1的冲突</h4><p>默认的寄存器组为寄存器0，默认栈的起始点为寄存器1的R0。</p><p>寄存器组1和栈使用的是同样的存储空间。如果一个程序需要使用寄存器组1和组2时，就必须重新分配RAM空间给栈。例如，可分配RAMM位置地址60H甚至更高的位置地址给栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOVSP,#5FH;RAM位置地址60H,即栈的第一个位置</span><br><span class="line"></span><br><span class="line">MOVR2,#25H</span><br><span class="line">MOVR1,#12H</span><br><span class="line">MOVR4,#0F3H</span><br><span class="line">PUSH2</span><br><span class="line">PUSH1</span><br><span class="line">PUSH4</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201602225.png" alt="image-20231020160228129" style="zoom:67%;"></p><h4 id="提高CPU效率的方法"><a href="#提高CPU效率的方法" class="headerlink" title="提高CPU效率的方法"></a>提高CPU效率的方法</h4><p>微处理器设计者可使用三种方法来提高CPU的处理效率。</p><ol><li>增加芯片的时钟频率。这种方法的缺点是：频率越高，则功耗和热损耗就越大，功耗和散热对掌上型设备尤其是大问题。</li><li>.通过增加导线成为哈佛体系结构，从而将更多的信息（代码和数据）装载到CPU中处理。而在x86和一些通用微处理器中，哈佛体系结构价格昂贵且不切实际，但是在今天的单芯片计算机中（微控制器），这已不是问题。</li><li>改变CPU的内部结构，使用RISC结构。</li></ol><p>&nbsp;</p><h2 id="跳转、循环和调用指令"><a href="#跳转、循环和调用指令" class="headerlink" title="跳转、循环和调用指令"></a>跳转、循环和调用指令</h2><h3 id="8051中的循环"><a href="#8051中的循环" class="headerlink" title="8051中的循环"></a>8051中的循环</h3><p>​    在8051中，循环操作通过指令“DJNZ &emsp;reg,label”来实现。该指令中，寄存器递减，如果非零，则跳转至标签所示的目标地址。在循环开始之前，寄存器预存人循环次数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201646151.png" alt="image-20231020164656061" style="zoom:67%;"></p><p>上诉代码所实现的功能为：</p><ol><li>累加器清零</li><li>将3加入累加器中10次</li></ol><p>注意：上述代码以R2为累加器，而R2为8位寄存器，它能储存的最大值为FHH（十进制的255），因此每次循环的最多次数也为256，如需更多的循环则需要进行循环的嵌套。</p><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201651505.png" alt="image-20231020165110399"></p><p>上述代码实现的功能：</p><ol><li>将数55H存入累加器ACC中</li><li>对累加器ACC执行700次取补码。</li></ol><p>&nbsp;</p><h4 id="其他条件跳转指令"><a href="#其他条件跳转指令" class="headerlink" title="其他条件跳转指令"></a>其他条件跳转指令</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201652828.png" alt="image-20231020165231702"></p><p>注意：重点记忆<code>JZ</code>和<code>JNC</code></p><p>&nbsp;</p><h4 id="所有的条件跳转指令都是短跳转指令"><a href="#所有的条件跳转指令都是短跳转指令" class="headerlink" title="所有的条件跳转指令都是短跳转指令"></a>所有的条件跳转指令都是短跳转指令</h4><p>​    必须指出，所有的条件跳转指令都是短跳转指令，也就是说，跳转指令的目标地址必须在程序计数器（PC）的-128~+127字节之内。</p><p>&nbsp;</p><h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p>无条件跳转指令是一种不需要任何条件，程序就可以跳转到目标地址的指令。</p><p>在8051中，这样的指令有两种：长跳转（LJMP）指令和短跳转（SJMP）指令</p><h5 id="LJMP（长跳转指令）"><a href="#LJMP（长跳转指令）" class="headerlink" title="LJMP（长跳转指令）"></a>LJMP（长跳转指令）</h5><p>它是一个3字节指令，其中第一个字节是操作码，第二个和第三个字节表示16位目标地址。2字节的目标地址允许程序在存储单元00000H~FFFFH中任意跳转。</p><h5 id="SJMP（短跳转指令）"><a href="#SJMP（短跳转指令）" class="headerlink" title="SJMP（短跳转指令）"></a>SJMP（短跳转指令）</h5><p>它是一个2字节指令，第一个字节是操作码，第二个字节是目标地址的相对跳转地址。相对跳转地址的范围为00H~FFH，相对跳转地址又分为前向跳转地址和后向跳转地址，即在相对于当前PC地址的-128～+127字节存储器范围内。如果是前向跳转地址，则目标地址可以在距当前PC的127字节范围内；如果是后向跳转地址，则目标地址可以在距当前PC的-128字节范围内。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="调用指令"><a href="#调用指令" class="headerlink" title="调用指令"></a>调用指令</h3><p>​    另一个控制跳转指令是CALL指令，该指令用于调用子程序。子程序常用于完成经常实现的任务。这样做不仅可以节省存储器空间，而且让程序更加结构化。在8051系列中，有两种调用指令：长调用（LCALL）指令及绝对调用（ACALL）指令。</p><h4 id="LCALL-长调用指令"><a href="#LCALL-长调用指令" class="headerlink" title="LCALL(长调用指令)"></a>LCALL(长调用指令)</h4><p>它是一个3字节指令，其中第一个字节是操作码，第二个和第三个字节是子程序人口地址。因此，长调用指令可以调用存放在8051中64KB程序存储器任意位置的子程序。</p><p>为保证8051在调用子程序执行结束后能够知道返回到哪里并继续执行，处理器自动将长跳转指令的下一条指令地址保存到栈中。当一个子程序被调用时，控制器跳转到该子程序，并且处理器将PC值保存到栈中，同时开始获取一条新的指令地址。当子程序执行结束时，返回指令RET将控制器返回到调用位置。</p><p>==每一个子程序都需要一条返回指令作为结束。==</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201709397.png" alt="image-20231020170936284"></p><p>RET指令的功能是将地址从栈中弹出并放入程序计数器中，从而恢复执行在CALL指令之后的指令。</p><p>&nbsp;</p><h4 id="ACALL-绝对调用指令"><a href="#ACALL-绝对调用指令" class="headerlink" title="ACALL(绝对调用指令)"></a>ACALL(绝对调用指令)</h4><p>由于ACALL是2字节指令，子程序的目标地址就必须在2KB字节范围内，这是因为2字节中只有11位表示地址。</p><p>&nbsp;</p><h3 id="8051芯片的延时"><a href="#8051芯片的延时" class="headerlink" title="8051芯片的延时"></a>8051芯片的延时</h3><h4 id="8051的机器周期"><a href="#8051的机器周期" class="headerlink" title="8051的机器周期"></a>8051的机器周期</h4><p>​    CPU执行指令时须花费一定的时钟周期，8051系列中，这些时钟周期就叫做机器周期（machine cycle,MC）。</p><p>​    最原始的8051中，1个机器周期可占用12个振荡器（时钟）周期。因此，要想计算8051的机器周期，我们采用1/12的晶振频率，然后再取倒数。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201718902.png" alt="image-20231020171851810"></p><p>在一个时钟周期内，能运行的机器周期越多，当然效率就越高，如上图，从上到下机器运行的效率是逐渐增加的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201720110.png" alt="image-20231020172032002"></p><p>&nbsp;</p><h4 id="8051的延时计算"><a href="#8051的延时计算" class="headerlink" title="8051的延时计算"></a>8051的延时计算</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201723498.png" alt="image-20231020172335390"></p><p>DELAY的子程序一般由两部分构成：</p><ol><li>计数器设置</li><li>延时</li></ol><p>增加延时时间的一种方式是在循环中使用NOP指令。NOP表示“空操作”，简单地浪费时间。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201726403.png" alt="image-20231020172624264"></p><h4 id="循环内套用循环延时"><a href="#循环内套用循环延时" class="headerlink" title="循环内套用循环延时"></a>循环内套用循环延时</h4><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201730434.png" alt="image-20231020173008270"></p><h4 id="关于各种IC的延时计算"><a href="#关于各种IC的延时计算" class="headerlink" title="关于各种IC的延时计算"></a>关于各种IC的延时计算</h4><ol><li>根据时钟周期与机器周期的比计算出，结合晶振频率计算出运行一个机器周期所需要的时间</li><li>计算延时函数中所运行机器周期的个数</li><li>如果是单个循环，则计算出的时间=循环所需的时间＋循环外的指令运行时间；如果是嵌套循环，延时时间=内循环时间＋外循环时间。它与所有其他延时循环一样，对它的延时计算只是约数，因为忽略了子程序的第一条及最后一条指令所产生的延时。</li></ol><p>&nbsp;</p><h4 id="使用-符号和SSJMP表示跳转到自身"><a href="#使用-符号和SSJMP表示跳转到自身" class="headerlink" title="使用$符号和SSJMP表示跳转到自身"></a>使用$符号和SSJMP表示跳转到自身</h4><p>如果芯片中不存在要监视的程序，就需要使用跳转到自身指令使得微控制器不处于空闲状态。简单的做法是在JUMP后面写上$符号，代表跳转的位置也就是如下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HERE:SJMPHERE</span><br></pre></td></tr></table></figure><p>也可以如下使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SJMP$</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="8051的I-O端口编程"><a href="#8051的I-O端口编程" class="headerlink" title="8051的I/O端口编程"></a>8051的I/O端口编程</h2><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201812908.png" alt="image-20231020181205765"></p><p>8051中一共有4个端口可以进行I/O操作，即P0-P3，每个端口有8个引脚。</p><p>8051有40个引脚，其中32个引脚属于4个端口，余下的引脚分别是$V_{cc}$​,GND，XTAL1，XTAL2，RST，EA，ALE/PROG和PSEN。</p><p>&nbsp;</p><h3 id="I-O端口引脚及其功能"><a href="#I-O端口引脚及其功能" class="headerlink" title="I/O端口引脚及其功能"></a>I/O端口引脚及其功能</h3><p>所有端口在RESET（复位）时都配置成输入，并准备用作输入。</p><p>当第一个0写入某端口时，该端口便成为输出。若将该端口重新配置成输入，则必须将1送入该端口。若想将任何端口用做输入端口，则必须编程。</p><p>&nbsp;</p><h3 id="将个位读入进位标志"><a href="#将个位读入进位标志" class="headerlink" title="将个位读入进位标志"></a>将个位读入进位标志</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310261952404.png" alt="image-20231026195225266"></p><h4 id="读取输出端口锁存内容"><a href="#读取输出端口锁存内容" class="headerlink" title="读取输出端口锁存内容"></a>读取输出端口锁存内容</h4><p>有些指令读取的是内部端口锁存内容而不是外部引脚的状态。如“ANL &amp;&emsp;P1，A”，执行该指令时会产生如下一系列的动作：</p><p>1.读取端口内部锁存内容，并将该数据传送给CPU。</p><p>2.将这些数据与寄存器A中的内容相与。</p><p>3.结果写入端口锁存。<br>4.端口引脚数据改变，内容与端口锁存内容一致。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="80511寻址方式"><a href="#80511寻址方式" class="headerlink" title="80511寻址方式"></a>80511寻址方式</h2><p>​    CPU可使用多种方式访问数据。数据可存放在寄存器、存储器中，或者以立即数的形式存在。访问这些数据的不同方法称为寻址方式（addressing&emsp;modes)。</p><p>8051共提供5种寻址方式，如下:</p><p>1.立即寻址方式；<br>2.寄存器寻址方式；<br>3.直接寻址方式；<br>4.寄存器间接寻址方式；<br>5.变址寻址方式</p><p>&nbsp;</p><h3 id="立即寻址方式"><a href="#立即寻址方式" class="headerlink" title="立即寻址方式"></a>立即寻址方式</h3><p>直接将源操作数加载至任意寄存器，注意：立即数必须加前缀“#”</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262002698.png" alt="image-20231026200259601"></p><h3 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h3><p>寄存器寻址方式是将寄存器中的内容加载到另一个寄存器中，而不是操作数本身。如下所示：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262004330.png" alt="image-20231026200404238"></p><p>&nbsp;</p><h3 id="直接寻址方式"><a href="#直接寻址方式" class="headerlink" title="直接寻址方式"></a>直接寻址方式</h3><p>1.RAM地址00～1FH分配给寄存器组和栈。</p><p>2.RAM地址20-2FH用于位可寻址空间保存单点数据。</p><p>3.RAM地址30~7FH用于保存字节数据。</p><p>使用直接寻址方式可以访问RAM的128字节，但通常情况下它只访问RAM地址30～7FH空间，这是因为寄存器组位置由名为RO～R7的寄存器访问，而RAM中除了寄存器空间之外再没有对应的名字。</p><p>在直接寻址方式中，存放在RAM存储器中的数据对应的地址就是指令中给出的地址。而在立即寻址方式中，指令执行的数据就是操作数本身。是否有前缀“#”是两种寻址方式的主要区别。如下例所示（注意没有百“#标志）:</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262006324.png" alt="image-20231026200609232"></p><p>&nbsp;</p><h4 id="SFR寄存器"><a href="#SFR寄存器" class="headerlink" title="SFR寄存器"></a>SFR寄存器</h4><p>在8051单片机中，寄存器A、B、PSW和DPTR通常称为SFR（特殊功能寄存器）</p><p>关于SFR地址，需注意以下两点:<br>1.特殊功能寄存器地址范围是80H～FFH。地址大于80H的原因是00H～7FH地址属于8051内部RAM。<br>2.不是80H～FFH范围中的所有地址都用于SFR。未使用的保留，且不可被8051程序员使用。</p><p>&nbsp;</p><h3 id="寄存器间接寻址方式"><a href="#寄存器间接寻址方式" class="headerlink" title="寄存器间接寻址方式"></a>寄存器间接寻址方式</h3><p>在寄存器间接寻址方式中，寄存器可作为数据指针。若数据存在于CPU内部，则只能使用寄存器R0或R1将数据取出。当R0和R1用作指针保存RAM中的数据地址时，则须加上前级“@标志，如下所示:</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262009654.png" alt="image-20231026200946568"></p><p>简单解释是将一个寄存器中数据的地址加载到另一个寄存器中。而不是数据本身。</p><p>如上，我们如果不佳@，那么就会将后面寄存器中的数据进行操作，而不是地址。</p><p>&nbsp;</p><h3 id="变址寻址方式"><a href="#变址寻址方式" class="headerlink" title="变址寻址方式"></a>变址寻址方式</h3><p>​    变址寻址方式广泛用于访间8051单片机的ROM空间的查找表入口数据，指令是“MOVC &emsp;A，@A+DPTR”。16位的寄存器DPTR和寄存器A存放在片上ROM中的数据元素地址，因为数据元素存放在8051ROM代码区，所以使用指令MOV&emsp;C，而不是MOV。“C”指代码。该指令将寄存器A中的内容与16位寄存器DPTR中的内容相加，形成所需数据的16位地址,如下所示：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262016423.png" alt="image-20231026201652253"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262019170.png" alt="image-20231026201946030"></p><p>&nbsp;</p><h3 id="算术逻辑指令与程序"><a href="#算术逻辑指令与程序" class="headerlink" title="算术逻辑指令与程序"></a>算术逻辑指令与程序</h3><p>在8051中，为了将数值相加，就必须使用累加器（寄存器A），ADD指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD A，源操作数;A = A + 源操作数</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="ADD指令-1"><a href="#ADD指令-1" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD指令的功能是将两个操作数相加，通常，目的操作数是寄存器A中的内容，而源操作数可以是立即数、寄存器中的内容或存储器中的内容。请记住，在8051汇编算术操作中不允许存储器-存储器式的操作。指令的执行将影响标志位AC、CY和P，这取决于执行的操作数。溢出标志位OV只有带符号数运算时才受影响。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262117746.png" alt="image-20231026211723672"></p><p>&nbsp;</p><h3 id="ADDC以及16位数加法"><a href="#ADDC以及16位数加法" class="headerlink" title="ADDC以及16位数加法"></a>ADDC以及16位数加法</h3><p>当两个16位的操作数相加时，需注意进位。指令ADDC（带进位加法指令）自的功能就是把源操作数的内容和进位标志CY都加入累加器A中。如下是3CE7H+3B8DH的相加操作：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262120484.png" alt="image-20231026212033413"></p><p>&nbsp;</p><h3 id="DA指令"><a href="#DA指令" class="headerlink" title="DA指令"></a>DA指令</h3><p>8051中的DA（十进制加法调整）指令用于解决两个BCD码相加不是BCD码的问题。助记符有一个操作数，就是累加器“A当有必要时，DA指令将6加入低位或高位，否则就不干涉结果。如下所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262127068.png" alt="image-20231026212758013"></p><h4 id="DA操作总结"><a href="#DA操作总结" class="headerlink" title="DA操作总结"></a>DA操作总结</h4><p>只能在ADD或ADDC指令执行之后才能执行。<br>1.若低位（4位）大于9，或AC=1，就将0110加入低4位。<br>2.若高位（4位）大于9，或CY=1，就将0110加入高4位。<br>事实上，AC（辅助进位）标志位除了用于纠正BCD加法之外，并无其他用处。例如，相加29H和18H，结果是41H，但这对于BDC码来说是错误的。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262128952.png" alt="image-20231026212846867"></p><h3 id="无符号数相减"><a href="#无符号数相减" class="headerlink" title="无符号数相减"></a>无符号数相减</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBB A，源操作数;A = A - 源操作数 -CY</span><br></pre></td></tr></table></figure><h4 id="SUBB（带借位减法），CY-0"><a href="#SUBB（带借位减法），CY-0" class="headerlink" title="SUBB（带借位减法），CY=0"></a>SUBB（带借位减法），CY=0</h4><p>算术减法中，8051微处理器（几乎涵盖所有的CPU）采用的是补码的方法。每个CPU中都包含加法电路，而因为减法电路的设计复杂（占用太多晶体管），因此8051使用加法电路来实现减法。如果8051执行减法指令时，须预设置CY=0。CPU硬件执行SUBB无符号数减法指令的步骤如下。<br>1.得到减数源操作数的补码。<br>2.将值与被减数（A）相加。<br>3.进位反相。</p><h3 id="无符号数乘法和除法"><a href="#无符号数乘法和除法" class="headerlink" title="无符号数乘法和除法"></a>无符号数乘法和除法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL AB    ;AXB，将16位结果分别放入B和A</span><br></pre></td></tr></table></figure><p>字节乘法中，其中一个操作数须放人寄存器A中，而另一个操作数则须放在寄存器B中，相乘后，结果分别放人寄存器A和B中，寄存器A保存低位字节，寄存器B保存高位字节。如下所示：225H与65H相乘的结果是16位数据，分别存入寄存器A和B中，如表所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262209071.png" alt="image-20231026220940002"></p><p>&nbsp;</p><h4 id="无符号数相除"><a href="#无符号数相除" class="headerlink" title="无符号数相除"></a>无符号数相除</h4><p>字节相除时，分子必须放在寄存器A中，分母放在寄存器B中。除法指令完成之后，商存放入寄存器A中，余数存人寄存器B中。如下列代码和表6-3所示。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262211631.png" alt="image-20231026221104566"></p><p>&nbsp;</p><h3 id="CPL-A（累加器取反）"><a href="#CPL-A（累加器取反）" class="headerlink" title="CPL A（累加器取反）"></a>CPL A（累加器取反）</h3><p>此指令将寄存器内容的1变成0，反之亦然，所以称为取反（1’scomplement）。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310262228183.png" alt="image-20231026222810134"></p><p>&nbsp;</p><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>8051中含有比较指令。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CJNE 目的操作数,源操作数,相对地址</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单片机&quot;&gt;&lt;a href=&quot;#单片机&quot; class=&quot;headerlink&quot; title=&quot;单片机&quot;&gt;&lt;/a&gt;单片机&lt;/h1&gt;&lt;h2 id=&quot;进制转换及其加减法，补码&quot;&gt;&lt;a href=&quot;#进制转换及其加减法，补码&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>电磁场原理</title>
    <link href="https://rozen12123.github.io/posts/a3afa0e4.html"/>
    <id>https://rozen12123.github.io/posts/a3afa0e4.html</id>
    <published>2023-09-18T08:11:44.000Z</published>
    <updated>2023-09-25T09:16:34.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电磁场"><a href="#电磁场" class="headerlink" title="电磁场"></a>电磁场</h1><h2 id="矢量的基本概念"><a href="#矢量的基本概念" class="headerlink" title="矢量的基本概念"></a>矢量的基本概念</h2><h3 id="1-矢量的表示"><a href="#1-矢量的表示" class="headerlink" title="1.矢量的表示"></a>1.矢量的表示</h3><ol><li><p>图形表示</p></li><li><p>数学表示</p><script type="math/tex; mode=display">\vec{A}= \vec{a_A}\left | \vec{A} \right | = \vec{a_A}A</script></li><li><p>坐标分量表示法</p></li></ol><script type="math/tex; mode=display">\vec{A}= \vec{a_x}A_x(x,y,z)+\vec{a_y}A_y(x,y,z)+\vec{a_z}A_z(x,y,z)</script><p>$a_A$是沿A的方向且大小等于1的无量纲的单位矢量</p><p>&nbsp;</p><h3 id="2-矢量的加减"><a href="#2-矢量的加减" class="headerlink" title="2.矢量的加减"></a>2.矢量的加减</h3><p><img src="/posts/a3afa0e4.htm/image-20230918162802552.png" alt="image-20230918162802552" style="zoom:50%;"></p><p>矢量的运算规则（Operation rules）</p><p>1.加减运算</p><script type="math/tex; mode=display">\begin{array}{ll}a.&A+B=B+A\\ \\ b.&A+B+C=(A+B)+C=A+(B+C)\\ \\ c.&A-B=A+(-B)\end{array}</script><script type="math/tex; mode=display">d  .\quad \begin{array}{r l}{if \quad A=\boldsymbol{a}_{x}A_{x}(x,y,z)+\boldsymbol{a}_{y}A_{y}(x,y,z)+\boldsymbol{a}_{z}A_{z}(x,y,z)}\\ {B=\boldsymbol{a}_{x}B_{x}(x,y;z)+\boldsymbol{a}_{y}B_{y}(x,y,z)+\boldsymbol{a}_{z}B_{z}(x,y,z)}\\ \end{array}</script><p>then</p><script type="math/tex; mode=display">\begin{array}{l}A\pm B=\boldsymbol a_x(A_x\pm B_x)+\boldsymbol a_y(A_y\pm B_y)+\boldsymbol a_z(A_z\pm B_z)\\ cA=\boldsymbol a_x(cA_y)+\boldsymbol a_y(cA_y)+\boldsymbol a_z(cA_z)\end{array}</script><p>2.点乘运算</p><script type="math/tex; mode=display">A \bullet B = AB \cos \theta (\theta \leq \pi)</script><script type="math/tex; mode=display">\theta=\cos^{-1}\frac{A\bullet B}{AB}=\cos^{-1}\frac{A_{x}B_{x}+A_{y}B_{y}+A_{z}B_{z}}{AB}</script><p>3.叉乘运算（vector or cross product）</p><script type="math/tex; mode=display">C=|A\times B|=AB\sin\theta</script><p><img src="/posts/a3afa0e4.htm/image-20230918170905521.png" alt="image-20230918170905521" style="zoom:50%;"></p><p>注意：叉乘有顺序，不可以使用交换律</p><p>方向：右手定则</p><p><img src="/posts/a3afa0e4.htm/image-20230918170845402.png" alt="image-20230918170845402" style="zoom:50%;"></p><script type="math/tex; mode=display">A\times B=a_{x}(A_{y}B_{z}-A_{z}B_{y})+a_{y}(A_{z}B_{x}-A_{x}B_{z})+a_{z}(A_{x}B_{y}-A_{y}B_{x})=\begin{vmatrix}\boldsymbol{a}_x&\boldsymbol{a}_y&\boldsymbol{a}_z\\ A_x&A_y&A_z\\ B_x&B_y&B_z\end{vmatrix}</script><script type="math/tex; mode=display">\theta=\sin^{-1}\frac{\left|A\times B\right|}{A B}</script><p>4.三个矢量相乘</p><ol><li>模的几何意义是六面体的体积<script type="math/tex; mode=display">\mathbf{A}\bullet(\mathbf{B}\times\mathbf{C})=\mathbf{B}\bullet(\mathbf{C}\times\mathbf{A})=\mathbf{C}\bullet(\mathbf{A}\times\mathbf{B})</script></li></ol><ol><li>遵从Back-cab rule</li></ol><script type="math/tex; mode=display">\begin{array}{l}\textbf{A}\times(\textbf{B}\times\textbf{C})=\textbf{B}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{C})-\textbf{C}(\textbf{A}\textbf{}\textbf{}\textbf{}\textbf{}\textbf{B})\\  \textbf{D}=\textbf{B}\times\textbf{C}\qquad\textbf{F}=\textbf{A}\times(\textbf{B}\times\textbf{C})\end{array}</script><script type="math/tex; mode=display">\begin{aligned}F_x&=A_y D_z-A_z D_y\\ &=A_y(B_x C_y-B_y C_z)-A_z(B_z C_x-B_x C_z)\\ &=B_x(A_y C_y+A_zC_z)-C_x(A_y B_y+A_z B_z)\\ &=B_x(\textbf{A}\textbf{C})-C_x(\textbf{A}\textbf{B})\end{aligned}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="正交坐标系及其微分元（Orhogonal-coordinate-systems）"><a href="#正交坐标系及其微分元（Orhogonal-coordinate-systems）" class="headerlink" title="正交坐标系及其微分元（Orhogonal coordinate systems）"></a>正交坐标系及其微分元（Orhogonal coordinate systems）</h2><p>常用的正交曲线坐标系</p><ol><li>直角坐标系</li><li>圆柱坐标系</li><li>球坐标系</li></ol><p>坐标线（轴）：三个正交曲面两两相交而成的曲线</p><p>坐标原点（基准点）:三条坐标系的焦点</p><p>坐标单位矢量：空间任意一点与坐标线相切且指向变量增加方向的三个单位矢量</p><p>&nbsp;</p><h3 id="正交坐标系的微分元"><a href="#正交坐标系的微分元" class="headerlink" title="正交坐标系的微分元"></a>正交坐标系的微分元</h3><script type="math/tex; mode=display">\text{d}l=\left[(\text{d}l_1)^2+(\text{d}l_2)^2+(\text{d}l_3)^2\right]^{1/2}\\ =\left[(h_1\text{d}u_1)^2+(h_2\text{d}u_2)^2+(h_3\text{d}u_3)^2\right]^{1/2}</script><ol><li>Differential directed distance</li></ol><script type="math/tex; mode=display">   d\mathbf{1}=\mathbf{a}_{u1}dl_1+\mathbf{a}_{u2}dl_2+\mathbf{a}_{u3}dl_3</script><ol><li>Differential area<script type="math/tex; mode=display">\begin{aligned}ds_1&=dl_2dl_3&=h_2h_3ah_2dt_3\\ ds_2&=dl_1dl_3&=h_1h_3dh_1du_3\\ ds_3&=dl_1dl_2&=h_1h_2du_1du_2\end{aligned}</script></li></ol><ol><li>Differential volume</li></ol><script type="math/tex; mode=display">dv=h_1h_2h_3du_1du_2du_3</script><h4 id="1-直角坐标系（Cartesian-coordinates）"><a href="#1-直角坐标系（Cartesian-coordinates）" class="headerlink" title="1.直角坐标系（Cartesian coordinates）"></a>1.直角坐标系（Cartesian coordinates）</h4><script type="math/tex; mode=display">\text{(u}_1,\text{u}_2,\text{u}_3\text{)=(x,y,z)}</script><ol><li>线元<script type="math/tex; mode=display">\begin{matrix}d\vec{l}_x=dx\vec{a}_x\\ {d}\vec{l}_y={dy}\vec{a}_y\\ {d}\vec{l}_z={dz}\vec{a}_z\\d\vec{l}=dx\vec{a}_x+dy\vec{a}_y+d{z}\vec{a}_z\end{matrix}</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{matrix}d\vec{S}_x=dy dz\vec{a_x}\\ d\vec{S}_y=dx dz \vec{a_y}\\ d\vec{S}_z=dx dy\vec{a}_z\end{matrix}</script></li></ol><ol><li>体元<script type="math/tex; mode=display">dV=dx dy dz</script></li></ol><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><p>已知一个线的矢量表达式A，求</p><ol><li>若B与A平行，那么求B的单位矢量表达式</li><li>若B垂直于A，且B处于x平面，求B的单位矢量表达式</li></ol><p>1.A×B=0 带入求解</p><p>2.A·B=0 带入求解</p><h4 id="2-圆柱坐标系（Cylindrical-coordinates）"><a href="#2-圆柱坐标系（Cylindrical-coordinates）" class="headerlink" title="2.圆柱坐标系（Cylindrical coordinates）"></a>2.圆柱坐标系（Cylindrical coordinates）</h4><script type="math/tex; mode=display">\left(\mathrm{u}_1,\mathrm{u}_2,\mathrm{u}_3\right)=\left(\mathrm{r},\mathrm{\varphi ,z}\right)</script><ol><li><p>线元</p><script type="math/tex; mode=display">\text{d}\vec{l}=\text{d}r\vec{a}_r+r\text{d}\varphi\vec{a}_\varphi+\text{d}z\vec{a}_z</script></li></ol><ol><li>面元<script type="math/tex; mode=display">\begin{aligned}\text{d}\vec{S}_r=r\text{d}\varphi\text{d}z\vec{a}_r\\ \text{d}\vec{S}_\varphi=\text{d}r\text{d}z\vec{a}_\varphi\\ \text{d}\vec{S}_z=r\text{d}\varphi\text{d}r\vec{a}_z\end{aligned}</script></li></ol><ol><li>体元</li></ol><script type="math/tex; mode=display">\text{d}V=r\text{d}r\text{d}\varphi\text{d}z</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电磁场&quot;&gt;&lt;a href=&quot;#电磁场&quot; class=&quot;headerlink&quot; title=&quot;电磁场&quot;&gt;&lt;/a&gt;电磁场&lt;/h1&gt;&lt;h2 id=&quot;矢量的基本概念&quot;&gt;&lt;a href=&quot;#矢量的基本概念&quot; class=&quot;headerlink&quot; title=&quot;矢量的基本概念</summary>
      
    
    
    
    
    <category term="电磁场" scheme="https://rozen12123.github.io/tags/%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>线性控制系统</title>
    <link href="https://rozen12123.github.io/posts/b9875b9f.html"/>
    <id>https://rozen12123.github.io/posts/b9875b9f.html</id>
    <published>2023-09-16T11:26:32.000Z</published>
    <updated>2023-12-19T08:21:31.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动控制原理"><a href="#自动控制原理" class="headerlink" title="自动控制原理"></a>自动控制原理</h1><p>​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统</p><p>​    控制系统中的操纵器：控制器（contriller）/补偿器（compensator）[重点在于控制参数与结构]</p><p>控制器需要考虑的三大性能</p><ol><li>稳定性（Stability）：有界输入对应有界输出（BIBO）</li><li>瞬时响应（Transient response）：指标：响应速度</li><li>稳态响应（Steady-state response）</li></ol><p>&nbsp;</p><p>控制目标：</p><ol><li>稳定不稳定的系统</li><li>提高系统的稳定性；使得系统具有更好的稳定性。等效于改善系统的瞬时响应：更快的响应，较小的超调量，减小振荡</li><li>精准跟踪输入命令：减少/消除特定类型输入的稳态误差</li></ol><p>&nbsp;</p><p>判断微分方程，线性或非线性，时变或定长</p><p>是否为线性：如果每一项都是c(t),r(t),高阶导数，则为线性。但是如果出现平方线与单常数x则为非线性。</p><p>时变与非时变：c(t),r(t)的系数全是常数，不存在变量t</p><p>&nbsp;</p><h2 id="传递方程（transfer-function）"><a href="#传递方程（transfer-function）" class="headerlink" title="传递方程（transfer function）"></a>传递方程（transfer function）</h2><script type="math/tex; mode=display">a_{n}\frac{d^{n}c(t)}{dt^{n}}+a_{n-1}\frac{d^{n-1}c(t)}{dt^{n-1}}+\cdots+a_{0}c(t)=b_{m}\frac{d^{m}r(t)}{dt^{m}}+b_{m-1}\frac{d^{m-1}r(t)}{dt^{m-1}}+\cdots+b_{0}r(t)</script><p>左右两边分别进行拉氏变换，我们假设其初始状态为0可得：</p><script type="math/tex; mode=display">(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)C(s)=(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)R(s)</script><script type="math/tex; mode=display">\frac{C(s)}{R(s)}=G(s)=\frac{(b_ms^m+b_{m-1}s^{m-1}+\cdots+b_0)}{(a_ns^n+a_{n-1}s^{n-1}+\cdots+a_0)}</script><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447490.png" alt="image-20231007193012932"></p><p>解题步骤：</p><ol><li><p>Replace passive element values with their impedances.</p></li><li><p>Replace all sources and time variables with their Laplace transform.</p></li><li><p>Assume a transform current and a current direction in each mesh.</p></li><li><p>Write Kirchhoff’s voltage law around each mesh.</p></li><li><p>Solve the simultaneous equations for the output.</p></li><li><p>Form the transfer function</p></li><li><p>将无源元件值替换为其阻抗。</p></li><li><p>将所有源和时间变量替换为其拉普拉斯变换。</p></li><li><p>假设每个网格中存在变换电流和当前方向。</p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p></li><li><p>求解联立方程以获得输出。</p></li><li><p>形成传递函数</p></li></ol><p>例题如下：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447493.png" alt="image-20231007193359608" style="zoom:67%;"></p><p>寻找其传递方程${I_2(s)/V(s)}$</p><ol><li><p>将无源元件值替换为其阻抗,并进行拉氏变换同时设定好电流在网格中的流动方向。<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447494.png" alt="image-20231007193625340"></p></li><li><p>在每个网格周围写出基尔霍夫电压定律。</p><script type="math/tex; mode=display">(R_1+Ls)I_1(s)&-LsI_2(s)=V(s)\\-LsI_1(s)+\left(Ls+R_2+\frac{1}{Cs}\right)I_2(s)&=0</script></li><li><p>求解联立方程以获得输出。（一般情况下使用克莱姆法则）</p><script type="math/tex; mode=display">I_{2}(s)=\frac{\left|\begin{array}{cc}\left(R_{1}+L s\right) & V(s) \\-L s & 0\end{array}\right|}{\Delta}=\frac{L s V(s)}{\Delta}</script><script type="math/tex; mode=display">\left.\Delta=\left|\begin{matrix}(R_1+Ls)&-Ls\\\\-Ls&\left(Ls+R_2+\frac{1}{Cs}\right)\end{matrix}\right.\right|</script></li><li><p>整理可得传递方程为</p><script type="math/tex; mode=display">G(s)=\frac{I_{2}(s)}{V(s)}=\frac{Ls}{\Delta}=\frac{LCs^{2}}{(R_{1}+R_{2})LCs^{2}+(R_{1}R_{2}C+L)s+R_{1}}</script></li></ol><p>利用拉普拉斯变换解微分方程的步骤如下：</p><p>①对方程两侧同时进行拉普拉斯变换，其中的F(s)就是我们要求的原函数经过拉普拉斯变换的结果；</p><p>②带入初值条件；</p><p>③把要求的原函数F(s)用关于s的表达式g(s)表达；</p><p>④对③中得到的F(s)=g(s)两侧进行拉普拉斯逆变换即可得到微分方程的解。</p><p>微分的拉式变换</p><p>一次微分$L[f’(t)]=sF(s)-f(0)$</p><p>二次微分$L[f’’(t)]=s^2F(s)-sf(0)-f’(0)$</p><p>三次微分$L[f’’’(t)]=s^3F(s)-s^2f(0)-sf’(0)-f’’(0)$</p><script type="math/tex; mode=display">L[f^{\prime}(t)]=\int_{0}^{\infty}e^{-s t}[e^{a t}f(t)]d t=e^{-s t}f(t)|\begin{array}{c}\\ 0\end{array}+s\int_{0}^{\infty}e^{-s t}f(t)d t=s F(s)=f(0)</script><h3 id="直线机械系统的传递函数（Translational-Mechanical-System）"><a href="#直线机械系统的传递函数（Translational-Mechanical-System）" class="headerlink" title="直线机械系统的传递函数（Translational Mechanical System）"></a>直线机械系统的传递函数（Translational Mechanical System）</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447495.png" alt="image-20231007195252596" style="zoom:80%;"></p><h3 id="旋转机械系统的传递函数（Rotational-Mechanical-System）"><a href="#旋转机械系统的传递函数（Rotational-Mechanical-System）" class="headerlink" title="旋转机械系统的传递函数（Rotational Mechanical System）"></a>旋转机械系统的传递函数（Rotational Mechanical System）</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447497.png" alt="image-20231007195402243" style="zoom:80%;"></p><h2 id="梅森公式"><a href="#梅森公式" class="headerlink" title="梅森公式"></a>梅森公式</h2><p>计算<strong>任意</strong>输入节点到输出节点的传递函数的梅森增益公式为：</p><script type="math/tex; mode=display">P=\frac{1}{\Delta}\sum_{k=1}^{n}P_{k}\Delta_{k}</script><p>其中$\Delta$为系统的特征多项式，其计算公式为：</p><script type="math/tex; mode=display">\Delta=1-\sum L_a+\sum L_bL_c-\sum L_dL_eL_f+\cdots</script><p>其中:</p><p> $\sum L_a$为所有不同回路增益之和；</p><p>$\sum L_bL_c$为所有两两不接触回路增益之和；</p><p>$\sum L_dL_eL_f+\cdots$ 为所有互不接触的回路中，每次取其中三个回路的增益乘积之和；</p><p>后面的以此类推。n为从输入节点到输出节点的前向通路条数</p><p>$P_k$ 为从输入节点到输出节点的第k条前向通路的总增益；<br>$\Delta_{k}$ 为第k条前向通路的余子式，即把特征式$\Delta$中与该前向通道相接触的回路增益置零后剩余的部分。</p><p>在做题中一共分为4步：</p><ol><li><p>先找出所有的闭环回路，即为 $\sum L_a$，再找出两两不相邻回路，即为$\sum L_bL_c$，依次类推直到找全,求出整个系统的特征式</p></li><li><p>接着找出系统的前向通路，即为$ \sum P_{k}$</p></li><li><p>找到每一项的余子式，各回路均与前向通路如果有接触，其余子式为1；如果相互没有接触<br>，其余子式为$1-其闭环回路$</p></li><li><p>带入即可求得其传递函数</p></li></ol><h2 id="一阶系统分析"><a href="#一阶系统分析" class="headerlink" title="一阶系统分析"></a>一阶系统分析</h2><p>一阶系统的传递函数标准形式为：$G(s)=\frac{C(s)}{R(s)}=\frac{1}{Ts+1}$</p><p>以输入信号为单位脉冲响应举例，单位脉冲信号的拉式变换为1，即$R(s)=1$其拉氏变换应为其自身的拉式变换。化简s的系数为1可得：$G(s)=\frac{1}{Ts+1}=\frac{1}{T}\cdot\frac{1}{s+1/T}$</p><p>进行拉氏变换：$c(t)=\mathscr{L}^{\prime}\bigl[G(s)\bigr]=\frac{1}{T}\cdot\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>有例题如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447498.png" alt="image-20231018171501486"></p><p>根据框图可以求得其传递函数为：$\frac{C(s)}{R(s)}=\frac{K_{h}G(s)}{1+K_{f}G(s)}=\frac{10K_{h}}{1+10K_{f}}\cdot\frac{1}{\frac{0.2}{1+10K_{f}}s+1}$</p><p>改变题目给定的传递时间由0.2变为0.02</p><p>可得：$\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}\cdot\frac1{\frac{0.2}{1+10K_\mathrm{f}}s+1}=\frac{10}{0.02s+1}$</p><p>列式可得：$\left.\left\{\begin{array}{cc}\frac{10K_\mathrm{h}}{1+10K_\mathrm{f}}=10\\\\\frac{0.2}{1+10K_\mathrm{f}}=0.02\\\end{array}\right.\right.$</p><p>解:$K_{f}=0.9,K_{h}=10$</p><p>&nbsp;</p><h2 id="劳斯判据"><a href="#劳斯判据" class="headerlink" title="劳斯判据"></a>劳斯判据</h2><p>可以根据<code>闭环传递函数的特征方程</code>如下表格对应写拉斯表</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447499.png" alt="image-20231018172507370"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447500.png" alt="image-20231018172512271"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447501.png" alt="image-20231018172520189"></p><p>举例:<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447502.png" alt="image-20231018172543560"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447503.png" alt="image-20231018172633894" style="zoom:67%;"></p><p>由于第一列的系数不全为正，因此系统不稳定。</p><p>例题：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447504.png" alt="image-20231018172732060"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447505.png" alt="image-20231018172746303" style="zoom:67%;"></p><p>由于第一列的系数都大于零，所以该系统稳定。</p><h3 id="劳斯判据中的特殊情况"><a href="#劳斯判据中的特殊情况" class="headerlink" title="劳斯判据中的特殊情况"></a>劳斯判据中的特殊情况</h3><p>（1）在计算中，第一列有零出现。</p><p>出现这种情况时，可以用一个很小的正数代替，继续完成计算。如果第一列中的元素除了出现的零值外，其余全部大于零，则说明系统有临界稳定的特征根。</p><p>（2）第一列的系数出现变号：改变符号（正负相互转化）的次数，即不稳定根的个数。</p><p>举例：$s^{3}-3s+2=0$</p><p>其劳斯表为：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447506.png" alt="image-20231018173756661" style="zoom:67%;"></p><p>这个变号的次数即为不稳定跟的个数。</p><p>（3）出现零行（即劳斯表的每一行都是0），则存在大小相等，方向相反的根。</p><p>$s^{5}+2s^{4}+24s^{3}+48s^{2}-25s-50=0$</p><p>劳斯表计算中出现零行时，可用零行的前一行作辅助多项式$P（s）$，然后由$\frac{dP(s)}{ds}$的系数行代替零行，完成劳斯表的计算，如下面例题所示。<br><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447507.png" alt="image-20231018174115812"><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447508.png" alt="image-20231018174123715" style="zoom:67%;"></p><p>&nbsp;</p><p>例题：</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447509.png" alt="image-20231018174402971" style="zoom:80%;"></p><p>根据框图可以得到其闭环传递函数为：$G_c(s)=\frac{\frac{10}{s(s+2)}}{1+(1+10s)\frac{10}{s(s+2)}}=\frac{10}{s^2+102s+10}$</p><p>闭环特征方程为：$s^2+102s+10=0$</p><p>据此列劳斯表易，其系数全部为正，即方程稳定。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="二阶系统分析"><a href="#二阶系统分析" class="headerlink" title="二阶系统分析"></a>二阶系统分析</h2><p>二阶系统的结构图如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447510.png" alt="image-20231018174729779"></p><p>其开环传递函数为：</p><script type="math/tex; mode=display">G_{_{o}}(s)=\frac{\omega_{n}^{2}}{s(s+2\zeta\omega_{_{n}})}</script><p>闭环传递函数：</p><script type="math/tex; mode=display">G_{c}(s)=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{n}s+\omega_{n}^{2}}</script><p>闭环传递函数的分母多项式等于零的代数方程称为二阶系统的闭环特征方程，即</p><script type="math/tex; mode=display">s^{2}+2\zeta\omega_{_n}s+\omega_{_n}^{2}=0</script><p>闭环特征方程的两个根称为二阶系统的特征根，即</p><script type="math/tex; mode=display">s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}</script><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>量纲</th></tr></thead><tbody><tr><td>$\zeta$</td><td>二阶系统的阻尼比</td><td>1</td></tr><tr><td>$ \omega_{_n}$</td><td>无阻尼振荡频率</td><td>rad/s</td></tr></tbody></table></div><p>根据$\zeta$的值范围的不同，一共有如下物种情况：</p><div class="table-container"><table><thead><tr><th>范围</th><th>特征根位置</th><th>系统响应情况</th></tr></thead><tbody><tr><td>$\zeta &gt; 1$</td><td>特征根为一对不相等的负实根，位于s平面的负实轴上</td><td>过阻尼</td></tr><tr><td>$\zeta = 1$</td><td>特征根为一对相等的负实根；也是位于s平面的负实轴上</td><td>临界阻尼</td></tr><tr><td>$0&lt; \zeta &lt;1$</td><td>特征根为一对带有负实部的共钜复数根，位于s平面的左半平面上</td><td>欠阻尼</td></tr><tr><td>$\zeta = 0$</td><td>特征根为一对纯虚根，位于s平面的虚轴上</td><td>无阻尼</td></tr><tr><td>$\zeta &lt; 0$</td><td>特征根位于s平面的右半平面上</td><td>发散</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447511.png" alt="image-20231018175617105" style="zoom:80%;"></p><h3 id="二阶系统的性能指标计算"><a href="#二阶系统的性能指标计算" class="headerlink" title="二阶系统的性能指标计算"></a>二阶系统的性能指标计算</h3><div class="table-container"><table><thead><tr><th>符号</th><th>名称</th><th>计算式</th></tr></thead><tbody><tr><td>$\omega_{\mathrm{d}}$</td><td>阻尼振荡频率（rad/s）</td><td>$\omega_{\mathrm{d}}=\omega_{_n}\sqrt{1-\xi^{2}}$</td></tr><tr><td>$t_r$</td><td>上升时间</td><td>$t_{_r}=\frac{\pi-\beta}{\omega_{_\mathrm{d}}}$</td></tr><tr><td>$t_p$</td><td>峰值时间</td><td>$t_{_p}=\frac{\pi}{\omega_{_d}}$</td></tr><tr><td>$M_p$</td><td>超调量</td><td>$M_p=\mathrm{e}^{-\frac\zeta{\sqrt{1-\zeta^2}}\pi}\times100\%$</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>依照一阶系统调节时间的计算公式可以近似估算二阶欠阻尼系统的调节时间为:</p><p>$t_{_s}=3T={\frac{3}{\zeta\omega_{_n}}},\pm5\%\text{误差带宽度时}$</p><p>$t_{_s}=4T=\frac{4}{\zeta\omega_{_n}},\pm2\%\text{误差带宽度时}$</p><p>&nbsp;</p><p>有例题如下：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447512.png" alt="image-20231018180846066"></p><p>根据框图易得其开环传递函数如下：</p><script type="math/tex; mode=display">G_{_o}(s)=\frac{5K}{s(s+34.5)}</script><p>（1）闭环传递函数：</p><script type="math/tex; mode=display">G_{_c}(s)=\frac{G_{_s}(s)}{1+G_{_s}(s)}=\frac{\frac{5K}{s(s+34.5)}}{1+\frac{5K}{s(s+34.5)}}=\frac{5K}{s^{2}+34.5s+5K}=\frac{1000}{s^{2}+34.5s+1000}</script><p>带入标准二阶传递函数形式，可得特征根参数：</p><script type="math/tex; mode=display">G_{\mathrm{c}}(s)=\frac{1}{s^{2}+34.5s+1000}=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{n}s+\omega_{n}^{2}}</script><script type="math/tex; mode=display">\begin{gathered}2\zeta\omega_{n}=34.5,\omega_{n}^{2}=1000 \\\omega_{n}=31.6\mathrm{rad/s} \\\zeta=0.545 \end{gathered}</script><p>峰值时间：<script type="math/tex">t_{_p}=\frac{\pi}{\omega_{_d}}=\frac{\pi}{\omega_{_n}\sqrt{1-\zeta^{^2}}}=0.12\mathrm{s}</script></p><p>超调量：$M_{_p}=\mathrm{e}^{-\frac{\zeta}{\sqrt{1-\zeta^{2}}}\pi}\times100\%=0.13\times100\%=13\%$</p><p>调节时间：$\begin{aligned}t_{s}&amp;=\frac{3}{\zeta\omega_{n}}=0.17\mathrm{s}(\pm5\%)\\t_{s}&amp;=\frac{4}{\zeta\omega_{n}}=0.23\mathrm{s}(\pm2\%)\end{aligned}$</p><p>（2）讨论K=1500和K=13.5时，对系统动态性能的影响。</p><p>当K=1500时，闭环传递函数为：$G_{_{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{7500}{s^{2}+34.5s+7500}$</p><p>特征参数：$\omega_{n}=86.6\mathrm{rad/s},\zeta=0.2$</p><p>性能指标：$t_{_p}=0.037s,M_{_p}=52.7\%,t_{_s}=0.17s$</p><p>可得其阻尼振荡频率：$\omega_{\mathrm{d}}=\omega_{\mathrm{n}}\sqrt{1-\zeta^{2}}=86.6\sqrt{1-0.2^{2}}\mathrm{rad/s=84.85rad/s}$</p><p>&nbsp;</p><p>当K=13.5时，闭环传递函数为:</p><p>$G_{\mathrm{c}}(s)=\frac{5K}{s^{2}+34.5s+5K}=\frac{67.5}{s^{2}+34.5s+67.5}$</p><p>对应特征参数为：$\omega_{_n}=8.22\mathrm{rad/s}$</p><p>$\zeta=2.1$</p><p>此时，系统为过阻尼的，没有超调量，曲线上升很慢。由近似计算可求得调节时间为：$t_{s}\approx3T_{1}=1.44\mathrm{s}$</p><h4 id="过阻尼情况下的调节时间"><a href="#过阻尼情况下的调节时间" class="headerlink" title="过阻尼情况下的调节时间"></a>过阻尼情况下的调节时间</h4><p>过阻尼系统的阻尼系数比：$\zeta&gt;1$</p><p>特征根为两个不相等的负实根：$s_{_{1,2}}=-\zeta\omega_{_n}\pm\omega_{_n}\sqrt{\zeta^{2}-1}$</p><p>闭环传递函数为：$G_{c}\left(s\right)=\frac{\omega_{n}^{2}}{s^{2}+2\zeta\omega_{_{n}}s+\omega_{n}^{2}}=\frac{\frac{1}{T_{1}T_{2}}}{\left(s+\frac{1}{T_{1}}\right)\left(s+\frac{1}{T_{2}}\right)}$</p><p>注意到在时间响应$ c（t）$的表达式中，当$T_2&lt;&lt;T_1$时，因为第三项极快地衰减到零。忽略该项后，时间响应$c(t)$可以近似为一阶系统的时间响应</p><p>$c(t)\approx1-\mathrm{e}^{-\frac{1}{T}\prime}$</p><p>因此，一阶系统的调节时间$t_s$用一阶系统的时间常数T作为参变量表示为:</p><p>$t_s=3T,\text{取误差带宽度为}\pm5\%\text{时}$</p><p>$t_s=4T,\text{取误差带宽度为}\pm2\%\text{时}$</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310201447513.png" alt="image-20231018182939773" style="zoom:50%;"></p><p>&nbsp;</p><h3 id="二阶系统响应特性的改善"><a href="#二阶系统响应特性的改善" class="headerlink" title="二阶系统响应特性的改善"></a><strong>二阶系统响应特性的改善</strong></h3><h4 id="1-误差信号的比例微分控制（PD控制）"><a href="#1-误差信号的比例微分控制（PD控制）" class="headerlink" title="1.误差信号的比例微分控制（PD控制）"></a>1.误差信号的比例微分控制（PD控制）</h4><p>在原典型二阶系统的前向通路上增加误差信号的速度分量并联通路。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211605259.png" alt="image-20231021160559090"></p><p>2.输出量的速度反馈控制（SF控制）<br>在原典型二阶系统的反馈通路上增加输出信号的速度分量反馈信号。</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211606436.png" alt="image-20231021160638285"></p><p>例题：<img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211607774.png" alt="image-20231021160743574"></p><p>易知上图的闭环传递函数为：</p><script type="math/tex; mode=display">G_{c}(s)=\frac{\frac{K}{s(s+1)}}{1+\frac{K}{s(s+1)}(1+K_{fs})}=\frac{K}{s^{2}+(1+KK_{f})s+K}</script><p>比较二阶系统的标准式有：</p><script type="math/tex; mode=display">\omega_{n}^{2}=K</script><script type="math/tex; mode=display">2\zeta\omega_{n}=1+KK_{f}</script><p>给定的性能指标为：</p><script type="math/tex; mode=display">M_{_p}=20\%,\text{和}t_{_p}=1\mathrm{s}</script><p>通过：${M_{_p}=\mathrm{e}^{-\frac{\zeta}{\sqrt{1-\zeta^{2}}}\pi}\times100\%=20\%}$</p><p>$ {t_{_p}=\frac{\pi}{\omega_{_d}}=\frac{\pi}{\omega_{_n}\sqrt{1-\zeta^{2}}}=1\mathrm{s} }$</p><p>解得：$\begin{array}{c}{\zeta=0.456}\\{\omega_{n}=3.53}\\\end{array}$</p><p>所以：$\begin{array}{c}{K=\omega_{n}^{2}=3.53^{2}=12.5}\\{K_{f}=\frac{2\sqrt{K}\zeta-1}{K}=0.178}\\\end{array}$</p><p>当K=12.5，$K_f = 0.178$时，可得：</p><script type="math/tex; mode=display">\begin{aligned}G_{e}(s)&=\frac{12.5}{s^{2}+s+12.5}\\\\\xi&=\frac{1}{2\sqrt{K}}=0.14\\\\\\M_{_p}&=\mathrm{e}^{-\frac{\xi}{\sqrt{1-\epsilon^2}}\pi}\times100\%=64\%\end{aligned}</script><h3 id="控制系统的稳态误差分析"><a href="#控制系统的稳态误差分析" class="headerlink" title="控制系统的稳态误差分析"></a>控制系统的稳态误差分析</h3><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211619265.png" alt="image-20231021161910919"></p><p>稳态误差系数类型：</p><p>1.当输入为单位阶跃信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_p$，表示为：</p><p>$K_{_p}=\operatorname*{lim}_{s\to0}G_{_0}(s)$</p><p>其稳态误差：$e_{ss}=\frac{1}{1+K_{_p}}$</p><p>2.当输入为单位斜坡信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_v$，表示为：</p><p>$K_{v}=\lim_{s\rightarrow0}s\cdot G_{_{o}}(s)$</p><p>其稳态误差：$e_{ss}=\frac{1}{K_{v}}$</p><p>3.当输入为加速度信号时：$\lim_{s\to0}G_{_0}(s)$定义为系统的静态位置误差系数$K_a$，表示为：</p><p>$K_{a}=\lim_{s\rightarrow0}s^{2}G_{_0}(s)$</p><p>其稳态误差：$e_{_{\mathrm{ss}}}=\frac{1}{K_{_{a}}}$</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211627804.png" alt="image-20231021162714529"></p><p>&nbsp;</p><h2 id="根轨迹法"><a href="#根轨迹法" class="headerlink" title="根轨迹法"></a>根轨迹法</h2><h3 id="绘制负反馈系统的9条法则"><a href="#绘制负反馈系统的9条法则" class="headerlink" title="绘制负反馈系统的9条法则"></a>绘制负反馈系统的9条法则</h3><p>1.连续性；</p><p>2.对称性；</p><p>3.根轨迹的分支数；</p><p>根轨迹的分支数等于系统的阶数</p><p>4.根轨迹的起点和终点；</p><p>$\frac{\prod_{j=1}^{m}\left(s+z_{j}\right)}{\prod_{i=1}^{n}\left(s+p_{i}\right)}=-\frac{1}{K_{g}}$</p><p>当$K_g = 0$是根轨迹的起点，分母等于零即为系统的开环极点</p><p>当$K_g = \infty$是根轨迹的起点，分子等于零即为系统的开环零点</p><p>5.实轴上的根轨迹；</p><p>在实轴上选取实验点$s_i$，如果实验点$s_i$的右方实轴上的开环零点数和极点数的总和为奇数，则实验点$s_i$所在的实验段是根轨迹，否则该实验段不是根轨迹。</p><p>6.根轨迹的会合点与分离点；</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211642610.png" alt="image-20231021164241432" style="zoom:67%;"></p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211642538.png" alt="image-20231021164256350" style="zoom:67%;"></p><p>计算分离点或汇合点：</p><p>$N’(s)D(s)-N(s)D’(s)=0$</p><p>PS：其中N(s)为变量s的分子多项式，D(s)为变量s的分母多项式。</p><p>7.根轨迹的渐近线（与实轴交点；倾斜角）</p><p>与实轴交点：$-\sigma=-\frac{a_{n-1}-b_{m-1}}{n-m}=-\frac{\sum_{i=1}^{n}p_{i}-\sum_{j=1}^{m}z_{j}}{n-m}$</p><p>倾斜角：$\theta=\frac{\pm180^{\circ}(2k+1)}{n-m}$</p><p>8.与虚轴交点；</p><p>根轨迹可能与虚轴相交，交点坐标的$\omega $值及相应的$K_g$值可由劳斯判据求得，也可在特征方程中令s=j$\omega$ ，然后使特征方程的实部和虚部分别为零求得。</p><p>9.出射角与入射角</p><p><img src="https://raw.githubusercontent.com/Rozen12123/picture/main/202310211648637.png" alt="image-20231021164835441" style="zoom:67%;"></p><p>幅角条件为:$\sum_{j=1}^{n}\arg[s+z_{j}]-\sum_{i=1}^{n}\arg[s+p_{i}]\Bigg|_{s = s_g}=\pm180^{\circ}(2k+1)$</p><p>令$\left.\theta_{j}=\arg\left[\begin{array}{c}{s+z_{j}}\\\end{array}\right.\right],\varphi_{i}=\arg\left[\begin{array}{c}{s+p_{i}}\\\end{array}\right]$</p><p>出射角：$\varphi_{k}=\mp180^{\circ}(2k+1)+\sum_{j=1}^{m}\theta_{j}-\sum_{i=1;i\ne k}^{n}\varphi_{i}\Bigg|_{s=p_{k}}$</p><p>入射角：$\theta_{l}=\pm180^{\circ}(2k+1)-\sum_{j=1\atop j\neq l}^{m}\theta_{j}+\sum_{i=1}^{n}\varphi_{i}\Bigg|_{s=z_{i}}$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动控制原理&quot;&gt;&lt;a href=&quot;#自动控制原理&quot; class=&quot;headerlink&quot; title=&quot;自动控制原理&quot;&gt;&lt;/a&gt;自动控制原理&lt;/h1&gt;&lt;p&gt;​    控制系统（Control system）:在给定的条件下，通过操纵达到预期性能的系统&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="课程总结" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>结构化数字设计</title>
    <link href="https://rozen12123.github.io/posts/3c5c3e03.html"/>
    <id>https://rozen12123.github.io/posts/3c5c3e03.html</id>
    <published>2023-09-13T02:38:58.000Z</published>
    <updated>2023-09-26T08:49:50.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字化结构设计"><a href="#数字化结构设计" class="headerlink" title="数字化结构设计"></a>数字化结构设计</h1><h2 id="层次建模的概念"><a href="#层次建模的概念" class="headerlink" title="层次建模的概念"></a>层次建模的概念</h2><h3 id="设计方法学"><a href="#设计方法学" class="headerlink" title="设计方法学"></a>设计方法学</h3><p>两种基本的设计方法：<code>自底向上</code>和<code>自顶向下</code>设计</p><p>1.自底向上</p><p>2.自顶向下</p><p>通常情况下，两种方法混合使用。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>​     Verilog使用模块（module）的概念来代表一个基本的功能块。</p><p>​    一个模块可以是一个元件，也可以是低层次模块的组合</p><h3 id="1-模块声明"><a href="#1-模块声明" class="headerlink" title="1.模块声明"></a>1.模块声明</h3><p>​    在Verilog中，模块声明是由关键字module开始，关键字endmodule必须出现在模块定义的结尾。每个模块必须有一个模块名，由它唯一的标志这个模块。模块的端口列表则描述这个模块的输入和输出端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;模块名&gt;(&lt;模块端口列表&gt;);</span><br><span class="line">...</span><br><span class="line">&lt;模块的内容&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>例如在脉动进位计数器的例子中，T触发器可以定义为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> T_FF (q, clock ,reset);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;T触发器的功能描述&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>​    使用Verilog可以在每个模块内4个抽象层次进行描述，定义如下：</p><ol><li>行为或算法级：注重实现的算法，并不注重硬件实现的细节</li><li>数据流级：说明数据的流程对模块进行描述，数据如何在各个寄存器之间流动，以及如何处理这些数据。</li><li>门级：从组成电路的逻辑门及其之间的相互关系的角度设计模块。</li><li>开关级：通过开关，储存节点及其互连关系来设计模块。</li></ol><p>&nbsp;</p><h3 id="2-模块实例"><a href="#2-模块实例" class="headerlink" title="2.模块实例"></a>2.模块实例</h3><p>​    模块声明类似于一个模板，使用这个模板就可以创建实际的对象。当一个模块被调用的时候，Verilog会根据模板创建一个唯一的模块对象，每个对象都有其各自的名字、变量、参数和输入/输出（I/O）接口。</p><p>​    从模板创建对象的过程称为<code>实例化</code>（instantiation），创建的对象称为<code>实例</code>（instance）</p><p>&nbsp;</p><p>​    在Verilog中，不允许在模块声明中嵌套模块，也就是在模块声明的module和endmodule关键字之间不能再包含模块声明。模块之间的相互调用是通过实例引用来完成的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它引用了4个触发器。它们之间的连接参见2.2节</span></span><br><span class="line"><span class="comment">//定义名为ripple_carry_counter（脉动进位计数器）的模块</span></span><br><span class="line"><span class="keyword">module</span> ripple_carry_counter(q,clk,reget);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>]q;<span class="comment">//输人输出端口的信号和向量声明，以后会讲解</span></span><br><span class="line"><span class="keyword">input</span> clk,reset；<span class="comment">//输入/输出端口的信号声明，以后会讲解</span></span><br><span class="line"><span class="comment">//生成了4个触发器TEF的实例，每个实例都有自己的名字，每个实例都传递一组信号</span></span><br><span class="line"><span class="comment">//注意每个实例都是FF模块的副本</span></span><br><span class="line">    TFF tff0 (q[<span class="number">0</span>]，clk,reset);</span><br><span class="line">    TFF tff1 (q[<span class="number">1</span>]，q[<span class="number">0</span>]，reset);</span><br><span class="line">    TFF tff2 (q&#123;<span class="number">2</span>&#125;，q[<span class="number">1</span>]，reset);</span><br><span class="line">    TFF tff3 (q[<span class="number">3</span>]，q[<span class="number">2</span>]，reset);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//定义名为TFF（触发器）的模块。它引用了一个D触发器。我们在本模块中假设</span></span><br><span class="line"><span class="comment">//D触发器（DEF）已经在该设计中的别处定义了，参见图2.4，看它们之间的互相连接</span></span><br><span class="line">moaule TFF (q,clk,reset);</span><br><span class="line"><span class="comment">//以后将对下列语句做进一步的解释</span></span><br><span class="line"><span class="keyword">output</span> q;<span class="number">0</span></span><br><span class="line"><span class="keyword">input</span> clk,reset;</span><br><span class="line"><span class="keyword">wire</span> d;</span><br><span class="line">DFF dff0（q,d,clk,reset）;<span class="comment">//调用（实例引用）DFF，取名为dffo</span></span><br><span class="line"><span class="keyword">not</span> n1（d,q）;<span class="comment">//非门（not）是veri1og语言的内部原语部件（primitive），以后会讲解</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>ps:关键字必须是小写字母</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Verilog中的基本词法约定与c语言类似。</p><h3 id="数字声明"><a href="#数字声明" class="headerlink" title="数字声明"></a>数字声明</h3><ol><li><p>指明位数的数字</p><p>指明位数的数字表现形式为</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;size&gt;&#x27;&lt;base format&gt;&lt;number&gt;</span><br></pre></td></tr></table></figure><p>$<size>$用来指明数字的宽度（二级制的个数），只能用十进制表示。Base format表示用什么进制</size></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1111</span><span class="comment">//这是一个4位的二进制数</span></span><br><span class="line"><span class="number">12&#x27;habc</span><span class="comment">//这是一个12位的十六进制数</span></span><br><span class="line"><span class="number">16&#x27;d255</span><span class="comment">//这是一个16位的十进制数</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>不指明位数的数字</p><p>没有指定基数默认为十进制数。如果没有指定宽度，则默认为32位</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">234566</span><span class="comment">//这是一个32位的十进制数</span></span><br><span class="line"><span class="number">&#x27;hc3</span><span class="comment">//这是一个32位的十六进制数</span></span><br><span class="line"><span class="number">&#x27;o21</span><span class="comment">//这是一个32位的八进制数</span></span><br></pre></td></tr></table></figure></li><li><p>X和Z值</p><p>x表示不确定值，z表示高阻值；不区分x，y的大小写。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;h13x</span><span class="comment">//这是一个12位的十六进制数，四个最低位不确定6&#x27;hx//这是一个6位的十六进制数，所有位都不确定</span></span><br><span class="line"><span class="number">32&#x27;bz</span><span class="comment">//这是一个32位的高阻值</span></span><br></pre></td></tr></table></figure><p>​    16进制为基数的表示中x或z表示4位，在8进制，x，z表示3位，在2进制中x，z代表1位。如果某数的最高位是0，x或z，verilog语言约定将分别使用0，x，z自动对这个数进行扩展，填满余下的更高位。如果最高位是1，余下的更高位用0来扩展。</p></li><li><p>复数</p><p>对于常数，我们可以通过在表示位宽的数字前面增加一个减号来表示它是一个负数，因为表示大小的常数总是正的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d3</span><span class="comment">//这是一个6位的用二进制补码形式存储的十进制数3，表示负数</span></span><br><span class="line">-<span class="number">6</span>&#x27;sd3<span class="comment">//这是一个6位的用于带符号算术运算的负数</span></span><br><span class="line"><span class="number">4</span>&#x27;d-<span class="number">2</span><span class="comment">//非法说明</span></span><br></pre></td></tr></table></figure></li><li><p>下划线和问号</p><p>除了第一个字符，下划线可以出现在数字中的任何位置，它的作用只是提高可读性，在编译阶段会被忽略，？是z的另一种表示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12&#x27;b1111_0000_1010</span><span class="comment">//用下划线符号来提高可读性4&#x27;b10??//相当于4&#x27;b10zz</span></span><br></pre></td></tr></table></figure></li><li><p>转义标识符</p><p>转义标识符以反斜线“\”开始，以空白符（空格、制表符和换行符）结束。Verilog将反斜线和空白符之间的字符逐个进行处理。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\a+b-C <span class="comment">//译者注：与a+b-c等同</span></span><br><span class="line">\**my_name** <span class="comment">//译者注：如果作为标识符则与**my_name**等同</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol><li><p>值的种类</p><p>Verilog使用四值逻辑和八种信号强度来对实际的硬件电路建模。</p><p>| 值的级别 | 硬件电路中的条件 |<br>| ———— | ———————— |<br>| 0        | 逻辑0，条件为假  |<br>| 1        | 逻辑0，条件为假  |<br>| x        | 逻辑值不确定     |<br>| z        | 高阻，浮动状态   |</p><p>| 强度等级 | 类型 | 程度 |<br>| ———— | —— | —— |<br>| supply   | 驱动 | 最强 |<br>| strong   | 驱动 |      |<br>| pull     | 驱动 |      |<br>| large    | 储存 |      |<br>| weak     | 驱动 |      |<br>| medium   | 储存 |      |<br>| small    | 储存 |      |<br>| highz    | 高阻 | 最弱 |</p></li><li><p>线网</p><ol><li><p>线网（net：代表了一类数据类型，包括wire，wand，wor，tri，trireg等）标识硬件单元之间的连接。</p></li><li><p>就像在真实的电路中一样，线网由其连接器件的输出连续驱动。</p></li><li><p>线网一般使用关键字wire进行声明。如果没有明显说明向量，则默认线网的位宽为1</p></li><li><p>线网的默认值为z（trireg类型的线网例外，其默认值为x），线网的值由驱动源确定，如果没有驱动源，则线网的值为z</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//声明上面的电路中a是wrie（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> b,c;<span class="comment">//声明上面的电路中b和c也是wire（连线）类型</span></span><br><span class="line"><span class="keyword">wire</span> d = <span class="number">1&#x27;b0</span>;<span class="comment">//连线d在声明时，d被赋值为逻辑值0</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><ol><li><p>寄存器用来表示储存元件，它保持原有的树脂，直到被改写。</p></li><li><p>寄存器数据类型一般通过关键字reg来声明，默认值为X</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> reset;<span class="comment">//声明能保持数值的变量reset</span></span><br><span class="line">initia1 <span class="comment">//这个结构将在以后讨论</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">reset = <span class="number">1&#x27;b1</span>;<span class="comment">//把reset初始化为1，使数字电路复位</span></span><br><span class="line">#<span class="number">100</span> reset=<span class="number">1&#x27;b0</span>;<span class="comment">//经过100个时间单位后，reset置逻辑0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>向量</p><ol><li><p>线网和寄存器类型的数据均可以声明为向量（位宽大于1）。若在声明中没有指定位宽，则默认为标量（1位）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> a;<span class="comment">//标量线网变量，默认</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] bus;<span class="comment">//8位的总线</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] busA,busB,busC;<span class="comment">//3条32位宽的总线</span></span><br><span class="line"><span class="keyword">reg</span> clock;<span class="comment">//标量寄存器，默认</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">40</span>] virtual_addr;<span class="comment">//向量寄存器，41位宽的虚拟地址</span></span><br></pre></td></tr></table></figure><ol><li><p>向量域选择</p><p>对于上面例子中声明的向量，我们可以指定它的某一位或若干个相邻位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">busA[<span class="number">7</span>] <span class="comment">//向量busA的第7位</span></span><br><span class="line">bus[<span class="number">2</span>:<span class="number">0</span>]<span class="comment">//向量bus的最低3位</span></span><br><span class="line"><span class="comment">//如果写成bus[0:2]是非法的，因为高位应该写在范围说明的左侧</span></span><br><span class="line">virtual_addr[<span class="number">0</span>:<span class="number">1</span>]<span class="comment">//向量virtual_addr的两个最高位</span></span><br></pre></td></tr></table></figure></li><li><p>可变的向量域选择</p><p>[<startingbit>+：width]：从起始位开始递增，位宽为width。</startingbit></p><p>[<startingbit>-：width]：从起始位开始递减，位宽为width。</startingbit></p></li></ol></li></ol><p>起始位可以是一个变量，但是位宽必须是一个常量。下面的例子说明了可变的向量域选择的使用方法：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">255</span>:<span class="number">0</span>]data1;<span class="comment">//data1【255】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">0</span>:<span class="number">255</span>]data2;<span class="comment">//data2【0】是最高有效位</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>]<span class="keyword">byte</span>;</span><br><span class="line"><span class="comment">//用变量选择向量的一部分</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data131:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data1[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data1【31:24】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">31</span>-:<span class="number">8</span>];<span class="comment">//从第31位算起，宽度为8位，相当于data2【24:31】</span></span><br><span class="line"><span class="keyword">byte</span>=data2[<span class="number">24</span>+:<span class="number">8</span>];<span class="comment">//从第24位算起，宽度为8位，相当于data2【24:311//超始位可以是变量，但宽度必须是常数。因此可以通过可变域选择，//用循环语句选取一个很长的向量的所有位</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">32</span>;j=j+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">byte</span>=data1[(j*<span class="number">8</span>)+<span class="number">8</span>];<span class="comment">//次序是【7:0】，【15:81..【255:248】</span></span><br><span class="line"><span class="comment">//用于初始化向量的一个域</span></span><br><span class="line">data1[(byteNum*<span class="number">8</span>)+:<span class="number">8</span>] = <span class="number">8&#x27;b0</span>;<span class="comment">//如果byteNum=1，共有8位被清零，【15:8】</span></span><br></pre></td></tr></table></figure></li><li><p>数字，实数和时间寄存器的数据类型</p><p>除reg类型之外，Verilog还支持integer,real和time寄存器数据类型。</p><ol><li><p>整数</p><p>用关键字integer进行声明，虽然可以用reg类型的寄存器作为通用变量，但声明一个整体类型的变量来完成计数会更为方便。</p><p>整数默认位宽为宿主机的字的位数，最小应为32位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> counter;<span class="comment">//一般用途的变量，作为计数器initial</span></span><br><span class="line">coumter=-<span class="number">1</span>;<span class="comment">//把-1存储到计数器中</span></span><br></pre></td></tr></table></figure></li><li><p>实数</p><p>用real来声明，实数声明不能带有范围，默认值为0。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> delta;<span class="comment">//定义一个名为delta的实型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">delta = <span class="number">4</span>e10;<span class="comment">//delta被赋值，用科学记数法表示</span></span><br><span class="line">delta = <span class="number">2</span><span class="variable">.13</span>;<span class="comment">//delta被赋值为2.13</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;<span class="comment">//定义一个名为的整型变量</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">i = delta;<span class="comment">//1得到值2（2.13取整数部分）</span></span><br></pre></td></tr></table></figure></li><li><p>时间寄存器</p><p>仿真是按仿真时间进行的，其宽度与具体实现有关，最小为64位。用time来声明。通过调用系统函数$time可以得到当前的仿真时间。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span> save_simtime;<span class="comment">//定义时间类型的变量savesim time initial</span></span><br><span class="line">save sim <span class="keyword">time</span>=<span class="built_in">$time</span>;<span class="comment">//把当前的仿真时间记录下来</span></span><br></pre></td></tr></table></figure></li><li><p>数组</p><p>在Verilog中允许声明reg,integer,time,real,realtime及其向量类型的数组，对数组的维数没有限制。</p><p>形如&lt;数组名&gt;&lt;下标&gt;。对于多维数组来讲，用户需要说明其每一维的索引。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> count[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个计数变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> boo1[<span class="number">31</span>:<span class="number">0</span>];<span class="comment">//由32个1位的布尔（boolean）寄存器变量组成的数组</span></span><br><span class="line"><span class="keyword">time</span> chk_point[<span class="number">1</span>:<span class="number">100</span>];<span class="comment">//由100个时间检查变量组成的数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] port_id[<span class="number">0</span>:<span class="number">7</span>];<span class="comment">//由8个端口标识变量组成的数组，端口变量的位宽为5</span></span><br><span class="line"><span class="keyword">integer</span> matrix[<span class="number">4</span>:<span class="number">0</span>][<span class="number">0</span>:<span class="number">255</span>];<span class="comment">//二维的整数型数组</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">63</span>:<span class="number">0</span>] array_4d[<span class="number">15</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//四维64位寄存器型数组</span></span><br><span class="line"><span class="keyword">wire</span>[<span class="number">7</span>:<span class="number">0</span>] w_array2[<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明8位向量的数组</span></span><br><span class="line"><span class="keyword">wire</span> w_array1[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>];<span class="comment">//声明1位线型变量的二维数组</span></span><br></pre></td></tr></table></figure><p>不要将数组和线网或寄存器向量混淆起来，向量是一个单独的元件，它的位宽是n；数组由多个元件组成，其中每个元件元素的赋值位n或1。</p><p>下面的例子显示了对数组元素的赋值：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count[<span class="number">5</span>]=<span class="number">0</span>;<span class="comment">//把count数组中的第5个整数型单元（32位）复位</span></span><br><span class="line">chk_point[<span class="number">100</span>]=<span class="number">0</span>;<span class="comment">//把chk_point数组中的第100个时间型单元（64位）复位</span></span><br><span class="line">port_id[<span class="number">3</span>]=<span class="number">0</span>;<span class="comment">//把port_id数组中的第3个寄存器型单元（5位）复位</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">33559</span>;<span class="comment">//把数组中第1行第0列的整数型单元（32位）置为33559</span></span><br><span class="line">array_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//把四维数组中索引号为【o】【O】【0】【O】的寄存器型单元</span></span><br><span class="line"><span class="comment">//的0-15位都置为0</span></span><br><span class="line">port_id=<span class="number">0</span>;<span class="comment">//非法，企图写整个数组</span></span><br><span class="line">matrix[<span class="number">1</span>] = <span class="number">0</span>；<span class="comment">//非法，企图写数组的整个第2行，即从matrix【1】【0】直到matrix【1】【255】</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>寄存器</p><p>在数字电路仿真中，需要对寄存器文件ROM和RAM建模。如果需要访问储存器中的一个特定字，可以将字的地址作为数组的下标来完成。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> memibit[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的1位存储器mem1bit</span></span><br><span class="line"><span class="keyword">reg</span>[<span class="number">7</span>:<span class="number">0</span>] membyte[<span class="number">0</span>:<span class="number">1023</span>];<span class="comment">//1K的字节（8位）存储器membyte </span></span><br><span class="line">membyte[<span class="number">511</span>]<span class="comment">//取出存储器membyte中地址511处所存的字节</span></span><br></pre></td></tr></table></figure></li><li><p>参数</p><p>Verilog允许使用关键字parameter在模块内定义常数。参数代表常数，不能像变量那样赋值，但是每个模块实例的参数值可以在编译阶段被重载。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> port_id=<span class="number">5</span>;<span class="comment">//定义常数portid为5</span></span><br><span class="line"><span class="keyword">parameter</span> cache_1ine_width=<span class="number">256</span>;<span class="comment">//定义高速缓冲器总线宽度为常数256</span></span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">signed</span>[<span class="number">15</span>:<span class="number">0</span>] WIDTH;<span class="comment">//把参数WIDTH规定为有正负号，宽度为16位</span></span><br></pre></td></tr></table></figure><p>Verilog中的局部参数使用关键字localparam来定义，其作用等同于参数，区别在于它的值不能改变。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">localparam</span>  state1 = <span class="number">4&#x27;b0001</span>,</span><br><span class="line">state2 = <span class="number">4&#x27;b0010</span>,</span><br><span class="line">state3 = <span class="number">4&#x27;b0100</span>,</span><br><span class="line">state4 = <span class="number">4&#x27;b1000</span>;</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><ol><li><p>字符串保存在reg类型的变量中，每个字符占用8位（一个字节），因此寄存器变量的宽度应足够大。</p></li><li><p>如果寄存器变量的宽度大于字符串的大小，则Verilog使用0来填充左边的空余位；如果寄存器变量的宽度小于字符串的大小，则Verilog截去字符串最左边的位。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">8</span>*<span class="number">18</span>:<span class="number">1</span>] string_value;<span class="comment">//声明变量string_vaiue，其宽度为18个字节</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">string_value = <span class="string">&quot;Hello Verilog World&quot;</span>;<span class="comment">//字符串可以存储在变量中</span></span><br></pre></td></tr></table></figure></li><li><p>有一些特殊字符在显示字符串时有特定的意义，例如换行符，制表符和显示参数值。如果需要在字符串中显示这些特殊字符，则必须加前缀转义字符。</p></li></ol></li></ol><div class="table-container"><table><thead><tr><th>转义字符</th><th>显示的字符</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>tab（制表空格）</td></tr><tr><td>%%</td><td>%</td></tr><tr><td>\\\</td><td>\\</td></tr><tr><td>\\”</td><td>“</td></tr><tr><td>\000</td><td>1到3个八进制数字字符</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><h2 id="系统任务和编译指令"><a href="#系统任务和编译指令" class="headerlink" title="系统任务和编译指令"></a>系统任务和编译指令</h2><h3 id="系统任务"><a href="#系统任务" class="headerlink" title="系统任务"></a>系统任务</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字化结构设计&quot;&gt;&lt;a href=&quot;#数字化结构设计&quot; class=&quot;headerlink&quot; title=&quot;数字化结构设计&quot;&gt;&lt;/a&gt;数字化结构设计&lt;/h1&gt;&lt;h2 id=&quot;层次建模的概念&quot;&gt;&lt;a href=&quot;#层次建模的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="课程" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子信息科学与技术攻略</title>
    <link href="https://rozen12123.github.io/posts/69d7a7f9.html"/>
    <id>https://rozen12123.github.io/posts/69d7a7f9.html</id>
    <published>2023-09-06T14:46:37.000Z</published>
    <updated>2023-09-18T02:42:04.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电子信息科学与技术攻略"><a href="#电子信息科学与技术攻略" class="headerlink" title="电子信息科学与技术攻略"></a>电子信息科学与技术攻略</h1><p>亲爱的学弟学妹们：</p><p>  首先，我要热烈欢迎你们加入电子信息科学与技术专业！恭喜你们顺利踏上了大学的征程，这将是一个充满挑战和成长的旅程。我是电子信息科学与技术专业的一名本科生，非常高兴能在这里与你们分享一些有关入学和大学生活的经验。</p><p>  在你们即将开始的学术和生活冒险中，我相信你们会遇到各种新的机会和挑战。作为学长，我们愿意与你们分享我们的经验，帮助你们更快地适应大学生活。不管你们面临什么问题，都请放心来寻求帮助，我们将竭尽全力支持你们。</p><p>  接下来，让我们一起探讨一些入学后关于学习的一些建议。无论你们有什么疑问或需要，都可以随时私信我。</p><h2 id="关于电子信息科学信息与技术"><a href="#关于电子信息科学信息与技术" class="headerlink" title="关于电子信息科学信息与技术"></a>关于电子信息科学信息与技术</h2><p>  在刚入学时我也对这个专业充满疑问，根本不知道这个专业是什么，要学什么，可以用来干什么。</p><p>  简单来说，电子信息科学与技术是一门涵盖电子工程、计算机科学和信息技术的跨学科领域。它关注的是如何处理、传输和管理信息，以及如何使用电子设备和计算机系统来解决实际问题。</p><p>  具体来说，这个领域包括了以下重要方面：</p><ol><li><strong>电子工程：</strong> 电子信息科学与技术涉及设计、开发和维护各种电子设备和系统，如电路、通信设备、传感器和嵌入式系统。这些技术在现代社会中无处不在，用于各种应用，从智能手机到医疗设备。</li><li><strong>计算机科学：</strong> 这个领域强调计算机系统的设计、编程和软件开发。学生将学习如何编写代码、开发应用程序，并理解计算机硬件和软件之间的相互作用。</li><li><strong>通信技术：</strong> 电子信息科学与技术还涉及到数据通信和网络技术，包括互联网、移动通信和无线传感器网络。这是现代社会中信息传递的关键组成部分。</li><li><strong>信息处理：</strong> 学生将学习如何处理和分析数据，以从中提取有用的信息。这包括数据挖掘、人工智能和机器学习等技术，这些技术在商业、科学和许多其他领域中都有广泛的应用。</li></ol><p>当然如果只这么说的话还是会有些抽象，不过不用担心，接下来的文章里我会对我们的专业做更加详细的解释。</p><p>​    这是一门涉及知识很广的学科，但你不得不说也是一门非常有趣的学科。我最开始知道这个专业并且对此感兴趣是在B站上看到的一个视频。是<strong>稚晖君</strong>做的一个小电视，我当时就被深深得吸引了，如此小的一个小电视上个怎么可以实现这么多功能，完全都可以当作一个电脑来使用。</p><p><a href="https://www.bilibili.com/video/BV1jE41137eu/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【自制】技术宅UP耗时三个月，自制B站最强小电视！【硬核】【3分钟从草图到实物】_哔哩哔哩_bilibili</a></p><p>​    随后，我又在B站发现了更多电子信息专业可以做的很多东西。</p><p><a href="https://www.bilibili.com/video/BV1BW41147kC/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">基于Arduino的十个可以DIY的炫酷项目_哔哩哔哩_bilibili</a></p><p>​    这对还没有开始学习大学知识的你来说可能就像魔法一样，我最开始刚进入大学的时候也是感觉这一切都是那么迷茫，不知道怎办开始，怎么学习才能做出来像这些视频里一样的diy项目。</p><p>​    但是经过一个学期的学习，我在大一上学期结束的那个寒假也用自己所学的东西，做了一个很简易的流水灯，虽然现在看起来是很简单的一个小制作，但是在当时把流水灯点亮的那一刻，心里的成就感是很强烈得，足够开心很久很久。</p><p><a href="https://www.bilibili.com/video/BV1uR4y1u7z5/?spm_id_from=333.999.0.0">做了个流水灯_哔哩哔哩_bilibili</a></p><p>希望你也可以在之后的学习中，做出一些很有趣的小制作。</p><p>&nbsp;</p><h2 id="电子信息科学与技术课程设置及其相关资料"><a href="#电子信息科学与技术课程设置及其相关资料" class="headerlink" title="电子信息科学与技术课程设置及其相关资料"></a>电子信息科学与技术课程设置及其相关资料</h2><h3 id="大一（Freshman-Year）"><a href="#大一（Freshman-Year）" class="headerlink" title="大一（Freshman Year）"></a><strong>大一（Freshman Year）</strong></h3><h4 id="第一学期课程（Curriculum-in-First-Semester）："><a href="#第一学期课程（Curriculum-in-First-Semester）：" class="headerlink" title="第一学期课程（Curriculum in First Semester）："></a>第一学期课程（Curriculum in First Semester）：</h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（一）College Physical Education I</p><p>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</p><p>l 线性代数导论（Introduction to Linear Algebra）</p><p>l 大学物理Ⅰ（University Physics Ⅰ）</p><p>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</p><p>l 编程导论（Introduction to Programming）</p><h4 id="第二学期课程（Curriculum-in-Second-Semester）："><a href="#第二学期课程（Curriculum-in-Second-Semester）：" class="headerlink" title="第二学期课程（Curriculum in Second Semester）："></a><strong>第二学期课程（Curriculum in Second Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（二）College Physical Education II</p><p>l 微积分Ⅱ和III（Calculus Ⅱ and III）</p><p>l 大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</p><p>l 工程学导论Ⅱ（Introduction to Engineering Ⅱ）</p><p>l 电路原理及实验（Electrical Circuit Theory and Lab）</p><h3 id="大二（Sophomore-Year）"><a href="#大二（Sophomore-Year）" class="headerlink" title="大二（Sophomore Year）"></a><strong>大二（Sophomore Year）</strong></h3><h4 id="第三学期课程（Curriculum-in-Third-Semester）："><a href="#第三学期课程（Curriculum-in-Third-Semester）：" class="headerlink" title="第三学期课程（Curriculum in Third Semester）："></a><strong>第三学期课程（Curriculum in Third Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（三）College Physical Education III</p><p>l 常微分方程导论（Introduction to Ordinary Differential）</p><p>l 大学物理III及实验（University Physics III and Lab）</p><p>l 数据结构（Data Structures）</p><p>l 电子学Ⅰ及实验（Electronics Ⅰ and Lab）</p><h4 id="第四学期课程（Curriculum-in-Forth-Semester）"><a href="#第四学期课程（Curriculum-in-Forth-Semester）" class="headerlink" title="第四学期课程（Curriculum in Forth Semester）"></a><strong>第四学期课程（Curriculum in Forth Semester）</strong></h4><p>l 大学体育（四）（College Physical Education IV）</p><p>l 工程概率基础（Introduction to Engineering Probability）</p><p>l 信号与系统（Circuits，Signals and System）</p><p>l 逻辑设计（Logic Design）</p><p>l 数字设计实验（Digital Design Lab）</p><p>l 电子学Ⅱ和实验（Electronics Ⅱ and Lab）</p><p>l 微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</p><p>l 电子电路CAD （Electronic Circuit CAD）</p><h3 id="大三（Junior-Year）"><a href="#大三（Junior-Year）" class="headerlink" title="大三（Junior Year）"></a><strong>大三（Junior Year）</strong></h3><h4 id="第五学期课程（Curriculum-in-Fifth-Semester）"><a href="#第五学期课程（Curriculum-in-Fifth-Semester）" class="headerlink" title="第五学期课程（Curriculum in Fifth Semester）"></a><strong>第五学期课程（Curriculum in Fifth Semester）</strong></h4><p>l 离散时间信号与系统（Discrete-Time Signals and Systems）</p><p>l 电磁场原理（Electromagnetic Field Theory）</p><p>l 固态电子学（Solid-State Electronics）</p><p>l 单片机原理（MCU Principle）</p><p>l 结构化数字设计（含FPGA）Structured Digital Design</p><p>l 创新项目实践（一）Practice of Innovation Project I</p><h4 id="第六学期课程（Curriculum-in-Sixth-Semester）"><a href="#第六学期课程（Curriculum-in-Sixth-Semester）" class="headerlink" title="第六学期课程（Curriculum in Sixth Semester）"></a><strong>第六学期课程（Curriculum in Sixth Semester）</strong></h4><p>l 嵌入式微处理系统设计（Embedded Microprocessor System Design）</p><p>l 通信系统（Communication Systems）</p><p>l 线性控制系统（Linear Control Systems）</p><p>l 电力电子（Power Electronics）</p><p>l VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</p><p>l 模拟集成电路（Analog Integrated Circuit）</p><p>l 创新项目实践（二）Practice of Innovation Project II</p><h3 id="大四（Senior-Year）"><a href="#大四（Senior-Year）" class="headerlink" title="大四（Senior Year）"></a><strong>大四（Senior Year）</strong></h3><h4 id="第七学期课程（Curriculum-in-Seventh-Semester）"><a href="#第七学期课程（Curriculum-in-Seventh-Semester）" class="headerlink" title="第七学期课程（Curriculum in Seventh Semester）"></a><strong>第七学期课程（Curriculum</strong> <strong>in Seventh Semester）</strong></h4><p>l 数字图像处理（Introduction to Digital Image Processing）</p><p>l 现场可编程逻辑阵列（Field programmable logic array）</p><p>l 高级项目设计（Advanced project design）</p><p>l 集成电路EDA（Integrated circuit EDA）</p><p>l 版图设计（Layout design）</p><p>l 专业实习（Internship）</p><h4 id="第八学期课程（Curriculum-in-Eighth-Semester）"><a href="#第八学期课程（Curriculum-in-Eighth-Semester）" class="headerlink" title="第八学期课程（Curriculum in Eighth Semester）"></a><strong>第八学期课程（Curriculum in Eighth Semester）</strong></h4><p>l 毕业设计（Senior Project）</p><p>&nbsp;</p><p>关于大学期间所有能用到得课本已经全部整理出来，链接就放到下面。</p><p>链接：<a href="https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg">https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg</a> 提取码：2038</p><p>​    这一部分要感谢一名学长，将我们所有的文档归纳起来并且分享给大家，我也把这位学长的原博客链接放到下面。这篇博客里还有所有对于我们课程的相关资料的推荐，我个人也是这篇博客的受益者。</p><p><a href="https://y006.github.io/2022/03/23/15-24-59/">电子专业资料共享计划 | Blog (y006.github.io)</a></p><p>​    如果打不开上面的博客，可能是因为博客的地址在GitHub，而你的电脑又没有开vpn。</p><p>关于vpn是什么，怎么使用，你可以去看这个视频。</p><p><a href="https://www.bilibili.com/video/BV1LX4y1E7AS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【科普】VPN到底是什么，你还敢用吗_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="课程部分"><a href="#课程部分" class="headerlink" title="课程部分"></a>课程部分</h2><p>​    大家最关心的莫过于自己将要学习的课程以及如何去学好他们，接下来我将对此讲一些自己的看法，如果你有更好的建议或者发现了错误也希望你及时联系我。</p><p>​    但是大学的知识学习不等同于高中，高中的一贯学习套路是：</p><ol><li>先学会基础知识，了解最基本的概念</li><li>反复练习简单题，中档题及压轴题</li><li>将练习后的题目分类总结，总结成一套自己的方法，直到考试碰到此类问题可以立即有思路，很快地解出题目。</li></ol><p>​    但是在大学如果你仍然按高中的学习方法明显是很吃力的，因为对于三年学习六门科目的学习方法去应对一学期学十几门课的实际情况，明显是不可能的。</p><p>​    我就对大一第一学期的课程做一些简单的介绍。我把课程分为三类，<code>基础类</code>，<code>导论类</code>，<code>应用类</code></p><h3 id="基础类：工程微积分，线性代数导论，大学物理"><a href="#基础类：工程微积分，线性代数导论，大学物理" class="headerlink" title="基础类：工程微积分，线性代数导论，大学物理"></a><em>基础类</em>：工程微积分，线性代数导论，大学物理</h3><p>​    基础类的课程设计了很多的基础概念，公式，和思想。学习这类课程需要你对自己学习过的知识有一个清晰的框架，以至于自己学习完这门课后知道自己都学习了什么内容。</p><p>​    例如你想去做一个平衡车，你学习完这些知识之后你要很清楚知道，微积分中的PID算法可以用来解决调节平衡角度的问题，大学物理的角动量可以让你更加了解平衡的机械部分是如何实现的。</p><h3 id="导论类：工程学导论，编程导论"><a href="#导论类：工程学导论，编程导论" class="headerlink" title="导论类：工程学导论，编程导论"></a><em>导论类</em>：工程学导论，编程导论</h3><p>​    导论类课程一般会带你们使用一种新的技术解决一个问题，这类课程不需要你像基础列课程学习得那么细致，对概念那么精通，你只需要知道这么课大概都讲了什么，用到了什么工具。</p><p>​    例如现在需要你在图纸上画出一个很标准的心形，或者一个零件。这时候你知道，自己在工程学导论中使用CAD可以用来解决这个问题，这个过程中，你不知道软件的工具在哪里，怎么使用，或者使用什么方案，这些都不要紧，你只需要知道有这些工具，并且这些工具可以解决什么问题就可以了。</p><p>​    当然，这也并不代表你就可以只是听故事一样听完整门课程就可以了，上课的例题，或者作业题也需要你去实践一下。</p><p>​    在编程导论中你知道用编程可以解决很多实际问题，它可以帮你计算，管理系统，等等。那你知道这些功能以后去自己写一个学生成绩管理系统是不是也是一个比较有趣的事情</p><p>&nbsp;</p><h3 id="实践类：编程导论"><a href="#实践类：编程导论" class="headerlink" title="实践类：编程导论"></a><em>实践类</em>：编程导论</h3><p>​    大多的实践类课程就是在你有一定的学习基础后，可以用这些基础的知识结合硬件去做一些项目。我们学习的编程导论虽然是一门导论课，但是编程在我们之后的学习生活中是不可或缺的一部分，这门课重要到即使它是一门导论课，也值得我们去把他当作一门实践类课程去学习。</p><p>​    你可以在学习了解完基础知识以后，写一个简单的猜数字游戏，学生成绩管理系统等等。</p><p>​    &nbsp;</p><p>​    或许对于还没有开始上课的你来说看这些内容还有些懵，但是在之后的学习生活中你会对此有更加深刻的体会。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>​    大一的课程是整个大学的基础，十分重要，其中的微积分，线性代数，大学物理，编程导论等也是之后很多课程的基础。</p><p>​    比如：大二你们要学习的常微分的基础就是微积分与线性代数，如果这两门你在最开始就没有学好，那在之后的学习中是很头疼的一件事情，你仍然要返回去学习这些基础课程。所以，希望同学们在最开始的时候就好好学习这些课程。</p><h4 id="l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）"><a href="#l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）" class="headerlink" title="l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）"></a>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</h4><p>微积分一中，主要的大方面学习分几部分</p><ol><li><p>对极限的理解</p></li><li><p>导数的进阶应用</p></li><li><p>微积分中重要思想———积分</p></li><li><p>积分方法的学习</p></li></ol><h5 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h5><p>在第二章极限的学习中，相较于初等数学，了解到了极限与无穷的概念，在图形中分析计算垂直与水平渐近线可以加深对与极限的理解。</p><p>要学会对连续性进行判断，从而判断出任意点的类型（如可去间断点，跳跃间断点等）</p><p>其次，在极限式子的计算中，多数较难的式子均可以最终化简为两个重要极限的形式。</p><script type="math/tex; mode=display">\lim _{x \rightarrow 0} \frac{\sin x}{x}=1 \quad \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e</script><p>由此，对于两个总要的极限的应用就显得及其重要，当然在极限中，熟练运用洛必达法则也是必不可少的</p><p>&nbsp; </p><h5 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h5><p>在高数开始接触导数便移入了很多新的概念，在导数中，很重要的一点就是加深对链法则的理解，这个对以后学习各类积分微分知识都是帮助很大的。</p><p>如果对链法则的理解加深了，关于隐函数求导，符合函数求导，三角函数求导中的一系列问题都可以迎刃而解。</p><p>如果可以，多用导数的概念定义式进行积分的运算，会加深对于极限的理解。</p><p>在导数中有一系列相关的应用问题</p><ol><li><p>求最大最小值</p></li><li><p>求极大极小值</p></li><li><p>凹度与拐点</p></li></ol><p>这些问题无非都是通过1.函数的一阶导2.函数的二阶导3.临界点进行求值</p><p>三个方面进行分析，从而就可以对上诉三个问题进行求解</p><p>熟练理解中值定理，并可以对简单的式子进行推导</p><p> &nbsp;</p><h5 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h5><p>在积分的学习中我也认为是本书中最重要的一个概念，对积分的理解不应该只是会算出各种各样的积分形式，我们当然会学习很多各种各样的积分方法，不限于:<code>分部积分法</code>，<code>三角积分法</code>，<code>三角换元法</code>，<code>分布分式法</code>……..这些方法在大量的练习中我们可以熟练地去解出各种类型的式子，配合506页的公式表，当然效果肯定会更棒。</p><p>对<code>反函数</code>，<code>对数指数</code>模型，<code>反三角函数</code>，在推导过一遍可以对公式进行记背。</p><p>在微积分的应用中，我们不应该仅仅停留在解出图形的<code>面积</code>，<code>体积</code>。</p><p>深刻理解微积分，把整个要计算的图形，分为极限趋向0的无数个点，由点去积分成线，再将由无数的线与一定区间进行积分，可以得到面，对面再积分可以得到体积。这是从一维到三维，我们都是很容易理解的。</p><p>但到四维呢？如果我们对于每个点再赋予一个维度的含义，那么这个式子就可以表达整个图形的质量。</p><p>这样去深刻理解每个维度之间的积分关系，就显得非常奇妙。</p><p>对于中间一些题型呢，如下</p><ol><li><p>求面积</p></li><li><p>求体积</p></li><li><p>求弧长</p></li></ol><p>&nbsp;</p><p>但是总得来说，上述只是对基础知识点的一个概述，微积分在我们的生活中可谓是应用广泛，比如在音乐播放器使用微积分来调整音频信号的音量和频率，以确保音乐听起来和谐而流畅；在电梯系统使用微积分来计算电梯的速度和位置，以便顺利地将你从一楼带到其他楼层；在电子游戏中的物理引擎使用微积分来模拟物体的运动和碰撞，以使游戏更加真实。</p><p>对于微积分，在你学完相关内容后你可以去看这些内容，可以更加加深你对知识的理解。</p><p><a href="https://www.bilibili.com/video/BV1qW411N7FU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【官方双语/合集】微积分的本质 - 系列合集_哔哩哔哩_bilibili</a></p><p>宋浩老师的视频也很适合你去进行预习或者打基础</p><p><a href="https://www.bilibili.com/video/BV1UW411k7Jv/?spm_id_from=333.337.search-card.all.click">《微积分》《高等数学》全程教学视频—宋浩老师_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-线性代数导论（Introduction-to-Linear-Algebra）"><a href="#l-线性代数导论（Introduction-to-Linear-Algebra）" class="headerlink" title="l 线性代数导论（Introduction to Linear Algebra）"></a>l 线性代数导论（Introduction to Linear Algebra）</h4><p>​    线性代数是一门数学分支，它主要研究向量、向量空间和线性变换等概念。它在电子信息科学与技术领域中具有关键作用，因为它提供了处理多维数据和解决复杂问题的数学工具。</p><p>​    注意，这门线性代数是一个数学工具，就好比你学习了方程以后就可以用使用方程来解决一些数学问题，而同样的，当你学习过线性代数以后，你也可以通过线性代数来解决一些数学或者工程上的问题。</p><ol><li><strong>向量和向量空间：</strong> 线性代数的核心概念之一是向量。向量可以用来表示多维数据，如在图像处理、信号处理和数据分析中常见的数据结构。线性代数还研究了向量空间，这是一组满足特定性质的向量的集合。向量空间理论为我们提供了处理和分析数据的框架。</li><li><strong>线性变换：</strong> 另一个重要的概念是线性变换，它描述了如何将一个向量空间映射到另一个向量空间。线性变换在图像处理、信号处理和控制系统等领域中广泛应用。例如，在通信系统中，线性变换可以用来描述信号的传输和变换。</li><li><strong>矩阵：</strong> 矩阵是线性代数中的另一个核心概念，它用于表示线性变换和解决线性方程组。在电子信息科学与技术中，矩阵常常用于描述电路、信号处理滤波器和数据转换等。</li></ol><p>​    我也在知乎上发现了一篇十分详细的知识点，链接在下方。</p><p><a href="https://zhuanlan.zhihu.com/p/453305373">【数学】线性代数知识点总结（精炼版） - 知乎 (zhihu.com)</a></p><p>​    宋浩老师的视频也是相当经典。</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.337.search-card.all.click">《线性代数》高清教学视频 “惊叹号”系列 宋浩老师_哔哩哔哩_bilibili</a></p><p>​    如果在学习完基础内容，会解一些基本题型后，你可以去看3Blue1Brown的视频，相信你在看完之后会对线性代数有更加深刻的认识。</p><p><a href="https://www.bilibili.com/video/BV1ib411t7YR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">-UP主汉语配音-【线性代数的本质】合集-转载于3Blue1Brown官方双语】_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-大学物理Ⅰ（University-Physics-Ⅰ）"><a href="#l-大学物理Ⅰ（University-Physics-Ⅰ）" class="headerlink" title="l 大学物理Ⅰ（University Physics Ⅰ）"></a>l 大学物理Ⅰ（University Physics Ⅰ）</h4><p>​    大学物理Ⅰ的大部分内容其实我们已经在高中学习过了，但要注意的是，大学的物理相较与初中的物理更贴合实际，更具有普遍性。解决这部分实际问题就需要结合微积分知识和大学物理把很多过程微分成很多很小的过程，然后在把这很多很小的过程累积在一起。</p><p>​    例如下面这个图片</p><p>​    在小球从O到A的过程中，弹簧的力一直在发生变化，如果我们需要求在原点O到A点弹簧的弹性势能，用中学的知识，我们可以用图像法分析出</p><script type="math/tex; mode=display">E = \frac{1}{2} k x ^2</script><p>​    在大学学习了微积分以后我们就可以将每一个微小过程中的做的功微分后积分在一起，结果是一样的</p><script type="math/tex; mode=display">E = \int_{0}^{x} kx dx</script><p>​    </p><p>​    但是假设k的值不是恒定的，用高中的知识就无法解决了，但是我们可以用二重积分来解决这个问题，这也就是为什么大学里解决的问题更具有普遍性的例子。也希望大家在学习物理的过程不要只局限与写题，而是多去思考这个过程。</p><p>​    学习大学物理你可以去看东北大学马文蔚老师的物理课。</p><p><a href="https://www.bilibili.com/video/BV1qW411H7UX/?spm_id_from=333.337.search-card.all.click">【大学物理】东北大学-马文蔚_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）"><a href="#l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）" class="headerlink" title="l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）"></a>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</h4><p>​    工程学导论的主要目标是引导你们进入电子信息科学与技术领域。它将帮助你们了解电子技术、通信系统、计算机科学和信息处理等方面的基本概念。</p><p>​    我们将介绍CAD（计算机辅助设计）工具、MATLAB和C++编程，这些工具在电子信息科学与技术领域中非常重要。</p><p>​    大家在课上认真听讲，积极完成老师布置的课下作业，如果你还有精力，那你可以去B站，谷歌，GitHub去了解更多的内容，这门课不是重点也不是难点，你们只需要知道了解我们上课学习的内容即可。</p><p>&nbsp;</p><h4 id="l-编程导论（Introduction-to-Programming）"><a href="#l-编程导论（Introduction-to-Programming）" class="headerlink" title="l 编程导论（Introduction to Programming）"></a>l 编程导论（Introduction to Programming）</h4><p>​    最开始我对编程的感觉就是黑客在都是黑色的屏幕上敲命令行，感觉就像是拥有魔法一样，敲几行代码就可以实现一些不可思议的功能。后来我开始接触编程，还很清楚得记得我在学习完if和for语句做出一个猜数字的游戏后激动的心情。</p><p>​    包括我之前做的那款心形流水灯也是用c语言进行编程的，学会了编程语言就好比你有了一把利器，解决之前不敢想象的问题。</p><p>​    如果你是刚刚入门，我希望你去看翁恺老师的c语言程序设计，这可谓是大家编程梦开始的地方。</p><p><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click">浙江大学翁恺教你C语言程序设计！C语言基础入门！_哔哩哔哩_bilibili</a></p><p>​    如果你已经开始了c++语言的学习，那我推荐你去看黑马程序员的视频，这个视频用很简单的语言就可以解释清楚复杂的知识点，也希望你尽可能得把所有视频上的程序都自己敲写一遍。</p><p><a href="https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></p><p>​    工欲善其事必先利其器，当然学习编程你就需要一款好的编译器，我推荐编程小白使用Visual Studio，这一款编译软件不要配置复杂的编译环境，可谓是上手即用，而且关于其的学习资料还比较多。下载方式如下。</p><p><a href="https://www.bilibili.com/video/BV1Xt411g7jT/?spm_id_from=333.337.search-card.all.click">vs2022(Visual Studio 2022)权威指南&amp;&amp;C语言&amp;&amp;软件工程开发的方向&amp;&amp;技巧要领_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>​    很明显，如果我们只学习课堂上教授的这部分内容，我们并没有办法去完成自己的diy项目或者小制作。我在最开始也有着这个疑问，不知道怎么样去动手实践，但是在之后摸索了很多方法之后，我认为初学者去学习arduino入门是很可行的一个道路。</p><p>​    Arduino是一款便捷灵活、方便上手的开源电子原型平台。很多重来没有接触过电子知识的创客也可用通过arduino来制作自己的小发明，更不用说我们这些科班出身的大学生。</p><p>​    你完全可用自己去淘宝买一套arduino的学习套件，跟着<code>太极创客</code>中的视频模仿，一步一步体会自己动手去做出来一个实物的快乐。</p><p><a href="https://www.bilibili.com/video/BV164411J7GE/?spm_id_from=333.337.search-card.all.click">【太极创客】零基础入门学用Arduino 第一部分 合辑_哔哩哔哩_bilibili</a></p><p>​    希望你一定不要把这作为自己的学习任务，自己去制作小发明就好比自己在拼乐高，去给玩偶涂色等等。是激动人心的一件事。我曾寒假在家就碰到了一个问题，屋子的灯只有一个开关，而我每次睡觉前关灯都需要爬下床去关灯然后抹黑爬回床上。于是我就花了一个下午的时间用蓝牙加舵机使用arduino的开发板制作了一个简易的智能开关。</p><p><a href="https://www.bilibili.com/video/BV1JF411r78p/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">arduino➕舵机➕蓝牙智能灯_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="竞赛部分"><a href="#竞赛部分" class="headerlink" title="竞赛部分"></a>竞赛部分</h2><p>​    我非常建议大一的新生去参加蓝桥杯的单片机赛道，虽然正常情况下大家在大三才会学到单片机的使用，可能在学习中你们并不知道138译码器，与非门等等这些概念，甚至设计功能都不知道这其中的原理是什么，但是这并不妨碍我们先去学习，去接触。</p><p>​    推荐你先去看江科大的单片机以后再去针对比赛看小蜜蜂的比赛视频，蓝桥杯在每年年末报名，次年的四五月份进行比赛。无论如何，只要付出了，这对你绝对是一段很宝贵的学习经历，而且这个比赛的获奖率也是很高的，每年的大一小白参加最后也是有很多获得了省奖。</p><p><a href="https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click">51单片机入门教程-2020版 程序全程纯手打 从零开始入门_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Bt41187hw/?spm_id_from=333.337.search-card.all.click">【小蜜蜂笔记】蓝桥杯大赛-单片机设计与开发基础技能与进阶强化教程_哔哩哔哩_bilibili</a></p><p>​    </p><p>&nbsp;</p><h2 id="寻找资源"><a href="#寻找资源" class="headerlink" title="寻找资源"></a>寻找资源</h2><p>​    大学的学习不同于高中，在高中针对固定的学科学校会统一给同学们发很多教辅，卷子，资料。</p><p>​    但是大学中并不会这样，甚至有些学科你甚至没有课本，电子版课本老师没有发给你的话，你可能上课连课本都没有了。这就需要你有一定的资源检索能力，对于想要学习的内容可以找到对应的学习资料或者网站。</p><p>​    下面会向大家介绍一些资源和网站。</p><h3 id="Chatgpt"><a href="#Chatgpt" class="headerlink" title="Chatgpt"></a>Chatgpt</h3><p>​    我把这个重量级的大模型放在第一位，是因为chatgpt是2022年底发布的，是人类最新技术的应用，强大到令人惊叹。</p><p>​    我曾经在2021年入学的时候遇到过很多问题，我想参加竞赛，想要在有限的时间内学好十几门课程，当了解到单片机，微处理器想去学习，但是会发现很难很难找到老师，去给你解答各种各样的问题，为你答疑解惑制定具体的学习方案。</p><p>​    直到Chatgpt的出现，我发现这个大模型就好像是一个无所不知的老师，你可以去问他任何你已有的疑问，甚至不限于学习，生活，情感，等等等。关于Chatgpt具体是什么，你可以看下面这个视频。</p><p><img src="/posts/69d7a7f9.htm/image-20230916201601406.png" alt="image-20230916201601406" style="zoom:100%;"></p><p><a href="https://www.bilibili.com/video/BV11m4y1B7ur/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">ChatGPT是什么？两分钟带你了解! （中英熟肉字幕）_哔哩哔哩_bilibili</a></p><p>​    当然你也需要找到正确使用它的方式，以至他可以更好理解你的问题并且为你回答，你可以看下面这个网站总结了如何对Chatgpt进行有效提问。</p><p><a href="https://flowus.cn/flowus101/share/f0601ddc-72e5-4b4e-ab17-0af2cce98732">GitHub - PlexPt/awesome-chatgpt-prompts-zh: ChatGPT 中文调教指南 (flowus.cn)</a></p><p>Chatgpt的网址放在下方，你可以去某宝购买一个账号，开vpn登录即可使用（vpn的地址最好是非亚州区，挂在美国更好）</p><p><a href="https://chat.openai.com/auth/login">ChatGPT (openai.com)</a></p><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h3><p>​    bilibili大家号称B站大学，B站上可谓是有着无数的学习资源，通常找一个课程，一个编程项目，去B站搜索这些资源链接都会出现在评论区的第一条或者视频的介绍中，点击链接下载即可。</p><p>​    B站也有着更种各样的优秀课程，宋浩老师的高数系列，3blue1brown等等，上课没听懂不用去担心，B站大学为你兜底。</p><p>​    你同样也可以在B站学习如何去寻找资源。</p><p><a href="https://www.bilibili.com/video/BV17P4y187Kw/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道能帮你找到所有想要资源！！！第2期_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Db4y1a7sa/?vd_source=db4533a45f532ba6c1133faafbf7f171">收藏血赚！3分钟大学逆袭，各专业最有用资源大合集！_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1TN411d7FL/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">99%的人不知道这些渠道，能帮你找到所有想要资源！第1期_哔哩哔哩_bilibili</a></p><h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>​    如果你想参加一个比赛，一个项目，去知乎搜索相关内容，它会给到你更加客观的答案（现在可能会对各种事情的看法会更加现实和消极）</p><p>​    如果你是想听听大家对一个事件，一个学科或者是各种各样问题的看法或者意见，那欢迎你来到知乎。</p><p>&nbsp;</p><h3 id="CDSN"><a href="#CDSN" class="headerlink" title="CDSN"></a>CDSN</h3><p>​    <em>CSDN</em>是全球知名中文IT技术交流平台，如果你是在学习编程语言，机器学习，各种各样的技术知识，这绝对是你绕不开的一个平台，去互联网上去寻找响应的代码，你很有可能就是在csdn上找到答案。</p><p>​    比如你正在学习数据结构的链表，但是你上课有没有太听懂，你就可以去csdn搜索链表，会出现各种各样关于链表的总结，其中可能就会点进我的主页（悄悄安利自己一波）</p><p><a href="https://blog.csdn.net/u011146203/article/details/127587997?spm=1001.2014.3001.5501">（数据结构）链表_指针怎么取数据域_江江江江江江江江江的博客-CSDN博客</a></p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>​    在开始学习编程的时候，经常会遇到编译错误的问题，但是这也可能是之前别人学习时也碰到的问题，把错误复制下来输入到搜索引擎，一般情况下你也会在其中找到你想要的答案。</p><p><a href="https://www.baidu.com/">百度一下，你就知道 (baidu.com)</a></p><p>&nbsp;</p><h3 id="小红书"><a href="#小红书" class="headerlink" title="小红书"></a>小红书</h3><p>​    去旅游想知道那里有什么好吃的，生了xx要怎么处理，想要去学习做个什么饭等等这些生活中的问题小红书会给你答案，（我也经常会去小红书上大家安利的美食店）。但毕竟是社交平台，还有微博，知乎这些，关于大家对事情都有自己的看法，保持正确三观，遵从内心的想法，不要别人说风就是雨。有时候看太多一些社会，工作还是情感上的内容会平添很多焦虑。希望大家可以自由愉快地享受大学生活。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>因为我目前也只是一名刚进入大三的本科生，很多想法见解可能在之后的学习过程中也会有不同的体验，如果你有更好的建议或者发现了一些错误请及时私信我，本文档将持续进行更新……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电子信息科学与技术攻略&quot;&gt;&lt;a href=&quot;#电子信息科学与技术攻略&quot; class=&quot;headerlink&quot; title=&quot;电子信息科学与技术攻略&quot;&gt;&lt;/a&gt;电子信息科学与技术攻略&lt;/h1&gt;&lt;p&gt;亲爱的学弟学妹们：&lt;/p&gt;
&lt;p&gt;  首先，我要热烈欢迎你们加入电子</summary>
      
    
    
    
    
    <category term="学习攻略" scheme="https://rozen12123.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>cpu制作</title>
    <link href="https://rozen12123.github.io/posts/68d8d011.html"/>
    <id>https://rozen12123.github.io/posts/68d8d011.html</id>
    <published>2023-08-22T10:15:33.000Z</published>
    <updated>2023-10-11T08:54:28.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu的制作"><a href="#cpu的制作" class="headerlink" title="cpu的制作"></a>cpu的制作</h1><p>cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可完成搭建。</p><p>而且自己制作cpu是一件非常有趣的一件事情，去理解身边的电脑，手机等等的一些运作的底层原理。</p><p>那么现在，我们就从最开始最简单的电路开始搭建吧。</p><h2 id="电路搭建"><a href="#电路搭建" class="headerlink" title="电路搭建"></a>电路搭建</h2><h3 id="与或非门，同或异或门"><a href="#与或非门，同或异或门" class="headerlink" title="与或非门，同或异或门"></a>与或非门，同或异或门</h3><p><img src="/posts/68d8d011.htm/image-20231010180429855.png" alt="image-20231010180429855" style="zoom:67%;"></p><p>与或非是计算机逻辑门的最基础的部件，其他任意的部件都可以通过与或非三种门来表示。</p><h3 id="八位加法器"><a href="#八位加法器" class="headerlink" title="八位加法器"></a>八位加法器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> eight_bit_full_adder  (</span><br><span class="line">  <span class="keyword">input</span> A,</span><br><span class="line">  <span class="keyword">input</span> B,</span><br><span class="line">  <span class="keyword">output</span> S,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> S = (A ^ B);</span><br><span class="line">  <span class="keyword">assign</span> C = (A &amp; B);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> DIG_Add</span><br><span class="line">#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">input</span> c_i,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">    <span class="keyword">output</span> c_o</span><br><span class="line">);</span><br><span class="line">   <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">   <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> \?????  (</span><br><span class="line">  <span class="keyword">input</span> A1,</span><br><span class="line">  <span class="keyword">input</span> B1,</span><br><span class="line">  <span class="keyword">input</span> A2,</span><br><span class="line">  <span class="keyword">input</span> B2,</span><br><span class="line">  <span class="keyword">input</span> A3,</span><br><span class="line">  <span class="keyword">input</span> B3,</span><br><span class="line">  <span class="keyword">input</span> A4,</span><br><span class="line">  <span class="keyword">input</span> B4,</span><br><span class="line">  <span class="keyword">input</span> A5,</span><br><span class="line">  <span class="keyword">input</span> B5,</span><br><span class="line">  <span class="keyword">input</span> A6,</span><br><span class="line">  <span class="keyword">input</span> B6,</span><br><span class="line">  <span class="keyword">input</span> A7,</span><br><span class="line">  <span class="keyword">input</span> B7,</span><br><span class="line">  <span class="keyword">input</span> A0,</span><br><span class="line">  <span class="keyword">input</span> B0,</span><br><span class="line">  <span class="keyword">output</span> S0,</span><br><span class="line">  <span class="keyword">output</span> S1,</span><br><span class="line">  <span class="keyword">output</span> S2,</span><br><span class="line">  <span class="keyword">output</span> S3,</span><br><span class="line">  <span class="keyword">output</span> S4,</span><br><span class="line">  <span class="keyword">output</span> S5,</span><br><span class="line">  <span class="keyword">output</span> S6,</span><br><span class="line">  <span class="keyword">output</span> S7,</span><br><span class="line">  <span class="keyword">output</span> C</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> s8;</span><br><span class="line">  <span class="keyword">wire</span> s9;</span><br><span class="line">  <span class="keyword">wire</span> s10;</span><br><span class="line">  <span class="keyword">wire</span> s11;</span><br><span class="line">  <span class="keyword">wire</span> s12;</span><br><span class="line">  <span class="keyword">wire</span> s13;</span><br><span class="line">  <span class="keyword">wire</span> s14;</span><br><span class="line">  \???  \???_i0 (</span><br><span class="line">    <span class="variable">.A</span>( A0 ),</span><br><span class="line">    <span class="variable">.B</span>( B0 ),</span><br><span class="line">    <span class="variable">.S</span>( S0 ),</span><br><span class="line">    <span class="variable">.C</span>( s8 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i1 (</span><br><span class="line">    <span class="variable">.a</span>( s8 ),</span><br><span class="line">    <span class="variable">.b</span>( A1 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B1 ),</span><br><span class="line">    <span class="variable">.s</span>( S1 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s9 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i2 (</span><br><span class="line">    <span class="variable">.a</span>( A2 ),</span><br><span class="line">    <span class="variable">.b</span>( s9 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B2 ),</span><br><span class="line">    <span class="variable">.s</span>( S2 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s10 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i3 (</span><br><span class="line">    <span class="variable">.a</span>( s10 ),</span><br><span class="line">    <span class="variable">.b</span>( A3 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B3 ),</span><br><span class="line">    <span class="variable">.s</span>( S3 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s11 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i4 (</span><br><span class="line">    <span class="variable">.a</span>( s11 ),</span><br><span class="line">    <span class="variable">.b</span>( A4 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B4 ),</span><br><span class="line">    <span class="variable">.s</span>( S4 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s12 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i5 (</span><br><span class="line">    <span class="variable">.a</span>( s12 ),</span><br><span class="line">    <span class="variable">.b</span>( A5 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B5 ),</span><br><span class="line">    <span class="variable">.s</span>( S5 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s13 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i6 (</span><br><span class="line">    <span class="variable">.a</span>( s13 ),</span><br><span class="line">    <span class="variable">.b</span>( A6 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B6 ),</span><br><span class="line">    <span class="variable">.s</span>( S6 ),</span><br><span class="line">    <span class="variable">.c_o</span>( s14 )</span><br><span class="line">  );</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">1</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i7 (</span><br><span class="line">    <span class="variable">.a</span>( s14 ),</span><br><span class="line">    <span class="variable">.b</span>( A7 ),</span><br><span class="line">    <span class="variable">.c_i</span>( B7 ),</span><br><span class="line">    <span class="variable">.s</span>( S7 ),</span><br><span class="line">    <span class="variable">.c_o</span>( C )</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h3><p>与门可以存储下来0，或门可以存储下来1，我们把与门和或门进行一个组合，就能做出来第一个有用的电路结构。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> latch  (</span><br><span class="line">  <span class="keyword">input</span> Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">output</span> Out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> Out_temp;</span><br><span class="line">  <span class="keyword">assign</span> Out_temp = ((Out_temp | (Din &amp; WE)) &amp; ~ (~ Din &amp; WE));</span><br><span class="line">  <span class="keyword">assign</span> Out = Out_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器=8位锁存器/16/32位</p><p>一次可以存储8位数据。</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>Dindatain</td><td>数据输入</td></tr><tr><td>WE</td><td>write enable</td></tr></tbody></table></div><p>当WE为高电平的时候，Din的数据可以被存储起来当WE为低电平的时候，out的值不发生变化。</p><p><img src="/posts/68d8d011.htm/image-20231011105654618.png" alt="image-20231011105654618" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="带边缘触发的锁存器"><a href="#带边缘触发的锁存器" class="headerlink" title="带边缘触发的锁存器"></a>带边缘触发的锁存器</h3><h4 id="为什么需要时钟"><a href="#为什么需要时钟" class="headerlink" title="为什么需要时钟"></a>为什么需要时钟</h4><p>大家都见过划船的，划船需要一个喊口号的主要原因是为了保证协调。通过喊口号，船员们可以同步动作，确保船在平稳且有效率地前进。<br>CPU需要clock来同步内部操作，如执行指令、进行数据传输等。Clock提供了精确的时间控制，确保每个内部操作在正确的顺序与速度内执行，从而确保CPU的正常工作。另外，Clock还与CPU的频率相关，通过控制Clock频率，可以控制CPU的速度。</p><h4 id="时钟信号是什么"><a href="#时钟信号是什么" class="headerlink" title="时钟信号是什么"></a>时钟信号是什么</h4><p>时钟信号就是周期性的高低电平变化的信号<br>我们可以用两个普通的寄存器加上一个非门，组成一个带有边缘触发的寄存器。<br>在按钮按下的一瞬间，电压从低电平到高电平的一瞬间，Din的数据被存储起来。</p><p>&nbsp;</p><h3 id="寄存器REG"><a href="#寄存器REG" class="headerlink" title="寄存器REG"></a>寄存器REG</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th><th></th></tr></thead><tbody><tr><td>D</td><td>数据输入</td><td></td></tr><tr><td>C</td><td>时钟信号</td><td></td></tr><tr><td>en</td><td>使能端口，高电平工作</td></tr></tbody></table></div><p>存储器-寄存器</p><blockquote><p>可以做的扩展，增加输入使能WE和输出使能OE<br>寄存器访问速度快，因为寄存器的每一条数据线都是直接接出来的。</p></blockquote><p>&nbsp;</p><h3 id="十六位的内存"><a href="#十六位的内存" class="headerlink" title="十六位的内存"></a>十六位的内存</h3><p>内存地址：从并行到串行<br>内存单元格要自己自己在哪一行和哪一列，需要有row和column<br>内存单元要有ld（load）读的控制<br>内存单元要有str（store）有存的控制<br>内存单元要有数据的输入</p><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>row&amp;column</td><td>确定需要储存的地址</td></tr><tr><td>ld（load）</td><td>读的控制</td></tr><tr><td>str（store）</td><td>存的控制</td></tr></tbody></table></div><p>内存地址：从并行到串行<br>内存地址的作用主要是为了节省数据线，简化电路数量有了内存地址的概念后，输入和输出只需要1条数据线了先选中需要读写的内存单元，再输入输出</p><p>&nbsp;</p><h3 id="8位的寄存器"><a href="#8位的寄存器" class="headerlink" title="8位的寄存器"></a>8位的寄存器</h3><p>设计8位（bit）的寄存器，用于CPU存储的临时计算的数据</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DIG_Register_BUS #(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> C,</span><br><span class="line">    <span class="keyword">input</span> en,</span><br><span class="line">    <span class="keyword">input</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]D,</span><br><span class="line">    <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>]Q</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] state = <span class="number">&#x27;h0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Q = state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> C) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (en)</span><br><span class="line">        state &lt;= D;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="number">8_</span>REG  (</span><br><span class="line">  <span class="keyword">input</span> Clock,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] Din,</span><br><span class="line">  <span class="keyword">input</span> WE,</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] Stored_Data_temp;</span><br><span class="line">  DIG_Register_BUS #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Register_BUS_i0 (</span><br><span class="line">    <span class="variable">.D</span>( Din ),</span><br><span class="line">    <span class="variable">.C</span>( Clock ),</span><br><span class="line">    <span class="variable">.en</span>( WE ),</span><br><span class="line">    <span class="variable">.Q</span>( Stored_Data_temp )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( Stored_Data_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> Stored_Data = Stored_Data_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>基于上面的原理图，我们分别设计4位和8位的寄存器4位的寄存器用于程序计数器（PC）和MAR（内存地址寄存器）<br>8位的寄存器用于指令寄存器（IR），CPU通用临时寄存器（RegA）（RegB），内存缓存寄存器（MBR）等。分别测试4位和8位的寄存器。</p><p><img src="/posts/68d8d011.htm/image-20231011154050156.png" alt="image-20231011154050156" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="逻辑和算数运算单元（ALU）"><a href="#逻辑和算数运算单元（ALU）" class="headerlink" title="逻辑和算数运算单元（ALU）"></a>逻辑和算数运算单元（ALU）</h3><div class="table-container"><table><thead><tr><th>引脚</th><th>解释</th></tr></thead><tbody><tr><td>RegA</td><td>8位的寄存器数据</td></tr><tr><td>RegB</td><td>8位的寄存器数据</td></tr><tr><td>OE</td><td>输出允许</td></tr><tr><td>ALUResult</td><td>ALU内部计算结果，方便观察调试</td></tr><tr><td>Carry</td><td>溢出位引出1位信号线</td></tr><tr><td>Dout</td><td>输出数据8位，默认高阻态</td></tr></tbody></table></div><p><img src="/posts/68d8d011.htm/image-20231011155356141.png" alt="image-20231011155356141" style="zoom:80%;"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">* <span class="keyword">module</span> DIG_Add</span><br><span class="line">  #(</span><br><span class="line">  <span class="keyword">parameter</span> Bits = <span class="number">1</span></span><br><span class="line">  )</span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] a,</span><br><span class="line">  <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] b,</span><br><span class="line">  <span class="keyword">input</span> c_i,</span><br><span class="line">  <span class="keyword">output</span> [(Bits - <span class="number">1</span>):<span class="number">0</span>] s,</span><br><span class="line">  <span class="keyword">output</span> c_o</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">wire</span> [Bits:<span class="number">0</span>] temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> temp = a + b + c_i;</span><br><span class="line">  <span class="keyword">assign</span> s = temp [(Bits-<span class="number">1</span>):<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> c_o = temp[Bits];</span><br><span class="line">  <span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DriverBus#(</span><br><span class="line">    <span class="keyword">parameter</span> Bits = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [(Bits-<span class="number">1</span>):<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out = (sel == <span class="number">1&#x27;b1</span>)? in : &#123;Bits&#123;<span class="number">1&#x27;bz</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">  <span class="keyword">input</span> OE,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegA,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] RegB,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Dout,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result,</span><br><span class="line">  <span class="keyword">output</span> Carry</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] ALU_Result_temp;</span><br><span class="line">  DIG_Add #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DIG_Add_i0 (</span><br><span class="line">    <span class="variable">.a</span>( RegA ),</span><br><span class="line">    <span class="variable">.b</span>( RegB ),</span><br><span class="line">    <span class="variable">.c_i</span>( <span class="number">1&#x27;b0</span> ),</span><br><span class="line">    <span class="variable">.s</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.c_o</span>( Carry )</span><br><span class="line">  );</span><br><span class="line">  DriverBus #(</span><br><span class="line">    <span class="variable">.Bits</span>(<span class="number">8</span>)</span><br><span class="line">  )</span><br><span class="line">  DriverBus_i1 (</span><br><span class="line">    <span class="variable">.in</span>( ALU_Result_temp ),</span><br><span class="line">    <span class="variable">.sel</span>( OE ),</span><br><span class="line">    <span class="variable">.out</span>( Dout )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">assign</span> ALU_Result = ALU_Result_temp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="CPU框架搭建"><a href="#CPU框架搭建" class="headerlink" title="CPU框架搭建"></a>CPU框架搭建</h3><p><img src="/posts/68d8d011.htm/image-20231011161355384.png" alt="image-20231011161355384" style="zoom:80%;"></p><p><img src="/posts/68d8d011.htm/image-20231011165424214.png" alt="image-20231011165424214" style="zoom:80%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cpu的制作&quot;&gt;&lt;a href=&quot;#cpu的制作&quot; class=&quot;headerlink&quot; title=&quot;cpu的制作&quot;&gt;&lt;/a&gt;cpu的制作&lt;/h1&gt;&lt;p&gt;cpu制作在最开始听起来是一个非常复杂的项目，但其实其所需要的基础非常简单，只需要一些简单的数字电路基础即可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单cpu的内部结构</title>
    <link href="https://rozen12123.github.io/posts/dee20e4.html"/>
    <id>https://rozen12123.github.io/posts/dee20e4.html</id>
    <published>2023-08-09T16:14:36.000Z</published>
    <updated>2023-10-10T08:16:20.615Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>verilog基础语法</title>
    <link href="https://rozen12123.github.io/posts/20b3f144.html"/>
    <id>https://rozen12123.github.io/posts/20b3f144.html</id>
    <published>2023-08-07T10:56:38.000Z</published>
    <updated>2023-08-09T15:51:29.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="verilog基础语法"><a href="#verilog基础语法" class="headerlink" title="verilog基础语法"></a>verilog基础语法</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Verilog 是区分大小写的。</p><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><p>标识符（identifier）可以是任意一组字母、数字、<strong>$</strong> 符号和 <strong>_</strong>(下划线)符号的合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元符开始。</p><p>关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。</p><p>Verilog 中关键字全部为小写。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter ; <span class="comment">//reg 为关键字， counter 为标识符</span></span><br><span class="line"><span class="keyword">input</span> clk; <span class="comment">//input 为关键字，clk 为标识符</span></span><br><span class="line"><span class="keyword">input</span> CLK; <span class="comment">//CLK 与 clk是 2 个不同的标识符</span></span><br></pre></td></tr></table></figure><p>Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：</p><ul><li>0：逻辑 0 或 “假”</li><li>1：逻辑 1 或 “真”</li><li>x 或 X：未知</li><li>z 或 Z：高阻</li></ul><p><strong>x</strong> 意味着信号数值的不确定，即在实际电路里，信号可能为 1，也可能为 0。</p><p><strong>z</strong> 意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 pad 的 input 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0 。</p><h3 id="整数数值表示方法"><a href="#整数数值表示方法" class="headerlink" title="整数数值表示方法"></a>整数数值表示方法</h3><p>数字声明时，合法的基数格式有 4 种，包括：十进制(‘d 或 ‘D)，十六进制(‘h 或 ‘H)，二进制（’b 或 ‘B），八进制（’o 或 ‘O）。数值可指明位宽，也可不指明位宽。</p><p><strong>指明位宽：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1011</span>         <span class="comment">// 4bit 数值</span></span><br><span class="line"><span class="number">32&#x27;h3022_c0de</span>   <span class="comment">// 32bit 的数值</span></span><br></pre></td></tr></table></figure><p><strong>不指明位宽:</strong></p><p>一般直接写数字时，默认为十进制表示，例如下面的 3 种写法是等效的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">&#x27;d100</span> ; <span class="comment">//一般会根据编译器自动分频位宽，常见的为32bit</span></span><br><span class="line">counter = <span class="number">100</span> ;</span><br><span class="line">counter = <span class="number">32&#x27;h64</span> ;</span><br></pre></td></tr></table></figure><p><code>位宽就是**内存或显存一次能传输的数据量**。 简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。</code></p><p><strong>负数表示</strong></p><p>通常在表示位宽的数字前面加一个减号来表示负数。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d15</span>  </span><br><span class="line">-<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="实数表示方法"><a href="#实数表示方法" class="headerlink" title="实数表示方法"></a>实数表示方法</h3><p>实数表示方法主要有两种方式：</p><p><strong>科学计数法：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="variable">.2e4</span>         <span class="comment">//大小为12000</span></span><br><span class="line"><span class="number">1_0001</span>e4      <span class="comment">//大小为100010000</span></span><br><span class="line"><span class="number">1</span>E-<span class="number">3</span>          <span class="comment">//大小为0.001</span></span><br></pre></td></tr></table></figure><h3 id="字符串表示方法"><a href="#字符串表示方法" class="headerlink" title="字符串表示方法"></a>字符串表示方法</h3><p>字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含<code>回车符</code>。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。例如，为存储字符串 “www.runoob.com”, 需要 14*8bit 的存储单元。例如：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;<span class="comment">//先定义字符串的大小14*8bit </span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="Verilog的数据类型"><a href="#Verilog的数据类型" class="headerlink" title="Verilog的数据类型"></a>Verilog的数据类型</h2><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p><h3 id="线网（wire）"><a href="#线网（wire）" class="headerlink" title="线网（wire）"></a>线网（wire）</h3><p>wire 类型表示硬件单元之间的<code>物理连线</code>，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>   interrupt ;</span><br><span class="line"><span class="keyword">wire</span>   flag1, flag2 ;</span><br><span class="line"><span class="keyword">wire</span>   gnd = <span class="number">1&#x27;b0</span> ;</span><br></pre></td></tr></table></figure><p>线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。</p><h3 id="寄存器（reg）"><a href="#寄存器（reg）" class="headerlink" title="寄存器（reg）"></a>寄存器（reg）</h3><p>寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>    clk_temp;</span><br><span class="line"><span class="keyword">reg</span>    flag1, flag2 ;</span><br></pre></td></tr></table></figure><p>例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rstn ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rstn = <span class="number">1&#x27;b0</span> ;</span><br><span class="line">    #<span class="number">100</span> ;</span><br><span class="line">    rstn = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>当位宽大于 1 时，wire 或 reg 即可声明为向量的形式。例如：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]      counter ;    <span class="comment">//声明4bit位宽的寄存器counter</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>-<span class="number">1</span>:<span class="number">0</span>]  gpio_data;   <span class="comment">//声明32bit位宽的线型变量gpio_data</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">2</span>]     addr ;       <span class="comment">//声明7bit位宽的线型变量addr，位宽范围为8:2</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">31</span>]     data ;       <span class="comment">//声明32bit位宽的寄存器变量data, 最高有效位为0</span></span><br></pre></td></tr></table></figure><p>对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如：</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>]     data_low = data[<span class="number">0</span>:<span class="number">9</span>] ;</span><br><span class="line">addr_temp[<span class="number">3</span>:<span class="number">2</span>] = addr[<span class="number">8</span>:<span class="number">7</span>] + <span class="number">1&#x27;b1</span> ;</span><br></pre></td></tr></table></figure><p>Verilog 支持可变的向量域选择，例如：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]     data1 ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]      byte1 [<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">integer</span> j ;</span><br><span class="line"><span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=<span class="number">3</span>;j=j+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        byte1[j] = data1[(j+<span class="number">1</span>)*<span class="number">8</span>-<span class="number">1</span> : j*<span class="number">8</span>]; </span><br><span class="line">        <span class="comment">//把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。</strong></p><ul><li><strong>[bit+: width]</strong> : 从起始 bit 位开始递增，位宽为 width。</li><li><strong>[bit-: width]</strong> : 从起始 bit 位开始递减，位宽为 width。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">A = data1[<span class="number">31</span>-: <span class="number">8</span>] ;</span><br><span class="line">A = data1[<span class="number">31</span>:<span class="number">24</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">B = data1[<span class="number">0</span>+ : <span class="number">8</span>] ;</span><br><span class="line">B = data1[<span class="number">0</span>:<span class="number">7</span>] ;</span><br></pre></td></tr></table></figure><p><strong>对信号重新进行组合成新的向量时，需要借助大括号。例如：</strong></p><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]    temp1, temp2 ;</span><br><span class="line"><span class="keyword">assign</span> temp1 = &#123;byte1[<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>], data1[<span class="number">31</span>:<span class="number">8</span>]&#125;;  <span class="comment">//数据拼接</span></span><br><span class="line"><span class="keyword">assign</span> temp2 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//赋值32位的数值0</span></span><br></pre></td></tr></table></figure><h2 id="整数，实数，时间寄存器变量"><a href="#整数，实数，时间寄存器变量" class="headerlink" title="整数，实数，时间寄存器变量"></a>整数，实数，时间寄存器变量</h2><p>整数，实数，时间等数据类型实际也属于寄存器类型。</p><p><strong>整数（integer）</strong>(相当于int)</p><p>整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。例如：</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reg [31:0]      data1 ;</span><br><span class="line">reg [3:0]       byte1 [7:0]; //数组变量，后续介绍</span><br><span class="line">integer j ;  //整型变量，用来辅助生成数字电路</span><br><span class="line">always@* begin</span><br><span class="line">    for (j=0; j&lt;=3;j=j+1) begin</span><br><span class="line">        byte1[j] = data1[(j+1)*8-1 : j*8]; </span><br><span class="line">        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>此例中，integer 信号 j 作为辅助信号，将 data1 的数据依次赋值给数组 byte1。综合后实际电路里并没有 j 这个信号，j 只是辅助生成相应的硬件电路。</p><p><code>always@* begin</code>：</p><ul><li>这是一个组合逻辑块的定义，<code>always@*</code>表示该组合逻辑块会在任何输入变化时执行。</li></ul><p><strong>时序逻辑</strong>：</p><ul><li><code>always @ (posedge clk)</code> 表示在时钟上升沿触发的时序逻辑。</li><li>在时钟上升沿触发时，将执行<code>begin</code>和<code>end</code>之间的代码块。</li></ul><p><strong>实数（real）</strong></p><p>实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。例如：</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>        data1 ;</span><br><span class="line"><span class="keyword">integer</span>     temp ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    data1 = <span class="number">2</span>e3 ;</span><br><span class="line">    data1 = <span class="number">3</span><span class="variable">.75</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    temp = data1 ; <span class="comment">//temp 值的大小为3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>时间（time）</strong></p><p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time$ 获取当前仿真时间。例如：</p><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span>       current_time ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">       #<span class="number">100</span> ;</span><br><span class="line">       current_time = <span class="built_in">$time</span> ; <span class="comment">//current_time 的大小为 100</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。</p><p>数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：<strong>&lt;数组名&gt;[&lt;下标&gt;]</strong>。对于多维数组来讲，用户需要说明其每一维的索引。例如：</p><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>          flag [<span class="number">7</span>:<span class="number">0</span>] ; <span class="comment">//8个整数组成的数组</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       counter [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个4bit计数器组成的数组</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]       addr_bus [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个8bit wire型变量组成的数组</span></span><br><span class="line"><span class="keyword">wire</span>             data_bit[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>] ; <span class="comment">//声明1bit wire型变量的二维数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]       data_4d[<span class="number">11</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>] ; <span class="comment">//声明4维的32bit数据变量数组</span></span><br></pre></td></tr></table></figure><p>下面显示了对数组元素的赋值操作：</p><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag [<span class="number">1</span>]   = <span class="number">32&#x27;d0</span> ; <span class="comment">//将flag数组中第二个元素赋值为32bit的0值</span></span><br><span class="line">counter[<span class="number">3</span>] = <span class="number">4&#x27;hF</span> ;  <span class="comment">//将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4&#x27;hF，即可省略宽度; </span></span><br><span class="line"><span class="keyword">assign</span> addr_bus[<span class="number">0</span>]        = <span class="number">8&#x27;b0</span> ; <span class="comment">//将数组addr_bus中第一个元素的值赋值为0</span></span><br><span class="line"><span class="keyword">assign</span> data_bit[<span class="number">0</span>][<span class="number">1</span>]     = <span class="number">1&#x27;b1</span>;  <span class="comment">//将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1&#x27;b1; 是非法的。</span></span><br><span class="line">data_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] = <span class="number">15&#x27;d3</span> ;  <span class="comment">//将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3</span></span><br></pre></td></tr></table></figure><p>虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1。它们在结构的定义上就有所区别。</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。例如：</p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>               membit[<span class="number">0</span>:<span class="number">255</span>] ;  <span class="comment">//256bit的1bit存储器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]        mem[<span class="number">0</span>:<span class="number">1023</span>] ;    <span class="comment">//1Kbyte存储器，位宽8bit</span></span><br><span class="line">mem[<span class="number">511</span>] = <span class="number">8&#x27;b0</span> ;                  <span class="comment">//令第512个8bit的存储单元值为0</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>      data_width = <span class="number">10&#x27;d32</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      mem_size = data_width * <span class="number">10</span> ;</span><br></pre></td></tr></table></figure><p>但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。</p><p>局部参数用 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 localparam 来说明。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p><p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”, 需要 14*8bit 的存储单元：</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;run.runoob.com&quot;</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>有一些特殊字符在显示字符串中有特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前面加前缀转义字符 <strong>\</strong> 。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">显示字符</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">%</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">1到3个8进制数字字符</td></tr></tbody></table></div><p>其实，在 SystemVerilog（主要用于 Verilog 仿真的编程语言）语言中，已经可以直接用关键字 string 来表示字符串变量类型，这为 Verilog 的仿真带来了极大的便利。有兴趣的学者可以简单学习下 SystemVerilog。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a^b ;          <span class="comment">//a与b进行异或操作</span></span><br><span class="line">address[<span class="number">9</span>:<span class="number">0</span>] + <span class="number">10&#x27;b1</span> ;  <span class="comment">//地址累加</span></span><br><span class="line">flag1 &amp;&amp; flag2 ;  <span class="comment">//逻辑与操作</span></span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。</p><p>操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。</p><h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//实数</span></span><br><span class="line"><span class="keyword">real</span> a, b, c;</span><br><span class="line">c = a + b ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       cprmu_1, cprmu_2 ;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cprmu_2 = cprmu_1 ^ cprmu_2 ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">reg</span>  flag1 ;</span><br><span class="line">flag = calculate_result(A, B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//非法操作数</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]         res;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]        temp;</span><br><span class="line"><span class="keyword">always</span>@ （*）<span class="keyword">begin</span></span><br><span class="line">    res    = cprmu_2 – cprmu_1 ;</span><br><span class="line">    <span class="comment">//temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。</p><p>大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 2 种写法都是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自右向左关联，两种写法等价</span></span><br><span class="line">A+B-C ;</span><br><span class="line">(A+B）-C ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span><br><span class="line">A ? B : C ? D : F ;</span><br><span class="line">A ? B : (C ? D : F) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法不等价</span></span><br><span class="line">(A ? B : C) ? D : F ;  <span class="comment">//结果 D 或 F</span></span><br><span class="line">A ? B : C ? D : F ; <span class="comment">//结果为 B、D 或 F</span></span><br></pre></td></tr></table></figure><p>不同操作符之间，优先级是不同的。下表列出了操作符优先级从高至低的排列顺序。当没有圆括号时，Verilog 会根据操作符优先级对表达式进行计算。为了避免由操作符优先级导致的计算混乱，在不确定优先级时，建议用圆括号将表达式区分开来。</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">操作符号</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">单目运算</td><td style="text-align:left">+ - ! ~</td><td style="text-align:left">最高</td></tr><tr><td style="text-align:left">乘、除、取模</td><td style="text-align:left">* / %</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt;  &gt;&gt;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">等价</td><td style="text-align:left">== != === !===</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">归约</td><td style="text-align:left">&amp; ~&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">^ ~^</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">~\</td><td></td><td></td></tr><tr><td style="text-align:left">逻辑</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td></td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">最低</td></tr></tbody></table></div><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>算术操作符包括单目操作符和双目操作符。</p><p>双目操作符对 2 个操作数进行算术运算，包括乘（<em>）、除（/）、加（+）、减（-）、求幂（*</em>）、取模（%）。</p><h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  a, b;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]  c ;</span><br><span class="line">a = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">b = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">c = a+b;        <span class="comment">//结果为c=b&#x27;b1011</span></span><br><span class="line">c = a/b;          <span class="comment">//结果为c=4，取整</span></span><br></pre></td></tr></table></figure><p>如果操作数某一位为 X，则计算结果也会全部出现 X。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">4&#x27;b100x</span> ;</span><br><span class="line">c = a+b ;       <span class="comment">//结果为c=4&#x27;bxxxx</span></span><br></pre></td></tr></table></figure><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。否则，高位将被截断，导致结果高位丢失。无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]        mula ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]        mulb;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>]        res ;</span><br><span class="line">mula = <span class="number">4&#x27;he</span>   ;</span><br><span class="line">mulb = <span class="number">2&#x27;h3</span>   ;</span><br><span class="line">res  = mula * mulb ; <span class="comment">//结果为res=6&#x27;h2a, 数据结果没有丢失位数</span></span><br></pre></td></tr></table></figure><p>+ 和 - 也可以作为单目操作符来使用，表示操作数的正负性。此类操作符优先级最高。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">4</span>  <span class="comment">//表示负4</span></span><br><span class="line">+<span class="number">3</span>  <span class="comment">//表示正3</span></span><br></pre></td></tr></table></figure><p>负数表示时，可以直接在十进制数字前面增加一个减号 <strong>-</strong>，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mula = -<span class="number">4&#x27;d4</span> ;</span><br><span class="line">mulb = <span class="number">2</span> ;</span><br><span class="line">res = mula * mulb ;      <span class="comment">//计算结果为res=-6&#x27;d8, 即res=6&#x27;h38，正常</span></span><br><span class="line">res = mula * (-<span class="number">&#x27;d4</span>) ;    <span class="comment">//(4的32次幂-4) * 2, 结果异常</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符有大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=）。</p><p>关系操作符的正常结果有 2 种，真（1）或假（0）。</p><p>如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">3</span> ;</span><br><span class="line">X = <span class="number">3&#x27;b1xx</span> ;</span><br><span class="line">    </span><br><span class="line">A &gt; B     <span class="comment">//为真</span></span><br><span class="line">A &lt;= B    <span class="comment">//为假</span></span><br><span class="line">A &gt;= Z    <span class="comment">//为X，不确定</span></span><br></pre></td></tr></table></figure><h3 id="等价操作符"><a href="#等价操作符" class="headerlink" title="等价操作符"></a>等价操作符</h3><p>等价操作符包括逻辑相等（ == ） ，逻辑不等（!=），全等（ ===  ），非全等（  !  ）。</p><p>等价操作符的正常结果有 2 种：为真（1）或假（0）。</p><p>逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。</p><p>全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">8&#x27;h04</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bxxxx</span> ;</span><br><span class="line">D = <span class="number">4&#x27;hx</span> ;</span><br><span class="line">A == B        <span class="comment">//为真</span></span><br><span class="line">A == (B + <span class="number">1</span>)  <span class="comment">//为假</span></span><br><span class="line">A == C        <span class="comment">//为X，不确定</span></span><br><span class="line">A === C       <span class="comment">//为假，返回值为0</span></span><br><span class="line">C === D       <span class="comment">//为真，返回值为1</span></span><br></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）。</p><p>逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。</p><p>如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。</p><p>如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。</p><p>逻辑操作符的操作数可以为变量，也可以为表达式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">3</span>; </span><br><span class="line">B = <span class="number">0</span>; </span><br><span class="line">C = <span class="number">2&#x27;b1x</span> ;</span><br><span class="line">    </span><br><span class="line">A &amp;&amp; B    <span class="comment">//     为假</span></span><br><span class="line">A || B    <span class="comment">//     为真</span></span><br><span class="line">! A       <span class="comment">//     为假</span></span><br><span class="line">! B       <span class="comment">//     为真</span></span><br><span class="line">A &amp;&amp; C    <span class="comment">//     为X，不确定</span></span><br><span class="line">A || C    <span class="comment">//     为真，因为A为真</span></span><br><span class="line">(A==<span class="number">2</span>) &amp;&amp; (! B)  <span class="comment">//为真，此时第一个操作数为表达式</span></span><br></pre></td></tr></table></figure><h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><p>按位操作符包括：取反（~），与（&amp;），或（|），异或（^），同或（~^）。</p><p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作。</p><p>如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p><p>取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p><p>下图给出了按位操作符的逻辑规则。</p><div class="table-container"><table><thead><tr><th style="text-align:left">&amp;(与）</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">\</th><th style="text-align:left">(或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th>x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">^(异或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">~^(同或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr></tbody></table></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b0101</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bx010</span> ;</span><br><span class="line">    </span><br><span class="line">~A        <span class="comment">//4&#x27;b1010</span></span><br><span class="line">A &amp; B     <span class="comment">//4&#x27;b0001</span></span><br><span class="line">A | B     <span class="comment">//4&#x27;b1101</span></span><br><span class="line">A^B       <span class="comment">//4&#x27;b1100</span></span><br><span class="line">A ~^ B    <span class="comment">//4&#x27;b0011</span></span><br><span class="line">B | C     <span class="comment">//4&#x27;b1011</span></span><br><span class="line">B&amp;C       <span class="comment">//4&#x27;bx000</span></span><br></pre></td></tr></table></figure><h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（~&amp;），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。</p><p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p><p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">&amp;A ;      <span class="comment">//结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#x27;b0，可用来判断变量A是否全1</span></span><br><span class="line">~|A ;     <span class="comment">//结果为 ~(1 | 0 | 1 | 0) = 1&#x27;b0, 可用来判断变量A是否为全0</span></span><br><span class="line">^A ;      <span class="comment">//结果为 1 ^ 0 ^ 1 ^ 0 = 1&#x27;b0</span></span><br></pre></td></tr></table></figure><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>算术左移和逻辑左移时，右边低位会补 0。</p><p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1100</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">A = A &gt;&gt; <span class="number">2</span> ;        <span class="comment">//结果为 4&#x27;b0011</span></span><br><span class="line">A = A &lt;&lt; <span class="number">1</span>;         <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">A = A &lt;&lt;&lt; <span class="number">1</span> ;       <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">C = B + (A&gt;&gt;&gt;<span class="number">2</span>);    <span class="comment">//结果为 2 + (-4/4) = 1, 4&#x27;b0001</span></span><br></pre></td></tr></table></figure><h3 id="拼接操作符"><a href="#拼接操作符" class="headerlink" title="拼接操作符"></a>拼接操作符</h3><p>拼接操作符用大括号 <strong>{，}</strong> 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。</p><p>拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">B = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">Y1 = &#123;B, A[<span class="number">3</span>:<span class="number">2</span>], A[<span class="number">0</span>], <span class="number">4&#x27;h3</span> &#125;;  <span class="comment">//结果为Y1=&#x27;b1100_0011</span></span><br><span class="line">Y2 = &#123;<span class="number">4</span>&#123;B&#125;, <span class="number">3&#x27;d4</span>&#125;;  <span class="comment">//结果为 Y2=7&#x27;b111_1100</span></span><br><span class="line">Y3 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值</span></span><br></pre></td></tr></table></figure><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件表达式有 3 个操作符，结构描述如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition_expression ? true_expression : false_expression</span><br></pre></td></tr></table></figure><p>计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> hsel    = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b0</span>) ? hsel_p1 : hsel_p2 ;</span><br><span class="line"><span class="comment">//当信号 addr 高 2bit 为 0 时，hsel 赋值为 hsel_p1; 否则，将 hsel_p2 赋值给 hsel。</span></span><br></pre></td></tr></table></figure><p>其实，条件表达式类似于 2 路（或多路）选择器，其描述方式完全可以用 if-else 语句代替。</p><p>当然条件操作符也能进行嵌套，完成一个多次选择的逻辑。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>   hsel = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b00</span>) ? hsel_p1 : </span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b01</span>) ? hsel_p2 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b10</span>) ? hsel_p3 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b11</span>) ? hsel_p4 ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;verilog基础语法&quot;&gt;&lt;a href=&quot;#verilog基础语法&quot; class=&quot;headerlink&quot; title=&quot;verilog基础语法&quot;&gt;&lt;/a&gt;verilog基础语法&lt;/h1&gt;&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilog</title>
    <link href="https://rozen12123.github.io/posts/ffaf1e77.html"/>
    <id>https://rozen12123.github.io/posts/ffaf1e77.html</id>
    <published>2023-08-07T09:51:42.000Z</published>
    <updated>2023-08-09T15:51:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartus"><a href="#Quartus" class="headerlink" title="Quartus"></a>Quartus</h1><h3 id="使用—全加器"><a href="#使用—全加器" class="headerlink" title="使用—全加器"></a>使用—全加器</h3><h3 id="原理图方式（而输入或门）"><a href="#原理图方式（而输入或门）" class="headerlink" title="原理图方式（而输入或门）"></a>原理图方式（而输入或门）</h3><p><img src="/posts/ffaf1e77.htm/image-20230807180738812.png" alt="image-20230807180738812" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181223960.png" alt="image-20230807181223960" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181408224.png" alt="image-20230807181408224" style="zoom:50%;"></p><p>然后完成一个2选1的原理图</p><p><img src="/posts/ffaf1e77.htm/image-20230807181746258.png" alt="image-20230807181746258" style="zoom:50%;"></p><p>然后点击new选择University Program VWF</p><p><img src="/posts/ffaf1e77.htm/image-20230807181829430.png" alt="image-20230807181829430" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181944693.png" alt="image-20230807181944693" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807182059221.png" alt="image-20230807182059221" style="zoom:50%;"></p><p>将其全部移入</p><p><img src="/posts/ffaf1e77.htm/image-20230807182228594.png" alt="image-20230807182228594" style="zoom:50%;"></p><p>选择器件然后点击设置时间。</p><p><img src="/posts/ffaf1e77.htm/image-20230807182426708.png" alt="image-20230807182426708" style="zoom:50%;"></p><h3 id="用verilog进行电路设计"><a href="#用verilog进行电路设计" class="headerlink" title="用verilog进行电路设计"></a>用verilog进行电路设计</h3><p><img src="/posts/ffaf1e77.htm/image-20230807183308472.png" alt="image-20230807183308472" style="zoom:50%;"></p><p>右击选择Insert Template</p><p><img src="/posts/ffaf1e77.htm/image-20230807183728558.png" alt="image-20230807183728558" style="zoom:50%;"></p><p>！！Verilog HDL要求module描述的实例名称必须与储存文件名一致，我们将程序性稍做修改</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quartus II Verilog Template</span></span><br><span class="line"><span class="comment">// Signed adder/subtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder_sub</span><br><span class="line">#(<span class="keyword">parameter</span> WIDTH=<span class="number">16</span>)</span><br><span class="line">(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] datab,</span><br><span class="line"><span class="keyword">input</span> add_sub,  <span class="comment">// if this is 1, add; else subtract</span></span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (add_sub)</span><br><span class="line">result &lt;= dataa + datab;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result &lt;= dataa - datab;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>Verilog HDL程序是以module为基本单位的，形式上以$module<name>$开头,以$endmodule$结尾，模块名称$name$可以由设计者自定，并要求和文件存储名称一致。</name></p></li><li><p>$module<name>$和$endmodule$之间成为<code>模块实体</code>，其包括输入输出端口及数据类型描述，接下来是实际语句体描述。输入输出端口数据名称和类型的描述，要放在模块名称后面，并且用括号括起来。</name></p></li><li><p>输入/输出/双向端口变量描述一般以如下形式，不同端口之间要用逗号<code>，</code>隔开</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="comment">//output 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line"><span class="comment">//bidir 变量宽度 变量名称</span></span><br></pre></td></tr></table></figure></li><li><p>Verilog HDL中主要有两种类型<code>导线型</code>$wire$和<code>寄存器型</code>$reg$。在端口变量描述中$wire$可以省略。</p><p>各种类型容纳变量都是容纳的二进制数，他们能够纳二进制数的位数称之为<code>线宽</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如[7:0],表示有8位宽度的向量，内部的二进制数或存放二进制数的位置编号是7，6，5，4，3，2，1，0</span></span><br></pre></td></tr></table></figure></li><li><p>形参要用parameter保留字来定义，形式为：$parameter 形参名称 = 常数$，大多数情况下形参都用大写字母来表示</p></li><li><p>$lways @ (posedge clk)$是一个结构体语句的头，有多个语句时要用$begin … end$语句括起来，其代表只要clk上升沿到来，该$begin … end$语句体的内容就会被执行一遍。always语句括号内的变量成为敏感变量，多个敏感变量同时存在，用<code>or</code>或者<code>，</code>分开。$posedge$和$negedge$必须在每个敏感变量之前修饰，如果下降沿有效则用$negedge$修饰。</p></li><li><p>$always$中的语句都是按顺序执行的。</p></li><li><p>这个Add_Sub程序中设计了一个16位的加减法运算器，输入输出端口有两个16位的数据导线$dataa$和$datab$一个时钟输入导线$clk$，一个控制选择加减法运算的导线Sub，输出端口是一个16位的寄存器$result$。每当时钟上升沿到来的时刻，依据Sub为0还是1进行加法或者减法运算，并且将结果送到$result$寄存器。</p></li></ol><p>&nbsp;</p><p><img src="/posts/ffaf1e77.htm/image-20230807220923070.png" alt="image-20230807220923070" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartus&quot;&gt;&lt;a href=&quot;#Quartus&quot; class=&quot;headerlink&quot; title=&quot;Quartus&quot;&gt;&lt;/a&gt;Quartus&lt;/h1&gt;&lt;h3 id=&quot;使用—全加器&quot;&gt;&lt;a href=&quot;#使用—全加器&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>acfly飞控</title>
    <link href="https://rozen12123.github.io/posts/a4e8942.html"/>
    <id>https://rozen12123.github.io/posts/a4e8942.html</id>
    <published>2023-07-29T13:25:07.000Z</published>
    <updated>2023-08-09T15:51:29.039Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>立创eda专业版</title>
    <link href="https://rozen12123.github.io/posts/9c8613dc.html"/>
    <id>https://rozen12123.github.io/posts/9c8613dc.html</id>
    <published>2023-07-25T09:58:36.000Z</published>
    <updated>2023-08-11T12:26:02.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="立创eda专业版"><a href="#立创eda专业版" class="headerlink" title="立创eda专业版"></a>立创eda专业版</h1><h2 id="1-新建文档"><a href="#1-新建文档" class="headerlink" title="1.新建文档"></a>1.新建文档</h2><p>创建工程，命名规则如下</p><p>文件名-版本-日期</p><p>例如：GD32F230C8T6-V1.0.0-20230725</p><p>&nbsp;</p><h2 id="2-原理图设计环境设置"><a href="#2-原理图设计环境设置" class="headerlink" title="2.原理图设计环境设置"></a>2.原理图设计环境设置</h2><p>设置—&gt;常规—&gt;设置原理图尺寸为0.1</p><p>保存—&gt;自动保存</p><p><img src="/posts/9c8613dc.htm/image-20230725180844637.png" alt="image-20230725180844637" style="zoom: 50%;"></p><p><img src="/posts/9c8613dc.htm/image-20230725181110414.png" alt="image-20230725181110414" style="zoom:50%;"></p><p>右方图页中可以更改相关信息，例如图纸尺寸，以及右下角的各种信息。</p><p><img src="/posts/9c8613dc.htm/image-20230725182334274.png" alt="image-20230725182334274" style="zoom:50%;"></p><p>&nbsp;</p><h2 id="3-电源转换电路"><a href="#3-电源转换电路" class="headerlink" title="3.电源转换电路"></a>3.电源转换电路</h2><p>在库中，选择器件进行原理图绘制，同时在绘制原理图时要注意对应的封装。</p><p>寻找元器件不仅可以通过==元器件的名称==去找，还可以通过==供应商编号==去找。</p><p><img src="/posts/9c8613dc.htm/image-20230725184044652.png" alt="image-20230725184044652" style="zoom:50%;"></p><p>并且通过折线和文本进行模块化的标注。</p><h2 id="4-查找元器件"><a href="#4-查找元器件" class="headerlink" title="4.查找元器件"></a>4.查找元器件</h2><p>当供应商编号查找不到元器件时，假如是0.1uf的电容，我们可以在立创商城中找到响应的替代品，复制其的器件型号，在专业版的库中进行查找。</p><p>&nbsp;</p><h2 id="5-更改网络标签"><a href="#5-更改网络标签" class="headerlink" title="5.更改网络标签"></a>5.更改网络标签</h2><p>点击网络标签出现预览按钮以后按住tab键即可</p><p>&nbsp;</p><h2 id="原理图转pcb"><a href="#原理图转pcb" class="headerlink" title="原理图转pcb"></a>原理图转pcb</h2><h3 id="1-设置板框"><a href="#1-设置板框" class="headerlink" title="1.设置板框"></a>1.设置板框</h3><p>放置—&gt;板框—&gt;矩形</p><p><img src="/posts/9c8613dc.htm/image-20230725203709836.png" alt="image-20230725203709836" style="zoom:50%;"></p><p>当然我们也可用通过右侧的矩形轮廓，修改板框的大小。</p><p>单击板框右键—&gt;添加—&gt;添加圆角，即可设置板框为圆角</p><p>&nbsp;</p><h3 id="2-规则设置"><a href="#2-规则设置" class="headerlink" title="2.规则设置"></a>2.规则设置</h3><p>设计—&gt;设计规则—&gt;导线设置为8mil—&gt;全部设置为8mil</p><p>设置导线，最小，默认，最大分别为10，10，30</p><p><img src="/posts/9c8613dc.htm/image-20230725205824273.png" alt="image-20230725205824273" style="zoom:50%;"></p><p>添加一个导线规则，最小，默认，最大分别设为10，30，30</p><p><img src="/posts/9c8613dc.htm/image-20230725210044705.png" alt="image-20230725210044705" style="zoom:50%;"></p><p>过孔尺寸按如下设置即可</p><p><img src="/posts/9c8613dc.htm/image-20230725210222093.png" alt="image-20230725210222093" style="zoom:50%;"></p><p>铺铜规则—-&gt;网络间隔和到边框均改为20</p><p><img src="/posts/9c8613dc.htm/image-20230725211405979.png" alt="image-20230725211405979" style="zoom:50%;"></p><p>之后，在网络规则中进行设置</p><p>&nbsp;</p><h3 id="3-绘制定位孔"><a href="#3-绘制定位孔" class="headerlink" title="3.绘制定位孔"></a>3.绘制定位孔</h3><p><code>放置</code>——&gt;<code>挖槽区域</code>——&gt;<code>圆孔</code></p><p><img src="/posts/9c8613dc.htm/image-20230811190718746.png" alt="image-20230811190718746" style="zoom:50%;"></p><p>在右侧可以设置相关参数</p><p><img src="/posts/9c8613dc.htm/image-20230811190950371.png" alt="image-20230811190950371" style="zoom:50%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="4-绘制OLED模块定位孔"><a href="#4-绘制OLED模块定位孔" class="headerlink" title="4.绘制OLED模块定位孔"></a>4.绘制OLED模块定位孔</h3><h4 id="丝印边框"><a href="#丝印边框" class="headerlink" title="丝印边框"></a>丝印边框</h4><p><img src="/posts/9c8613dc.htm/image-20230811191917326.png" alt="image-20230811191917326" style="zoom:67%;"></p><p>1.选择顶层丝印层—&gt;2.网格类型选用正方形—&gt;3.选择为矩形</p><p>&nbsp;</p><h3 id="5-布局"><a href="#5-布局" class="headerlink" title="5.布局"></a>5.布局</h3><p>在原理图中选择<code>对应元器件</code>—-&gt;<code>设计</code>—&gt;<code>布局传递</code></p><p>这样回到pcb图就会自动选择相关元器件</p><p><img src="/posts/9c8613dc.htm/image-20230811192421560.png" alt="image-20230811192421560" style="zoom:67%;"></p><p>ps：丝印放置规则，横着为从左到右，竖着为从上到下</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="6-布线"><a href="#6-布线" class="headerlink" title="6.布线"></a>6.布线</h3><p>常用<code>焊盘</code>，<code>过孔</code>,<code>单路布线</code></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="7-修改位号丝印大小"><a href="#7-修改位号丝印大小" class="headerlink" title="7.修改位号丝印大小"></a>7.修改位号丝印大小</h3><p>右键丝印点击查找</p><p><img src="/posts/9c8613dc.htm/image-20230811201254714.png" alt="image-20230811201254714" style="zoom:50%;"></p><p>查找—-&gt;查找全部—&gt;线宽8mil—&gt;线高70mil</p><p>&nbsp;</p><h3 id="8-添加丝印"><a href="#8-添加丝印" class="headerlink" title="8.添加丝印"></a>8.添加丝印</h3><p><img src="/posts/9c8613dc.htm/image-20230811201619036.png" alt="image-20230811201619036" style="zoom:67%;"></p><p><img src="/posts/9c8613dc.htm/image-20230811201740095.png" alt="image-20230811201740095" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="9-泪滴"><a href="#9-泪滴" class="headerlink" title="9.泪滴"></a>9.泪滴</h3><p><img src="/posts/9c8613dc.htm/image-20230811201848466.png" alt="image-20230811201848466" style="zoom:67%;"></p><p>&nbsp;</p><h3 id="10-铺铜"><a href="#10-铺铜" class="headerlink" title="10.铺铜"></a>10.铺铜</h3><p>点击选择矩形</p><p><img src="/posts/9c8613dc.htm/image-20230811202050096.png" alt="image-20230811202050096" style="zoom:67%;"></p><p>网络选择GND</p><p>图层顶层和底层分别进行铺铜，如果顶层有大面积没有铺铜，在此区域添加过孔然后继续铺铜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;立创eda专业版&quot;&gt;&lt;a href=&quot;#立创eda专业版&quot; class=&quot;headerlink&quot; title=&quot;立创eda专业版&quot;&gt;&lt;/a&gt;立创eda专业版&lt;/h1&gt;&lt;h2 id=&quot;1-新建文档&quot;&gt;&lt;a href=&quot;#1-新建文档&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="eda" scheme="https://rozen12123.github.io/tags/eda/"/>
    
  </entry>
  
  <entry>
    <title>k210与esp32串口通信</title>
    <link href="https://rozen12123.github.io/posts/bfa0354e.html"/>
    <id>https://rozen12123.github.io/posts/bfa0354e.html</id>
    <published>2023-07-07T07:22:55.000Z</published>
    <updated>2023-07-12T13:50:22.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k210与esp32串口通信"><a href="#k210与esp32串口通信" class="headerlink" title="k210与esp32串口通信"></a>k210与esp32串口通信</h1><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO，<strong>外部I对应上图K210的IO而非Maxiduino</strong></p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>&nbsp;</p><h2 id="maxiduino与电脑串口进行通信"><a href="#maxiduino与电脑串口进行通信" class="headerlink" title="maxiduino与电脑串口进行通信"></a>maxiduino与电脑串口进行通信</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">11</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">10</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello word!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="esp32-s3与电脑串口进行通信"><a href="#esp32-s3与电脑串口进行通信" class="headerlink" title="esp32_s3与电脑串口进行通信"></a>esp32_s3与电脑串口进行通信</h2><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://blog.csdn.net/Naisu_kun/article/details/86004049">(8条消息) 使用Arduino开发ESP32（02）：串口（Serial port）使用说明_arduino esp32 serial_Naisu Xu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_50064262/article/details/119006749">(8条消息) ESP32 之 ESP-IDF 教学（九）—— 串口通信（UART）_esp32 idf 串口_Augtons正(单片机)的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1A3411Z7gd/?spm_id_from=333.880.my_history.page.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">40 ESP32之UART串口简介 - 基于Arduino_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k210与esp32串口通信&quot;&gt;&lt;a href=&quot;#k210与esp32串口通信&quot; class=&quot;headerlink&quot; title=&quot;k210与esp32串口通信&quot;&gt;&lt;/a&gt;k210与esp32串口通信&lt;/h1&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32_s3多任务处理</title>
    <link href="https://rozen12123.github.io/posts/a1417d5c.html"/>
    <id>https://rozen12123.github.io/posts/a1417d5c.html</id>
    <published>2023-07-05T13:07:40.000Z</published>
    <updated>2023-07-06T07:47:38.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-S3多任务处理"><a href="#esp32-S3多任务处理" class="headerlink" title="esp32_S3多任务处理"></a>esp32_S3多任务处理</h1><h2 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2><ul><li>多任务的概念：同一时间内执行多个任务，它充分利用CPU资源，提高程序的执行效率。</li><li>对于单核CPU处理多任务，操作系统会给每个运行的任务一小段运行的时间，时间一到，然后立马切换任务，由于交替切换的速度过快，以人的眼光去看感觉每个程序都是同时执行的错觉。</li><li>相对于多核CPU，操作系统会给每个内核安排一个执行的软件同时运行，从而达到同一个时间内执行多任务的效果。</li><li>ESP32的任务和操作系统的进程的概念是一样的</li></ul><ul><li>ESP32有两颗CPU，包含ProtocolcPU（称为CPUO或PRO_CPU）和ApplicationcPu（称为CPU1或APP_CPU）。这两个核实际上是相同的，并且共享相同的内存</li><li>我们之前用的setup和loop方法都是在CPU1上执行的CPUO一直不干活，我们要使用多任务让它动起来。</li><li>保证所有的任务都以合理正确的速率推进，不被其它任务所阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void1oop（）&#123;</span><br><span class="line">task1（）<span class="comment">//这个需要较长的操作，比如59oms</span></span><br><span class="line">task2（）；<span class="comment">//这个需要50ms执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如上代码，任务一的时间较长，但任务二时间较短，就会有一定冲突。此时就适合双线程来完成任务。</p><h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>参考：<a href="https://blog.csdn.net/a568713197/article/details/81542772">(8条消息) UCOS学习笔记（四）时间片轮转调度_ucosii时间片轮转调度_爱吃肉的大高个的博客-CSDN博客</a></p><h3 id="多任务处理相关函数"><a href="#多任务处理相关函数" class="headerlink" title="多任务处理相关函数"></a>多任务处理相关函数</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">tXTaskCreatePinnedToCore</span><span class="params">(TaskFunctiont_t pvTaskcode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="type">const</span> <span class="type">uint32_t</span> usstackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> pvParameters,UBaseType_t uxPriority,TaskHandle_t <span class="type">const</span> pvCreatedTask,<span class="type">const</span> BaseType_t xCoreID)</span>；</span><br></pre></td></tr></table></figure><ul><li>pvTaskCode：指向任务输入函数的指针。任务必须被实现为永不Return（如：死循环），或者应该使用</li><li>vtTaskDelete:函数终止</li><li>pcName：该任务的描述性名称，最大长度16字节</li><li>usStackDepth：指定为字节数的任务堆栈的大小</li><li>pvParameters：将用作所创建的任务的参数的指针，在创建任务的时候可以向任务传递参数。</li><li>uxPriority：任务运行的优先级。目前ESP32的优先级有25级，0-24，数字越大优先级越高，Idle为0，loop任务的优先级是1</li><li>pvCreatedTask：用于传递回所创建任务的句柄</li><li>xCoreID：如果值为tskNOAFFINITY，则创建的任务不会固定到任何CPU，调度程序可以在任何可用的核心上运行。值0或1表示任务应固定到的CPU的索引编号。指定大于（portNUMPROCESSORS-1）的值将导致函数失败</li><li>函数成功返回pdPASS，其它值都是失败。</li></ul><h4 id="任务函数原型"><a href="#任务函数原型" class="headerlink" title="任务函数原型"></a>任务函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> task（<span class="type">void</span>* param）;</span><br></pre></td></tr></table></figure><h4 id="获取任务的优先级"><a href="#获取任务的优先级" class="headerlink" title="获取任务的优先级"></a>获取任务的优先级</h4><p>如果在任务函数里获取本任务的优先级可以使用uxTaskPriorityGet（NULL）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(<span class="type">const</span> TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure><h4 id="获取本任务在哪个CPU上运行"><a href="#获取本任务在哪个CPU上运行" class="headerlink" title="获取本任务在哪个CPU上运行"></a>获取本任务在哪个CPU上运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t IRAM_ATTR <span class="title function_">xPortGetcoreID</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h4><p>如果在任务函数体内使用vTaskDelete（NULL）来结束本任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="互斤量（xSemaphoreHandle）"><a href="#互斤量（xSemaphoreHandle）" class="headerlink" title="互斤量（xSemaphoreHandle）"></a>互斤量（xSemaphoreHandle）</h3><p>互压量又称互床信号量（本质是信号量），是一种特殊的二值信号量，它用于实现对临界资源的独占式处理（它不会屏蔽CPU的中断处理）任意时刻互压量的状态只有两种，开锁或闭锁。当互斤量被任务持有时，该互压量处于闭锁状态，这个任务获得互压量的所有权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle<span class="comment">//互斤锁，也算是一种信号量</span></span><br></pre></td></tr></table></figure><p>创建一个互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle xMutex = xSemaphoreCreateMutex()</span><br></pre></td></tr></table></figure><p>获取互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake (xSemaphore,xBlockTime)</span><br></pre></td></tr></table></figure><p>功能：在普通任务中获取信号量<br>参数：xSemaphore信号量句柄<br>           xBlockTime等待的节拍数，立即返回，portMAX_DELAY等待到信号到来<br>ESP32默认的一节拍是1ms<br>返回值：pdTRUE：获取成功1pdFALSE：获取失败</p><p>释放互压锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive（xSemaphore）</span><br></pre></td></tr></table></figure><p>功能：在普通任务中释放信号量，也就是将信号量设为有信号的状态返回值：pdTRUE：设置成功 ，pdFALSE：设置失败</p><p>&nbsp;</p><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (xSemaphoreTake(xMutex,portMAX_DELAY))</span><br><span class="line">//临界资源处理</span><br><span class="line">xSemaphoreGive(xMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line">xSemaphoreHandle xMutex; <span class="comment">//互斥量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;          <span class="comment">//互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = *((<span class="type">int</span>*)param);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.print(<span class="string">&quot;I am task1, Param: &quot;</span>);</span><br><span class="line">    Serial.print(p);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot; number: %d&quot;</span>, number);</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println();</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.println(<span class="string">&quot;I am task2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      number++;</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  </span><br><span class="line">  TaskHandle_t handle1;</span><br><span class="line">  <span class="type">int</span> param = <span class="number">30</span>;</span><br><span class="line">  xMutex = xSemaphoreCreateMutex();</span><br><span class="line">  xTaskCreatePinnedToCore(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;param, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line">  xTaskCreatePinnedToCore(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; I am loop &quot;</span>, core);</span><br><span class="line">  <span class="keyword">auto</span> pri = uxTaskPriorityGet(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot; priority: %d&quot;</span>, pri);</span><br><span class="line">  Serial.println();</span><br><span class="line">  delay(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">//一个任务的delay不会影响到其它任务的运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY))&#123; </span><br><span class="line"><span class="comment">//临界资源处理</span></span><br><span class="line">xSemaphoreGive（xMutex）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多并行任务创建"><a href="#多并行任务创建" class="headerlink" title="多并行任务创建"></a>多并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_FREERTOS_UNICORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FreeRTOS任务优先级：任务优先级数值越小，任务优先级越低。</span></span><br><span class="line"><span class="comment">一、 FreeRTOS 中任务的最高优先级是通过 FreeRTOSConfig.h 文件中的 configMAX_PRIORITIES 进行</span></span><br><span class="line"><span class="comment">配置的，用户实际可以使用的优先级范围是 0 到 configMAX_PRIORITIES – 1。比如我们配置此宏定</span></span><br><span class="line"><span class="comment">义为 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5。</span></span><br><span class="line"><span class="comment">二、用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0。</span></span><br><span class="line"><span class="comment">三、用户配置宏定义 configMAX_PRIORITIES 的最大值不要超过 32，即用户任务可以使用的优先级</span></span><br><span class="line"><span class="comment">范围是0到31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// define two tasks for Blink &amp; AnalogRead</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the setup function runs once when you press reset or power the board</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize serial communication at 115200 bits per second:</span></span><br><span class="line">  USBSerial.begin(<span class="number">115200</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Now set up two tasks to run independently.</span></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskBlink</span><br><span class="line">    ,  <span class="string">&quot;TaskBlink&quot;</span>   <span class="comment">// A name just for humans</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// This stack size can be checked &amp; adjusted by reading the Stack Highwater</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">2</span>  <span class="comment">// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskAnalogReadA3</span><br><span class="line">    ,  <span class="string">&quot;AnalogReadA3&quot;</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// Stack size</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">1</span>  <span class="comment">// Priority</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Empty. Things are done in Tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*---------------------- Tasks ---------------------*/</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Blink</span></span><br><span class="line"><span class="comment">  Turns on an LED on for one second, then off for one second, repeatedly.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  If you want to know what pin the on-board LED is connected to on your ESP32 model, check</span></span><br><span class="line"><span class="comment">  the Technical Specs of your board.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize digital LED_BUILTIN on pin 13 as an output.</span></span><br><span class="line">  pinMode(<span class="number">45</span>, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="comment">// A Task shall never return or exit.</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(<span class="number">45</span>, HIGH);   <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">    digitalWrite(<span class="number">45</span>, LOW);    <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AnalogReadSerial</span></span><br><span class="line"><span class="comment">  Reads an analog input on pin A3, prints the result to the serial monitor.</span></span><br><span class="line"><span class="comment">  Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)</span></span><br><span class="line"><span class="comment">  Attach the center pin of a potentiometer to pin A3, and the outside pins to +5V and ground.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// read the input on analog pin A3:</span></span><br><span class="line">    <span class="type">int</span> sensorValueA3 = analogRead(A3);</span><br><span class="line">    <span class="comment">// print out the value you read:</span></span><br><span class="line">    USBSerial.print(<span class="string">&quot;A3-&gt;&quot;</span>);</span><br><span class="line">    USBSerial.println(sensorValueA3);</span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="基于多核并行任务创建"><a href="#基于多核并行任务创建" class="headerlink" title="基于多核并行任务创建"></a>基于多核并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//  多线程基于FreeRTOS，可以多个任务并行处理；</span></span><br><span class="line"><span class="comment">//  ESP32具有两个32位Tensilica Xtensa LX6微处理器；</span></span><br><span class="line"><span class="comment">//  实际上我们用Arduino进行编程时只使用到了第一个核（大核），第0核并没有使用</span></span><br><span class="line"><span class="comment">//  多线程可以指定在那个核运行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_MULTCORE 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskOne</span><span class="params">(<span class="type">void</span> *xTask1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task1 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskTwo</span><span class="params">(<span class="type">void</span> *xTask2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task2 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    USBSerial.begin(<span class="number">115200</span>);</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !USE_MULTCORE</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskOne,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskOne&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">1</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskTwo,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskTwo&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">2</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个参数至关重要，决定这个任务创建在哪个核上.PRO_CPU 为 0, APP_CPU 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</span></span><br><span class="line">    xTaskCreatePinnedToCore(xTaskOne, <span class="string">&quot;TaskOne&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(xTaskTwo, <span class="string">&quot;TaskTwo&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial.<span class="built_in">printf</span>(<span class="string">&quot;XTask is running\r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32-S3多任务处理&quot;&gt;&lt;a href=&quot;#esp32-S3多任务处理&quot; class=&quot;headerlink&quot; title=&quot;esp32_S3多任务处理&quot;&gt;&lt;/a&gt;esp32_S3多任务处理&lt;/h1&gt;&lt;h2 id=&quot;多任务介绍&quot;&gt;&lt;a href=&quot;#多任务介</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32开发环境搭建（arduino）</title>
    <link href="https://rozen12123.github.io/posts/ec4b5731.html"/>
    <id>https://rozen12123.github.io/posts/ec4b5731.html</id>
    <published>2023-07-05T06:56:01.000Z</published>
    <updated>2023-07-06T07:47:56.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32开发环境搭建（arduino）"><a href="#esp32开发环境搭建（arduino）" class="headerlink" title="esp32开发环境搭建（arduino）"></a>esp32开发环境搭建（arduino）</h1><h2 id="首先下载arduino-IDE最新版"><a href="#首先下载arduino-IDE最新版" class="headerlink" title="首先下载arduino IDE最新版"></a>首先下载arduino IDE最新版</h2><p>网址：<a href="https://www.arduino.cc/en/software">Software | Arduino</a></p><p><img src="https://i.imgtg.com/2023/07/05/Oxe1Rb.png" alt="Oxe1Rb.png" border="0"></p><p>点击windows win10</p><p><img src="https://i.imgtg.com/2023/07/05/Oxehu6.png" alt="Oxehu6.png" border="0"></p><p>点击just download</p><p>此时即可下载到电脑。</p><h3 id="方法二（github）"><a href="#方法二（github）" class="headerlink" title="方法二（github）"></a>方法二（github）</h3><p>打开网址<a href="https://github.com/arduino/arduino-ide">arduino/arduino-ide: Arduino IDE 2.x (github.com)</a></p><p>点击code<img src="/posts/ec4b5731.htm/OxenFP.png" alt="OxenFP.png" border="0"></p><p>点击Download ZIP下载压缩包，下载完压缩即可。</p><p><a href="https://imgtg.com/image/Oxe79l"><img src="/posts/ec4b5731.htm/Oxe79l.png" alt="Oxe79l.png" border="0"></a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="安装esp32开发环境"><a href="#安装esp32开发环境" class="headerlink" title="安装esp32开发环境"></a>安装esp32开发环境</h2><p>你需要向 Arduino IDE 板管理器添加一个额外的源，然后安装 ESP32。</p><p>打开<code>文件</code> 菜单下的 <code>首选项</code>。</p><p><img src="https://i.imgtg.com/2023/07/05/OxeFEF.png" alt="OxeFEF.png" border="0"></p><p>把下面的链接复制粘贴到 <code>附加开发板管理网址</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/05/OxeeUg.png" alt="OxeeUg.png" border="0"></p><p>再安装 ESP32 开发板，选择 <code>工具</code> 菜单中的 <code>开发板</code> -&gt; <code>开发板管理器...</code></p><p><img src="https://i.imgtg.com/2023/07/05/OxeryB.png" alt="OxeryB.png" border="0"></p><p>在搜索栏搜索esp32，点击安装即可</p><p><img src="https://i.imgtg.com/2023/07/05/OxeAds.png" alt="OxeAds.png" border="0"></p><p>完成安装后即可在 工具—-&gt;开发板中发现esp32</p><p><img src="https://i.imgtg.com/2023/07/05/OxeZaK.png" alt="OxeZaK.png" border="0"></p><p>&nbsp;</p><h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>如果在连接esp32后没有反应则需要下载驱动</p><p>链接：<a href="https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc">https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc</a><br>提取码：m1bc</p><p>下在完可以在<strong>设备管理器</strong>中查看到设备</p><p><img src="https://i.imgtg.com/2023/07/05/Oxevea.png" alt="Oxevea.png" border="0"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;a href=&quot;#esp32开发环境搭建（arduino）&quot; class=&quot;headerlink&quot; title=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;/a&gt;esp32开发环境搭建（arduino）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32WIFI</title>
    <link href="https://rozen12123.github.io/posts/e7f7981b.html"/>
    <id>https://rozen12123.github.io/posts/e7f7981b.html</id>
    <published>2023-07-02T06:20:25.000Z</published>
    <updated>2023-07-06T07:46:04.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WiFi-应用"><a href="#WiFi-应用" class="headerlink" title="WiFi 应用"></a><strong>WiFi</strong> <strong>应用</strong></h1><p>通过前面的实验，我们已经对 ESP32-S2 有了一定的了解。从本章开始，将迎来非常重要实用的内容，那就是 WIFI 应用。ESP32-S2 就是为 WIFI 无线连接而生的。通过本章内容，我们可以看到基于 MicroPython 的 WIFI 开发是多么的简单而美妙。物联网的学习变得非常简单有趣！事不宜迟，马上开始学习。</p><h2 id="连接无线路由器"><a href="#连接无线路由器" class="headerlink" title="连接无线路由器"></a><strong>连接无线路由器</strong></h2><p>⚫ <strong>前言：</strong></p><p>WIFI 是物联网中非常重要的角色，现在基本上家家户户都有 WIFI 网络了，通过 WIFI 接入到互联网，成了智能家居产品普遍的选择。而要想上网，首先需要连接上无线路由器。这一节我们就来学习如何通过 MicroPython 编程连上路由器。</p><p>⚫ <strong>实验目的：</strong></p><p>编程实现连接路由器，将 IP 地址等相关信息通过 OLED 显示（只支持 2.4G网络）。</p><p>⚫ <strong>实验讲解：</strong></p><p>连接路由器上网是我们每天都做的事情，日常生活中我们只需要知道路由器的账号和密码，就能使用电脑或者手机连接到无线路由器，然后上网冲浪。</p><p>MicroPython 已经集成了 network 模块，开发者使用内置的 network 模块函数可以非常方便地连接上路由器。但往往也有各种连接失败的情况，如密码不正确等。这时候我们只需要再加上一些简单的判断机制，避免陷入连接失败的死循环即可！</p><p>我们先来看看 network 基于 WiFi（WLAN 模块）的构造函数和使用方法。</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>wlan = network.WLAN(interface_id)</p><p>构建 WIFI 连接对象。interface_id:分为热点 network.AP_IF 和客户端</p><p>network.STA_IF 模式。</p><p><strong>使用方法</strong></p><p>wlan.active([is_active])</p><p>激活 wlan 接口。Ture：激活；False:关闭。</p><p>wlan.scan ()</p><p>扫描允许访问的 SSID。</p><p>wlan.isconnected()</p><p>检查设备是否已经连接上。返回 Ture:已连接；False：未连接。</p><p>wlan.connected(ssid,passwork)</p><p>WIFI 连接。ssid:账号；passwork：密码。</p><p>wlan.ifconfig([ip,subnet,gateway,dns])</p><p>设备信息配置。ip：IP 地址；subnet:子网掩码；gateway:网关地址；dns:DNS</p><p>信息。<strong>（如果参数为空，则返回当前连接信息。）</strong></p><p>wlan.disconnected()</p><p>断开连接。</p><p>&nbsp;</p><p>从上表可以看到 MicroPython 通过模块封装，让 WIFI 联网变得非常简单。模块包含热点 AP 模块和客户端 STA 模式，热点 AP 是指电脑端直接连接 ESP32-S2发出的热点实现连接，但这样你的电脑就不能上网了，因此我们一般情况下都是使用 STA 模式。也就是电脑和设备同时连接到相同网段的路由器上。模块上电后可以先判断是否已经连接到网络，如果是则无需再次连接，否的话则进入 WIFI 连接状态，指示灯闪烁，连接成功后指示灯常亮，IP 等相关信息通过 OLED 显示和串口打印。另外需要配置超时 15 秒还没连接成功时执行取消连接，避免因无法连接而陷入死循环。代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702142321217.png" alt="image-20230702142321217" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：编程实现连接路由器，将IP地址等相关信息通过OLED显示（只支持2.4G网络）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> network,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;01Studio&#x27;</span>, <span class="string">&#x27;88888888&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行WIFI连接函数</span></span><br><span class="line">WIFI_Connect()</span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>本节是 WIFI 应用的基础，成功连接到无线路由器的实验后，后面就可以做socket 等相关网络通信的应用了。</p><p>&nbsp;</p><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a><strong>Socket</strong> <strong>通信</strong></h2><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了如何通过 MicroPython 编程实现 pyWiFi-ESP32-S2 模块连接到无线路由器。这一节我们则来学习一下 Socket 通信实验。Socket 几乎是整个互联网通信的基础。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 Socket 编程实现 pyWiFi-ESP32-S2 与电脑服务器助手建立连接，相互收发数据。</p><p>⚫ <strong>实验讲解：</strong></p><p>Socket 我们听得非常多了，但由于网络工程是一门系统工程，涉及的知识非常广，概念也很多，任何一个知识点都能找出一堆厚厚的的书，因此我们经常会混淆。在这里，我们尝试以最容易理解的方式来讲述 Socket，如果需要全面了解，可以自行查阅相关资料学习。</p><p>我们先来看看网络层级模型图，这是构成网络通信的基础：</p><p>我们看看 TCP/IP 模型的传输层和应用层，传输层比较熟悉的概念是 TCP 和UDP，UPD 协议基本就没有对 IP 层的数据进行任何的处理了。而 TCP 协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。应用层中网页常用的则是 HTTP。那么我们先来解析一下这 TCP 和 HTTP 两者的关系。我们知道网络通信是最基础是依赖于 IP 和端口的，HTTP 一般情况下默认使用端口 80。举个简单的例子：我们逛淘宝，浏览器会向淘宝网的网址（本质是IP）和端口发起请求，而淘宝网收到请求后响应，向我们手机返回相关网页数据信息，实现了网页交互的过程。而这里就会引出一个多人连接的问题，很多人访问淘宝网，实际上接收到网页信息后就断开连接，否则淘宝网的服务器是无法支撑这么多人长时间的连接的，哪怕能支持，也非常占资源。</p><p>也就是应用层的 HTTP 通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。简单来说，Socket 抽象层介于传输层和应用层之间，跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p>套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议（通常是 <strong>TCP</strong> <strong>或</strong> <strong>UDP</strong>），本地主机的 <strong>IP</strong> <strong>地址，本地进程的协议端**</strong>口，远地主机的<strong>IP</strong> <strong>地址，远地进程的协议端口。</strong></p><p>所以，socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，简单理解就是其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等等。以下是通讯流程：</p><p><img src="/posts/e7f7981b.htm/image-20230702143005669.png" alt="image-20230702143005669" style="zoom:70%;"></p><p>从上图可以看到，建了 Socket 通信需要一个服务器端和一个客户端，以本实验为例，pyWiFi-ESP32-S2 作为客户端，电脑使用网络调试助手作为服务器端，双方使用 TCP 协议传输。对于客户端，则需要知道电脑端的 IP 和端口即可建立连接。（端口可以自定义，范围在 0~65535，注意不占用常用的 80 等端口即可。）以上的内容，简单来说就是如果用户面向应用来说，那么 ESP32-S2 只需要知道<strong>通讯协议是</strong> <strong>TCP</strong> <strong>或</strong> <strong>UDP**</strong>、服务器的<strong> </strong>IP<strong> </strong>和端口号**这 3 个信息，即可向服务器发起连接和发送信息。就这么简单。</p><p>MicroPython 已经封装好相关模块 usocket,跟传统的 socket 大部分兼容，两者均可使用，本实验使用 usocket，对象如下介绍：</p><p><strong>构造函数</strong></p><p>s=usocket.socekt(af=AF_INET, type=SOCK_STREAM,proto=IPPROTO_TCP)</p><p>构建 usocket 对象。</p><p>af: AF_INET→IPV4，AF_INET6 → IPV6；</p><p>type: SCOK_STREAM→TCP，SOCK_DGRAM→UDP；</p><p>proto: IPPROTO_TCP→TCP 协议，IPPROTO_UDP→UDP 协议。</p><p>（如果要构建 TCP 连接，可以使用默认参数配置，即不输入任何参数。）</p><p><strong>使用方法</strong></p><p>addr=usocket.getaddrinfo(‘www.01studio.org’, 80)[0][-1]</p><p>获取 Socket 通信格式地址。返回：(‘47.91.208.161’,80)</p><p>s.connect(address)</p><p>创建连接。address:地址格式为 IP+端口。例：(‘192.168.1.115’,10000)</p><p>s.send(bytes)</p><p>发送。bytes：发送内容格式为字节</p><p>s.recv(bufsize)</p><p>接收数据。bufsize：单次最大接收字节个数。</p><p>s.bind(address)</p><p>绑定，用于服务器角色</p><p>s.listen([backlog])</p><p>监听，用于服务器角色。backlog:允许连接个数，必须大于 0。</p><p>s.accept()</p><p>接受连接，用于服务器角色。</p><p>&nbsp;</p><p>本实验中 pyWiFi-ESP32-S2 属于客户端，因此只用到客户端的函数即可。实验代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702143126631.png" alt="image-20230702143126631" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过Socket编程实现pyWiFi-ESP32与电脑服务器助手建立TCP连接，相互收发数据。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">import</span> network,usocket,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;henu-student&#x27;</span>, <span class="string">&#x27;hbwz12138&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断WIFI是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> WIFI_Connect():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建socket连接TCP类似，连接成功后发送“Hello 01Studio！”给服务器。</span></span><br><span class="line">    s=usocket.socket()</span><br><span class="line">    addr=(<span class="string">&#x27;192.168.1.115&#x27;</span>,<span class="number">10000</span>) <span class="comment">#服务器IP和端口</span></span><br><span class="line">    s.connect(addr)</span><br><span class="line">    s.send(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">    text=s.recv(<span class="number">128</span>) <span class="comment">#单次最多接收128字节</span></span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打印接收到的信息为字节，可以通过decode(&#x27;utf-8&#x27;)转成字符串</span></span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        s.send(<span class="string">&#x27;I got:&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    time.sleep_ms(<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>WIFI 连接代码在上一节已经讲解，这里不再重复，WIFI 连接成功后返回 True，否则返回 False。程序在返回连接成功后建了 Socket 连接，连接成功发送‘Hello 01Studio!’信息到服务器。另外 RTOS 定时器设定了了每 300ms 处理从服务器接收到的数据。将接收到数据通过串口打印和发送给服务器。</p><p>⚫ <strong>实验结果：</strong></p><p>先在电脑端打开网络调试助手并建立服务器，软件在 零一科技（01Studio）MicroPython 开发套件配套资料_latest\01-开发工具\01-Windows\网络调试助手下的 NetAssist.exe ，直接双击打开即可！</p><p><img src="/posts/e7f7981b.htm/image-20230702143433653.png" alt="image-20230702143433653" style="zoom:67%;"></p><p>以下是新建服务器的方法，打开网络调试助手后在左上角协议类型选择 TCP Server；中间的本地 IP 地址是自动识别的，不要修改，这个就是服务器的 IP 地址。然后端口写 10000（0-65535 都可以。），点击连接，成功后红点亮。如下图：</p><p><img src="/posts/e7f7981b.htm/image-20230702143452690.png" alt="image-20230702143452690" style="zoom:80%;"></p><p>在时候服务器已经在监听状态！用户需要根据自己的实际情况自己输入 WIFI信息和服务器 IP 地址+端口。即修改上面的代码以下部分内容。（服务器 IP 和端口可以在网络调试助手找到。）</p><p>WiFi 网络信息：</p><p>wlan.connect(‘01Studio’, ‘88888888’) #输入 WIFI 账号密码</p><p>服务器信息：</p><p>addr=(‘192.168.1.115’,10000) #服务器 IP 和端口</p><p>下载程序，开发板成功连接 WIFI 后，发起了 socket 连接，连接成功可以可以看到网络调试助手收到了开发板发来的信息。在下方列表多了一个连接对象，点击选中</p><p>选中后我们在发送框输入信息“Hi”，点击发送，可以看到开发板的 REPL 打印出来信息 Hi。为字节数据。另外由于程序将收到的信息发回给服务器，所以在网络调试助手中也接收到开发板返回的信息：I got:Hi。</p><p><img src="/posts/e7f7981b.htm/image-20230702143554343.png" alt="image-20230702143554343" style="zoom:60%;"></p><p><img src="/posts/e7f7981b.htm/image-20230702143618314.png" alt="image-20230702143618314" style="zoom:80%;"></p><p>⚫ <strong>总结：</strong></p><p>通过本节学习，我们了解了socket通信原理以及使用MicroPython进行socket编程并且通信的实验。得益于优秀的封装，让我们可以直接面向 socket 对象编程就可以快速实现 socket 通信，从而开发更多的网络应用，例如将前面采集到的传感器数据发送到服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WiFi-应用&quot;&gt;&lt;a href=&quot;#WiFi-应用&quot; class=&quot;headerlink&quot; title=&quot;WiFi 应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;WiFi&lt;/strong&gt; &lt;strong&gt;应用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通过前面的实验，我们已经对 ES</summary>
      
    
    
    
    
    <category term="espe32" scheme="https://rozen12123.github.io/tags/espe32/"/>
    
  </entry>
  
  <entry>
    <title>esp32传感器</title>
    <link href="https://rozen12123.github.io/posts/30e8a1b9.html"/>
    <id>https://rozen12123.github.io/posts/30e8a1b9.html</id>
    <published>2023-07-02T04:20:30.000Z</published>
    <updated>2023-07-06T07:47:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传感器实验"><a href="#传感器实验" class="headerlink" title="传感器实验"></a><strong>传感器实验</strong></h1><p>日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程师驱动一款未接触过的传感器的一般流程是：了解传感器原理、设计电路图、信号时序分析和编程。没个几天折腾不出来。生活中有很多传感器已经是非常通用了，前人已经做好封装函数模块，我们直接调用函数即可。我们不需要将时间花在“怎么用”上，而更多的是考虑“用到什么地方”！</p><h3 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a><strong>温度传感器</strong> <strong>DS18B20</strong></h3><p>⚫ <strong>前言：</strong></p><p>相信没有电子爱好者不知道 DS18B20 的，DS18B20 是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。DS18B20 数字温度传感器接线方便，封装成后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式，型号多种多样。主要根据应用场合的不同而改变其外观。封装后的 DS18B20 可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我，们来看看原理图：</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我们来看看原理图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140646041.png" alt="image-20230702140646041" style="zoom:50%;"></p><p>可以看到 DS18B20 传感器连接到了 pyBase 的 X11 引脚上。也就是连接到pyWiFi-ESP32-S2 的引脚 41，如下图所示：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140747976.png" alt="image-20230702140747976" style="zoom:50%;"></p><p>也就是说我们需要针对引脚 41 编写程序来驱动 DS18B20。那么我们需要自己来编写驱动么？如果你有兴趣的可以自己尝试一下。这部分我们 01Studio 已经收集整理和编写好了，单总线模块文件是：onewire.py，DS18B20 模块的文件是 ds18x20.py。如果你学习过前面基于 STM32 平台应该不陌生。而对于 ESP32-S2,这两个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可！单总线模块（onewire）和 ds18x20 模块说明如下：</p><p><strong>构造函数</strong></p><p>ow=onewire.OneWire(machine.Pin(id))</p><p>构建单总线对象。id:引脚编号；</p><p><strong>使用方法</strong></p><p>ow.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ow.reset()</p><p>总线设备复位。</p><p>ow.readbyte()</p><p>读 1 个字节。</p><p>ow.writebyte(0x12)</p><p>写入 1 个字节。</p><p>ow.write(‘123’)</p><p>写入多个字节。</p><p>ow.select_rom(b’12345678’)</p><p>根据 ROM 编号选择总线上指定设备</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>ds=ds18x20.DS18X20(ow)</p><p>构建 DS18B20 传感器对象。ow:定义好的单总线对象；</p><p><strong>使用方法</strong></p><p>ds.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ds.convert_temp()</p><p>温度转换。</p><p>ds.read_temp(rom)</p><p>获取温度值。rom：表示对应的设备号。</p><p>&nbsp;</p><p>大部分场景下温度的变化不会太频繁，我们可以每隔 1 秒采集一次，显示精度为小数点后 2 位，基本满足大部分应用需求。编程逻辑如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140853444.png" alt="image-20230702140853444" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：温度传感器DS18B20</span></span><br><span class="line"><span class="string">说明：通过编程采集温度数据，并在OLED上显示。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"><span class="keyword">import</span> onewire,ds18x20,time</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化DS18B20</span></span><br><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) <span class="comment">#使能单总线</span></span><br><span class="line">ds = ds18x20.DS18X20(ow)        <span class="comment">#传感器是DS18B20</span></span><br><span class="line">rom = ds.scan()         <span class="comment">#扫描单总线上的传感器地址，支持多个传感器同时连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_get</span>(<span class="params">tim</span>):</span><br><span class="line">    ds.convert_temp()</span><br><span class="line">    temp = ds.read_temp(rom[<span class="number">0</span>]) <span class="comment">#温度显示,rom[0]为第1个DS18B20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#OLED数据显示</span></span><br><span class="line">    oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">    oled.text(<span class="string">&#x27;MicroPython&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;Temp test:&#x27;</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%temp)+<span class="string">&#x27; C&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>) <span class="comment">#显示temp,保留2位小数</span></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(-<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=temp_get) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验拓展：</strong></p><p>pyBase 开发底板预留了外界传感器接口，只要接线正确就可以进行更多的传感器实验。我们将带金属探头的 DS18B20 传感器接到 pyBase 右侧上面的传感器母座，其连接到 pyBase 的“Y11”引脚,也就是对应 pyWiFi-ESP32-S2 的引脚 10。</p><p>所以只要将原程序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) </span><br></pre></td></tr></table></figure><p>改成 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">10</span>))，</span><br></pre></td></tr></table></figure><p>即可驱动外接的 DS18B20。</p><p>⚫ <strong>总结</strong></p><p>DS18B20 作为我们第一个实验传感器，使用 MicroPython 编程非常容易就用起来了，而且精度和稳定性丝毫没有影响。温度传感器只是一个敲门砖，接下来我们将会学习更多的传感器应用。</p><p>&nbsp;</p><h3 id="温湿度传感器-DHT11"><a href="#温湿度传感器-DHT11" class="headerlink" title="温湿度传感器 DHT11"></a><strong>温湿度传感器</strong> <strong>DHT11</strong></h3><p>⚫ <strong>前言：</strong></p><p>温湿度也是我们日常非常常见的指标，我们使用的是 DHT11 数字温湿度传感器。这是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。</p><p>DHT11 具有小体积、极低的功耗，信号传输距离可达 20 米以上，使其成为给类应用甚至最为苛刻的应用场合的最佳选择。产品为 4 针单排引脚封装，连接方便。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温湿度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DHT11 虽然有 4 个引脚，但其中第 3 个引脚是悬空的，也就是说 DHT11 也是单总线的传感器，只占用 1 个 IO 口。</p><p><img src="/posts/30e8a1b9.htm/image-20230702141333793.png" alt="image-20230702141333793" style="zoom:80%;"></p><p>我们来看看 DHT11 在开发板上的接线图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141347945.png" alt="image-20230702141347945" style="zoom:67%;"></p><p>可以看到 DHT11 连接到 pyBase 的‘X12’引脚，也就是连接到 pyWiFi-ESP32-S2 的引脚 42，如下图所示：</p><p>因此可以针对引脚 42 编程来驱动 DHT11 传感器，模块文件是 dht.py。而对于 pyWiFi-ESP32-S2,这个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可。函数模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>d = dht.DHT11(machine.Pin(id))</p><p>构建 DHT11 传感器对象。id:传感器所连接的引脚；</p><p><strong>使用方法</strong></p><p>d.measure()</p><p>测量温湿度。</p><p>d.temperature()</p><p>获取温度值。</p><p>d.humidity()</p><p>获取湿度值</p><p>建议上电先延时 1 秒，让 DHT11 稳定后再开始读取。代码编写流程如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141458320.png" alt="image-20230702141458320" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="人体感应传感器"><a href="#人体感应传感器" class="headerlink" title="人体感应传感器"></a><strong>人体感应传感器</strong></h3><p>⚫ <strong>前言：</strong></p><p>人体感应传感器，在室内安防应用非常普遍，其原理是由探测元件将探测到人体的红外辐射转变成微弱的电压信号，经过放大后输出。为了提高探测器的探测灵敏度以增大探测距离，一般在探测器的前方装设一个塑料的菲涅尔透镜，它和放大电路相配合，可将信号放大 70dB 以上，这样就可以测出 5~10 米范围内人的行动。</p><p>⚫ <strong>实验目的：</strong></p><p>通过外部中断编程来检测人体感应模块，当有人出现时候 OLED 通过“GetPeople!！！”闪烁提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传感器实验&quot;&gt;&lt;a href=&quot;#传感器实验&quot; class=&quot;headerlink&quot; title=&quot;传感器实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;传感器实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
</feed>
