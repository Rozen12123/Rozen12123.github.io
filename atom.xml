<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小江的博客</title>
  
  <subtitle>想成为一个温暖而有趣的人</subtitle>
  <link href="https://rozen12123.github.io/atom.xml" rel="self"/>
  
  <link href="https://rozen12123.github.io/"/>
  <updated>2023-07-05T09:53:45.011Z</updated>
  <id>https://rozen12123.github.io/</id>
  
  <author>
    <name>小江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>esp32开发环境搭建（arduino）</title>
    <link href="https://rozen12123.github.io/posts/ec4b5731.html"/>
    <id>https://rozen12123.github.io/posts/ec4b5731.html</id>
    <published>2023-07-05T06:56:01.000Z</published>
    <updated>2023-07-05T09:53:45.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32开发环境搭建（arduino）"><a href="#esp32开发环境搭建（arduino）" class="headerlink" title="esp32开发环境搭建（arduino）"></a>esp32开发环境搭建（arduino）</h1><h2 id="首先下载arduino-IDE最新版"><a href="#首先下载arduino-IDE最新版" class="headerlink" title="首先下载arduino IDE最新版"></a>首先下载arduino IDE最新版</h2><p>网址：<a href="https://www.arduino.cc/en/software">Software | Arduino</a></p><p><img src="/posts/ec4b5731.htm/image-20230705173111732.png" alt="image-20230705173111732" style="zoom:50%;"></p><p>点击windows win10</p><p><img src="/posts/ec4b5731.htm/image-20230705173234138.png" alt="image-20230705173234138" style="zoom:50%;"></p><p>点击just download</p><p>此时即可下载到电脑。</p><h3 id="方法二（github）"><a href="#方法二（github）" class="headerlink" title="方法二（github）"></a>方法二（github）</h3><p>打开网址<a href="https://github.com/arduino/arduino-ide">arduino/arduino-ide: Arduino IDE 2.x (github.com)</a></p><p>点击code<img src="/posts/ec4b5731.htm/image-20230705173428162.png" alt="image-20230705173428162" style="zoom:50%;"></p><p>点击Download ZIP下载压缩包，下载完压缩即可。</p><p><img src="/posts/ec4b5731.htm/image-20230705173503553.png" alt="image-20230705173503553" style="zoom:50%;"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="安装esp32开发环境"><a href="#安装esp32开发环境" class="headerlink" title="安装esp32开发环境"></a>安装esp32开发环境</h2><p>你需要向 Arduino IDE 板管理器添加一个额外的源，然后安装 ESP32。</p><p>打开<code>文件</code> 菜单下的 <code>首选项</code>。</p><p><img src="/posts/ec4b5731.htm/image-20230705173759404.png" alt="image-20230705173759404" style="zoom:50%;"></p><p>把下面的链接复制粘贴到 <code>附加开发板管理网址</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure><p><img src="/posts/ec4b5731.htm/image-20230705173901853.png" alt="image-20230705173901853" style="zoom:50%;"></p><p>再安装 ESP32 开发板，选择 <code>工具</code> 菜单中的 <code>开发板</code> -&gt; <code>开发板管理器...</code></p><p><img src="/posts/ec4b5731.htm/image-20230705174120798.png" alt="image-20230705174120798" style="zoom:67%;"></p><p>在搜索栏搜索esp32，点击安装即可</p><p><img src="/posts/ec4b5731.htm/image-20230705174231819.png" alt="image-20230705174231819" style="zoom:67%;"></p><p>完成安装后即可在 工具—-&gt;开发板中发现esp32</p><p><img src="/posts/ec4b5731.htm/image-20230705174720673.png" alt="image-20230705174720673" style="zoom:67%;"></p><p>&nbsp;</p><h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>如果在连接esp32后没有反应则需要下载驱动</p><p>链接：<a href="https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc">https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc</a><br>提取码：m1bc</p><p>下在完可以在<strong>设备管理器</strong>中查看到设备</p><p><img src="/posts/ec4b5731.htm/image-20230705175338657.png" alt="image-20230705175338657" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;a href=&quot;#esp32开发环境搭建（arduino）&quot; class=&quot;headerlink&quot; title=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;/a&gt;esp32开发环境搭建（arduino）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32WIFI</title>
    <link href="https://rozen12123.github.io/posts/e7f7981b.html"/>
    <id>https://rozen12123.github.io/posts/e7f7981b.html</id>
    <published>2023-07-02T06:20:25.000Z</published>
    <updated>2023-07-02T06:42:39.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WiFi-应用"><a href="#WiFi-应用" class="headerlink" title="WiFi 应用"></a><strong>WiFi</strong> <strong>应用</strong></h1><p>通过前面的实验，我们已经对 ESP32-S2 有了一定的了解。从本章开始，将迎来非常重要实用的内容，那就是 WIFI 应用。ESP32-S2 就是为 WIFI 无线连接而生的。通过本章内容，我们可以看到基于 MicroPython 的 WIFI 开发是多么的简单而美妙。物联网的学习变得非常简单有趣！事不宜迟，马上开始学习。</p><h2 id="连接无线路由器"><a href="#连接无线路由器" class="headerlink" title="连接无线路由器"></a><strong>连接无线路由器</strong></h2><p>⚫ <strong>前言：</strong></p><p>WIFI 是物联网中非常重要的角色，现在基本上家家户户都有 WIFI 网络了，通过 WIFI 接入到互联网，成了智能家居产品普遍的选择。而要想上网，首先需要连接上无线路由器。这一节我们就来学习如何通过 MicroPython 编程连上路由器。</p><p>⚫ <strong>实验目的：</strong></p><p>编程实现连接路由器，将 IP 地址等相关信息通过 OLED 显示（只支持 2.4G网络）。</p><p>⚫ <strong>实验讲解：</strong></p><p>连接路由器上网是我们每天都做的事情，日常生活中我们只需要知道路由器的账号和密码，就能使用电脑或者手机连接到无线路由器，然后上网冲浪。</p><p>MicroPython 已经集成了 network 模块，开发者使用内置的 network 模块函数可以非常方便地连接上路由器。但往往也有各种连接失败的情况，如密码不正确等。这时候我们只需要再加上一些简单的判断机制，避免陷入连接失败的死循环即可！</p><p>我们先来看看 network 基于 WiFi（WLAN 模块）的构造函数和使用方法。</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>wlan = network.WLAN(interface_id)</p><p>构建 WIFI 连接对象。interface_id:分为热点 network.AP_IF 和客户端</p><p>network.STA_IF 模式。</p><p><strong>使用方法</strong></p><p>wlan.active([is_active])</p><p>激活 wlan 接口。Ture：激活；False:关闭。</p><p>wlan.scan ()</p><p>扫描允许访问的 SSID。</p><p>wlan.isconnected()</p><p>检查设备是否已经连接上。返回 Ture:已连接；False：未连接。</p><p>wlan.connected(ssid,passwork)</p><p>WIFI 连接。ssid:账号；passwork：密码。</p><p>wlan.ifconfig([ip,subnet,gateway,dns])</p><p>设备信息配置。ip：IP 地址；subnet:子网掩码；gateway:网关地址；dns:DNS</p><p>信息。<strong>（如果参数为空，则返回当前连接信息。）</strong></p><p>wlan.disconnected()</p><p>断开连接。</p><p>&nbsp;</p><p>从上表可以看到 MicroPython 通过模块封装，让 WIFI 联网变得非常简单。模块包含热点 AP 模块和客户端 STA 模式，热点 AP 是指电脑端直接连接 ESP32-S2发出的热点实现连接，但这样你的电脑就不能上网了，因此我们一般情况下都是使用 STA 模式。也就是电脑和设备同时连接到相同网段的路由器上。模块上电后可以先判断是否已经连接到网络，如果是则无需再次连接，否的话则进入 WIFI 连接状态，指示灯闪烁，连接成功后指示灯常亮，IP 等相关信息通过 OLED 显示和串口打印。另外需要配置超时 15 秒还没连接成功时执行取消连接，避免因无法连接而陷入死循环。代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702142321217.png" alt="image-20230702142321217" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：编程实现连接路由器，将IP地址等相关信息通过OLED显示（只支持2.4G网络）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> network,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;01Studio&#x27;</span>, <span class="string">&#x27;88888888&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行WIFI连接函数</span></span><br><span class="line">WIFI_Connect()</span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>本节是 WIFI 应用的基础，成功连接到无线路由器的实验后，后面就可以做socket 等相关网络通信的应用了。</p><p>&nbsp;</p><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a><strong>Socket</strong> <strong>通信</strong></h2><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了如何通过 MicroPython 编程实现 pyWiFi-ESP32-S2 模块连接到无线路由器。这一节我们则来学习一下 Socket 通信实验。Socket 几乎是整个互联网通信的基础。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 Socket 编程实现 pyWiFi-ESP32-S2 与电脑服务器助手建立连接，相互收发数据。</p><p>⚫ <strong>实验讲解：</strong></p><p>Socket 我们听得非常多了，但由于网络工程是一门系统工程，涉及的知识非常广，概念也很多，任何一个知识点都能找出一堆厚厚的的书，因此我们经常会混淆。在这里，我们尝试以最容易理解的方式来讲述 Socket，如果需要全面了解，可以自行查阅相关资料学习。</p><p>我们先来看看网络层级模型图，这是构成网络通信的基础：</p><p><img src="/posts/e7f7981b.htm/image-20230702142812428.png" alt="image-20230702142812428"></p><p>我们看看 TCP/IP 模型的传输层和应用层，传输层比较熟悉的概念是 TCP 和UDP，UPD 协议基本就没有对 IP 层的数据进行任何的处理了。而 TCP 协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。应用层中网页常用的则是 HTTP。那么我们先来解析一下这 TCP 和 HTTP 两者的关系。我们知道网络通信是最基础是依赖于 IP 和端口的，HTTP 一般情况下默认使用端口 80。举个简单的例子：我们逛淘宝，浏览器会向淘宝网的网址（本质是IP）和端口发起请求，而淘宝网收到请求后响应，向我们手机返回相关网页数据信息，实现了网页交互的过程。而这里就会引出一个多人连接的问题，很多人访问淘宝网，实际上接收到网页信息后就断开连接，否则淘宝网的服务器是无法支撑这么多人长时间的连接的，哪怕能支持，也非常占资源。</p><p>也就是应用层的 HTTP 通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。简单来说，Socket 抽象层介于传输层和应用层之间，跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p><img src="/posts/e7f7981b.htm/image-20230702142910112.png" alt="image-20230702142910112"></p><p>套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议（通常是 <strong>TCP</strong> <strong>或</strong> <strong>UDP</strong>），本地主机的 <strong>IP</strong> <strong>地址，本地进程的协议端**</strong>口，远地主机的<strong>IP</strong> <strong>地址，远地进程的协议端口。</strong></p><p>所以，socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，简单理解就是其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等等。以下是通讯流程：</p><p><img src="/posts/e7f7981b.htm/image-20230702143005669.png" alt="image-20230702143005669" style="zoom:70%;"></p><p>从上图可以看到，建了 Socket 通信需要一个服务器端和一个客户端，以本实验为例，pyWiFi-ESP32-S2 作为客户端，电脑使用网络调试助手作为服务器端，双方使用 TCP 协议传输。对于客户端，则需要知道电脑端的 IP 和端口即可建立连接。（端口可以自定义，范围在 0~65535，注意不占用常用的 80 等端口即可。）以上的内容，简单来说就是如果用户面向应用来说，那么 ESP32-S2 只需要知道<strong>通讯协议是</strong> <strong>TCP</strong> <strong>或</strong> <strong>UDP**</strong>、服务器的<strong> </strong>IP<strong> </strong>和端口号**这 3 个信息，即可向服务器发起连接和发送信息。就这么简单。</p><p>MicroPython 已经封装好相关模块 usocket,跟传统的 socket 大部分兼容，两者均可使用，本实验使用 usocket，对象如下介绍：</p><p><strong>构造函数</strong></p><p>s=usocket.socekt(af=AF_INET, type=SOCK_STREAM,proto=IPPROTO_TCP)</p><p>构建 usocket 对象。</p><p>af: AF_INET→IPV4，AF_INET6 → IPV6；</p><p>type: SCOK_STREAM→TCP，SOCK_DGRAM→UDP；</p><p>proto: IPPROTO_TCP→TCP 协议，IPPROTO_UDP→UDP 协议。</p><p>（如果要构建 TCP 连接，可以使用默认参数配置，即不输入任何参数。）</p><p><strong>使用方法</strong></p><p>addr=usocket.getaddrinfo(‘www.01studio.org’, 80)[0][-1]</p><p>获取 Socket 通信格式地址。返回：(‘47.91.208.161’,80)</p><p>s.connect(address)</p><p>创建连接。address:地址格式为 IP+端口。例：(‘192.168.1.115’,10000)</p><p>s.send(bytes)</p><p>发送。bytes：发送内容格式为字节</p><p>s.recv(bufsize)</p><p>接收数据。bufsize：单次最大接收字节个数。</p><p>s.bind(address)</p><p>绑定，用于服务器角色</p><p>s.listen([backlog])</p><p>监听，用于服务器角色。backlog:允许连接个数，必须大于 0。</p><p>s.accept()</p><p>接受连接，用于服务器角色。</p><p>&nbsp;</p><p>本实验中 pyWiFi-ESP32-S2 属于客户端，因此只用到客户端的函数即可。实验代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702143126631.png" alt="image-20230702143126631" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过Socket编程实现pyWiFi-ESP32与电脑服务器助手建立TCP连接，相互收发数据。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">import</span> network,usocket,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;henu-student&#x27;</span>, <span class="string">&#x27;hbwz12138&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断WIFI是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> WIFI_Connect():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建socket连接TCP类似，连接成功后发送“Hello 01Studio！”给服务器。</span></span><br><span class="line">    s=usocket.socket()</span><br><span class="line">    addr=(<span class="string">&#x27;192.168.1.115&#x27;</span>,<span class="number">10000</span>) <span class="comment">#服务器IP和端口</span></span><br><span class="line">    s.connect(addr)</span><br><span class="line">    s.send(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">    text=s.recv(<span class="number">128</span>) <span class="comment">#单次最多接收128字节</span></span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打印接收到的信息为字节，可以通过decode(&#x27;utf-8&#x27;)转成字符串</span></span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        s.send(<span class="string">&#x27;I got:&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    time.sleep_ms(<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>WIFI 连接代码在上一节已经讲解，这里不再重复，WIFI 连接成功后返回 True，否则返回 False。程序在返回连接成功后建了 Socket 连接，连接成功发送‘Hello 01Studio!’信息到服务器。另外 RTOS 定时器设定了了每 300ms 处理从服务器接收到的数据。将接收到数据通过串口打印和发送给服务器。</p><p>⚫ <strong>实验结果：</strong></p><p>先在电脑端打开网络调试助手并建立服务器，软件在 零一科技（01Studio）MicroPython 开发套件配套资料_latest\01-开发工具\01-Windows\网络调试助手下的 NetAssist.exe ，直接双击打开即可！</p><p><img src="/posts/e7f7981b.htm/image-20230702143433653.png" alt="image-20230702143433653" style="zoom:67%;"></p><p>以下是新建服务器的方法，打开网络调试助手后在左上角协议类型选择 TCP Server；中间的本地 IP 地址是自动识别的，不要修改，这个就是服务器的 IP 地址。然后端口写 10000（0-65535 都可以。），点击连接，成功后红点亮。如下图：</p><p><img src="/posts/e7f7981b.htm/image-20230702143452690.png" alt="image-20230702143452690" style="zoom:80%;"></p><p>在时候服务器已经在监听状态！用户需要根据自己的实际情况自己输入 WIFI信息和服务器 IP 地址+端口。即修改上面的代码以下部分内容。（服务器 IP 和端口可以在网络调试助手找到。）</p><p>WiFi 网络信息：</p><p>wlan.connect(‘01Studio’, ‘88888888’) #输入 WIFI 账号密码</p><p>服务器信息：</p><p>addr=(‘192.168.1.115’,10000) #服务器 IP 和端口</p><p>下载程序，开发板成功连接 WIFI 后，发起了 socket 连接，连接成功可以可以看到网络调试助手收到了开发板发来的信息。在下方列表多了一个连接对象，点击选中</p><p><img src="/posts/e7f7981b.htm/image-20230702143524077.png" alt="image-20230702143524077"></p><p>选中后我们在发送框输入信息“Hi”，点击发送，可以看到开发板的 REPL 打印出来信息 Hi。为字节数据。另外由于程序将收到的信息发回给服务器，所以在网络调试助手中也接收到开发板返回的信息：I got:Hi。</p><p><img src="/posts/e7f7981b.htm/image-20230702143554343.png" alt="image-20230702143554343" style="zoom:60%;"></p><p><img src="/posts/e7f7981b.htm/image-20230702143618314.png" alt="image-20230702143618314" style="zoom:80%;"></p><p>⚫ <strong>总结：</strong></p><p>通过本节学习，我们了解了socket通信原理以及使用MicroPython进行socket编程并且通信的实验。得益于优秀的封装，让我们可以直接面向 socket 对象编程就可以快速实现 socket 通信，从而开发更多的网络应用，例如将前面采集到的传感器数据发送到服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WiFi-应用&quot;&gt;&lt;a href=&quot;#WiFi-应用&quot; class=&quot;headerlink&quot; title=&quot;WiFi 应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;WiFi&lt;/strong&gt; &lt;strong&gt;应用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通过前面的实验，我们已经对 ES</summary>
      
    
    
    
    
    <category term="espe32" scheme="https://rozen12123.github.io/tags/espe32/"/>
    
  </entry>
  
  <entry>
    <title>esp32传感器</title>
    <link href="https://rozen12123.github.io/posts/30e8a1b9.html"/>
    <id>https://rozen12123.github.io/posts/30e8a1b9.html</id>
    <published>2023-07-02T04:20:30.000Z</published>
    <updated>2023-07-05T07:12:41.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传感器实验"><a href="#传感器实验" class="headerlink" title="传感器实验"></a><strong>传感器实验</strong></h1><p>日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程师驱动一款未接触过的传感器的一般流程是：了解传感器原理、设计电路图、信号时序分析和编程。没个几天折腾不出来。生活中有很多传感器已经是非常通用了，前人已经做好封装函数模块，我们直接调用函数即可。我们不需要将时间花在“怎么用”上，而更多的是考虑“用到什么地方”！</p><h3 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a><strong>温度传感器</strong> <strong>DS18B20</strong></h3><p>⚫ <strong>前言：</strong></p><p>相信没有电子爱好者不知道 DS18B20 的，DS18B20 是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。DS18B20 数字温度传感器接线方便，封装成后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式，型号多种多样。主要根据应用场合的不同而改变其外观。封装后的 DS18B20 可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。</p><p><img src="/posts/30e8a1b9.htm/image-20230702122309279.png" alt="image-20230702122309279"></p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我，们来看看原理图：</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我们来看看原理图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140646041.png" alt="image-20230702140646041" style="zoom:50%;"></p><p>可以看到 DS18B20 传感器连接到了 pyBase 的 X11 引脚上。也就是连接到pyWiFi-ESP32-S2 的引脚 41，如下图所示：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140747976.png" alt="image-20230702140747976" style="zoom:50%;"></p><p>也就是说我们需要针对引脚 41 编写程序来驱动 DS18B20。那么我们需要自己来编写驱动么？如果你有兴趣的可以自己尝试一下。这部分我们 01Studio 已经收集整理和编写好了，单总线模块文件是：onewire.py，DS18B20 模块的文件是 ds18x20.py。如果你学习过前面基于 STM32 平台应该不陌生。而对于 ESP32-S2,这两个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可！单总线模块（onewire）和 ds18x20 模块说明如下：</p><p><strong>构造函数</strong></p><p>ow=onewire.OneWire(machine.Pin(id))</p><p>构建单总线对象。id:引脚编号；</p><p><strong>使用方法</strong></p><p>ow.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ow.reset()</p><p>总线设备复位。</p><p>ow.readbyte()</p><p>读 1 个字节。</p><p>ow.writebyte(0x12)</p><p>写入 1 个字节。</p><p>ow.write(‘123’)</p><p>写入多个字节。</p><p>ow.select_rom(b’12345678’)</p><p>根据 ROM 编号选择总线上指定设备</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>ds=ds18x20.DS18X20(ow)</p><p>构建 DS18B20 传感器对象。ow:定义好的单总线对象；</p><p><strong>使用方法</strong></p><p>ds.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ds.convert_temp()</p><p>温度转换。</p><p>ds.read_temp(rom)</p><p>获取温度值。rom：表示对应的设备号。</p><p>&nbsp;</p><p>大部分场景下温度的变化不会太频繁，我们可以每隔 1 秒采集一次，显示精度为小数点后 2 位，基本满足大部分应用需求。编程逻辑如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140853444.png" alt="image-20230702140853444" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：温度传感器DS18B20</span></span><br><span class="line"><span class="string">说明：通过编程采集温度数据，并在OLED上显示。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"><span class="keyword">import</span> onewire,ds18x20,time</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化DS18B20</span></span><br><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) <span class="comment">#使能单总线</span></span><br><span class="line">ds = ds18x20.DS18X20(ow)        <span class="comment">#传感器是DS18B20</span></span><br><span class="line">rom = ds.scan()         <span class="comment">#扫描单总线上的传感器地址，支持多个传感器同时连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_get</span>(<span class="params">tim</span>):</span><br><span class="line">    ds.convert_temp()</span><br><span class="line">    temp = ds.read_temp(rom[<span class="number">0</span>]) <span class="comment">#温度显示,rom[0]为第1个DS18B20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#OLED数据显示</span></span><br><span class="line">    oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">    oled.text(<span class="string">&#x27;MicroPython&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;Temp test:&#x27;</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%temp)+<span class="string">&#x27; C&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>) <span class="comment">#显示temp,保留2位小数</span></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(-<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=temp_get) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验拓展：</strong></p><p>pyBase 开发底板预留了外界传感器接口，只要接线正确就可以进行更多的传感器实验。我们将带金属探头的 DS18B20 传感器接到 pyBase 右侧上面的传感器母座，其连接到 pyBase 的“Y11”引脚,也就是对应 pyWiFi-ESP32-S2 的引脚 10。</p><p>所以只要将原程序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) </span><br></pre></td></tr></table></figure><p>改成 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">10</span>))，</span><br></pre></td></tr></table></figure><p>即可驱动外接的 DS18B20。</p><p>⚫ <strong>总结</strong></p><p>DS18B20 作为我们第一个实验传感器，使用 MicroPython 编程非常容易就用起来了，而且精度和稳定性丝毫没有影响。温度传感器只是一个敲门砖，接下来我们将会学习更多的传感器应用。</p><p>&nbsp;</p><h3 id="温湿度传感器-DHT11"><a href="#温湿度传感器-DHT11" class="headerlink" title="温湿度传感器 DHT11"></a><strong>温湿度传感器</strong> <strong>DHT11</strong></h3><p>⚫ <strong>前言：</strong></p><p>温湿度也是我们日常非常常见的指标，我们使用的是 DHT11 数字温湿度传感器。这是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。</p><p>DHT11 具有小体积、极低的功耗，信号传输距离可达 20 米以上，使其成为给类应用甚至最为苛刻的应用场合的最佳选择。产品为 4 针单排引脚封装，连接方便。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温湿度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DHT11 虽然有 4 个引脚，但其中第 3 个引脚是悬空的，也就是说 DHT11 也是单总线的传感器，只占用 1 个 IO 口。</p><p><img src="/posts/30e8a1b9.htm/image-20230702141333793.png" alt="image-20230702141333793" style="zoom:80%;"></p><p>我们来看看 DHT11 在开发板上的接线图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141347945.png" alt="image-20230702141347945" style="zoom:67%;"></p><p>可以看到 DHT11 连接到 pyBase 的‘X12’引脚，也就是连接到 pyWiFi-ESP32-S2 的引脚 42，如下图所示：</p><p>因此可以针对引脚 42 编程来驱动 DHT11 传感器，模块文件是 dht.py。而对于 pyWiFi-ESP32-S2,这个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可。函数模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>d = dht.DHT11(machine.Pin(id))</p><p>构建 DHT11 传感器对象。id:传感器所连接的引脚；</p><p><strong>使用方法</strong></p><p>d.measure()</p><p>测量温湿度。</p><p>d.temperature()</p><p>获取温度值。</p><p>d.humidity()</p><p>获取湿度值</p><p>建议上电先延时 1 秒，让 DHT11 稳定后再开始读取。代码编写流程如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141458320.png" alt="image-20230702141458320" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="人体感应传感器"><a href="#人体感应传感器" class="headerlink" title="人体感应传感器"></a><strong>人体感应传感器</strong></h3><p>⚫ <strong>前言：</strong></p><p>人体感应传感器，在室内安防应用非常普遍，其原理是由探测元件将探测到人体的红外辐射转变成微弱的电压信号，经过放大后输出。为了提高探测器的探测灵敏度以增大探测距离，一般在探测器的前方装设一个塑料的菲涅尔透镜，它和放大电路相配合，可将信号放大 70dB 以上，这样就可以测出 5~10 米范围内人的行动。</p><p>⚫ <strong>实验目的：</strong></p><p>通过外部中断编程来检测人体感应模块，当有人出现时候 OLED 通过“GetPeople!！！”闪烁提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传感器实验&quot;&gt;&lt;a href=&quot;#传感器实验&quot; class=&quot;headerlink&quot; title=&quot;传感器实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;传感器实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32基础实验</title>
    <link href="https://rozen12123.github.io/posts/7fbb683d.html"/>
    <id>https://rozen12123.github.io/posts/7fbb683d.html</id>
    <published>2023-07-01T14:34:17.000Z</published>
    <updated>2023-07-02T06:42:39.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a><strong>基础实验</strong></h1><p>MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的实现，也就是说我们只要理解和熟练相关的函数用法，就可以很好</p><p>的玩转 MicroPython。它让我们可以做到不关心硬件和底层原理（当然有兴趣和能力的小伙伴可以深入研究）而直接跑起硬件。</p><h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 上有 1 个 LED（蓝色），控制 LED 使用 machine 中的 Pin 对</p><p>象，其构造函数和使用方法如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>led=machine.Pin(id,mode,pull)</td></tr><tr><td>构建 led 对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>led.value([x])</td></tr><tr><td>引脚电平值。输出状态：x=0 表示低电平，x=1 表示高电平；输入状态：无须</td></tr><tr><td>参数，返回当前引脚值。</td></tr><tr><td>led.on()</td></tr><tr><td>使引脚输出高电平“1”。</td></tr><tr><td>led.off()</td></tr><tr><td>使引脚输出低电平“0”。</td></tr><tr><td>更详细内容，请查看 micropython 库文档：<a href="https://docs.01studio.cc/">https://docs.01studio.cc/</a></td></tr></tbody></table></div><p>上表对 MicroPython 的 machine 中 Pin 对象做了详细的说明，machine 是大</p><p>模块，Pin 是 machine 下面的其中一个小模块，在 python 编程里有两种方式引用</p><p>相关模块:</p><p><strong>方式</strong> <strong>1</strong> <strong>是</strong>：import machine，然后通过 machine.Pin 来操作；</p><p><strong>方式</strong> <strong>2</strong> <strong>是</strong>：from machine import Pin,意思是直接从 machine 中引入 Pin 模块，</p><p>然后直接通过构建 led 对象来操作。显然方式 2 会显得更直观和方便，本实验也</p><p>是使用方式 2 来编程。代码编写流程如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701223716097.png" alt="image-20230701223716097"></p><p>从原理图可以看到 LED 跟模块引脚 2 相连，通过输出高电平方式点亮</p><p><img src="/posts/7fbb683d.htm/image-20230701223726651.png" alt="image-20230701223726651" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮 LED 蓝灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入 Pin 模块</span></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 led 对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮 LED，也可以使用 led.on()</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>从第一个实验我们可以看到，使用 MicroPython 来开发关键是要学会构造函</p><p>数和其使用方法，便可完成对相关对象的操作，在强大的模块函数支持下，实验</p><p>只用了简单的两行代码便实现了点亮 LED 灯。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h2><p>⚫ <strong>前言：</strong></p><p>按键是最简单也最常见的输入设备，很多产品都离不开按键，包括早期的iPhone。有了按键输入功能，我们就可以做很多好玩的东西了。</p><p>⚫ <strong>实验目的：</strong></p><p>使用按键功能，通过检测按键被按下后，改变 LED（蓝灯）的亮灭状态。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板上有 2 个按键，RST 和 KEY，RST 顾名思义是复位用的，所以真正自带可以用的就只有 1 个按键 KEY。</p><p>让我们先来搞清楚 MicroPython 里面 Pin 模块实现按键的构造函数和使用方法。</p><p>&nbsp;</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>KEY.value()</td></tr><tr><td>引脚电平值。输入状态：无须参数，返回当前引脚值 0 或者 1。</td></tr></tbody></table></div><p>可以看到跟上一节 LED 一样，只是输入/输出状态的一个改变。从下面原理图可以看到，我们只需要在开发板上电后判断 KEY 引脚的电平，当被按下时候引</p><p>脚为低电平“0</p><p><img src="/posts/7fbb683d.htm/image-20230701224109222.png" alt="image-20230701224109222"></p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p><img src="/posts/7fbb683d.htm/image-20230701224121294.png" alt="image-20230701224121294" style="zoom:67%;"></p><p>常用的方法就是当检测按键值为 0 时，延时一段时间，大约 10ms，再判断按键引脚值仍然是 0，是的话说明按键被按下。延时使用 time 模块，使用方法如</p><p>下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 睡眠 1 秒</span></span><br><span class="line">time.sleep_ms(<span class="number">500</span>) <span class="comment"># 睡眠 500 毫秒</span></span><br><span class="line">time.sleep_us(<span class="number">10</span>) <span class="comment"># 睡眠 10 微妙</span></span><br><span class="line">start = time.ticks_ms() <span class="comment"># 获取毫秒计时器开始值</span></span><br><span class="line">delta = time.ticks_diff(time.ticks_ms(), start) <span class="comment"># 计算从上电开始到当前时间</span></span><br><span class="line">的差值</span><br></pre></td></tr></table></figure><p><img src="/posts/7fbb683d.htm/image-20230701224211967.png" alt="image-20230701224211967"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：按键</span></span><br><span class="line"><span class="string">说明：通过按键改变 LED 的亮灭状态</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 LED 对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建 KEY 对象</span></span><br><span class="line">state=<span class="number">0</span> <span class="comment">#LED 引脚状态</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下</span></span><br><span class="line"> time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state=<span class="keyword">not</span> state <span class="comment">#使用 not 语句而非~语句</span></span><br><span class="line"> LED.value(state) <span class="comment">#LED 状态翻转</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;KEY&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">not</span> KEY.value(): <span class="comment">#检测按键是否松开</span></span><br><span class="line"> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看到，初始化各个对象后，进入循环，当检测到 KEY 的值为0（按键被按下）时候，先做了 10ms 的延时，再次判断；</p><p>state 为 LED 状态的值，每次按键按下后通过使用 not 来改变。这里注意的是在 python 里使用‘not’而不是‘~’的方式。not 返回的是 True 和 False，即</p><p>0,1。而~ 是取反操作，会导致出错。</p><p>&nbsp;</p><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h2><p>⚫ <strong>前言：</strong></p><p>前面我们在做普通的 GPIO 时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如</p><p>某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断</p><p>的在实际项目的应用非常普遍.</p><p>⚫ <strong>实验目的：</strong></p><p>利用中断方式来检查按键 KEY 状态，被按键被按下（产生外部中断）后使 LED</p><p>的亮灭状态翻转</p><p>⚫ <strong>实验讲解：</strong></p><p>外部中断也是通过 machine 模块的 Pin 子模块来配置，我们先来看看其配构</p><p>造函数和使用方法</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th><th></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td><td></td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td><td></td></tr><tr><td><strong>使用方法</strong></td><td></td></tr><tr><td>KEY.irq(handler,trigger)</td><td></td></tr><tr><td>配置中断模式。</td><td></td></tr><tr><td>handler:中断执行的回调函数；</td><td></td></tr><tr><td>trigger: 触发中断的方式，共 4 种，分别是 Pin.IRQ_FALLING（下降沿触发）、</td><td></td></tr><tr><td>Pin.IRQ_RISING（上升沿触发）、Pin.IRQ_LOW_LEVEL（低电平触发）、</td><td></td></tr><tr><td>Pin.IRQ_HIGH_LEVEL（高电平触发）</td></tr></tbody></table></div><p>上升沿和下降沿触发统称边沿触发。从上一节按键可以看到，按键被按下时一个引脚值从 1 到 0 变化的过程，边沿触发就是指这个过程。</p><p><img src="/posts/7fbb683d.htm/image-20230701224921935.png" alt="image-20230701224921935" style="zoom:50%;"></p><p>由此可见，我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产生中断。</p><p>编程思路中断跟按键章节类似，在初始化中断后，当系统检测到外部终端时候，执行 LED 亮灭状态反转的代码即可。</p><p><img src="/posts/7fbb683d.htm/image-20230701224954474.png" alt="image-20230701224954474"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：外部中断</span></span><br><span class="line"><span class="string">说明：通过按键改变LED的亮灭状态（外部中断方式）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建LED对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">state=<span class="number">0</span>  <span class="comment">#LED引脚状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LED状态翻转函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state = <span class="keyword">not</span> state</span><br><span class="line">        LED.value(state)</span><br><span class="line"></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中需要注意的地方：</p><p>1、state 是全局变量，因此在 fun 函数里面用该变量必须添加 globalstate 代码，否则会在函数里面新建一个样的变量造成冲突。</p><p>2、在定义回调函数 fun 的时候，需要将 Pin 对象 KEY 传递进去。</p><p>⚫ <strong>总结：</strong></p><p>从参考代码来看，只是用了几行代码就实现了实验功能，而且相对于使用while True 实时检测函数来看，代码的效率大大增强。外部中断的应用非常广，</p><p>出来普通的按键输入和电平检测外，很大一部分输入设备，比如传感器也是通过外部中断方式来实时检测.</p><p>&nbsp;</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><p>⚫ <strong>前言：</strong></p><p>定时器，顾名思义就是用来计时的，我们常常会设定计时或闹钟，然后时间到了就告诉我们要做什么了。单片机也是这样，通过定时器可以完成各种预设好</p><p>的任务。</p><p>⚫ <strong>实验目的：</strong></p><p>通过定时器让 LED 周期性每秒闪烁 1 次。</p><p>⚫ <strong>实验讲解：</strong></p><p>ESP32-S2 内置 RTOS（实时操作系统）定时器，在 machine 的 Timer 模块中。通过 MicroPython 可以轻松编程使用。我们也是只需要了解其构造对象函数和使</p><p>用方法即可！</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>tim=machine.Timer(id)</td></tr><tr><td>构建定时器对象。</td></tr><tr><td>【id】ESP32-S2 有 2 路硬件定时器，id=0~1，也可以定义成-1，即RTOS 虚拟定时器</td></tr><tr><td></td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>tim.init(period,mode,callback)</td></tr><tr><td>定时器初始化。</td></tr><tr><td>period:单位为 ms；</td></tr><tr><td>mode：2 种工作模式，Timer.ONE_SHOT（执行一次）、Timer.PERIODIC（周期性）；callback:定时器中断后的回调函数。</td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类似，代码编程流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701225642158.png" alt="image-20230701225642158" style="zoom:75%;"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：定时器</span></span><br><span class="line"><span class="string">说明：通过定时器让LED周期性每秒闪烁1次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,Timer</span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line">Counter = <span class="number">0</span></span><br><span class="line">Fun_Num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> Counter</span><br><span class="line">    Counter = Counter + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(Counter)</span><br><span class="line">    led.value(Counter%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=fun) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="I2C-总线（OLED-显示屏）"><a href="#I2C-总线（OLED-显示屏）" class="headerlink" title="I2C 总线（OLED 显示屏）"></a><strong>I2C</strong> <strong>总线（</strong>OLED <strong>显示屏）</strong></h3><p>前面学习了按键输入设备后，这一节我们来学习输出设备 OLED 显示屏，其实之前的 LED 灯也算是输出设备，因为它们确切地告诉了我们硬件的状态。只是</p><p>相对于只有亮灭的 LED 而言，显示屏可以显示更多的信息，体验更好。</p><p>⚫ <strong>实验讲解：</strong></p><p><strong>什么是</strong> <strong>I2C**</strong>？**</p><p>I2C 是用于设备之间通信的双线协议，在物理层面，它由 2 条线组成：SCL 和SDA，分别是时钟线和数据线。也就是说不通设备间通过这两根线就可以进行通</p><p>信。</p><p><strong>什么是</strong> <strong>OLED</strong> <strong>显示屏？</strong></p><p>OLED 的特性是自己发光，不像 TFT LCD 需要背光，因此可视度和亮度均高，其次是电压需求低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成</p><p>本低等特点。简单来说跟传统液晶的区别就是里面像素的材料是由一个个发光二极管组成，因为密度不高导致像素分辨率低，所以早期一般用作户外 LED 广告</p><p>牌。随着技术的成熟，使得集成度越来越高。小屏也可以制作出较高的分辨率。</p><p><img src="/posts/7fbb683d.htm/image-20230701230249879.png" alt="image-20230701230249879" style="zoom:50%;"></p><p>在了解完 I2C 和 OLED 显示屏后，我们先来看看 pyBase 开发板的原理图，也就是上面的 OLED 接口是如何连线的。</p><p><img src="/posts/7fbb683d.htm/image-20230701230306218.png" alt="image-20230701230306218" style="zoom:50%;"></p><p>我们从 pyWiFi-ESP32-S2 和 pyBase 相结合的原理图可以看到 GPIO38—Y6—SCL, GPIO40—Y8—SDA 的连接关系：</p><p><img src="/posts/7fbb683d.htm/image-20230701230321167.png" alt="image-20230701230321167" style="zoom:50%;"></p><p>本实验将使用 MicroPython 的 Machine 模块来定义 Pin 口和 I2C 初始化。具体如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>i2c = machine.I2C(scl,sda)i2c = machine.I2C(scl,sda)</td></tr><tr><td>构建 I2C 对象。scl:时钟引脚；sda:数据引脚。构建 I2C 对象。scl:时钟引脚；sda:数据引脚。</td></tr><tr><td><strong>使用方法**</strong>使用方法**</td></tr><tr><td>i2c.scan()i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,nbytes)i2c.readfrom(addr,nbytes)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；</td></tr><tr><td>i2c.write(buf)</td></tr><tr><td>写数据。buf:数据内容；</td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306.py 文件里面。开发者只需要拷贝到 pyBoard 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306.py 文件代码。OLED 显示屏对象介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>oled = SSD1306_I2C(width, height, i2c, addr)</td></tr><tr><td>构 OLED 显示屏对象。width:屏幕宽像素；height: 屏幕高像素；i2c:定义好的</td></tr><tr><td>I2C 对象; addr:显示屏设备地址。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>oled.text(string,x,y)</td></tr><tr><td>将 string 字符写在指定为位置。string：字符；x:横坐标；y:纵坐标。</td></tr><tr><td>oled.show()</td></tr><tr><td>执行显示。</td></tr><tr><td>oled.fill(RGB)</td></tr><tr><td>清屏。RGB：0 表示黑色，1 表示白色。</td></tr></tbody></table></div><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><p><img src="/posts/7fbb683d.htm/image-20230701231539182.png" alt="image-20230701231539182" style="zoom:80%;"></p><h4 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：I2C总线(OLED显示屏)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin         <span class="comment">#从machine模块导入I2C、Pin子模块</span></span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C     <span class="comment">#从ssd1306模块中导入SSD1306_I2C子模块</span></span><br><span class="line"></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))   <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>) <span class="comment">#OLED显示屏初始化：128*64分辨率,OLED的I2C地址是0x3c</span></span><br><span class="line"></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>,  <span class="number">0</span>)      <span class="comment">#写入第1行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>,  <span class="number">0</span>, <span class="number">20</span>)      <span class="comment">#写入第2行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>,  <span class="number">0</span>, <span class="number">50</span>)      <span class="comment">#写入第3行内容</span></span><br><span class="line"></span><br><span class="line">oled.show()   <span class="comment">#OLED执行显示</span></span><br></pre></td></tr></table></figure><p>上述代码中 OLED 的 I2C 地址是 0x3C,不同厂家的产品地址可能预设不一样，具体参考厂家的说明书。或者也可以通过 I2C.scan()来获取设备地址。另外记得将我们提供的示例代码中的 ssd1306.py 驱动文件拷贝到 pyWiFiESP32-S2 的文件系统下，跟 main.py 保持同一个路径。</p><p><img src="/posts/7fbb683d.htm/image-20230701231632416.png" alt="image-20230701231632416" style="zoom:50%;"></p><p>⚫ <strong>总结：</strong></p><p>这一节我们学会了驱动 OLED 显示屏，换着以往如果从使用单片机从 0 开发的话你需要了解 I2C 总线原理，了解 OLED 显示屏的使用手册，编程 I2C 代码，有经验的嵌入式工程师搞不好也要弄个几天。现在基本半个小时解决问题。当然前提是别人已经给你搭好桥了，有了强大的底层驱动代码支持，我们只做好应用就好。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="RTC-实时时钟"><a href="#RTC-实时时钟" class="headerlink" title="RTC 实时时钟"></a><strong>RTC</strong> <strong>实时时钟</strong></h3><p>⚫ <strong>前言：</strong></p><p>时钟可以说我们日常最常用的东西了，手表、电脑、手机等等无时无刻不显示当前的时间。可以说每一个电子爱好者心中都希望拥有属于自己制作的一个电子时钟，接下来我们就用 MicroPython 开发板来制作一个属于自己的电子时钟。</p><p>⚫ <strong>实验讲解：</strong></p><p>实验的原理是读取 RTC 数据，然后通过 OLED 显示。毫无疑问，强大的MicroPython 已经集成了内置时钟函数模块。位于 machine 的 RTC 模块中，具体介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>rtc=machine.RTC()</td></tr><tr><td>构建 RTC 对象。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>rtc.datetime((2019, 4, 1, 0, 0, 0, 0, 0))</td></tr><tr><td>设置日期和时间。按顺序分别是：（年，月，日，星期，时，分，秒，微秒），</td></tr><tr><td>其中星期使用 0-6 表示周一至周日。</td></tr><tr><td>rtc.datetime()</td></tr><tr><td>获取当前日期和时间</td></tr></tbody></table></div><p>从上表可以看到 RTC()的使用方法，我们需要做的就是先设定时间，然后再获取当前芯片里的时间，通过 OLED 显示屏显示，如此循环。在循环里，如果一直获取日期时间数据会造成资源浪费，所以可以每隔第一段时间获取一次数据，又由于肉眼需要看到至少每秒刷新一次即可，这里每隔 300ms 获取一次数据，使用前面学习过的 RTOS 定时器来计时，具体编程流程如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701232806658.png" alt="image-20230701232806658" style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：RTC实时时钟</span></span><br><span class="line"><span class="string">说明：使用Thonny连接开发板会自动更新RTC时间</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, SoftI2C, RTC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义星期和时间（时分秒）显示字符列表</span></span><br><span class="line">week = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tues&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">time_list = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化所有相关对象</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>)) <span class="comment">#I2C初始化：sda--&gt;40, scl--&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">rtc = RTC()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次上电配置时间，按顺序分别是：年，月，日，星期，时，分，秒，次秒级；这里做了</span></span><br><span class="line"><span class="comment"># 一个简单的判断，检查到当前年份不对就修改当前时间，开发者可以根据自己实际情况来</span></span><br><span class="line"><span class="comment"># 修改。</span></span><br><span class="line"><span class="keyword">if</span> rtc.datetime()[<span class="number">0</span>] != <span class="number">2023</span>:</span><br><span class="line">    rtc.datetime((<span class="number">2021</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RTC_Run</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    datetime = rtc.datetime()  <span class="comment"># 获取当前时间</span></span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;RTC Clock&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)  <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示日期，字符串可以直接用“+”来连接</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(datetime[<span class="number">0</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">1</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">2</span>]) + <span class="string">&#x27; &#x27;</span> + week[datetime[<span class="number">3</span>]], <span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间需要判断时、分、秒的值否小于10，如果小于10，则在显示前面补“0”以达</span></span><br><span class="line">    <span class="comment"># 到较佳的显示效果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">if</span> datetime[i] &lt; <span class="number">10</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间</span></span><br><span class="line">    oled.text(time_list[<span class="number">0</span>] + <span class="built_in">str</span>(datetime[<span class="number">4</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">1</span>] + <span class="built_in">str</span>(datetime[<span class="number">5</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">2</span>] + <span class="built_in">str</span>(datetime[<span class="number">6</span>]), <span class="number">0</span>, <span class="number">55</span>)</span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器</span></span><br><span class="line">tim = Timer(<span class="number">0</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=RTC_Run) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于实验要用到 OLED 显示屏，所以同样别忘了将示例代码该实验文件夹下的 ssd1306.py 文件复制到 pyWiFi-ESP32-S2 的文件系统里面。</p><p>由于 ESP32-S2 没有后备电池引脚，所以不支持掉电保存。因此 pybase 上面的纽扣电池是不起作用的。</p><p>⚫ <strong>总结：</strong></p><p>细心的用户或许已经发现运行程序后 RTC 时间自动更新，那是因为 thonny每次连接 MicroPython 开发板会自动更新开发板的 RTC 时间。</p><p>RTC 实时时钟的可玩性很强，我们还可以根据自己的风格来设定数字显示位置，以及加上一些属于自己的字符标识。打造自己的电子时钟。</p><p>&nbsp;</p><h3 id="ADC（电位器）"><a href="#ADC（电位器）" class="headerlink" title="ADC（电位器）"></a><strong>ADC</strong>（电位器）</h3><p>⚫ <strong>前言：</strong></p><p>ADC(analog to digital conversion) 模拟数字转换。意思就是将模拟信号转化成数字信号，由于单片机只能识别二级制数字，所以外界模拟信号常常会通过 ADC转换成其可以识别的数字信息。常见的应用就是将变化的电压转成数字信号。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程调用 MicroPython 的内置 ADC 函数，实现测量输入电压，并显示到屏幕上。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyBase 开发底板的 X7 引脚连接到了电位器，通过电位器的调节可以使得 X7引脚上的电压变化范围实现从 0-3.3V。</p><p><img src="/posts/7fbb683d.htm/image-20230701233122746.png" alt="image-20230701233122746" style="zoom:50%;"></p><p><img src="/posts/7fbb683d.htm/image-20230701233132565.png" alt="image-20230701233132565" style="zoom:50%;"></p><p>从上图可以看到，电位器引脚对应 pyBase 的 X7,实际是跟 pyWiFi-ESP32-S2</p><p>的‘</p><p>6’引脚 ADC 输入引脚相连。ESP32-S2 的 ADC 默认只能测量 0-1V 的量程，</p><p>但 ESP32-S2 内部集成了衰减器，最大支持 11dB 衰减，通过配置衰减器最多能测</p><p>量 3V 左右的电压。我们来看看 ADC 模块的构造函数和使用方法。</p><p><strong>构造函数</strong></p><p>adc=machine.ADC(Pin(id))</p><p>构建 ADC 对象。</p><p>【id】目前仅支持 ESP32-S2 的 ADC1，共 10 个通道：</p><p>GPIO1: ADC1_0</p><p>GPIO2: ADC1_1</p><p>GPIO3: ADC1_2</p><p>GPIO4: ADC1_3</p><p>GPIO5: ADC1_4</p><p>GPIO6: ADC1_5</p><p>GPIO7: ADC1_6</p><p>GPIO8: ADC1_7</p><p>GPIO9: ADC1_8</p><p>GPIO10: ADC1_9</p><p><strong>使用方法</strong></p><p>adc.read()</p><p>获取 ADC 值。测量精度是 13 位，返回 0- 8191（表示 0-1V）。</p><p>adc.atten(attenuation)</p><p>配置衰减器。配置衰减器能增加电压测量范围，但是以精度为代价的。</p><p>attenuation:衰减设置</p><p>ADC.ATTN_0DB： 0dB 衰减, 最大输入电压为 1.00v - 这是默认配置；</p><p>ADC.ATTN_2_5DB： 2.5dB 衰减, 最大输入电压约为 1.34v；</p><p>ADC.ATTN_6DB：6dB 衰减, 最大输入电压约为 2.00v；</p><p>ADC.ATTN_11DB：11dB 衰减, 最大输入电压约为 3.3v。</p><p>你没看错，就这么简单，两句函数就可以获得 ADC 数值。我们将在本实验中以默认的量程 0-1V 来测试。让我们来理顺一下编程逻辑。先导入相关模块，然后初始化模块。在循环中不断读取 ADC 的值，转化成电压值后在 OLED 上面显示，每隔 300 毫秒读取一次，具体如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701233235973.png" alt="image-20230701233235973" style="zoom:75%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：ADC-电压测量</span></span><br><span class="line"><span class="string">说明：通过对ADC数据采集，转化成电压在显示屏上显示。ADC精度13位（0~8191），默认电压0-1V。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,ADC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))  <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">adc = ADC(Pin(<span class="number">6</span>)) <span class="comment">#6引脚跟pyBase的电位器相连接</span></span><br><span class="line">adc.atten(ADC.ATTN_11DB) <span class="comment">#开启衰减，测量量程增大到3.3V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ADC_Test</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;ADC&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)      <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取ADC数值</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(adc.read()),<span class="number">0</span>,<span class="number">40</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;(8191)&#x27;</span>,<span class="number">60</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算电压值，获得的数据0-4095相当于0-1V，（&#x27;%.2f&#x27;%）表示保留2位小数</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%(adc.read()/<span class="number">8191</span>*<span class="number">3.3</span>)),<span class="number">0</span>,<span class="number">55</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;V&#x27;</span>,<span class="number">40</span>,<span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启定时器</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=ADC_Test) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>这一节我们学习了 ADC 的应用，主要用于电压的检测。有兴趣的用户可以尝试使用其衰减器测试，可以扩充电压量程，但精度会有所下降。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM（无源蜂鸣器）"><a href="#PWM（无源蜂鸣器）" class="headerlink" title="PWM（无源蜂鸣器）"></a><strong>PWM</strong>（无源蜂鸣器）</h3><p>⚫ <strong>前言：</strong></p><p>上一节的 ADC 是信号输入，这节的 PWM 就是一个信号输出。PWM（脉冲宽度调制），主要用于输出不同频率、占空比（一个周期内高电平出现时间占总时间比例）的方波。以实现固定频率或平均电压输出。</p><p><img src="/posts/7fbb683d.htm/image-20230702110658705.png" alt="image-20230702110658705"></p><p>⚫ <strong>实验目的：</strong></p><p>通过不同频率的 PWM 信号输出，驱动无源蜂鸣器发出不同频率的声音。</p><p>⚫ <strong>实验讲解：</strong></p><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyWiFi-ESP32-S2 的 PWM 输出频率是在变化的。pyBase 开发底板上的无源蜂鸣器连接到 pyBase 引脚 X5。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702110722346.png" alt="image-20230702110722346" style="zoom:50%;"></p><p>从 pyWiFi-ESP32-S2 原理图可以看到由底板蜂鸣器 X5 连接到 ESP32-S2 的引脚 4。</p><p><img src="/posts/7fbb683d.htm/image-20230702110739134.png" alt="image-20230702110739134" style="zoom:50%;"></p><p>PWM 可以通过 ESP32-S2 所有 GPIO 引脚输出. 所有通道都有 1 个特定的频率，从 0 到 40M 之间（单位是 Hz）。占空比的值为 0 至 1023 之间。在本实验中我们用到引脚 4。</p><p>先看看 PWM 模块对象：</p><p><strong>构造函数</strong></p><p>pwm=machine.PWM(machine.Pin(id),freq,duty)</p><p>构建 PWM 对象。id:引脚编号；freq:频率值；duty:占空比；配置完后 PWM 自</p><p>动生效。</p><p><strong>使用方法</strong></p><p>pwm.freq(freq)</p><p>设置频率。freq:频率值在 1-1000 之间，freq 为空时表示获取当前频率值。</p><p>pwm.duty(duty)</p><p>设置占空比。duty:占空比在 0-1023 之间，duty 为空时表示获取当前占空比值。</p><p>pwm.deinit()</p><p>关闭 PWM。</p><p>无源蜂鸣器我们可以用特定频率的方波来驱动，方波的原理很简单，就是一定频率的高低电平转换，可以简单理解成占空比为 50%的 PWM 输出。</p><p><img src="/posts/7fbb683d.htm/image-20230702110852679.png" alt="image-20230702110852679"></p><p>结合上述讲解，总结出代码编写流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230702110920198.png" alt="image-20230702110920198"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：PWM</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过不同频率的PWM信号输出，驱动无源蜂鸣器发出不同频率的声音。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">Beep = PWM(Pin(<span class="number">4</span>), freq=<span class="number">0</span>, duty=<span class="number">512</span>) <span class="comment"># 在同一语句下创建和配置PWM,占空比50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率200Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">200</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率400Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">400</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率600Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">600</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率800Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">800</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率1000Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">1000</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">Beep.deinit()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART</strong>（串口通信）</h3><p>⚫ <strong>前言：</strong></p><p>串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板一共有 2 个串口，编号是 0-1，如下表：</p><div class="table-container"><table><thead><tr><th>UART(0)</th><th>TX</th><th>43</th></tr></thead><tbody><tr><td></td><td>RT</td><td>44</td></tr><tr><td>UART(1)</td><td>TX</td><td>任意映射IO</td></tr><tr><td></td><td>RX</td><td>任意映射IO</td></tr></tbody></table></div><p>由于 UART0 用于下载和 REPL 调试，因此我们使用 UART1 来进行本节实验。</p><p>我们先来了解一下串口对象的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>uart=machine.UART(id,baudrate,tx=None,rx=None bits=8, parity=None, stop=1,…)</p><p>创建 UART 对象。</p><p>【id】0-1</p><p>【baudrate】波特率，常用 115200、9600</p><p>【tx】自定义 IO</p><p>【rx】自定义 IO</p><p>【bits】数据位</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>…</p><p>特别说明： ESP32-S2 的 UART 引脚映射到其它 IO 来使用，用户可以通过构造</p><p>函数时候指定如 tx=8,rx=9 的方式来改变串口引脚，实现更灵活的应用。</p><p><strong>使用方法</strong></p><p>uart.deinit()</p><p>关闭串口</p><p>uart.any()</p><p>返回等待读取的字节数据，0 表示没有</p><p>uart.read([<em>nbytes</em>])</p><p>【nbytes】读取字节数</p><p>UART.readline()</p><p>读行</p><p>UART.write(<em>buf</em>)</p><p>【buf】串口 TX 写数据</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p><img src="/posts/7fbb683d.htm/image-20230702111650095.png" alt="image-20230702111650095" style="zoom:50%;"></p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用串口 2，也就是 8（TX）和 9（RX），接线示意图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230702111711515.png" alt="image-20230702111711515"></p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230702111732984.png" alt="image-20230702111732984"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：串口通信</span></span><br><span class="line"><span class="string">说明：通过编程实现串口通信，跟电脑串口助手实现数据收发。</span></span><br><span class="line"><span class="string">平台：pyWiFi-ESP32</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入串口模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line">uart=UART(<span class="number">1</span>,<span class="number">115200</span>,rx=<span class="number">9</span>,tx=<span class="number">8</span>) <span class="comment">#设置串口号1和波特率</span></span><br><span class="line"></span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)<span class="comment">#发送一条数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断有无收到信息</span></span><br><span class="line">    <span class="keyword">if</span> uart.<span class="built_in">any</span>():</span><br><span class="line"></span><br><span class="line">        text=uart.read(<span class="number">128</span>) <span class="comment">#接收128个字符</span></span><br><span class="line">        <span class="built_in">print</span>(text) <span class="comment">#通过REPL打印串口3接收的数据</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>我们按照上述方式将 USB 转 TTL 的 TX 接到开发板的 RX（</p><p>9），USB 转 TTL 的</p><p>RX 接到开发板的 TX（</p><p>8）。GND 接一起，3.3V 可以选择接或不接。</p><p>根据上图设备管理器里面的信息，将串口工具配置成 COM14，REPL 串口配置成 COM27（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到开发板上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到 pyWiFi-ESP32-S2 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702111909798.png" alt="image-20230702111909798" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="LCD-显示屏"><a href="#LCD-显示屏" class="headerlink" title="LCD 显示屏"></a><strong>LCD</strong> <strong>显示屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>前面用到的 OLED 显示屏虽然能显示信息，但是颜色只有黑白，而且分辨率也比较低 128x64，本节我们来学习 3.2 寸 TFT_LCD 彩色显示屏的使用方法。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 MicorPython 编程方式实现 LCD 的各种显示功能，包括画点、线、矩形、圆形、显示英文、显示图片等</p><p>&nbsp;</p><p>实验用的 LCD 是 3.2 寸，驱动是的 ILI9341，使用 SPI 方式跟 ESP32-S2 通信，按以往嵌入式 C 语言开发，我们需要对 ILI9341 进行编程实现驱动，然后再建立各种描点、划线、以及显示图片函数。</p><p>使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点我们只需要搞清各个对象函数使如何使用即可。总的来说和前面实验一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉开发板该外设是怎么接线，初始化参数如何，而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！</p><p>我们管这些函数的集合叫<strong>驱动</strong>，驱动可以是预先在固件里面，也可以通过.py文件存放在开发板文件系统。也就是说工程师已经将复杂的底层代码封装好，我们顶层直接使用 python 开发即可，人生苦短。我们来看看 pyWiFi-ESP32-S2P 开发板 3.2 寸 LCD 的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>tftlcd.LCD32(portrait=1)</p><p>构建 3.2 寸 LCD 对象。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p>LCD32.fill(color)</p><p>【color】RGB 颜色数据；如(255,0,0)表示红色。</p><p>LCD32.drawPixel(x,y,color)</p><p>画点。</p><p>【x】:横坐标，</p><p>【y】:纵坐标，</p><p>【color】:颜色。</p><p>LCD32.drawLine(x0,y0,x1,y1,color)</p><p>画线段。</p><p>【x0,y0】:起始坐标，</p><p>【x1,y1】:终点坐标，</p><p>【color】:颜色</p><p>LCD32.drawRect(x,y,width,height,color,border=1,fillcolor=None)</p><p>画矩形。</p><p>【</p><p>x,y】:起始坐标，</p><p>【width】:宽度，</p><p>【height】:高度，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.drawCircle(x,y,radius,color,border=1,fillcolor=None)</p><p>画圆。</p><p>【x, y】:圆心，</p><p>【radius】:半径，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.printStr(text,x,y,color,backcolor=None,size=2)</p><p>写字符。</p><p>【text】:字符，</p><p>【x,y】:起始坐标,</p><p>【color】:字体颜色；</p><p>【backcolor】:字体背景颜色；</p><p>【size】:字体尺寸（1-小号，2-标准，3-中号，4-大号）</p><p>LCD32.Picture(x,y,filename)</p><p>显示图片。支持图片格式类型：jpg、bmp</p><p>【x,y】:起始坐标。</p><p>【filename】: 图片路径+名称，如：”/cat.jpg”</p><p><strong>（‘</strong>/<strong>’表示开发板的板载</strong> <strong>flash</strong> <strong>的根目录。）</strong></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们在使用中将以上功能都跑一遍先看看编程流程图：</p><p><img src="/posts/7fbb683d.htm/image-20230702112205074.png" alt="image-20230702112205074"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：3.2寸LCD液晶显示屏</span></span><br><span class="line"><span class="string">说明：通过编程实现LCD的各种显示功能，包括填充、画点、线、矩形、圆形、显示英文、显示图片等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义常用颜色</span></span><br><span class="line">RED = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">GREEN = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">BLUE = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line"><span class="comment"># 构建3.2寸LCD对象并初始化</span></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认方向竖屏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充白色</span></span><br><span class="line">d.fill(WHITE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画点</span></span><br><span class="line">d.drawPixel(<span class="number">5</span>, <span class="number">5</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画线段</span></span><br><span class="line">d.drawLine(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画矩形</span></span><br><span class="line">d.drawRect(<span class="number">5</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">40</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画圆</span></span><br><span class="line">d.drawCircle(<span class="number">100</span>, <span class="number">120</span>, <span class="number">30</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写字符,4种尺寸</span></span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">200</span>, RED, size=<span class="number">1</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">230</span>, GREEN, size=<span class="number">2</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">270</span>, BLUE, size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment">#等待5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/1.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/2.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/01studio.jpg&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>将示例程序的素材文件上传到 pyWiFi-ESP32-S2P 开发板。<strong>（也可以只上传单</strong>张图片，注意修改代码中文件的路径即可。）</p><p>&nbsp;</p><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了 LCD 实验，但 LCD 只能显示相关内容，跟人是缺乏交互的。好比我们的智能手机，如果只有显示不能触碰，那么就没有可玩性了。因此本节学习一下 3.2 寸 LCD 的电阻触摸屏使用方法。</p><p>⚫ <strong>实验讲解：</strong></p><p>01Studio 配套的 3.2 寸 LCD 上带电阻触摸屏,驱动芯片为 XPT2046。当手指按下时候，通过简单的编程即可返回一个坐标，我们来看看其 micropython 构造函数和使用方法：</p><p><strong>构造函数</strong></p><p><strong>touch.XPT2046(portrait=1)</strong></p><p>构建触摸屏对象。<strong>XPT2046</strong> 表示驱动芯片型号。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p><strong>XPT2046.tick_inc()</strong></p><p>手动刷新触摸。</p><p><strong>XPT2046.read()</strong></p><p>读取触摸屏数据，返回（states,x,y）</p><p>【states】-当前触摸状态：0：按下；1：移动；2：松开。</p><p>【x】:触摸横坐标</p><p>【y】:触摸纵坐标</p><p>&nbsp;</p><p>学会了触摸对象用法后，我们可以编程实现触摸后屏幕打点表示，然后左上角显示当前触摸的坐标。另外再加入一个按键，按下清空屏幕。编程流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230702113752112.png" alt="image-20230702113752112"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：电阻触摸屏</span></span><br><span class="line"><span class="string">说明：电阻触摸屏采集触摸信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> touch <span class="keyword">import</span> XPT2046</span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色</span></span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line">RED=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认竖屏</span></span><br><span class="line">d.fill(WHITE) <span class="comment">#填充白色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#电阻触摸屏初始化，方向和LCD一致</span></span><br><span class="line">t = XPT2046(portrait=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    </span><br><span class="line">    d.fill(WHITE) <span class="comment">#清屏</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#USR按键初始化</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    data = t.read() <span class="comment">#获取触摸屏坐标</span></span><br><span class="line">    <span class="built_in">print</span>(data) <span class="comment">#REPL打印</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当产生触摸时</span></span><br><span class="line">    <span class="keyword">if</span> data[<span class="number">0</span>]!=<span class="number">2</span>: <span class="comment">#0：按下； 1：移动； 2：松开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#触摸坐标画圆</span></span><br><span class="line">        d.drawCircle(data[<span class="number">1</span>], data[<span class="number">2</span>], <span class="number">5</span>, BLACK, fillcolor=BLACK)</span><br><span class="line">        d.printStr(<span class="string">&#x27;(X:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">1</span>])+<span class="string">&#x27; Y:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">2</span>])+<span class="string">&#x27;)&#x27;</span>,<span class="number">10</span>,<span class="number">10</span>,RED,size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep_ms(<span class="number">20</span>) <span class="comment">#触摸响应间隔</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>运行程序，首次运行会自动提示进行触摸校准（电阻屏需要校准），按提示分别点击四个角落进行校准，如校准失败会自动重复。校准成功会自动保存一个“touch.cail”文件到开发板 flash，下次无须再校准。</p><p>成功后出现空白画面，用手指触摸屏幕或者在屏幕上滑动，可以看到描点并在 LCD 左上角显示当前坐标。</p><p>重启开发板，可以看到文件系统多了一个“touch.cail”，在运行电阻屏初始化时候会检测这个文件，如果存在则不进行校准，若想重新校准的用户可以把这个文件删除即可！</p><p>⚫ <strong>总结：</strong></p><p>没有触摸屏的 LCD 就失去了灵魂，有了触摸屏，跟开发板的交互就变得有意思了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础实验&quot;&gt;&lt;a href=&quot;#基础实验&quot; class=&quot;headerlink&quot; title=&quot;基础实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32</title>
    <link href="https://rozen12123.github.io/posts/86375cb2.html"/>
    <id>https://rozen12123.github.io/posts/86375cb2.html</id>
    <published>2023-07-01T13:55:14.000Z</published>
    <updated>2023-07-02T06:42:39.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32"><a href="#esp32" class="headerlink" title="esp32"></a>esp32</h1><h2 id="ESP32-S2-平台"><a href="#ESP32-S2-平台" class="headerlink" title="ESP32-S2 平台"></a><strong>ESP32-S2</strong> <strong>平台</strong></h2><h3 id="pyWiFi-ESP32-S2"><a href="#pyWiFi-ESP32-S2" class="headerlink" title="pyWiFi-ESP32-S2"></a><strong>pyWiFi-ESP32-S2</strong></h3><p>pyWiFi-ESP32-S2 是由 01Studio 设计研发，基于 ESP32-S2 平台的 MicroPython</p><p>开发板，主要特点如下：</p><p> 自动下载电路</p><p> 板载锂电池输入接口和充电电路</p><p> 标准 24P 摄像头接口</p><p> USB OTG 接口</p><p> 全 IO 引出</p><p> 按键和 LED 排列整齐，丝印清晰</p><p> 兼容 pyBoard 接口</p><p><img src="/posts/86375cb2.htm/image-20230701220231747.png" alt="image-20230701220231747"></p><p><img src="/posts/86375cb2.htm/image-20230701220244595.png" alt="image-20230701220244595"></p><h3 id="开发环境快速建立"><a href="#开发环境快速建立" class="headerlink" title="开发环境快速建立"></a><strong>开发环境快速建立</strong></h3><p>ESP32-S2 是基于是继 ESP32 普遍板后推出的一个版本，主要特点是引脚数量非常多。还支持标准 USB HOST。</p><h4 id="安装开发软件-Thonny"><a href="#安装开发软件-Thonny" class="headerlink" title="安装开发软件 Thonny"></a><strong>安装开发软件</strong> <strong>Thonny</strong></h4><p>Thonny Python IDE 是一款开源软件，以极简方式设计，对 MicroPython 的兼容性非常友善。而且支持 Windows、Mac OS、Linux、树莓派。由于开源，所以软</p><p>件迭代速度非常快，功能日趋成熟。具体安装方法如下：在 <a href="https://thonny.org/">https://thonny.org/</a> 下载最新版，选择自己的开发平台进行下载安装即可(这里选择 Windows！)：</p><p>&nbsp;</p><h3 id="REPL-串口交互调试"><a href="#REPL-串口交互调试" class="headerlink" title="REPL 串口交互调试"></a><strong>REPL</strong> <strong>串口交互调试</strong></h3><p>yWiFi-ESP32-S2 的 MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试开发板。我们打开 Thonny，将开发板连接到电脑。点击右下角：</p><p><img src="/posts/86375cb2.htm/image-20230701221427314.png" alt="image-20230701221427314" style="zoom:50%;"></p><p>在弹出的列表选择：<strong>Configure interpreter</strong></p><p><img src="/posts/86375cb2.htm/image-20230701221436676.png" alt="image-20230701221436676"></p><p>选择“MicroPython（ESP32）”和开发板对应的串口号，点击确认。</p><p><img src="/posts/86375cb2.htm/image-20230701221656057.png" alt="image-20230701221656057" style="zoom:50%;"></p><p>连接成功后可以在 shell（串口终端）看到固件的相关信息：</p><p><img src="/posts/86375cb2.htm/image-20230701221713389.png" alt="image-20230701221713389" style="zoom:50%;"></p><p>我们在 Shell 里面输入 print(“Hello 01Studio!”) , 按回车，可以看到打印出Hello 01Studio 字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">LED = Pin(<span class="number">2</span>, Pin.OUT) </span><br><span class="line">LED.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/posts/86375cb2.htm/image-20230701221806760.png" alt="image-20230701221806760" style="zoom:50%;"></p><p>接下来我们将上一节的三行代码逐行输入和逐行按回车，可以看到 LED 灯也被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701222057224.png" alt="image-20230701222057224" style="zoom:50%;"></p><p>REPL 还有一个强大的功能就是打印错误的代码来调试程序，在后面代码运行时候，如果程序出错，出错信息将通过 REPL 打印。</p><p><img src="/posts/86375cb2.htm/image-20230701222115947.png" alt="image-20230701222115947" style="zoom:50%;"></p><p><strong>REPL</strong> <strong>终端常用键盘按键：</strong></p><p>Ctrl + C : 打断正在运行的程序（特别是含 While True: 的代码）；</p><p>Ctrl + D : 软件复位开发板</p><p>&nbsp;</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p>pyWiFi-ESP32-S2 里面内置了文件系统，可以简单理解成上电后运行的 python文件，这个可以通过 Thonny 非常方便地读写。</p><p>点击 <strong>视图</strong>—<strong>文件</strong> ：</p><p><img src="/posts/86375cb2.htm/image-20230701222203009.png" style="zoom:50%;"></p><p>可以看到左边出现本地和开发板的实时文件浏览窗口：</p><p><img src="/posts/86375cb2.htm/image-20230701222237796.png" alt="image-20230701222237796" style="zoom:50%;"></p><p>在本地文件点击右键—上传到即可将相关文件发送到开发板，也可以将开发板上的文件发送到本地，非常方便。</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><strong>代码测试</strong></h3><p>前面已经安装好了 Thonny IDE 和配置，接下来使用最简单的方式来做一个点亮 LED 蓝灯的实验。具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮LED蓝灯</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入Pin模块</span></span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建led对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮LED，也可以使用led.on()</span></span><br></pre></td></tr></table></figure><p>运行功能代码是保存在开发板的 RAM（内存）里面，断电后丢失，那么如何实现开发板上电运行我们的代码呢？方法如下：</p><p>Micropython 上电默认先运行名字为 boot.py 文件，然后在运行 main.py 文件，如果没有 boot.py 那么直接运行 main.py。</p><p><strong>boot.py:</strong> <strong>一般用于配置初始化参数；</strong></p><p><strong>main.py**</strong>：主程序**</p><p>也就是我们只需要将代码以 main.py 文件发送到开发板，那么开发板就可以实现上电运行相关程序。</p><p>我们将 LED 例程的 main.py 发送到开发板</p><p><img src="/posts/86375cb2.htm/image-20230701222956537.png" alt="image-20230701222956537" style="zoom:50%;"></p><p>按下开发板的复位键，可以看到 LED 蓝灯被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701223032307.png" alt="image-20230701223032307" style="zoom:50%;"></p><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>固件更新是指重新烧写开发板的出厂文件或者是升级的固件，使用上海乐鑫提供的官方软件烧录：</p><p><img src="/posts/86375cb2.htm/image-20230701223127927.png" alt="image-20230701223127927" style="zoom:50%;"></p><p>芯片这里选择 ESP32-S2，develop 开发者模式，然后点击 OK :</p><p><img src="/posts/86375cb2.htm/image-20230701223146766.png" alt="image-20230701223146766" style="zoom:50%;"></p><p>选择 SPIDownload，在下图箭头位置点击，选择要烧录固件。</p><p>其它配置选项也请参考下图，注意下载地址是 <strong>0x1000</strong>。（COM 串口是选择自己的串口，在设备管理器查询。）</p><p><img src="/posts/86375cb2.htm/image-20230701223234252.png" alt="image-20230701223234252" style="zoom:50%;"></p><p>配置好后，先点击“ERASE”按钮刷除模块里面内容。点击软件下方“ERASE”按钮，刷除成功后，左边绿色框出现完成字样</p><p><img src="/posts/86375cb2.htm/image-20230701223253705.png" alt="image-20230701223253705"></p><p>刷除成功后，点击“START”按钮开始烧录，烧录完成有左边绿色框出现“完成”字样。完成后记得点”stop”按钮或者关闭软件释放串口。</p><p><img src="/posts/86375cb2.htm/image-20230701223316527.png" alt="image-20230701223316527"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32&quot;&gt;&lt;a href=&quot;#esp32&quot; class=&quot;headerlink&quot; title=&quot;esp32&quot;&gt;&lt;/a&gt;esp32&lt;/h1&gt;&lt;h2 id=&quot;ESP32-S2-平台&quot;&gt;&lt;a href=&quot;#ESP32-S2-平台&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>k210项目</title>
    <link href="https://rozen12123.github.io/posts/384e6f73.html"/>
    <id>https://rozen12123.github.io/posts/384e6f73.html</id>
    <published>2023-03-19T10:30:52.000Z</published>
    <updated>2023-03-23T08:50:30.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="照相机"><a href="#照相机" class="headerlink" title="照相机"></a>照相机</h2><p>本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复</p><p>外部中断按键实验：请参阅 <strong>4.4</strong> <strong>外部中断</strong> 章节内容；</p><p>拍摄照片实验：请参阅 <strong>5.9</strong> <strong>图片拍摄</strong> 章节内容。</p><p>拍照后我们应该让图片停留一段时间，让用户观察照片的拍摄情况，然后再进行继续拍摄。代码编写流程如下：</p><p><img src="/posts/384e6f73.htm/image-20230319183420293.png" alt></p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, utime</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 KEY 的外部 IO</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建 KEY 对象</span></span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># or sensor.GRAYSCALE</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># or sensor.QVGA (or others)</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #摄像头后置模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">key_node = <span class="number">0</span> <span class="comment">#按键标志位</span></span><br><span class="line">name_num = <span class="number">0</span> <span class="comment">#照片名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 按键和其回调函数</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"></span><br><span class="line"> <span class="keyword">global</span> key_node</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">  key_node = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> lcd.display(sensor.snapshot()) <span class="comment"># LCD 实时显示</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> key_node==<span class="number">1</span>: <span class="comment">#按键被按下</span></span><br><span class="line">  key_node = <span class="number">0</span> <span class="comment">#清空按键标志位</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#拍照并保存，保存文件用时间来命名。</span></span><br><span class="line">  lcd.display(sensor.snapshot().save(<span class="built_in">str</span>(name_num)+<span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line">  name_num=name_num+<span class="number">1</span> <span class="comment">#名字编码加 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Done! Reset the camera to see the saved image.&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#延时 3 秒，观看拍摄图片</span></span><br><span class="line"></span><br><span class="line">  utime.sleep_ms(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a><strong>视频播放器</strong></h2><p>音视频解码是一个复杂的过程，但 K210 底层 MicroPython 库写好后，着重应用来编程就变得非常简单了。和以往一样，我们只需要熟悉模块用法即可。</p><p>本实验实验 01Studio 音频模块，基于 PAM8403 的一款 D 类功放 IC，和麦克风一样使用 I2S 接口通信，这里不再重复 I2S 内容。</p><p>而视频播放被封装成 video 模块，在前面视频录制章节内容已经介绍过，这里重温一下，模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><p><img src="/posts/384e6f73.htm/image-20230319184439344.png" alt="image-20230319184439344"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：视频播放器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">翻译和注释：01Studio</span></span><br><span class="line"><span class="string">说明：AVI视频播放。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> video,time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">    audio_en=GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频控制IO</span></span><br><span class="line">fm.register(<span class="number">34</span>,  fm.fpioa.I2S0_OUT_D1, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">35</span>,  fm.fpioa.I2S0_SCLK, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">33</span>,  fm.fpioa.I2S0_WS, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#播放avi文件</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/badapple.avi&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印视频文件信息</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音量调节</span></span><br><span class="line">v.volume(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v.play() == <span class="number">0</span>: <span class="comment">#播放完毕</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;play end&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">v.__del__() <span class="comment">#销毁对象，释放内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本实验播放的视频是 badapple.avi，文件在本例程文件夹中，先将该文件拷贝到 sd 卡。然后将 sd 卡插到 pyAI-K210。</p><p>接上 01Studio 音频模块，运行本实验程序代码，可以见到串口终端打印了avi 视频信息后，开发板便开始播放视频。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="NES-游戏机"><a href="#NES-游戏机" class="headerlink" title="NES 游戏机"></a><strong>NES</strong> <strong>游戏机</strong></h2><p>MaixPy 集成了 NES 的 MicroPython 模块,用户通过几行代码就可以实现游戏的加载，已经使用键盘或者标准游戏手柄来操控。NES 对象如下：</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nes</span><br></pre></td></tr></table></figure><p>导入 nes 模块；</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=<span class="number">16</span>,vol=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>初始化 nes 游戏模拟器；</p><p>【rc_type】遥控类型。nes.KEYBOARD:REPL 中使用键盘；nes.JOYSTICK:PS2 手柄。</p><p>【cs,mosi,miso,clk】使用 PS2 手柄时的引脚配置；</p><p>【repeat】键盘按键重复率；</p><p>【vol】音量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.run(xx.nes)</span><br></pre></td></tr></table></figure><p>运行 nes 文件。</p><p>*更多使用说明请阅读官方文档：</p><p>&nbsp;</p><p>键盘和手柄的快捷键如下：</p><h4 id="键盘（串口）"><a href="#键盘（串口）" class="headerlink" title="键盘（串口）"></a>键盘（串口）</h4><p>【移动】：WSAD(上下左右)</p><p>【A】：J</p><p>【B】：K</p><p>【start】：M 或 Enter</p><p>【option】：N 或\</p><p>【退出】：ESC</p><p>【音量-】：-</p><p>【音量+】：=</p><p>【运行速度-】：R</p><p>【运行速度+】：F</p><h4 id="PS2-手柄"><a href="#PS2-手柄" class="headerlink" title="PS2 手柄"></a>PS2 手柄</h4><p>【移动】：方向键(上下左右)</p><p>【A】：口</p><p>【B】：X</p><p>【start】：START</p><p>【option】：SELECT</p><p>【退出】：暂无</p><p>【音量-】：R2</p><p>【音量+】：R1</p><p>【运行速度-】：L1</p><p>【运行速度+】：L2</p><p>从上表 NES 对象看到，只需要简单的初始化和运行语句，即可运行 NES 游戏模拟器，编程思路如下：</p><p><img src="/posts/384e6f73.htm/image-20230319190642974.png" alt="image-20230319190642974"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> nes, lcd</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化nes，配置为键盘控制</span></span><br><span class="line">nes.init(nes.KEYBOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行游戏</span></span><br><span class="line">nes.run(<span class="string">&quot;/sd/Bomberman.nes&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;照相机&quot;&gt;&lt;a href=&quot;#照相机&quot; class=&quot;headerlink&quot; title=&quot;照相机&quot;&gt;&lt;/a&gt;照相机&lt;/h2&gt;&lt;p&gt;本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复&lt;/p&gt;
&lt;p&gt;外部中断按键实验：请参阅 &lt;stron</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210拓展模块</title>
    <link href="https://rozen12123.github.io/posts/a4696bae.html"/>
    <id>https://rozen12123.github.io/posts/a4696bae.html</id>
    <published>2023-03-19T07:25:35.000Z</published>
    <updated>2023-03-23T08:50:30.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓展模块"><a href="#拓展模块" class="headerlink" title="拓展模块"></a><strong>拓展模块</strong></h2><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>本实验 LCD 触摸屏上使用 NS2009 芯片，将电阻触摸屏信号转化为 I2C 信号跟 K210 通信，而 MaixPy 已经集成了触摸屏应用的相关函数模块，具体介绍如下：</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br></pre></td></tr></table></figure><p>导入 touchscreen 模块;</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.init(i2c=<span class="literal">None</span>,cal=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>初始化触摸屏。</p><p>【i2c】I2C 总线；</p><p>【cal】一个 7 个整型值的元组，触摸校准数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.calibrate()</span><br></pre></td></tr></table></figure><p>触摸校准。返回一个 7 个整型值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.read()</span><br></pre></td></tr></table></figure><p>读取屏幕状态和坐标信息。返回（status,x,y）</p><p>【status】: 触摸状态，取值有如下</p><p>touchscreen.STATUS_RELEASE,值为 1，触摸屏没动作；</p><p>touchscreen.STATUS_PRESS,值为 2，触摸屏被按下；</p><p>touchscreen.STATUS_MOVE,值为 3，触摸屏在滑动；</p><p>【x】x 轴坐标</p><p>【y】y 轴坐标</p><p><img src="/posts/a4696bae.htm/image-20230319164444481.png" alt="image-20230319164444481"></p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">import</span> lcd, image</span><br><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br><span class="line"></span><br><span class="line"><span class="comment">#按键 KEY 用于清屏</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">btn_clear = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸使用 I2C 控制（NS2009）</span></span><br><span class="line">i2c = I2C(I2C.I2C0, freq=<span class="number">400000</span>, scl=<span class="number">30</span>, sda=<span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸屏初始化</span></span><br><span class="line">ts.init(i2c)</span><br><span class="line"><span class="comment">#ts.calibrate() #触摸校准</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">lcd.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建图像和触摸屏相关参数变量</span></span><br><span class="line">img = image.Image()</span><br><span class="line">status_last = ts.STATUS_IDLE</span><br><span class="line">x_last = <span class="number">0</span></span><br><span class="line">y_last = <span class="number">0</span></span><br><span class="line">draw = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#获取触摸屏状态</span></span><br><span class="line"> (status,x,y) = ts.read()</span><br><span class="line"> <span class="built_in">print</span>(status, x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line"> <span class="keyword">if</span> draw:</span><br><span class="line">  img.draw_line((x_last, y_last, x, y))</span><br><span class="line"></span><br><span class="line"> <span class="comment">#更新最后坐标</span></span><br><span class="line"> x_last = x</span><br><span class="line"> y_last = y</span><br><span class="line"></span><br><span class="line"> <span class="comment">#根据触摸屏状态判断是否继续执行画图功能</span></span><br><span class="line"> <span class="keyword">if</span> status_last!=status:</span><br><span class="line">  <span class="keyword">if</span> (status==ts.STATUS_PRESS <span class="keyword">or</span> status == ts.STATUS_MOVE):</span><br><span class="line">   draw = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#松开</span></span><br><span class="line">   draw = <span class="literal">False</span></span><br><span class="line">  status_last = status</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#按键 KEY 按下清屏</span></span><br><span class="line"> <span class="keyword">if</span> btn_clear.value() == <span class="number">0</span>:</span><br><span class="line">  img.clear()</span><br></pre></td></tr></table></figure><p>固件用如下所示固件，其中含有touchscreen库<img src="/posts/a4696bae.htm/image-20230319172358292.png" alt="image-20230319172358292"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a><strong>舵机</strong></h3><p>伺服电机对象通过 3 线（信号，电源，地）控制，pyBase 上有 4 个位置可以插这些电机，分别是 X1-X4 引脚。对应 pyAI-K210 的 17、35、34、33 脚。</p><p><img src="/posts/a4696bae.htm/image-20230319181201545.png" alt="image-20230319181201545"></p><p>180°舵机的控制一般需要一个 20ms 左右的时基脉冲，该脉冲的高电平部分一般为 0.5ms-2.5ms 范围内的角度控制脉冲部分，总间隔为 2ms。以 180 度角度伺服为例，在 MicroPython 编程对应的控制关系是从-90°至 90°，示例图如下</p><p><img src="/posts/a4696bae.htm/image-20230319181239783.png" alt="image-20230319181239783"></p><p>而对于 360°连续旋转舵机，上面的脉冲表则对应从正向最大速度旋转到反向最大速度旋转的过程。</p><p>如果过你学习过前面基于 STM32 平台的舵机实验，那就知道在 STM32 平台集成了舵机模块，使用起来非常方便。当前的 ESP32 平台并没有集成 Servo 模块，但从上面可以看到上面是通过 PWM 来控制的，我们可以直接写 PWM 函数驱动即可。代码编程流程图如下：</p><p><img src="/posts/a4696bae.htm/image-20230319181418047.png" alt="image-20230319181418047"></p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO17 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">S1 = PWM(tim, freq=<span class="number">50</span>, duty=<span class="number">0</span>, pin=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">说明：舵机控制函数</span></span><br><span class="line"><span class="string">功能：180 度舵机：angle:-90 至 90 表示相应的角度</span></span><br><span class="line"><span class="string"> 360 连续旋转度舵机：angle:-90 至 90 旋转方向和速度值。</span></span><br><span class="line"><span class="string"> 【duty】占空比值：0-100</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Servo</span>(<span class="params">servo,angle</span>):</span><br><span class="line"> S1.duty((angle+<span class="number">90</span>)/<span class="number">180</span>*<span class="number">10</span>+<span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#-90 度</span></span><br><span class="line"> Servo(S1,-<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#-45 度</span></span><br><span class="line"> Servo(S1,-<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#0 度</span></span><br><span class="line"> Servo(S1,<span class="number">0</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#45 度</span></span><br><span class="line"> Servo(S1,<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#90 度</span></span><br><span class="line"> Servo(S1,<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将 180°舵机插到 pyBase 的 X1 的三线接口，运行程序。可以看到舵机依次旋转至不同角度。</p><p><img src="/posts/a4696bae.htm/image-20230319181610319.png" alt="image-20230319181610319"></p><p>⚫ <strong>实验拓展：</strong></p><p>我们刚刚实现了 180°舵机的角度控制，现在来做一下 360°连续旋转舵机的实验，360°连续旋转舵机可以实现直流减速电机功能，用在小车或者航模上。</p><p>实验的代码不变，参数【-90 至 90】代表旋转方向和速度值大小。插上 360°连续旋转舵机。可以看到舵机的旋转速度和方向逐渐变变化。</p><p><img src="/posts/a4696bae.htm/image-20230319181745849.png" alt="image-20230319181745849"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拓展模块&quot;&gt;&lt;a href=&quot;#拓展模块&quot; class=&quot;headerlink&quot; title=&quot;拓展模块&quot;&gt;&lt;/a&gt;&lt;strong&gt;拓展模块&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;电阻触摸屏&quot;&gt;&lt;a href=&quot;#电阻触摸屏&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>机器听觉</title>
    <link href="https://rozen12123.github.io/posts/e06f755d.html"/>
    <id>https://rozen12123.github.io/posts/e06f755d.html</id>
    <published>2023-03-19T05:38:31.000Z</published>
    <updated>2023-03-23T08:50:30.136Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>k210机器视觉</title>
    <link href="https://rozen12123.github.io/posts/210a3ee2.html"/>
    <id>https://rozen12123.github.io/posts/210a3ee2.html</id>
    <published>2023-03-18T14:32:27.000Z</published>
    <updated>2023-03-23T08:50:30.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a><strong>LCD</strong></h3><p>LCD 液晶显示屏是非常常见的一个外接显示设备，跟前面的 OLED 显示屏相比，LCD 会更常用一些，我们看到的手持设备、小型电器，很多都用到 LCD，部分配合触摸屏应用，能实现非常多的功能。</p><p>除此之外，LCD 还是 pyAI-K210 机器视觉应用中显示的重要工具。</p><p>本实验用的 LCD 是 2.8 寸，驱动是常见的 ST7789V，使用 8 位接口跟 pyAIK210 通信，按以往嵌入式 C 语言开发，我们需要对 ST7789 进行编程实现驱动，然后再建立各种字符显示及显示图片等函数。使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点，我们只需要搞清各个对象函数使如何使用即可。总的来说和之前一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉 pyAI-K210 外设是怎么接线，是什么样的；而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！我们管这些函数的集合叫驱动，MaixPy 已经将这 LCD.py 驱动写好了，我们学会如何使用即可。其构造函数和使用方法如下：</p><p>&nbsp;</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.init(<span class="built_in">type</span>=<span class="number">1</span>,freq=<span class="number">15000000</span>,color=lcd.BLACK)</span><br></pre></td></tr></table></figure><p>初始化 LCD。</p><p>【type】LCD 类型；</p><p>【freq】通信频率；</p><p>【color】LCD 初始化的颜色。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.deinit()</span><br></pre></td></tr></table></figure><p>注销 LCD 驱动，释放 IO 引脚。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.clear(color)</span><br></pre></td></tr></table></figure><p>填充指定颜色。默认是黑色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.draw_string(x,y,<span class="built_in">str</span>,color,bg_color)</span><br></pre></td></tr></table></figure><p>写字符</p><p>【x,y】起始坐标；</p><p>【str】字符内容</p><p>【color】字体颜色</p><p>【bg_color】字体背景颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.display(image,roi=Auto)</span><br></pre></td></tr></table></figure><p>显示图片。</p><p>【image】RGB565 或 GRAYSCALE 图片。</p><p>【ROI】显示的感兴趣区域，未指定则为图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.rotation(<span class="built_in">dir</span>)</span><br></pre></td></tr></table></figure><p>LCD 屏幕方向设定。</p><p>【dir】取值范围[0-3]，从 0 到 3 依顺时钟旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.mirror(invert)</span><br></pre></td></tr></table></figure><p>镜面显示。</p><p>【invert】=True 则为镜面显示；=False 则否。</p><p>更多 LCD 模块说明请看 MaxiPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html</a></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们来跑</p><p>一下其主要功能显示字符和图像，代码编写流程如下：</p><p><img src="/posts/210a3ee2.htm/image-20230318214237090.png" alt="image-20230318214237090"></p><p><img src="/posts/210a3ee2.htm/image-20230318220959008.png" alt="image-20230318220959008"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lcd,image,utime</span><br><span class="line">lcd.init() <span class="comment">#初始化 LCD</span></span><br><span class="line">lcd.clear(lcd.WHITE) <span class="comment">#清屏白色</span></span><br><span class="line"><span class="comment">#显示字符</span></span><br><span class="line">lcd.draw_string(<span class="number">110</span>, <span class="number">120</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>,lcd.BLACK, lcd.WHITE) <span class="comment">#显示字符</span></span><br><span class="line">utime.sleep(<span class="number">2</span>) <span class="comment">#延时 2 秒</span></span><br><span class="line">lcd.rotation(<span class="number">1</span>) <span class="comment">#由于图像默认是 240*320，因此顺时钟旋转 90°。</span></span><br><span class="line"><span class="comment">#显示图像，必须先将 01Studio.bmp 文件发送到开发板才能正常运行</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;01Studio.bmp&quot;</span>))</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="摄像头应用"><a href="#摄像头应用" class="headerlink" title="摄像头应用"></a><strong>摄像头应用</strong></h3><p>从前面的基础实验我们熟悉了 K210 基于 MicroPython 的编程方法，但那可以说是只发挥了 K210 冰山一角的性能应用，摄像头是整个机器视觉应用的基础。今天我们就通过示例代码来看看 pyAI-K210 是如何使用摄像头的。</p><p>&nbsp;</p><p>MaixPy 机器视觉库代码大部分都是参考 OpenMV 移植过来，其已经将所有的摄像头功能封装到 sersor 模块中，用户可以通过调用轻松使用。这也是使用MicroPython 编程的魅力所在。</p><p>&nbsp;</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>sensor</p><p>摄像头对象，通过 import 直接调用</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.reset()</span><br></pre></td></tr></table></figure><p>初始化摄像头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_pixformat(*pixformat*)</span><br></pre></td></tr></table></figure><p>设置像素格式。pixformat 有 3 个参数。</p><p>sensor.GRAYSCAL：灰度图像，每像素 8 位（1 字节），处理速度快；</p><p>sensor.RGB565: 每像素为 16 位（2 字节），5 位用于红色，6 位用于绿色，5 位用于蓝色，处理速度比灰度图像要慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_framesize(*framesize*)</span><br></pre></td></tr></table></figure><p>设置每帧大小（即图像尺寸）。常用的 <em>framesize</em> 参数有下面这些：</p><p>sensor.QQVGA: 160*120;</p><p>sensor.QVGA: 320*240;</p><p>sensor.VGA: 640*480;</p><p>sensor.skip_frames([<em>n</em>, <em>time</em>])</p><p>摄像头配置后跳过 n 帧或者等待时间 time 让其变稳定。n:跳过帧数；time：等待</p><p>时间,单位 ms。</p><p>（如果 n 和 time 均没指定，则默认跳过 300 毫秒的帧。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.snapshot()</span><br></pre></td></tr></table></figure><p>使用相机拍摄一张照片，并返回 image 对象。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio</a></p><p>n/sensor.html</p><p>&nbsp;</p><p>我们再来看看本例程用于计算 FPS（每秒帧数）的 clock 模块。</p><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock=time.clock()</span><br></pre></td></tr></table></figure><p>创建一个时钟。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.tick()</span><br></pre></td></tr></table></figure><p>开始追踪运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.fps ()</span><br></pre></td></tr></table></figure><p>停止追踪运行时间，并返回当前 FPS（每秒帧数）。</p><p>在调用该函数前始终首先调用 tick 。</p><p>*其它更多用法请阅读 Maixpy 官方文档：</p><p>文档链接：<a href="http://docs.openmv.io/library/omv.time.html">http://docs.openmv.io/library/omv.time.html</a></p><p>&nbsp;</p><p>&nbsp;</p><p>我们来看看 helloword 代码的编写流程图：</p><p><img src="/posts/210a3ee2.htm/image-20230318215914725.png" alt="image-20230318215914725"></p><p>这个实验运行的就是编辑框里面的 helloworld 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>) <span class="comment">#初始化 LCD</span></span><br><span class="line">sensor.reset() <span class="comment">#复位和初始化摄像头，执行 sensor.run(0)停止。</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式为彩色 RGB565 (或灰色)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧大小为 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 等待设置生效.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 创建一个时钟来追踪 FPS（每秒拍摄帧数）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() <span class="comment"># 更新 FPS 时钟.</span></span><br><span class="line"> img = sensor.snapshot() <span class="comment"># 拍摄一个图片并保存.</span></span><br><span class="line"> lcd.display(img) <span class="comment"># 在 LCD 上显示</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># 注意: 当 K210 连接到 IDE 时候，运行速度减</span></span><br><span class="line"> <span class="comment">#半，因此当断开 IDE 时 FPS 会提升。</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a><strong>画图</strong></h3><p>通过摄像头采集到照片后，我们会进行一些处理，而这时候往往需要一些图形来指示，比如在图片某个位置标记箭头、人脸识别后用矩形框提示等。本节就是学习在图形上画图的使用功能。</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot() 或 img=image.Image(path[, copy_to_fb=<span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>创建图像，通过拍摄或者读取文件路径获取。</p><p><em>copy_to_fb=True**：可以加载大图片；</em></p><p>copy_to_fb=False：不可以加载大图片。</p><p>示例：img = image.Image(“01Studio.bmp”, copy_to_fb=True),表示加载根</p><p>目录下的 01Studio.bmp 图片。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_line(*x0*, *y0*, *x1*, *y1*[, *color*[, *thickness=<span class="number">1</span>*]])</span><br></pre></td></tr></table></figure><p>画线段。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色，如</p><p>（255,0,0）表示红色；thickness：粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_rectangle(*x*, *y*, *w*, *h*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画矩形。（x,y）:起始坐标；w:宽度；h:长度；color：颜色；thickness：边框粗细；fill:是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_circle(*x*, *y*, *radius*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画圆。（x,y）:圆心； radius:半径； color：颜色；thickness:线条粗细；</p><p>fill：是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_arrow(*x0*, *y0*, *x1*, *y1*[, *color*[, size,[thickness*=<span class="number">1</span>]*]])</span><br></pre></td></tr></table></figure><p>画箭头。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色；size:箭头位置大小。thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_cross(*x*, *y*[, *color*[, *size=<span class="number">5</span>*[, *thickness=<span class="number">1</span>*]]])</span><br></pre></td></tr></table></figure><p>画十字交叉。（x,y）:交叉坐标；color:颜色；size:尺寸；thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_string(*x*, *y*, *text*[, *color*[, *scale=*<span class="number">1</span>[,*mono_space=<span class="literal">True</span>*…]]]])</span><br></pre></td></tr></table></figure><p>写字符。(x,y): 起始坐标；text:字符内容；color：颜色；scale：字体大小；</p><p>mono_space:强制间距。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>&nbsp;</p><p>熟悉了 image 对象的画图功能后，我们尝试在摄像头采集到的画面依次画出线段、矩形、圆形、箭头、十字交叉和字符。具体编程思路如下：</p><p><img src="/posts/210a3ee2.htm/image-20230318221247027.png" alt="image-20230318221247027"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>)</span><br><span class="line">sensor.reset() <span class="comment">#复位摄像头</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式 RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧尺寸 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 灯带设置响应.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 新建一个时钟对象计算 FPS.</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() </span><br><span class="line"> img = sensor.snapshot() </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 画线段：从 x0, y0 到 x1, y1 坐标的线段，颜色红色，线宽度 2。</span></span><br><span class="line"> img.draw_line(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>, color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画矩形：绿色不填充。</span></span><br><span class="line"> img.draw_rectangle(<span class="number">150</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line"> thickness = <span class="number">2</span>, fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画圆：蓝色不填充。</span></span><br><span class="line"> img.draw_circle(<span class="number">60</span>, <span class="number">120</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness = <span class="number">2</span>,</span><br><span class="line"> fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画箭头：白色。</span></span><br><span class="line"> img.draw_arrow(<span class="number">150</span>, <span class="number">120</span>, <span class="number">250</span>, <span class="number">120</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size =</span><br><span class="line"> <span class="number">20</span>, thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画十字交叉。</span></span><br><span class="line"> img.draw_cross(<span class="number">60</span>, <span class="number">200</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size = <span class="number">20</span>,</span><br><span class="line"> thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#写字符。</span></span><br><span class="line"> img.draw_string(<span class="number">150</span>, <span class="number">200</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>, color = (<span class="number">255</span>, <span class="number">255</span>,</span><br><span class="line"> <span class="number">255</span>), scale = <span class="number">2</span>,mono_space = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment"># Display on LCD</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># Note: MaixPy&#x27;s Cam runs about half as fast when connected</span></span><br><span class="line"> <span class="comment"># to the IDE. The FPS should increase once disconnected</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a><strong>颜色识别</strong></h3><p>我们活在一个色彩斑斓的世界里。本节我们来学习机器视觉中的颜色识别。我们会预先设定颜色阈值，如红、绿、蓝。这样 K210 摄像头采集图像后就能自动识别了。</p><p>&nbsp;</p><p>通过编程实现 pyAI-K210 识别程序预先设定的颜色色块，分别是红、绿、蓝三种颜色。</p><p>MaixPy 集成了 RGB565 颜色块识别 find_blobs 函数，主要是基于 LAB 颜色模型（每个颜色都是用一组 LAB 阈值表示，有兴趣的用户可以自行查阅相关模型资料）。其位于 image 模块下，因此我们直接将拍摄到的图片进行处理即可，那么我们像以往一样像看一下本实验相关对象和函数说明，具体如下：</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_blobs(thresholds[,invert=<span class="literal">False</span>[,roi[,x_stride=<span class="number">2</span>[,y_stride=<span class="number">1</span>[,area_threshold=<span class="number">10</span>[,pixels_threshold=<span class="number">10</span>[,merge=<span class="literal">False</span>[,margin=<span class="number">0</span>[, threshold_cb=<span class="literal">None</span>[, merge_cb=<span class="literal">None</span>]]]]]]]]]])</span><br></pre></td></tr></table></figure><p>查找图像中指定的色块。返回 image.blog 对象列表；</p><p>【thresholds】 必须是元组列表。 [(lo, hi), (lo, hi), …, (lo, hi)] 定义你想追踪的颜</p><p>色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰</p><p>度值。 仅考虑落在这些阈值之间的像素区域。 对于 RGB565 图像，每个元</p><p>组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是 LAB L，A 和 B</p><p>通道的最小值和最大值。</p><p>【area_threshold】若色块的边界框区域小于此参数值，则会被过滤掉；</p><p>【pixels_threshold】若色块的像素数量小于此参数值，则会被过滤掉；</p><p>【merge】若为 True,则合并所有没有被过滤的色块；</p><p>【margin】调整合并色块的边缘。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.blob。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.rect()</span><br></pre></td></tr></table></figure><p>返回一个矩形元组（x,y,w,h）,如色块边界。可以通过索引[0-3]来获得这些值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cx()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 x 位置。可以通过索引[5]来获得这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cy()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 y 位置。可以通过索引[6]来获得这个值。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>了解了找色块函数应用方法后，我们可以理清一下编程思路，代码编写流程如下：<img src="/posts/210a3ee2.htm/image-20230318222341030.png" alt="image-20230318222341030"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式，所见即所得</span></span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock=time.clock()</span><br><span class="line"><span class="comment"># 颜色识别阈值 (L Min, L Max, A Min, A Max, B Min, B Max) LAB 模型</span></span><br><span class="line"><span class="comment"># 下面的阈值元组是用来识别 红、绿、蓝三种颜色，当然你也可以调整让识别变得更好。</span></span><br><span class="line">thresholds = [(<span class="number">30</span>, <span class="number">100</span>, <span class="number">15</span>, <span class="number">127</span>, <span class="number">15</span>, <span class="number">127</span>), <span class="comment"># 红色阈值</span></span><br><span class="line"> (<span class="number">30</span>, <span class="number">100</span>, -<span class="number">64</span>, -<span class="number">8</span>, -<span class="number">32</span>, <span class="number">32</span>), <span class="comment"># 绿色阈值</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">64</span>, -<span class="number">128</span>, -<span class="number">20</span>)] <span class="comment"># 蓝色阈值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> clock.tick()</span><br><span class="line"> </span><br><span class="line"> img=sensor.snapshot()</span><br><span class="line"> </span><br><span class="line"> blobs = img.find_blobs([thresholds[<span class="number">2</span>]]) <span class="comment"># 0,1,2 分别表示红，绿，蓝色。</span></span><br><span class="line"> <span class="keyword">if</span> blobs:</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> blobs:</span><br><span class="line">   tmp=img.draw_rectangle(b[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">   tmp=img.draw_cross(b[<span class="number">5</span>], b[<span class="number">6</span>])</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment">#LCD 显示图片</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>在 IDE 中运行代码，代码默认检测的是蓝色，用户可以自行修改 find_blobs()参数的阈值数组编号来切换识别颜色</p><p>&nbsp;</p><h3 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a><strong>二维码识别</strong></h3><p>相信大家都知道二维码了，特别是在扫描支付越来越流行的今天，二维码的应用非常广泛。今天我们就来学习如何使用 pyAI-K210 开发套件实现二维码信息识别</p><p>而对于 pyAI-K210 而言，直接使用 MicroPython 中的 find_qrcodes()即可获取摄像头采集图像中二维码的相关信息。具体说明如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_qrcodes([roi])</span><br></pre></td></tr></table></figure><p>查找 roi 区域内的所有二维码并返回一个 image.qrcode 的对象列表。</p><h4 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.qrcode 对象列表。</p><p>qrcode.rect()</p><p>返回一个矩形元组（</p><p>x,y,w,h）;</p><p>qrcode.payload()</p><p>返回二维码字符串信息。可以通过索引[4]来获得这个值。</p><p>qrcode.verison()</p><p>返回二维码版本号。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29</a></p><p>&nbsp;</p><p>从上表可以看到，使用 MicroPython 编程我们只需要简单地调find_qrcodes()函数，对得到的结果再进行处理即可，非常方便。代码编写流程如下图所示:</p><p><img src="/posts/210a3ee2.htm/image-20230318223402217.png" alt="image-20230318223402217"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头模块初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> res = img.find_qrcodes() <span class="comment">#寻找二维码</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span>: <span class="comment">#在图片和终端显示二维码信息</span></span><br><span class="line">  img.draw_rectangle(res[<span class="number">0</span>].rect())</span><br><span class="line">  img.draw_string(<span class="number">2</span>,<span class="number">2</span>, res[<span class="number">0</span>].payload(), color=(<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(res[<span class="number">0</span>].payload())</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> <span class="built_in">print</span>(clock.fps())</span><br></pre></td></tr></table></figure><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><p>pyAI-K210 开发套件，配 SD 卡放模型文件。</p><p>我们来简单介绍一下 K210 的 KPU。KPU 是 K210 内部一个神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，实时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。</p><p>KPU 具备以下几个特点：</p><p>➢ 支持主流训练框架按照特定限制规则训练出来的定点化模型</p><p>➢ 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输</p><p>入输出通道数目、输入输 出行宽列高</p><p>➢ 支持两种卷积内核 1x1 和 3x3</p><p>➢ 支持任意形式的激活函数</p><p>➢ 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB</p><p>➢ 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积）</p><p>简单来说就是 KPU 能加载和运行各种现成的 AI 算法模型，实现各种机器视</p><p>觉等功能。</p><p>MaixPy 中人脸识别本质是目标检测，主要通过在 K210 的 KPU 上跑 YOLO（You Only Look Once）目标检测算法来实现。我们来看一下 KPU 在 MaixPy 下的用法</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><p>&nbsp;</p><p>从上表可以看到通过 KPU 模块直接加载 YOLO2 网络，再结合人脸检测模型</p><p>来实现人脸识别。具体编程思路如下：</p><p><img src="/posts/210a3ee2.htm/image-20230318224139037.png" alt="image-20230318224139037"></p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#设置摄像头</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #设置摄像头后置</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#需要将模型（face.kfpkg）烧写到 flash 的 0x300000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x300000) </span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/facedetect.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#模型描参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="comment">#识别到人脸就画矩形表示</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line">   b = img.draw_rectangle(i.rect())</span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>有了代码后我们还需要将模型放在文件系统中。这里介绍 2 个方法：</p><p><strong>方法一：将模型放在</strong> <strong>SD</strong> <strong>卡中。</strong></p><p>在本节示例程序路径中可以看到有 1 个件夹 <strong>face_model_at_0x300000</strong>将里面的 <strong>facedetect.kmodel</strong> 文件移动到 SD 卡，运行上述代码即可。</p><p><img src="/posts/210a3ee2.htm/image-20230318224320677.png" alt="image-20230318224320677"></p><p><strong>方法二：将模型烧录到</strong> <strong>K210</strong> <strong>的</strong> <strong>Flash</strong> <strong>中。</strong></p><p>打开本节示例程序路径的件夹<strong>face_model_at_0x300000</strong>里面的<strong>flash-list.json</strong>文件，内容如下（告诉烧录软件烧写地址和文件名）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line"> &quot;files&quot;: [</span><br><span class="line"> &#123;</span><br><span class="line"> &quot;address&quot;: 0x00300000,</span><br><span class="line"> &quot;bin&quot;: &quot;facedetect.kmodel&quot;,</span><br><span class="line"> &quot;sha256Prefix&quot;: false</span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来直接将</strong> <strong>kmodel</strong> <strong>和</strong> <strong>json</strong> <strong>这两个文件用</strong> <strong>zip</strong> <strong>方式压缩（不要用文件夹）</strong>，然后将 zip 后缀名改成 kfpkg，得到一个可以用 K210 固件烧录工具烧录的文件。</p><p><img src="/posts/210a3ee2.htm/image-20230318224427813.png" alt="image-20230318224427813"></p><p>再使用 K210 固件烧录工具烧录直接烧录该文件即可，烧录软件会根据上述的 json 文件自动调整烧录地址，无需再次填写。</p><p><img src="/posts/210a3ee2.htm/image-20230318224453811.png" alt="image-20230318224453811"></p><p>当我们去识别图片时候，可以将摄像头设置成后置，sensor 初始化时增加以</p><p>下代码：(LCD 装在 pyAI-K210 核心板背面，横屏测试。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#设置摄像头后置</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a><strong>物体识别</strong></h3><p>在上一节人脸检测章节我们已经介绍过 KPU 的用法，这里不再重复。本实验还是使用到 YOLO2 网络，结合 20class 模型（20 种物体分类模型）来识别图像中的物体。下面重温一下 KPU 的用法</p><h4 id="构造函数-7"><a href="#构造函数-7" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><p><img src="/posts/210a3ee2.htm/image-20230318233151073.png" alt="image-20230318233151073"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,image,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#摄像头后置方式</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#模型分类，按照 20class 顺序</span></span><br><span class="line">classes = [<span class="string">&#x27;aeroplane&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;diningtable&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;motorbike&#x27;</span>, <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;pottedplant&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;sofa&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;tvmonitor&#x27;</span>]</span><br><span class="line"><span class="comment">#下面语句需要将模型（20class.kfpkg）烧写到 flash 的 0x500000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x500000)</span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/20class.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#网络参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络，识别可信概率为 0.7（70%）</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   a=img.draw_rectangle(i.rect())</span><br><span class="line">   a = lcd.display(img)</span><br><span class="line">   lcd.draw_string(i.x(), i.y(),classes[i.classid()],lcd.RED, lcd.WHITE)</span><br><span class="line">   lcd.draw_string(i.x(), i.y()+<span class="number">12</span>,<span class="string">&#x27;%f1.3&#x27;</span>%i.value(),lcd.RED,lcd.WHITE)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  a = lcd.display(img)</span><br><span class="line"><span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="在线训练模型"><a href="#在线训练模型" class="headerlink" title="在线训练模型"></a><strong>在线训练模型</strong></h3><p>当我们想自己学习识别自</p><p>己的东西（比如键盘和鼠标的区分），就可以通过在线训练平台训练自己的模型。</p><p>在线训练上有完整的教程，这里不再重复</p><p>MaixHub 在线训练链接：<a href="https://maixhub.com/">https://maixhub.com/</a></p><p>当然上面也有很多现成别人训练好的模型可以直接使用，在模型库中选择</p><p>nncase 即可以看到适合 K210 使用的模型</p><p>&nbsp;</p><h3 id="图片拍摄"><a href="#图片拍摄" class="headerlink" title="图片拍摄"></a><strong>图片拍摄</strong></h3><p>我们在前面摄像头应用章节已经学习过拍摄是使用 image=sensor.snapshot()函数模块，那么我们只需要学会将图片保存即可。保存也是可以直接使用 image下的 save 模块，具体如下：</p><h4 id="构造函数-8"><a href="#构造函数-8" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot()</span><br></pre></td></tr></table></figure><p>通过拍摄创建图像 img</p><h4 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.save(*path*[, *roi*[, *quality=<span class="number">50</span>*]])</span><br></pre></td></tr></table></figure><p>保存图片。</p><p>path：保存路径；</p><p>roi:指定保存区域(x, y, w, h)，默认全图保存；</p><p>quality:仅针对 JPEG 格式的质量控制，有效值为 0-100。</p><p>&nbsp;</p><p>掌握了拍照和保存功能，我们就可以编程实现了，例程编程代码流程图如下：</p><p><img src="/posts/210a3ee2.htm/image-20230319123658898.png" alt="image-20230319123658898"></p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, image</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#配置 LED 蓝、红引脚</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO1,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.skip_frames(<span class="number">40</span>)</span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line"><span class="comment">#红灯亮提示拍照开始</span></span><br><span class="line">LED_R.value(<span class="number">0</span>)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 给 2 秒时间用户准备.</span></span><br><span class="line">LED_R.value(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#蓝灯亮提示正在拍照</span></span><br><span class="line">LED_B.value(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You&#x27;re on camera!&quot;</span>)</span><br><span class="line"><span class="comment"># 拍摄并保存相关文件，也可以用&quot;example.bmp&quot;或其它文件方式。</span></span><br><span class="line">sensor.snapshot().save(<span class="string">&quot;/sd/example.jpg&quot;</span>)</span><br><span class="line">LED_B.value(<span class="number">1</span>) <span class="comment">#l 蓝灯灭提示拍照完成</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;/sd/example.jpg&quot;</span>)) <span class="comment">#LCD 显示照片</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="视频录制"><a href="#视频录制" class="headerlink" title="视频录制"></a><strong>视频录制</strong></h3><p>pyAI-K210 使用的 MaixPy 集成了 vedio 视频模块，也就是通过 MicroPython编程可以轻松实现录制视频功能，我们来看看 vedio 对象：</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vedio</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h4 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><p>&nbsp;</p><p>学习了 vedio 的相关用法后，我们整理思路，代码编写流程如下：</p><p><img src="/posts/210a3ee2.htm/image-20230319133336848.png" alt="image-20230319133336848"></p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video, sensor, image, lcd, time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置拍摄模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"><span class="comment">#指定录制文件路径和文件名</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/example.avi&quot;</span>, record=<span class="number">1</span>)</span><br><span class="line">i = <span class="number">0</span> <span class="comment">#计算录制帧数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> tim = time.ticks_ms()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> img_len = v.record(img) <span class="comment">#img_len 为返回的录制帧长度。</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;record&quot;</span>,time.ticks_ms() - tim) <span class="comment">#打印录制的每帧间隔</span></span><br><span class="line"> <span class="comment">#录制 100 帧,每帧默认 100ms，即 10 秒视频。</span></span><br><span class="line"> i += <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span> i &gt; <span class="number">100</span>:</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">v.record_finish() <span class="comment">#停止录制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>) <span class="comment">#录制完成提示</span></span><br></pre></td></tr></table></figure><h3 id="人脸识别-1"><a href="#人脸识别-1" class="headerlink" title="人脸识别"></a>人脸识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sensor</span><br><span class="line"><span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> FPIOA, GPIO</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment"># task_fd = kpu.load(0x300000)</span></span><br><span class="line"><span class="comment"># task_ld = kpu.load(0x400000)</span></span><br><span class="line"><span class="comment"># task_fe = kpu.load(0x500000)</span></span><br><span class="line"></span><br><span class="line">task_fd = kpu.load(<span class="string">&quot;/sd/FaceDetection.smodel&quot;</span>)</span><br><span class="line">task_ld = kpu.load(<span class="string">&quot;/sd/FaceLandmarkDetection.smodel&quot;</span>)</span><br><span class="line">task_fe = kpu.load(<span class="string">&quot;/sd/FeatureExtraction.smodel&quot;</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line">fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0)</span><br><span class="line">key_gpio = GPIO(GPIO.GPIOHS0, GPIO.IN)</span><br><span class="line">start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">BOUNCE_PROTECTION = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_key_state</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="keyword">global</span> start_processing</span><br><span class="line">    start_processing = <span class="literal">True</span></span><br><span class="line">    utime.sleep_ms(BOUNCE_PROTECTION)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_gpio.irq(set_key_state, GPIO.IRQ_RISING, GPIO.WAKEUP_NOT_SUPPORT)</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_hmirror(<span class="number">1</span>)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>)</span><br><span class="line">sensor.run(<span class="number">1</span>)</span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>,</span><br><span class="line">          <span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)  <span class="comment"># anchor for face detect</span></span><br><span class="line">dst_point = [(<span class="number">44</span>, <span class="number">59</span>), (<span class="number">84</span>, <span class="number">59</span>), (<span class="number">64</span>, <span class="number">82</span>), (<span class="number">47</span>, <span class="number">105</span>),</span><br><span class="line">             (<span class="number">81</span>, <span class="number">105</span>)]  <span class="comment"># standard face key point position</span></span><br><span class="line">a = kpu.init_yolo2(task_fd, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line">img_lcd = image.Image()</span><br><span class="line">img_face = image.Image(size=(<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">a = img_face.pix_to_ai()</span><br><span class="line">record_ftr = []</span><br><span class="line">record_ftrs = []</span><br><span class="line">names = [<span class="string">&#x27;Mr.1&#x27;</span>, <span class="string">&#x27;Mr.2&#x27;</span>, <span class="string">&#x27;Mr.3&#x27;</span>, <span class="string">&#x27;Mr.4&#x27;</span>, <span class="string">&#x27;Mr.5&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;Mr.6&#x27;</span>, <span class="string">&#x27;Mr.7&#x27;</span>, <span class="string">&#x27;Mr.8&#x27;</span>, <span class="string">&#x27;Mr.9&#x27;</span>, <span class="string">&#x27;Mr.10&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ACCURACY = <span class="number">85</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    clock.tick()</span><br><span class="line">    code = kpu.run_yolo2(task_fd, img)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">            <span class="comment"># Cut face and resize to 128x128</span></span><br><span class="line">            a = img.draw_rectangle(i.rect())</span><br><span class="line">            face_cut = img.cut(i.x(), i.y(), i.w(), i.h())</span><br><span class="line">            face_cut_128 = face_cut.resize(<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">            a = face_cut_128.pix_to_ai()</span><br><span class="line">            <span class="comment"># a = img.draw_image(face_cut_128, (0,0))</span></span><br><span class="line">            <span class="comment"># Landmark for face 5 points</span></span><br><span class="line">            fmap = kpu.forward(task_ld, face_cut_128)</span><br><span class="line">            plist = fmap[:]</span><br><span class="line">            le = (i.x() + <span class="built_in">int</span>(plist[<span class="number">0</span>] * i.w() - <span class="number">10</span>), i.y() + <span class="built_in">int</span>(plist[<span class="number">1</span>] * i.h()))</span><br><span class="line">            re = (i.x() + <span class="built_in">int</span>(plist[<span class="number">2</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">3</span>] * i.h()))</span><br><span class="line">            nose = (i.x() + <span class="built_in">int</span>(plist[<span class="number">4</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">5</span>] * i.h()))</span><br><span class="line">            lm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">6</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">7</span>] * i.h()))</span><br><span class="line">            rm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">8</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">9</span>] * i.h()))</span><br><span class="line">            a = img.draw_circle(le[<span class="number">0</span>], le[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(re[<span class="number">0</span>], re[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(nose[<span class="number">0</span>], nose[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(lm[<span class="number">0</span>], lm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(rm[<span class="number">0</span>], rm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            <span class="comment"># align face to standard position</span></span><br><span class="line">            src_point = [le, re, nose, lm, rm]</span><br><span class="line">            T = image.get_affine_transform(src_point, dst_point)</span><br><span class="line">            a = image.warp_affine_ai(img, img_face, T)</span><br><span class="line">            a = img_face.ai_to_pix()</span><br><span class="line">            <span class="comment"># a = img.draw_image(img_face, (128,0))</span></span><br><span class="line">            <span class="keyword">del</span> (face_cut_128)</span><br><span class="line">            <span class="comment"># calculate face feature vector</span></span><br><span class="line">            fmap = kpu.forward(task_fe, img_face)</span><br><span class="line">            feature = kpu.face_encode(fmap[:])</span><br><span class="line">            reg_flag = <span class="literal">False</span></span><br><span class="line">            scores = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(record_ftrs)):</span><br><span class="line">                score = kpu.face_compare(record_ftrs[j], feature)</span><br><span class="line">                scores.append(score)</span><br><span class="line">            max_score = <span class="number">0</span></span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):</span><br><span class="line">                <span class="keyword">if</span> max_score &lt; scores[k]:</span><br><span class="line">                    max_score = scores[k]</span><br><span class="line">                    index = k</span><br><span class="line">            <span class="keyword">if</span> max_score &gt; ACCURACY:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;%s :%2.1f&quot;</span> % (</span><br><span class="line">                    names[index], max_score)), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;X :%2.1f&quot;</span> % (</span><br><span class="line">                    max_score)), color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> start_processing:</span><br><span class="line">                record_ftr = feature</span><br><span class="line">                record_ftrs.append(record_ftr)</span><br><span class="line">                start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    fps = clock.fps()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2.1f fps&quot;</span> % fps)</span><br><span class="line">    a = lcd.display(img)</span><br><span class="line">    gc.collect()</span><br><span class="line">    <span class="comment"># kpu.memtest()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fe)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_ld)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fd)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机器视觉&quot;&gt;&lt;a href=&quot;#机器视觉&quot; class=&quot;headerlink&quot; title=&quot;机器视觉&quot;&gt;&lt;/a&gt;机器视觉&lt;/h2&gt;&lt;h3 id=&quot;LCD&quot;&gt;&lt;a href=&quot;#LCD&quot; class=&quot;headerlink&quot; title=&quot;LCD&quot;&gt;&lt;/a&gt;&lt;s</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210基础实验</title>
    <link href="https://rozen12123.github.io/posts/abdf738c.html"/>
    <id>https://rozen12123.github.io/posts/abdf738c.html</id>
    <published>2023-03-17T07:16:09.000Z</published>
    <updated>2023-04-10T17:39:55.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>其连接到 pyAI-K210 的外部 IO 引脚如下（可以看开发板原理图），LED 蓝灯对应的外部 IO 为 IO12，从电路可以看到当 IO12 为低电平时，蓝灯被点亮。</p><p><img src="/posts/abdf738c.htm/image-20230317151920787.png" alt="image-20230317151920787"></p><p>K210 为外部 IO 和内部 IO，其片上外设（比如 GPIO、I2C 等）对应的引脚是可以任意设置的，而传统大部分 MCU 片上外设和引脚对应关系已经固定了， 只有部分引脚可以复用， 相比之下 K210 自由度更大。</p><p>因此我们在编程使用 GPIO 的时候需要注册一下硬件 IO 和 K210 内部 IO 的对应关系。注册方式使用 fpioa_manager：简称 fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO</p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>更多有关引脚和功能注册信息请看官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html</a></p><p>注册成功后我们就可以通过 GPIO 对象模块来控制外部 IO，从而控制 LED。</p><p>GPIO 对象说明如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GPIO 对象。</span><br><span class="line"></span><br><span class="line">【ID】内部 GPIO 编号;</span><br><span class="line"></span><br><span class="line">【MODE】GPIO 模式；</span><br><span class="line"></span><br><span class="line">GPIO.IN ：输入模式</span><br><span class="line"></span><br><span class="line">GPIO.OUT ：输出模式</span><br><span class="line"></span><br><span class="line">【PULL】</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_UP ：上拉</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">GPIO.PULL_</span>DOWN ：下拉</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_NONE ：无</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">【value】GPIO 初始化电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1：高电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">0：低电平</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>方式 1 是：import Maix，然后通过 Maix.GPIO 来操作；</p><p>方式 2 是：from Maix import GPIO，意思是直接从 Maix 中引入 GPIO 模块，然后直接通过 GPIO 来操作。显然方式 2 会显得更直观和方便，本实验也是使用</p><p>方式 2 来编程。代码编写流程如下：</p><p><img src="/posts/abdf738c.htm/image-20230317160716756.png" alt="image-20230317160716756"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">实验名称：点亮 LED_B 蓝灯</span></span><br><span class="line"><span class="string">实验目的：学习 led 点亮。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#将蓝灯引脚 IO12 配置到 GPIO0，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br></pre></td></tr></table></figure><p>关于python中from和import</p><p><a href="https://www.cnblogs.com/keenajiao/p/15336312.html">Python的from和import用法 - keena_jiao - 博客园 (cnblogs.com)</a></p><h3 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utime()</span><br><span class="line"><span class="comment">#时间模块</span></span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">utime.sleep(seconds)</span><br><span class="line">秒级颜色。seconds:延时秒数</span><br><span class="line">utime.sleep_ms(ms)</span><br><span class="line">毫秒级延时。ms：延时毫秒数。</span><br><span class="line">utime.sleep_us(us)</span><br><span class="line">微秒级延时。us：延时微秒数。</span><br></pre></td></tr></table></figure><p>*更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html</a></p><p>知道了延时函数的使用方法后，我们可以简单的梳理一下流程，首先导入LED 和 utime 模块，程序开始先让 RGB LED 灭掉，开启循环，依次点亮每个 LED，延时 1 秒，关闭 LED。流程如下：</p><p><img src="/posts/abdf738c.htm/image-20230317164443689.png" alt="image-20230317164443689"></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#蓝灯亮 1 秒</span></span><br><span class="line"> LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_B.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#绿灯亮 1 秒</span></span><br><span class="line"> LED_G.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line">    utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_G.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> <span class="comment">#红灯亮 1 秒</span></span><br><span class="line"> LED_R.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line">LED_R.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><p>上述代码没错是完整地按照编程思路来编写，但可以见到有很多格式相似的地方，这显得代码非常冗余。我们可以通过 for 函数来编写程序，由于是对 3 个LED 的操作，因此我们可以用 for i in range(0,3): 语句来修改，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line"><span class="comment">#构建 LED 对象，并初始化输出高电平，关闭 LED</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#定义数组方便循环语句调用</span></span><br><span class="line">LED=[LED_B, LED_G, LED_R]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">  LED[i].value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED[i].value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h3><p><img src="/posts/abdf738c.htm/image-20230317172918745.png" alt="image-20230317172918745"></p><p>从原理图可以看到，按键 KEY 的一端连接到 K210 的外部 IO16，另一端连接到 GND。所以按键在没按下时候输入高电平（1），按下时候输入低电平（0）。和 LED 一样，按键的输入检测也是用到 GPIO 对象模块，具体如下：</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><p>GPIO 对象。</p><p>【ID】内部 GPIO 编号;</p><p>【MODE】GPIO 模式；</p><p>GPIO.IN ：输入模式</p><p>GPIO.OUT ：输出模式</p><p>【PULL】</p><p>GPIO.PULL_UP ：上拉</p><p>GPIO.PULL_DOWN ：下拉</p><p>GPIO.PULL_NONE ：无</p><p>【value】GPIO 初始化电平</p><p>1：高电平</p><p>0：低电平</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>*输入模式时候参数为空，表示获取当前 IO 输入电平值。</p><p>GPIO 对象使用非常简单，我们将按键即外部“IO16”引脚配置成输入，实现当检测到按键被按下时候点亮 LED 蓝灯，松开时关闭 LED 蓝灯来做指示。代码编写流程如下：</p><p><img src="/posts/abdf738c.htm/image-20230317173251976.png" alt="image-20230317173251976"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#注册 IO，蓝灯--&gt;IO12,KEY--&gt;IO16</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1)</span><br><span class="line"><span class="comment">#初始化 IO</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line">KEY = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下接地</span></span><br><span class="line">  LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED_B,蓝灯</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  LED_B.value(<span class="number">1</span>) <span class="comment">#熄灭 LED</span></span><br></pre></td></tr></table></figure><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h3><p>前面我们在做普通的按键（GPIO）时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断的在实际项目的应用非常普遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION)</span><br></pre></td></tr></table></figure><p>配置中断。</p><p>【CALLBACK_FUNC】中断执行的回调函数；</p><p>【TRIGGER_CONDITION】中断触发方式；</p><p>GPIO.IRQ_RISING：上升沿触发</p><p>GPIO.IRQ_FALLING：下降沿沿触发</p><p>GPIO.IRQ_BOTH：都触发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.disirq()</span><br></pre></td></tr></table></figure><p>关闭中断。</p><p>我们先来了解一下上升沿和下降沿的概念，由于按键 KEY 引脚是通过按键接到 GND，也就是我们所说的低电平“0”，所以当按键被按下再松开时，引脚先获得下降沿，再获得上升沿，如下图所示：</p><p><img src="/posts/abdf738c.htm/image-20230317174406258.png" alt="image-20230317174406258"></p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p><img src="/posts/abdf738c.htm/image-20230317174514133.png" alt="image-20230317174514133"></p><p>我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产</p><p>生中断。</p><p>需要注意的是 K210 只有高速 GPIO 才有外部中断，GPIO 常量表如下：</p><div class="table-container"><table><thead><tr><th><strong>K210 - GPIO</strong></th></tr></thead><tbody><tr><td>普通 GPIO</td></tr><tr><td>GPIO0 - GPIO7</td></tr><tr><td>高速 GPIO</td></tr><tr><td>GPIOHS0 – GPIOHS31</td></tr></tbody></table></div><p>编程思路中断跟 GPIO 按键章节类似，在初始化中断后，当系统检测到外部</p><p>中断时候，执行 LED 状态反转的代码即可。流程图如下：</p><p><img src="/posts/abdf738c.htm/image-20230317174715882.png" alt="image-20230317174715882"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO，注意高速 GPIO 口才有中断</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0)</span><br><span class="line"><span class="comment">#构建 lED 和 KEY 对象</span></span><br><span class="line"></span><br><span class="line">LED_B=GPIO(GPIO.GPIO0,GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LED 状态表示</span></span><br><span class="line">state = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#中断回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"> <span class="keyword">global</span> state</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line"> state = <span class="keyword">not</span> state</span><br><span class="line"> LED_B.value(state)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.Timer(<span class="built_in">id</span>,channel,mode=Timer.MODE_ONE_SHOT,period=<span class="number">1000</span>,unit=Timer.UNIT_MS, callback=<span class="literal">None</span>, arg=<span class="literal">None</span>, start=<span class="literal">True</span>,</span><br><span class="line">priority=<span class="number">1</span>, div=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>定时器对象 Timer 对象在 machine 模块下。</p><p>【id】定时器编号, [Timer.TIMER0~TIMER2] 定时器 0-2;</p><p>【channel】Timer 通道，[Timer.CHANNEL0~Timer.CHANNEL3]</p><p>【mode】定时器模式</p><p>MODE_ONE_SHOT: 一次性</p><p>MODE_PERIODIC: 周期性</p><p>MODE_PWM</p><p>【period】定时器为周期性模块时每个周期时间值</p><p>【unit】周期的单位</p><p>Timer.UNIT_S：秒</p><p>Timer.UNIT_MS：毫秒</p><p>Timer.UNIT_US：微妙</p><p>Timer.UNIT_NS：纳秒</p><p>【callback】定时器中断执行的回调函数；<strong>注意：回调函数是在中断中调用</strong></p><p><strong>的，所以在回调函数中请不要占用太长时间以及做动态内存分配开关中断等</strong></p><p><strong>动作。</strong></p><p>【arg】回调函数第 2 个参数</p><p>【start】是否在构建对象后立即开始定时器，</p><p>=True: 立即开始；</p><p>=False: 不立即开始，需要调用 start()来开启。</p><p>【priority】硬件中断优先级，在 K210 中，取值范围是[1,7],值越小优先级越高</p><p>【div】硬件分频器。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>Timer.callback(fun)</th></tr></thead><tbody><tr><td>定义回调函数。</td></tr><tr><td>Timer.period([value])</td></tr><tr><td>配置周期。</td></tr><tr><td>Timer.start()</td></tr><tr><td>启动定时器。</td></tr><tr><td>Timer.stop()</td></tr><tr><td>停止定时器。</td></tr><tr><td>Timer.deinit()</td></tr><tr><td>注销定时器。</td></tr><tr><td>*更多用法请阅读 MaixPy 官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html</a></td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类</p><p>似，代码编程流程图如下：</p><p><img src="/posts/abdf738c.htm/image-20230317231336487.png" alt="image-20230317231336487"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO 和构建 LED 对象</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数变量</span></span><br><span class="line">Counter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定时器回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"> <span class="keyword">global</span> Counter</span><br><span class="line"> Counter = Counter + <span class="number">1</span></span><br><span class="line"> <span class="built_in">print</span>(Counter)</span><br><span class="line"> LED_B.value(Counter%<span class="number">2</span>)<span class="comment">#LED 循环亮灭。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#定时器 0 初始化，周期 1 秒</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, </span><br><span class="line">period=<span class="number">1000</span>, callback=fun)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a><strong>PWM</strong></h3><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需</p><p>要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyAI-K210 的 PWM 输出频率是在变化的。</p><p>pyBase 开发底板上的无源蜂鸣器连接到引脚 X5。如下图所示：</p><p><img src="/posts/abdf738c.htm/image-20230317233012578.png" alt="image-20230317233012578"></p><p>而 pyAI-K210 并没有引脚直接连接到 pyBase 的 X5（主要避免影响 IO 复用。）而 IO15 连接到 pyBase 开发底板的 X6 引脚，因此我们可以用跳线帽或者跳线来连接 pyBase 的 X5 和 X6 引脚。相当于将无源蜂鸣器接到 pyAI-K210 的外部 IO15引脚。</p><p><img src="/posts/abdf738c.htm/image-20230317233431274.png" alt="image-20230317233431274"></p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.PWM(tim, freq, duty, pin, enable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>PWM 对象在 machine 模块下。</p><p>【tim】K210 的 PWM 依赖于定时器来产生波形</p><p>【freq】PWM 频率</p><p>【duty】PWM 占空比</p><p>【pin】PWM 输出引脚</p><p>【enable】是否在构建对象后立即产生波形，默认 True。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>PWM.freq(freq)</th></tr></thead><tbody><tr><td>设置频率。不传参数返回当前频率值。</td></tr><tr><td>PWM.duty(duty)</td></tr><tr><td>设置占空比。不传参数返回当前占空比值。[0-100]表示占空比百分比<strong>107</strong></td></tr><tr><td>PWM.enable()</td></tr><tr><td>使能 PWM 输出。</td></tr><tr><td>PWM.disable()</td></tr><tr><td>暂停 PWM 输出。</td></tr><tr><td>PWM.deinit()</td></tr><tr><td>注销 PWM。</td></tr></tbody></table></div><p><img src="/posts/abdf738c.htm/image-20230317233619775.png" alt="image-20230317233619775"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO15 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">beep = PWM(tim, freq=<span class="number">1</span>, duty=<span class="number">50</span>, pin=<span class="number">15</span>)</span><br><span class="line"><span class="comment">#循环发出不同频率响声。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> beep.freq(<span class="number">200</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">400</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">600</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">800</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">1000</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有条件的朋友可以使用示波器测量 pyAI-K210 的 IO15 引脚或 pyBase 的 X5 引脚，观察信号波形的变化：</p><p>&nbsp;</p><h3 id="I2C-总线（OLED显示屏）"><a href="#I2C-总线（OLED显示屏）" class="headerlink" title="I2C 总线（OLED显示屏）"></a><strong>I2C</strong> <strong>总线（OLED显示屏）</strong></h3><p>我们先来看看开发板的原理图，也就是MicroPython 上的 OLED 接口是如何连线的。下图是 pyBase 开发底板的原理图。</p><p><img src="/posts/abdf738c.htm/image-20230317234836169.png" alt="image-20230317234836169"></p><p>我们再来看看 pyAI-K210 转接板的原理图接口部分。</p><p><img src="/posts/abdf738c.htm/image-20230317235033250.png" alt="image-20230317235033250"></p><p>结合以上可以得知 pyBase 底板连接到 OLED 的对应关系是 Y6→SCL 和Y8→SDA。对应 pyAI-K210 的关系是：IO27→Y6→SCL，IO28→Y8→SDA。本例程将使用 MicroPython 的 Machine 模块的 I2C 来定义 Pin 口和 I2C 初始化。具体如下：</p><p>&nbsp;</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.I2C(<span class="built_in">id</span>, mode=I2C.MODE_MASTER, scl=<span class="literal">None</span>, sda=<span class="literal">None</span>,</span><br><span class="line">freq=<span class="number">400000</span>, timeout=<span class="number">1000</span>, addr=<span class="number">0</span>, addr_size=<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>构建 I2C 对象。</p><p>【id】I2C ID,[ I2C.I2C0~I2C.I2C2 ]</p><p>【scl】时钟引脚；直接传引脚编号；</p><p>【sda】数据引脚; 直接传引脚编号；</p><p>【freq】通信频率，即速度；</p><p>【timeout】参数保留，设置无效；</p><p>【addr】从机地址；</p><p>【addr_size】地址长度， 支持 7 位寻址和 10 位寻址， 取值 7 或者 10。</p><div class="table-container"><table><thead><tr><th><strong>使用方法</strong></th></tr></thead><tbody><tr><td>i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,len)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；len:读取字节数；</td></tr><tr><td>i2c.writeto(addr,buf)</td></tr><tr><td>写数据。addr:从机地址；buf:数据内容；</td></tr><tr><td>i2c.deinit()</td></tr><tr><td>注销 I2C。</td></tr><tr><td>*其它更多用法请阅读官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h</a></td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306k.py 文件里面。开发者只需要将改 py 文件拷贝到 pyAI-K210 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306k.py 文件代码。OLED 显示屏对象介绍如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oled = SSD1306_I2C(i2c, addr)</span><br></pre></td></tr></table></figure><p>构 OLED 显示屏对象。默认分辨率 128*64；</p><p>【i2c】定义好的 I2C 对象;</p><p>【addr】显示屏设备地址。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><p>oled.fill([value])</p><p>清屏</p><p>value=0x00 (黑屏)；value=0xFF(白屏)</p><p>oled.text(string,x,y)</p><p>将 string 字符写在指定为位置。</p><p>【string】：字符；</p><p>【x】横坐标；[0-127]；</p><p>【y】纵坐标。[0-7] 共 8 行</p><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><p><img src="/posts/abdf738c.htm/image-20230318000154918.png" alt="image-20230318000154918"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> ssd1306k <span class="keyword">import</span> SSD1306</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 I2C 接口和 OLED 对象</span></span><br><span class="line">i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER,scl=<span class="number">27</span>, sda=<span class="number">28</span>)</span><br><span class="line">oled = SSD1306(i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"><span class="comment">#清屏,0x00(白屏)，0xff(黑屏)</span></span><br><span class="line">oled.fill(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#显示字符。参数格式为（str,x,y）,其中 x 范围是 0-127，y 范围是 0-7（共 8 行）</span></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">#写入第 0 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">#写入第 2 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">#写入第 5 行内容</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART（串口通信）</strong></h3><p>  串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>&nbsp;</p><p>K210 一共有 3 个串口，每个串口可以自由映射引脚。 例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IO6→RX1，IO7→TX1</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len)</span><br></pre></td></tr></table></figure><p>创建 UART 对象。</p><p>【uart】串口编号。[UART.UART1~UART3]</p><p>【baudrate】波特率，常用 115200、9600</p><p>【bits】数据位,默认 8</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>【timeout】串口接收超时时间</p><p>【read_buf_len】串口接收缓冲大小。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>UART.read(num)</p><p>读取串口缓冲数据</p><p>【num】读取字节数</p><p>UART.readline(num)</p><p>读取串口缓冲数据的行</p><p>【num】行数</p><p>UART.write(buf)</p><p>串口发送数据</p><p>【buf】需要发送的数据</p><p>UART.deinit()</p><p>注销串口</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。<img src="/posts/abdf738c.htm/image-20230318211732179.png" alt="image-20230318211732179"></p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用 pyBase 的外</p><p>接串口引脚，也就是 Y9（TX）和 Y10（RX），接线示意图如下：</p><p><img src="/posts/abdf738c.htm/image-20230318211750029.png" alt="image-20230318211750029"></p><p>从 pyAI-K210 原理图可以看到外部 IO6→Y9→RX ，IO7→Y10→TX。</p><p><img src="/posts/abdf738c.htm/image-20230318211813224.png" alt="image-20230318211813224"></p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><p><img src="/posts/abdf738c.htm/image-20230318211835639.png" alt="image-20230318211835639"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>这时候打开电脑的设备管理器，能看到 2 个 COM。写着 CH340 的是串口工具，另外一个则是 pyAI-K210 的 REPL。如果 CH340 驱动没安装，则需要手动安装，驱动在：配套资料包→开发工具→windows→串口终端→CH340 文件夹下。</p><p><img src="/posts/abdf738c.htm/image-20230318212444828.png" alt="image-20230318212444828"></p><p>本实验要用到串口助手，打开配套资料包→开发工具→windows→串口终端工具下的【UartAssist.exe】软件。</p><p><img src="/posts/abdf738c.htm/image-20230318212503108.png" alt="image-20230318212503108"></p><p>将串口工具配置成 COM14（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到 pyAI-K210 上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到pyAI-K210 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p><img src="/posts/abdf738c.htm/image-20230318212528352.png" alt="image-20230318212528352"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a><strong>thread（线程）</strong></h3><p>我们看到前面的编程都是一个循环来完成，但当我们需要分时完成不同任务时候，线程编程就派上用场了。这有点像 RTOS(实时操作系统)，今天我们就来学习一下如何通过 MicroPython 编程实现多线程。</p><p>&nbsp;</p><p>pyAI-K210 的 MicroPython 固件已经集成了_thread 线程模块。我们直接调用即可。该模块衍生于 python3，属于低级线程，详情可以看官网介绍：<a href="https://docs.python.org/3.5/library/_thread.html#module-thread">https://docs.python.org/3.5/library/_thread.html#module-thread</a></p><p>编程流程如下：</p><p><img src="/posts/abdf738c.htm/image-20230318212724180.png" alt="image-20230318212724180"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread <span class="comment">#导入线程模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#线程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name)) </span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> _thread.start_new_thread(func,(<span class="string">&quot;1&quot;</span>,)) <span class="comment">#开启线程 1，参数必须是元组</span></span><br><span class="line">_thread.start_new_thread(func,(<span class="string">&quot;2&quot;</span>,)) <span class="comment">#开启线程 2，参数必须是元组</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;点亮第一个-LED&quot;&gt;&lt;a href=&quot;#点亮第一个-LED&quot; class=&quot;headerlink&quot; title=&quot;点亮第一个 LED&quot;&gt;&lt;/a&gt;&lt;strong&gt;点亮第一个&lt;/strong&gt; &lt;strong&gt;LED&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;其连接到 pyA</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210</title>
    <link href="https://rozen12123.github.io/posts/a08a9fe.html"/>
    <id>https://rozen12123.github.io/posts/a08a9fe.html</id>
    <published>2023-03-17T06:40:18.000Z</published>
    <updated>2023-03-23T08:50:30.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k210开发环境"><a href="#k210开发环境" class="headerlink" title="k210开发环境"></a>k210开发环境</h1><h3 id="python的一些基本语法"><a href="#python的一些基本语法" class="headerlink" title="python的一些基本语法"></a>python的一些基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用.format 来格式化字符串</span></span><br><span class="line"><span class="comment"># 可以重复参数以节省时间</span></span><br><span class="line"><span class="string">&quot;&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line"><span class="string">&quot;candle stick&quot;</span>)</span><br><span class="line"><span class="comment"># =&gt; &quot;Jack be nimble, Jack be quick, Jack jump over the candle stick&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想数参数，可以用关键字</span></span><br><span class="line"><span class="string">&quot;&#123;name&#125; wants to eat &#123;food&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Bob&quot;</span>, food=<span class="string">&quot;lasagna&quot;</span>) </span><br><span class="line"><span class="comment"># =&gt; &quot;Bob wants to eat lasagna&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># None，0，空字符串，空列表，空字典都算是 False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="安装开发软件-MaixPy-IDE"><a href="#安装开发软件-MaixPy-IDE" class="headerlink" title="安装开发软件 MaixPy IDE"></a><strong>安装开发软件</strong> <strong>MaixPy IDE</strong></h3><p>当前版本为 v0.2.5，官网下载地址：（如有更新请下载最新版）</p><p><a href="http://cn.dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5，下载界面如下图。">http://cn.dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5，下载界面如下图。</a></p><p><img src="/posts/a08a9fe.htm/image-20230317150914712.png" alt="image-20230317150914712"></p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>驱动路径选择：零一科技（01Studio）MicroPython 开发套件配套资料\01-开</p><p>发工具\01-Windows\串口终端工具\CH9102x 驱动，点击确认后即可自动安装：</p><h3 id="例程测试"><a href="#例程测试" class="headerlink" title="例程测试"></a><strong>例程测试</strong></h3><p>我们用最简单的 LED 程序来测试，在 MaixPy IDE 中打开 零一科技（01Studio）</p><p>MicroPython 开发套件配套资料_latest\02-示例程序\5.pyAI-K210\1.基础实验\1.点</p><p>亮第一个 LED 里面的 LED.py 例程</p><p><img src="/posts/a08a9fe.htm/image-20230317151039585.png" alt="image-20230317151039585"></p><p>在连接状态下点击工具—将打开的脚本保存到开发板的 boot.py，这里的意</p><p>思是将当前编辑框的代码拷贝到开发板文件系统中的 boot.py，由于 boot.py 是</p><p>Maixpy 上电运行的第一个脚本文件，因此相当于实现了上电运行写入的程序。</p><p><img src="/posts/a08a9fe.htm/image-20230317151058425.png" alt="image-20230317151058425"></p><h3 id="REPL-串口调试"><a href="#REPL-串口调试" class="headerlink" title="REPL 串口调试"></a><strong>REPL</strong> <strong>串口调试</strong></h3><p>MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试 pyboard 或 micropython 开发套件。我们使用的软件是一款免费的串口终端软件 putty。</p><p>打开 MicroPython 开发套件配套资料\开发工具\串口终端工具\Putty.exe，选择左下角 Serial，配置信息如下：</p><p><img src="/posts/a08a9fe.htm/image-20230317151158055.png" alt="image-20230317151158055"></p><p>配置好后不是点 open，而是点左边上方 Session，选择 Serial 后可看到刚刚的配置信息。串口号通常不会变化，我们在 Save Session 下方输入 COM4 或者自己喜欢的名称，点右边 Save，在空白框里面就出现 COM4 字样，以后可以直接使用。设置好后我们点击 Open。</p><p><img src="/posts/a08a9fe.htm/image-20230317151215314.png" alt="image-20230317151215314"></p><p>现在对话框相当于连接上了开发板上，由于 pyAI-K210 集成了 MicroPython</p><p>解析器。我们在这里可以进行调试和简单编程，接下来我们测试一下。在对话框</p><p>输入下面代码，按回车，可以看到代码运行情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(“Hello 01Studio!”)</span><br></pre></td></tr></table></figure><p><img src="/posts/a08a9fe.htm/image-20230317151307943.png" alt="image-20230317151307943"></p><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>MaixPy 官方提供了免安装的烧录工具，通过板载 USB 转串口烧录的。我们</p><p>打开 MicroPython 开发套件配套资料\开发工具\Windows\固件更新工具\</p><p>kflash_gui 目录下的 kflash_gui.exe 烧录软件。</p><p><img src="/posts/a08a9fe.htm/image-20230317151346090.png" alt="image-20230317151346090"></p><p><img src="/posts/a08a9fe.htm/image-20230317151350781.png" alt="image-20230317151350781"></p><p>选择配套资料包路径 零一科技（01Studio）MicroPython 开发套件配套资料</p><p>\03-相关固件\05-pyAI-K210 下的固件：</p><p><img src="/posts/a08a9fe.htm/image-20230317151409005.png" alt="image-20230317151409005"></p><p>烧录地址默认为 0x00000 即可。选择开发板和串口 COM，开发板可以选择</p><p>跟 pyAI-K210 串口方案一样的 Maix Dock ，而串口则选择自己开发板对应的串口。</p><p><img src="/posts/a08a9fe.htm/image-20230317151426467.png" alt="image-20230317151426467"></p><p>点击 Download 下载。<strong>（如出现一直等待情况说明无法自动下载，这时候按</strong></p><p><strong>一下开发板的</strong> <strong>RST</strong> <strong>复位键即可。）</strong></p><p>或者直接连按两下ret键</p><p>MaixPy 针对不同的应用场景提供不同大小的固件，而且不断更新，详见固件</p><p>下载链接（不同固件区别见里面的 readme.txt）：</p><p><a href="https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master">https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k210开发环境&quot;&gt;&lt;a href=&quot;#k210开发环境&quot; class=&quot;headerlink&quot; title=&quot;k210开发环境&quot;&gt;&lt;/a&gt;k210开发环境&lt;/h1&gt;&lt;h3 id=&quot;python的一些基本语法&quot;&gt;&lt;a href=&quot;#python的一些基本语法&quot; c</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>esp8266闪存文件系统</title>
    <link href="https://rozen12123.github.io/posts/58716004.html"/>
    <id>https://rozen12123.github.io/posts/58716004.html</id>
    <published>2023-01-29T08:32:54.000Z</published>
    <updated>2023-02-01T08:33:26.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESP8266闪存文件系统"><a href="#ESP8266闪存文件系统" class="headerlink" title="ESP8266闪存文件系统"></a>ESP8266闪存文件系统</h2><p>如果网页比较大，那么只用程序去储存明显是不太可能的，我们可以用esp8266闪存文件系统储存网页。</p><p>通常的闪存文件系统大小为4Mb</p><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th></th></tr></thead><tbody><tr><td>闪存文件系统</td><td>4Mb</td><td></td></tr><tr><td>程序储存</td><td>1Mb</td><td></td></tr><tr><td>用户可以文件储存（会包含一些系统文件）</td><td>3Mb</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="ESP8266闪存文件系统基本操作"><a href="#ESP8266闪存文件系统基本操作" class="headerlink" title="ESP8266闪存文件系统基本操作"></a>ESP8266闪存文件系统基本操作</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-operation/">ESP8266闪存文件系统基本操作 </a></p><h3 id="1-通过程序向闪存文件系统写入信息"><a href="#1-通过程序向闪存文件系统写入信息" class="headerlink" title="1.通过程序向闪存文件系统写入信息"></a>1.通过程序向闪存文件系统写入信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-write</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的SPIFFS中建立名为</span></span><br><span class="line"><span class="comment">                            notes.txt的文件，程序还将向该文件写入信息。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;w&quot;); </span></span><br><span class="line"><span class="comment">以上函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;w&quot; 代表写入文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format start&quot;</span>);</span><br><span class="line">  SPIFFS.format();    <span class="comment">// 格式化SPIFFS</span></span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format finish&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动SPIFFS</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello IOT World.&quot;</span>);       <span class="comment">// 向dataFile写入字符串信息</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2-通过程序从闪存文件系统读取信息"><a href="#2-通过程序从闪存文件系统读取信息" class="headerlink" title="2.通过程序从闪存文件系统读取信息"></a>2.通过程序从闪存文件系统读取信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-read</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中存储的文件notes.txt读取数据。</span></span><br><span class="line"><span class="comment">                           notes.txt 文件内容将会通过串口监视器显示出来供用户确认。</span></span><br><span class="line"><span class="comment">                           注意在使用本程序以前需要先将notes.txt 文件上传到NodeMCU开发板的SPIFFS中</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;r&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;r&quot; 代表读取文件信息。（如需了解如何写入信息，请参阅示例程序esp8266-flash-write）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//建立File对象用于从SPIFFS中读取文件</span></span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;r&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//读取文件内容并且通过串口监视器输出文件信息</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;dataFile.size(); i++)&#123;</span><br><span class="line">    Serial.print((<span class="type">char</span>)dataFile.read());       </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//完成文件读取后关闭文件</span></span><br><span class="line">  dataFile.close();                           </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="3-通过程序向闪存文件系统文件添加信息"><a href="#3-通过程序向闪存文件系统文件添加信息" class="headerlink" title="3.通过程序向闪存文件系统文件添加信息"></a>3.通过程序向闪存文件系统文件添加信息</h3><p>要注意写入操作和添加操作的区别。假设闪存系统中已经有这样一文件，写入操作会对原文件进行覆盖，而添加操作会将文件最后加入新的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-append</span></span><br><span class="line"><span class="comment">=</span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的内置SPIFFS中存储的文件</span></span><br><span class="line"><span class="comment">                            notes.txt添加数据。                      </span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------  </span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;a&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;a&quot; 代表添加文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">此示例程序所演示的是向SPIFFS中的文件里添加信息。这一操作写入信息有所区别。</span></span><br><span class="line"><span class="comment">添加信息是不会删除文件内原有信息，而是在原有信息后面添加新的信息。</span></span><br><span class="line"><span class="comment">但写入操作（示例 esp8266-flash-write.ino）是将文件内容完全清除，重新写入新信息。    </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    File dataFile = SPIFFS.open(file_name, <span class="string">&quot;a&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息</span></span><br><span class="line">    dataFile.println(<span class="string">&quot;This is Appended Info.&quot;</span>); <span class="comment">// 向dataFile添加字符串信息</span></span><br><span class="line">    dataFile.close();                           <span class="comment">// 完成文件操作后关闭文件   </span></span><br><span class="line">    Serial.println(<span class="string">&quot;Finished Appending data to SPIFFS&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="4-通过程序读取目录内容"><a href="#4-通过程序读取目录内容" class="headerlink" title="4.通过程序读取目录内容"></a>4.通过程序读取目录内容</h3><p>读取某个文件夹中程序的内容。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-folder-read</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中文件夹里读取文件信息</span></span><br><span class="line"><span class="comment">                           文件夹内容将会通过串口监视器显示出来。</span></span><br><span class="line"><span class="comment">                           </span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.openDir(folder_name);</span></span><br><span class="line"><span class="comment">以上函数打开指定目录并返回一个目录对象实例。</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/myFile.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line">String folder_name = <span class="string">&quot;/taichi-maker&quot;</span>;         <span class="comment">//被读取的文件夹</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即myFile.txt）写入信息</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello Taichi-Maker.&quot;</span>);    <span class="comment">// 向dataFile写入字符串信息</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件</span></span><br><span class="line">  Serial.println(F(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 显示目录中文件内容以及文件大小</span></span><br><span class="line">  Dir dir = SPIFFS.openDir(folder_name);  <span class="comment">// 建立“目录”对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (dir.next()) &#123;  <span class="comment">// dir.next()用于检查目录中是否还有“下一个文件”</span></span><br><span class="line">    Serial.println(dir.fileName()); <span class="comment">// 输出文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="5-从闪存文件系统中删除文件"><a href="#5-从闪存文件系统中删除文件" class="headerlink" title="5.从闪存文件系统中删除文件"></a>5.从闪存文件系统中删除文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-remove</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">日期/Date（YYYYMMDD）      : 20191109</span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何删除SPIFFS中存储的文件                        </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从闪存中删除file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.remove(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove sucess&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove fail&quot;</span>);</span><br><span class="line">  &#125;                       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="6-显示闪存文件系统信息"><a href="#6-显示闪存文件系统信息" class="headerlink" title="6.显示闪存文件系统信息"></a>6.显示闪存文件系统信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-info</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何使用FSInfo对象来显示闪存文件系统状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">FSInfo fs_info;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line"> </span><br><span class="line">  SPIFFS.begin();       <span class="comment">//启动SPIFFS</span></span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 闪存文件系统信息</span></span><br><span class="line">  SPIFFS.info(fs_info);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 可用空间总和（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;totalBytes: &quot;</span>);     </span><br><span class="line">  Serial.print(fs_info.totalBytes); </span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 已用空间（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;usedBytes: &quot;</span>); </span><br><span class="line">  Serial.print(fs_info.usedBytes);</span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最大文件名字符限制（含路径和&#x27;\0&#x27;）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxPathLength: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxPathLength);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最多允许打开文件数量</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxOpenFiles: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxOpenFiles);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 存储块大小</span></span><br><span class="line">  Serial.print(<span class="string">&quot;blockSize: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.blockSize);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  Serial.print(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">  Serial.println(fs_info.pageSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="ESP8266闪存文件应用"><a href="#ESP8266闪存文件应用" class="headerlink" title="ESP8266闪存文件应用"></a>ESP8266闪存文件应用</h2><p>向esp8266上传任意的文件类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ESP8266闪存文件系统&quot;&gt;&lt;a href=&quot;#ESP8266闪存文件系统&quot; class=&quot;headerlink&quot; title=&quot;ESP8266闪存文件系统&quot;&gt;&lt;/a&gt;ESP8266闪存文件系统&lt;/h2&gt;&lt;p&gt;如果网页比较大，那么只用程序去储存明显是不太可能的，</summary>
      
    
    
    
    
    <category term="esp8266" scheme="https://rozen12123.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>esp8266网络服务器</title>
    <link href="https://rozen12123.github.io/posts/56387d0f.html"/>
    <id>https://rozen12123.github.io/posts/56387d0f.html</id>
    <published>2023-01-29T08:31:47.000Z</published>
    <updated>2023-02-01T08:33:26.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESP8266-NodeMCU网服务器"><a href="#ESP8266-NodeMCU网服务器" class="headerlink" title="ESP8266-NodeMCU网服务器"></a>ESP8266-NodeMCU网服务器</h2><h3 id="建立基本网络服务器"><a href="#建立基本网络服务器" class="headerlink" title="建立基本网络服务器"></a>建立基本网络服务器</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/web-server/">建立基本网络服务器</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页（Hello from ESP8266）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立ESP8266WebServer对象，对象名称为esp8266_server</span></span><br><span class="line">                                    <span class="comment">// 括号中的数字是网路服务器响应http请求的端口号</span></span><br><span class="line">                                    <span class="comment">// 网络服务器标准http端口号为80，因此这里使用80为端口号</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1</span></span><br><span class="line">  esp8266_server.begin();                   <span class="comment">//  详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">//  第3章-第2节 ESP8266-NodeMCU网络服务器-1</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分结束--------</span></span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数语句为本示例程序重点3</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下两个函数为本示例程序重点2</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>                                                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站根目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello from ESP8266&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这段示例程序上传给NodeMCU以后，启动NodeMCU并且确保它已经成功连接WiFi。接下来请打开浏览器，并且在地址栏中输入NodeMCU的IP地址并按下回车。假如将在浏览器中看到“Hello from ESP8266”，那么恭喜你已经成功的让NodeMCU实现了网络服务功能，因为你所看到的这条文字信息正是来自于NodeMCU。换句话说，NodeMCU为你建立了一个超级迷你的小网站。这个网站只有一个网页。这个网页只有一行文字“Hello from ESP8266”。</p><p>&nbsp;</p><h3 id="通过网络服务实现NodeMCU开发板基本控制"><a href="#通过网络服务实现NodeMCU开发板基本控制" class="headerlink" title="通过网络服务实现NodeMCU开发板基本控制"></a>通过网络服务实现NodeMCU开发板基本控制</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/pin-control/">通过网络服务实现NodeMCU开发板基本控制 </a></p><p>在网页中控制nodemcu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_2_Turning_on_and_off_an_LED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页并通过该页面点亮/熄灭NodeMCU的内置LED</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是 &#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT); <span class="comment">//设置内置LED引脚为输出模式以便控制LED</span></span><br><span class="line">  </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 通过串口监视器输出连接的WiFi名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// 通过串口监视器输出ESP8266-NodeMCU的IP</span></span><br><span class="line"> </span><br><span class="line">  esp8266_server.begin();                           <span class="comment">// 启动网站服务</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, HTTP_GET, handleRoot);     <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/LED&quot;</span>, HTTP_POST, handleLED);  <span class="comment">// 设置处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        <span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();                     <span class="comment">// 检查http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line"><span class="comment">  该函数的作用是每当有客户端访问NodeMCU服务器根目录时，</span></span><br><span class="line"><span class="comment">  NodeMCU都会向访问设备发送 HTTP 状态 200 (Ok) 这是send函数的第一个参数。</span></span><br><span class="line"><span class="comment">  同时NodeMCU还会向浏览器发送HTML代码，以下示例中send函数中第三个参数，</span></span><br><span class="line"><span class="comment">  也就是双引号中的内容就是NodeMCU发送的HTML代码。该代码可在网页中产生LED控制按钮。 </span></span><br><span class="line"><span class="comment">  当用户按下按钮时，浏览器将会向NodeMCU的/LED页面发送HTTP请求，请求方式为POST。</span></span><br><span class="line"><span class="comment">  NodeMCU接收到此请求后将会执行handleLED函数内容*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;       </span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&lt;form action=\&quot;/LED\&quot; method=\&quot;POST\&quot;&gt;&lt;input type=\&quot;submit\&quot; value=\&quot;Toggle LED\&quot;&gt;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleLED</span><span class="params">()</span> &#123;                          </span><br><span class="line">  digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN));<span class="comment">// 改变LED的点亮或者熄灭状态</span></span><br><span class="line">  esp8266_server.sendHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/&quot;</span>);          <span class="comment">// 跳转回页面根目录</span></span><br><span class="line">  esp8266_server.send(<span class="number">303</span>);                           <span class="comment">// 发送Http相应代码303 跳转  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>); <span class="comment">// 发送 HTTP 状态 404 (未找到页面) 并向浏览器发送文字 &quot;404: Not found&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过网络服务实现NodeMCU开发板基本控制-1"><a href="#通过网络服务实现NodeMCU开发板基本控制-1" class="headerlink" title="通过网络服务实现NodeMCU开发板基本控制"></a>通过网络服务实现NodeMCU开发板基本控制</h3><p>我们可以通过NodeMCU开发板上的FLASH按键控制D3引脚的电平。当我们没有按下该按键时，D3引脚将会保持高电平状态。当按下该按键后，D3引脚会变为低电平。</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_3_Pin_State_Display</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该页面将会自动刷新并且显示NodeMCU</span></span><br><span class="line"><span class="comment">                           的D3引脚状态。NodeMCU开发板上的FLASH按键可以控制D3引脚的电平。</span></span><br><span class="line"><span class="comment">                           没有按下该按键时D3引脚将会保持高电平状态。当按下该按键后，</span></span><br><span class="line"><span class="comment">                           D3引脚会变为低电平。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WiFi<span class="variable">.h</span>&gt;        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WiFiMulti<span class="variable">.h</span>&gt;   <span class="comment">//  ESP8266WiFiMulti库</span></span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WebServer<span class="variable">.h</span>&gt;   <span class="comment">//  ESP8266WebServer库</span></span><br><span class="line"> </span><br><span class="line">#define buttonPin D3            <span class="comment">// 按钮引脚D3</span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer esp8266_server(<span class="number">80</span>);<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line">bool pinState;  <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> setup()&#123;</span><br><span class="line">  Serial<span class="variable">.begin</span>(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial<span class="variable">.println</span>(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti<span class="variable">.run</span>() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial<span class="variable">.print</span>(i++); Serial<span class="variable">.print</span>(&#x27; &#x27;);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial<span class="variable">.println</span>(&#x27;\n&#x27;);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial<span class="variable">.print</span>(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial<span class="variable">.println</span>(WiFi<span class="variable">.SSID</span>());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial<span class="variable">.print</span>(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial<span class="variable">.println</span>(WiFi<span class="variable">.localIP</span>());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server<span class="variable">.begin</span>();                   <span class="comment">// 启动网站服务                </span></span><br><span class="line">  esp8266_server<span class="variable">.on</span>(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server<span class="variable">.onNotFound</span>(handleNotFound);<span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;        </span></span><br><span class="line"> </span><br><span class="line">  Serial<span class="variable">.println</span>(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> loop()&#123;</span><br><span class="line">  esp8266_server<span class="variable">.handleClient</span>();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">*/</span>                                                                       </span><br><span class="line"><span class="keyword">void</span> handleRoot() &#123;   </span><br><span class="line">  String displayPinState;                   <span class="comment">// 存储按键状态的字符串变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pinState == HIGH)&#123;                     <span class="comment">// 当按键引脚D3为高电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: HIGH&quot;</span>; <span class="comment">// 字符串赋值高电平信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                  <span class="comment">// 当按键引脚D3为低电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: LOW&quot;</span>;  <span class="comment">// 字符串赋值低电平信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  esp8266_server<span class="variable">.send</span>(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, displayPinState); </span><br><span class="line">                                            <span class="comment">// 向浏览器发送按键状态信息  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="keyword">void</span> handleNotFound()&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server<span class="variable">.send</span>(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然。也可以不用一种刷新网页，让其自动刷新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_4_Pin_State_Display_Auto_Refresh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该网页将显示引脚D3状态。同时状态会</span></span><br><span class="line"><span class="comment">                           每隔5秒钟更新一次。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buttonPin D3            <span class="comment">// 按钮引脚D3</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> pinState;                      <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU在启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">                                                               <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多</span></span><br><span class="line">                                                               <span class="comment">// 的WiFi信息在此处。</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                  </span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);      </span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;                                                                   </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, sendHTML(pinState));  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建立用于发送给客户端浏览器的HTML代码。此代码将会每隔5秒刷新页面。</span></span><br><span class="line"><span class="comment">通过页面刷新，引脚的最新状态也会显示于页面中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">sendHTML</span><span class="params">(<span class="type">bool</span> buttonState)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  String htmlCode = <span class="string">&quot;&lt;!DOCTYPE html&gt; &lt;html&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;head&gt;&lt;meta http-equiv=&#x27;refresh&#x27; content=&#x27;5&#x27;/&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;title&gt;ESP8266 Butoon State&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;style&gt;html &#123; font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;body&#123;margin-top: 50px;&#125; h1 &#123;color: #444444;margin: 50px auto 30px;&#125; h3 &#123;color: #444444;margin-bottom: 50px;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/style&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;h1&gt;ESP8266 BUTTON STATE&lt;/h1&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(buttonState)</span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: HIGH&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: LOW&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> htmlCode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ESP8266-NodeMCU网服务器&quot;&gt;&lt;a href=&quot;#ESP8266-NodeMCU网服务器&quot; class=&quot;headerlink&quot; title=&quot;ESP8266-NodeMCU网服务器&quot;&gt;&lt;/a&gt;ESP8266-NodeMCU网服务器&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
    <category term="esp8266" scheme="https://rozen12123.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>esp8266</title>
    <link href="https://rozen12123.github.io/posts/6450c6c0.html"/>
    <id>https://rozen12123.github.io/posts/6450c6c0.html</id>
    <published>2023-01-20T14:25:26.000Z</published>
    <updated>2023-03-13T15:22:16.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp8266-NodeMCU"><a href="#esp8266-NodeMCU" class="headerlink" title="esp8266-NodeMCU"></a>esp8266-NodeMCU</h1><p>esp8266的数字引脚电压是3.3v，即其引脚输出高电平就是3.3v。</p><p>设置数字引脚为读取模式，其所连接的电压不能超过3.3v。</p><p>模拟引脚可以读取电压范围0-1v。</p><p><img src="/posts/6450c6c0.htm/image-20230120224956449.png" alt="image-20230120224956449"></p><h2 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h2><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>以下内容的具体解释也可以在<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/">第2章 互联网知识基础 – 太极创客 (taichi-maker.com)</a>中找到更好的解释。</p><div class="table-container"><table><thead><tr><th>分层名称</th><th>TCP/IP 包含以下协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP，FTP，mDNS，WebSocket，OSC…..</td></tr><tr><td>传输层</td><td>TCP,UDP</td></tr><tr><td>网络层</td><td>IP</td></tr><tr><td>链路层（网络接口层）</td><td>Ethernet,Wi-Fi…</td></tr></tbody></table></div><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层的主要作用是实现设备之间的物理链接。</p><p>链路层的主要作用是实现设备之间的物理链接。举例来说，我们日常使用的WiFi就是链路层协议中的一种。</p><h4 id="ESP8266利用WiFi联网时有三种工作模式。"><a href="#ESP8266利用WiFi联网时有三种工作模式。" class="headerlink" title="ESP8266利用WiFi联网时有三种工作模式。"></a>ESP8266利用WiFi联网时有三种工作模式。</h4><ul><li>接入点模式（esp8266自己当wifi）</li><li>无线终端模式（esp8266自己跟wifi进行连接，控制其他跟wifi连接后的设备）</li><li>混合模式</li></ul><p>&nbsp;</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP地址</li></ul><p>给设备提供地址功能</p><h4 id="IP协议版本"><a href="#IP协议版本" class="headerlink" title="IP协议版本"></a>IP协议版本</h4><p>查看电脑ip</p><p>命令提示符&gt;&gt;&gt;ipconfig</p><p>&nbsp;</p><p>网关相当于连接网络与网络之间的端口</p><p>wifi路由器会创建一个局域网，并给局域网内的每个设备分配一个ip地址，相对于互联网</p><p>&nbsp;</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>特点：稳</p><ul><li><p>保证所有数据都能被接收端接收</p></li><li><p>数据的传输顺序不会打乱</p></li><li><p>传输数据如有损坏则重发受损数据</p></li></ul><p>&nbsp;</p><p>TCP协议经常用于对数据稳定性要求比较高的领域</p><h4 id="TCP协议应用领域："><a href="#TCP协议应用领域：" class="headerlink" title="TCP协议应用领域："></a>TCP协议应用领域：</h4><ul><li>电子邮件</li><li>文件传输</li></ul><p>&nbsp;</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>特点：快</p><ul><li>UDP比TCP速度快</li><li>不保证所有数据都能被接收端接收数数据一旦受损的，UDP协议将抛弃受损数据。</li><li>有数据损坏不会重发受损数据</li></ul><p>&nbsp;</p><h4 id="UDP协议应用领域："><a href="#UDP协议应用领域：" class="headerlink" title="UDP协议应用领域："></a>UDP协议应用领域：</h4><ul><li>在线语音/视频</li><li>网游</li></ul><p>&nbsp;</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>由==请求==和==响应==进行工作的</p><h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET/HTTP/1.1    //请求行</span><br><span class="line">Host:www.taichi-maker.com   //请求头</span><br><span class="line">User-Agent:Mozilla/5.0（Windows NT 10.0WOW64）Accept：：text/html   </span><br><span class="line">Accept-Language:zh-CN,zh；q=0.8</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure><h6 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h6><p><img src="/posts/6450c6c0.htm/image-20230127222443771.png" alt="image-20230127222443771"></p><h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>HTTP1.0定义了三种请求方法：GET,POST和HEAD方法。 、</p><h5 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h5><p><img src="/posts/6450c6c0.htm/image-20230127223432974.png" alt="image-20230127223432974"></p><p><img src="/posts/6450c6c0.htm/image-20230127223728305.png" alt="image-20230127223728305"></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="ESP8266物联网开发基础"><a href="#ESP8266物联网开发基础" class="headerlink" title="ESP8266物联网开发基础"></a>ESP8266物联网开发基础</h2><p>安装esp8266的网址<a href="https://cn.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads">USB 至 UART 桥 VCP 驱动器 - 芯科科技 (silabs.com)</a></p><p>&nbsp;</p><h3 id="为开发板搭建开发环境"><a href="#为开发板搭建开发环境" class="headerlink" title="为开发板搭建开发环境"></a>为开发板搭建开发环境</h3><p>要想使用Arduino IDE来配合NodeMCU开发板使用，首先要对Arduino IDE进行设置工作。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/nodemcu-arduino-ide/">3-1-2 为ESP8266-NodeMCU搭建Arduino IDE开发环境 – 太极创客 (taichi-maker.com)</a></p><p>如果开发板库中没有，可以去网盘盘里进行手动安装。</p><p>&nbsp;</p><p>如果一切都正常安装，那么我们可以用如下一段代码测试，测试结果应为esp8266一个板载LED间断闪烁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// initialize digital pin LED_BUILTIN as an output.</span></span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the loop function runs over and over again forever</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED_BUILTIN, HIGH);  <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">  delay(<span class="number">1000</span>);                      <span class="comment">// wait for a second</span></span><br><span class="line">  digitalWrite(LED_BUILTIN, LOW);   <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">  delay(<span class="number">1000</span>);                      <span class="comment">// wait for a second</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NodeMCU开发板的接入点模式"><a href="#NodeMCU开发板的接入点模式" class="headerlink" title="NodeMCU开发板的接入点模式"></a>NodeMCU开发板的接入点模式</h3><p>NodeMCU开发板可以建立WiFi网络供其它设备连接。当NodeMCU以此模式运行时，我们可以使用手机或者电脑搜索NodeMCU所发出的WiFi网络并进行连接。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/ap/">3-1-3 NodeMCU开发板的接入点模式 – 太极创客 (taichi-maker.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU接入点模式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序用于演示如何将NodeMCU以接入点模式工作。通过此程序，您可以使用</span></span><br><span class="line"><span class="comment">电脑或者手机连接NodeMCU所建立WiFi网络。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">网络名: taichi-maker</span></span><br><span class="line"><span class="comment">密码：12345678</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ssid = <span class="string">&quot;taichi-maker&quot;</span>; <span class="comment">// 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span></span><br><span class="line">                                   <span class="comment">// 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *password = <span class="string">&quot;12345678&quot;</span>;  <span class="comment">// 这里定义将要建立的WiFi密码。此处以12345678为示例</span></span><br><span class="line">                                    <span class="comment">// 您可以将自己想要使用的WiFi密码放入引号内</span></span><br><span class="line">                                    <span class="comment">// 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     <span class="comment">// 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span><br><span class="line">                                   <span class="comment">// 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span><br><span class="line">                                   <span class="comment">// 这两个参数具体内容在setup函数之前的位置进行定义。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.print(<span class="string">&quot;Access Point: &quot;</span>);    <span class="comment">// 通过串口监视器输出信息</span></span><br><span class="line">  Serial.println(ssid);              <span class="comment">// 告知用户NodeMCU所建立的WiFi名</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address: &quot;</span>);      <span class="comment">// 以及NodeMCU的IP地址</span></span><br><span class="line">  Serial.println(WiFi.softAPIP());   <span class="comment">// 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如上代码，我们可以创建一个wifi</p><p>连接过后在命令提示符中输入&gt;&gt;ping 192.168.4.1</p><p>ping就是用来测试我们的电脑是不是已经与某个网络设备成功连接了</p><p>&nbsp;</p><h3 id="NodeMCU开发板的无线终端模式"><a href="#NodeMCU开发板的无线终端模式" class="headerlink" title="NodeMCU开发板的无线终端模式"></a>NodeMCU开发板的无线终端模式</h3><p>NodeMCU通过WiFi连接无线路由器并访问互联网。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/station/">3-1-4 NodeMCU开发板的无线终端模式 – 太极创客 (taichi-maker.com)</a></p><p>以下示例程序用于演示如何使用NodeMCU以无线终端模式通过WiFi连接无线路由器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本示例程序用于演示如何使用NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid     = <span class="string">&quot;taichi-maker&quot;</span>;      <span class="comment">// 连接WiFi名（此处使用taichi-maker为示例）</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi名填入引号中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;12345678&quot;</span>;          <span class="comment">// 连接WiFi密码（此处使用12345678为示例）</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi密码填入引号中</span></span><br><span class="line">                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);         <span class="comment">// 启动串口通讯</span></span><br><span class="line">  </span><br><span class="line">  WiFi.begin(ssid, password);                  <span class="comment">// 启动网络连接</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);              <span class="comment">// 串口监视器输出网络连接信息</span></span><br><span class="line">  Serial.print(ssid); Serial.println(<span class="string">&quot; ...&quot;</span>);  <span class="comment">// 告知用户NodeMCU正在尝试WiFi连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                   <span class="comment">// 这一段程序语句用于检查WiFi是否连接成功</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;      <span class="comment">// WiFi.status()函数的返回值是由NodeMCU的WiFi连接状态所决定的。 </span></span><br><span class="line">    delay(<span class="number">1000</span>);                               <span class="comment">// 如果WiFi连接成功则返回值为WL_CONNECTED                       </span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);      <span class="comment">// 此处通过While循环让NodeMCU每隔一秒钟检查一次WiFi.status()函数返回值</span></span><br><span class="line">  &#125;                                            <span class="comment">// 同时NodeMCU将通过串口监视器输出连接时长读秒。</span></span><br><span class="line">                                               <span class="comment">// 这个读秒是通过变量i每隔一秒自加1来实现的。</span></span><br><span class="line">                                               </span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);                          <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connection established!&quot;</span>);   <span class="comment">// NodeMCU将通过串口监视器输出&quot;连接成功&quot;信息。</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:    &quot;</span>);             <span class="comment">// 同时还将输出NodeMCU的IP地址。这一功能是通过调用</span></span><br><span class="line">  Serial.println(WiFi.localIP());              <span class="comment">// WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以一次性添加很多wifi名称和密码，使nodemuc选择性添加最强信号的网络。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi-2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序将会控制NodeMCU在当前的网络环境里搜索预先存储好的WiFi。</span></span><br><span class="line"><span class="comment">一旦找到预存的WiFi名称，NodeMCU将会使用预存的密码信息尝试连接该WiFi。</span></span><br><span class="line"><span class="comment">如果同时找到多个预存WiFi，NodeMCU将会尝试连接信号最强的WiFi。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>          <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">// 本程序使用ESP8266WiFiMulti库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);            <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line">                                                </span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);         <span class="comment">// 通过串口监视器输出信息告知用户NodeMCU正在尝试连接WiFi</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(<span class="string">&#x27;.&#x27;</span>);                       <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                           <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                              <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp8266-NodeMCU&quot;&gt;&lt;a href=&quot;#esp8266-NodeMCU&quot; class=&quot;headerlink&quot; title=&quot;esp8266-NodeMCU&quot;&gt;&lt;/a&gt;esp8266-NodeMCU&lt;/h1&gt;&lt;p&gt;esp8266的数字引脚电压是3.3</summary>
      
    
    
    
    
    <category term="esp8266" scheme="https://rozen12123.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>inventor开发</title>
    <link href="https://rozen12123.github.io/posts/undefined.html"/>
    <id>https://rozen12123.github.io/posts/undefined.html</id>
    <published>2023-01-16T07:33:59.000Z</published>
    <updated>2023-01-16T07:49:04.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="app-inventor开发蓝牙app"><a href="#app-inventor开发蓝牙app" class="headerlink" title="app inventor开发蓝牙app"></a>app inventor开发蓝牙app</h1><h2 id="蓝牙app开发流程"><a href="#蓝牙app开发流程" class="headerlink" title="蓝牙app开发流程"></a>蓝牙app开发流程</h2><ol><li>App inventor开发APP</li><li>AT指令配置蓝牙模块</li><li>测试</li></ol><p>&nbsp;</p><p>App inventor网址：<a href="http://app.gzjkw.net/">http://app.gzjkw.net/</a></p><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="蓝牙的选择和断开"><a href="#蓝牙的选择和断开" class="headerlink" title="蓝牙的选择和断开"></a>蓝牙的选择和断开</h4><p>表格布局————列表选择框———-可以选择连接哪个蓝牙</p><p>&nbsp;</p><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>列表选择框</p><p><img src="/posts/undefined.htm/image-20230116154719576.png" alt="image-20230116154719576"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;app-inventor开发蓝牙app&quot;&gt;&lt;a href=&quot;#app-inventor开发蓝牙app&quot; class=&quot;headerlink&quot; title=&quot;app inventor开发蓝牙app&quot;&gt;&lt;/a&gt;app inventor开发蓝牙app&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="app开发" scheme="https://rozen12123.github.io/tags/app%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hc06</title>
    <link href="https://rozen12123.github.io/posts/85bbd6e3.html"/>
    <id>https://rozen12123.github.io/posts/85bbd6e3.html</id>
    <published>2023-01-15T05:24:12.000Z</published>
    <updated>2023-02-07T08:14:26.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HC-06-无线蓝牙串口透传模块"><a href="#HC-06-无线蓝牙串口透传模块" class="headerlink" title="HC-06 无线蓝牙串口透传模块"></a>HC-06 无线蓝牙串口透传模块</h1><p><img src="/posts/85bbd6e3.htm/image-20230115132713635.png" alt="image-20230115132713635"></p><p>arduino和hc06的高电平时不一样的</p><p>&nbsp;</p><h2 id="串口透传"><a href="#串口透传" class="headerlink" title="串口透传"></a>串口透传</h2><p>在数据传输过程中，数据不发生任何形式的改变，仿佛传输过程是透明的一样。数据原封不动地从发送者传到接收者。</p><h3 id="使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭"><a href="#使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭" class="headerlink" title="使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭"></a>使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">char</span> serialData;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(<span class="number">11</span>, OUTPUT); <span class="comment">//11引脚连接演示用LED</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( Serial.available()&gt;<span class="number">0</span> )&#123; </span><br><span class="line">    </span><br><span class="line">    serialData =  Serial.read();   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serialData == <span class="string">&#x27;1&#x27;</span> ) &#123;  <span class="comment">//接收到点亮LED指令</span></span><br><span class="line">      Serial.print(<span class="string">&quot;Got command: &quot;</span>);  Serial.println(serialData); </span><br><span class="line">      Serial.println(<span class="string">&quot;LED-ON&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      digitalWrite(<span class="number">11</span>, HIGH);  <span class="comment">//点亮LED指令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//接收到熄灭LED指令</span></span><br><span class="line">      Serial.print(<span class="string">&quot;Got command: &quot;</span>);  </span><br><span class="line">      Serial.println(serialData); </span><br><span class="line">      Serial.println(<span class="string">&quot;LED-OFF&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      digitalWrite(<span class="number">11</span>, LOW);      <span class="comment">//熄灭LED指令  </span></span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗"><a href="#使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗" class="headerlink" title="使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗"></a>使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HC-06-Serial-LED-Fade</span></span><br><span class="line"><span class="comment">by 太极创客（2017-07-08）</span></span><br><span class="line"><span class="comment">www.taici-maker.com</span></span><br><span class="line"><span class="comment">此程序旨在演示如何利用HC-06蓝牙模块通过手机或平板电脑的</span></span><br><span class="line"><span class="comment">蓝牙功能来设置arduino开发板上11引脚上连接LED的亮度。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需获得更多关于本程序的使用说明，请参见太极创客制作的《零基础入门学用Arduino》教程。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">---- 电路连接 ---- </span></span><br><span class="line"><span class="comment">HC-06     Arduino Uno R3 引脚</span></span><br><span class="line"><span class="comment">TX                0 (RX)  </span></span><br><span class="line"><span class="comment">RX                1 (TX)</span></span><br><span class="line"><span class="comment">VCC              +5v</span></span><br><span class="line"><span class="comment">GND              GND</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">LED       Arduino Uno R3 引脚</span></span><br><span class="line"><span class="comment"> +                11 (RX) </span></span><br><span class="line"><span class="comment"> -                GND (通过220欧姆限流电阻)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1. 须使用分压电路，确保HC-06 RX信号电压为3.3伏特。</span></span><br><span class="line"><span class="comment">2. 须先将此程序上传至ARDUINO后，再将HC-06连接在ARDUINO开发板的串口引脚上。</span></span><br><span class="line"><span class="comment">   否则程序将无法正常上传。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> brightness;  <span class="comment">//LED亮度变量</span></span><br><span class="line"><span class="type">int</span> serialData;  <span class="comment">//串口数据变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">  pinMode(<span class="number">11</span>, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( Serial.available()&gt;<span class="number">0</span> )&#123;             <span class="comment">//如果串口缓存有数据</span></span><br><span class="line">    serialData =  Serial.parseInt();      <span class="comment">//将串口缓存数值存储到serialData变量</span></span><br><span class="line">    Serial.print(<span class="string">&quot;serialData = &quot;</span>); Serial.println(serialData);  </span><br><span class="line">    <span class="keyword">if</span> (serialData &gt;=<span class="number">0</span> &amp;&amp; serialData &lt;= <span class="number">255</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (serialData &gt;= brightness)&#123;       <span class="comment">//逐渐调节LED亮度</span></span><br><span class="line">        <span class="keyword">for</span> (brightness; brightness &lt;= serialData; brightness++)&#123;</span><br><span class="line">          analogWrite(<span class="number">11</span>, brightness); </span><br><span class="line">          Serial.print(<span class="string">&quot;brightness = &quot;</span>); Serial.println(brightness);  </span><br><span class="line">          delay(<span class="number">5</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (brightness; brightness &gt;= serialData; brightness--)&#123;</span><br><span class="line">          analogWrite(<span class="number">11</span>, brightness); </span><br><span class="line">          Serial.print(<span class="string">&quot;brightness = &quot;</span>); Serial.println(brightness);          </span><br><span class="line">          delay(<span class="number">5</span>);          </span><br><span class="line">        &#125;        </span><br><span class="line">      &#125;       </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/85bbd6e3.htm/image-20230115155153934.png" alt="image-20230115155153934"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HC-06-无线蓝牙串口透传模块&quot;&gt;&lt;a href=&quot;#HC-06-无线蓝牙串口透传模块&quot; class=&quot;headerlink&quot; title=&quot;HC-06 无线蓝牙串口透传模块&quot;&gt;&lt;/a&gt;HC-06 无线蓝牙串口透传模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/pos</summary>
      
    
    
    
    
    <category term="单片机" scheme="https://rozen12123.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>电机</title>
    <link href="https://rozen12123.github.io/posts/ef868677.html"/>
    <id>https://rozen12123.github.io/posts/ef868677.html</id>
    <published>2023-01-13T09:22:37.000Z</published>
    <updated>2023-01-21T10:09:39.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电机"><a href="#电机" class="headerlink" title="电机"></a>电机</h1><ul><li><p>普通直流电机</p></li><li><p>步进电机</p></li><li><p>伺服电机（舵机）</p></li></ul><p>  电机又称为电动机、马达，是一种通过电磁感应定律将电能转化成机械能，并可再使用机械能产生动能，用来驱动其他装置的电气设备。</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>直流电机（DC）</li><li>交流电机（AC）</li><li>交直流两用电机（Universal）</li></ul><p>直流电机根据有无电刷可分为</p><ul><li><p>有刷直流电机（BDC）</p><p>电刷和换向器之间会不断进行摩擦</p></li><li><p>无刷直流电机（BLDC）</p></li></ul><p>​        转子的永磁场和定子的电磁场互动进行工作</p><h2 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h2><h3 id="有刷直流电机（BDC）主要参数"><a href="#有刷直流电机（BDC）主要参数" class="headerlink" title="有刷直流电机（BDC）主要参数"></a>有刷直流电机（BDC）主要参数</h3><h4 id="额定电流"><a href="#额定电流" class="headerlink" title="额定电流"></a>额定电流</h4><p>即电机在额定环境条件下可以长期连续工作的电流。</p><h4 id="空载转速"><a href="#空载转速" class="headerlink" title="空载转速"></a>空载转速</h4><p>电机不带任何负载的转速。</p><h4 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h4><p>重量、工作温度等。</p><p>&nbsp;</p><p>对于电机的控制，我们主要考虑电机的==旋转方向==和==旋转速度==</p><h5 id="旋转方向"><a href="#旋转方向" class="headerlink" title="旋转方向"></a>旋转方向</h5><p>H桥电路可以用来控制电机的旋转方向</p><p><img src="/posts/ef868677.htm/image-20230113175504061.png" alt="image-20230113175504061"></p><h5 id="旋转速度"><a href="#旋转速度" class="headerlink" title="旋转速度"></a>旋转速度</h5><p>通过PWM控制转速</p><p>用arduino控制开关的开合，从而使电压产生PWM</p><p>&nbsp;</p><h2 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h2><ul><li>可精确控制电机输出轴角度</li><li>低速运行时可获得更高的扭矩</li><li>开环控制/性价比高</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>单极性步进电机</li><li>双极性步进电机</li></ul><h3 id="单-双极性步进电机比较"><a href="#单-双极性步进电机比较" class="headerlink" title="单/双极性步进电机比较"></a>单/双极性步进电机比较</h3><div class="table-container"><table><thead><tr><th>单极性</th><th>双极性</th></tr></thead><tbody><tr><td>通常有5-6条引线</td><td>通常有4条引线</td></tr><tr><td>相对输出扭矩低</td><td>通常输出扭矩高</td></tr><tr><td>控制电路相对简单</td><td>控制电路相对复杂</td></tr></tbody></table></div><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>永磁式步进电机（Permanent Magnet Stepper）</li><li>反应式步进电机（Variable Reluctance Stepper）</li><li>混含式步进电机（Hybrid Stepper）</li></ul><p>&nbsp;</p><p>永磁式步进电机的转子用永磁材料制成。</p><p>反应式步进电机的转子用软磁材料制成。</p><p>&nbsp;</p><h3 id="28BYJ-48-步进电机"><a href="#28BYJ-48-步进电机" class="headerlink" title="28BYJ-48 步进电机"></a>28BYJ-48 步进电机</h3><h4 id="永磁型单极性四相步进电机"><a href="#永磁型单极性四相步进电机" class="headerlink" title="永磁型单极性四相步进电机"></a>永磁型单极性四相步进电机</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电机&quot;&gt;&lt;a href=&quot;#电机&quot; class=&quot;headerlink&quot; title=&quot;电机&quot;&gt;&lt;/a&gt;电机&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;普通直流电机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;步进电机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伺服电机（舵机）&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="单片机" scheme="https://rozen12123.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>红外遥控</title>
    <link href="https://rozen12123.github.io/posts/24aabf4.html"/>
    <id>https://rozen12123.github.io/posts/24aabf4.html</id>
    <published>2023-01-13T05:55:40.000Z</published>
    <updated>2023-01-21T10:09:49.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红外遥控"><a href="#红外遥控" class="headerlink" title="红外遥控"></a>红外遥控</h2><p>常用红外协议资料<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/irremote-library/#ir-protocol">IRremote库 – 太极创客 (taichi-maker.com)</a></p><p>&nbsp;</p><h3 id="1838红外接收器"><a href="#1838红外接收器" class="headerlink" title="1838红外接收器"></a>1838红外接收器</h3><p><img src="/posts/24aabf4.htm/image-20230113140331904.png" alt="image-20230113140331904"> </p><div class="table-container"><table><thead><tr><th>1838红外接收器引脚</th><th>Arduino引脚</th><th></th></tr></thead><tbody><tr><td>OUT</td><td>11</td><td></td></tr><tr><td>VCC</td><td>+5V</td><td></td></tr><tr><td>GND</td><td>GND</td></tr></tbody></table></div><h3 id="红外接收（NEC协议）"><a href="#红外接收（NEC协议）" class="headerlink" title="红外接收（NEC协议）"></a>红外接收（NEC协议）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IRremote.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  RECV_PIN 11</span></span><br><span class="line"> </span><br><span class="line">IRrecv <span class="title function_">irrecv</span><span class="params">(RECV_PIN)</span>;   <span class="comment">// 红外遥控初始化</span></span><br><span class="line">decode_results results;   <span class="comment">// 储存接收到的红外遥控信息</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">  digitalWrite(LED_BUILTIN, LOW);     </span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Enabling IRin&quot;</span>);</span><br><span class="line">  irrecv.enableIRIn();     <span class="comment">// 启动红外接收</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Enabled IRin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  decode()库函数用于判断红外接收器所接收到的红外信号是否可以被解析。</span></span><br><span class="line"><span class="comment">  如可以成功解析，则返回非零数值。并将解析结果存储于results中。</span></span><br><span class="line"><span class="comment">  如无法成功解析，则返回零。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  每一次解析完成，都需要调用resume()函数从而让Arduino开始准备接收下一个红外</span></span><br><span class="line"><span class="comment">  遥控指令。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (irrecv.decode(&amp;results)) &#123;  </span><br><span class="line">    Serial.println(results.value, HEX);  <span class="comment">// results.value为红外遥控信号的具体数值</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(results.value == <span class="number">0xF7C03F</span>) <span class="comment">//如果控制信息数值为F7C03F</span></span><br><span class="line">    &#123;          </span><br><span class="line">        Serial.println(<span class="string">&quot;Command Received: Turn On LED.&quot;</span>);</span><br><span class="line">        digitalWrite(LED_BUILTIN, HIGH); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(results.value == <span class="number">0xF740BF</span>) <span class="comment">//如果控制信息数值为F740BF</span></span><br><span class="line">    &#123;          </span><br><span class="line">        Serial.println(<span class="string">&quot;Command Received: Turn Off LED.&quot;</span>);</span><br><span class="line">        digitalWrite(LED_BUILTIN, LOW); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    irrecv.resume(); <span class="comment">// 恢复接收下一个红外遥控信号</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="信号发射"><a href="#信号发射" class="headerlink" title="信号发射"></a>信号发射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IRremote.h&gt;</span></span></span><br><span class="line">IRsend irsend;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;  </span><br><span class="line">    irsend.sendNEC(<span class="number">0xF7C03F</span>, <span class="number">32</span>);  <span class="comment">//发射NEC红外遥控协议F7C03F指令码，16进制每个占用4bit，所以一共32个bit</span></span><br><span class="line">    delay(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * IRremote库支持NEC, Sony, Philips RC5, Philips RC6等协议指令。</span></span><br><span class="line"><span class="comment">  * 本示例程序中Arduino将通过调用函数sendSony(0xa90, 12) 来发射Sony协议指令。</span></span><br><span class="line"><span class="comment">  * 该函数的两个参数中， 0xa90为指令信息内容，12位指令信息位数。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 假如需要发射NEC协议指令则可以调用函数sendNEC(0xF7C03F, 32)。</span></span><br><span class="line"><span class="comment">  * 其中0xF740BF为指令信息内容，32位指令信息位数。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 如果需要发射其它遥控协议指令请参考以下程序代码：</span></span><br><span class="line"><span class="comment">  * sendNEC(unsigned long data, int nbits);   //发射NEC协议指令</span></span><br><span class="line"><span class="comment">  * sendSony(unsigned long data, int nbits);  //发射Sony协议指令</span></span><br><span class="line"><span class="comment">  * void sendRC5(unsigned long data, int nbits);   //发射Philips RC5协议指令</span></span><br><span class="line"><span class="comment">  * void sendRC6(unsigned long data, int nbits);   //发射Philips RC6协议指令</span></span><br><span class="line"><span class="comment">  * void sendSharp(unsigned long data, int nbits); //发射Sharp协议指令</span></span><br><span class="line"><span class="comment">  * void sendPanasonic(unsigned int address, unsigned long data); //发射Panasonic协议指令</span></span><br><span class="line"><span class="comment">  * void sendJVC(unsigned long data, int nbits, int repeat);  //发射JVC协议指令</span></span><br><span class="line"><span class="comment">  * void sendRaw(unsigned int buf[], int len, int hz);        //发射原始指令</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">//延迟5秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>红外LED发射的信号具有方向性</li><li>控制距离最远不超过2-3米</li><li>需要为红外LED配限流电阻</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;红外遥控&quot;&gt;&lt;a href=&quot;#红外遥控&quot; class=&quot;headerlink&quot; title=&quot;红外遥控&quot;&gt;&lt;/a&gt;红外遥控&lt;/h2&gt;&lt;p&gt;常用红外协议资料&lt;a href=&quot;http://www.taichi-maker.com/homepage/referenc</summary>
      
    
    
    
    
    <category term="单片机" scheme="https://rozen12123.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>arduino内存</title>
    <link href="https://rozen12123.github.io/posts/44ae0abd.html"/>
    <id>https://rozen12123.github.io/posts/44ae0abd.html</id>
    <published>2023-01-10T02:45:23.000Z</published>
    <updated>2023-01-21T10:10:01.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="arduino内存"><a href="#arduino内存" class="headerlink" title="arduino内存"></a>arduino内存</h2><p>内部储存单元由几种不同的介质组成</p><div class="table-container"><table><thead><tr><th>介质</th><th>名称</th><th>特点</th><th>储存特点</th></tr></thead><tbody><tr><td>FLASH</td><td>闪存（U盘）</td><td>价格低，读写慢</td><td>数量较大的静态信息。断电后可以保持存储内容。存储程序</td></tr><tr><td>SRAM</td><td>静态随机存储器</td><td>价格高，读写快</td><td>数量较小的动态信息，断电后不可以保持存储内容。储存程序变量</td></tr><tr><td>EEPROM</td><td>电可擦除可编程只读存储器</td><td>可擦写可编程 ，读写速度慢</td><td>只能读取信息，不能储存信息。（例如光盘）用于需要断电保持的程序变量</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="在EEPROM中读取和储存数据"><a href="#在EEPROM中读取和储存数据" class="headerlink" title="在EEPROM中读取和储存数据"></a>在EEPROM中读取和储存数据</h3><p>对于arduino uno其有1024个字节（1kb）</p><p>可以储存1024个0~255十进制数</p><p>&nbsp;</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>SRAM资源远远小于FLASH资源</p><h3 id="优化SRAM"><a href="#优化SRAM" class="headerlink" title="优化SRAM"></a>优化SRAM</h3><h4 id="串口监视器输出时用"><a href="#串口监视器输出时用" class="headerlink" title="串口监视器输出时用"></a>串口监视器输出时用</h4><p>用SRAM储存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial. println(<span class="string">&quot;Taichi-Maker&quot;</span>);</span><br></pre></td></tr></table></figure><p>用FLASH储存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial. println (F(<span class="string">&quot;Taichi-Maker&quot;</span>));</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="建立常量"><a href="#建立常量" class="headerlink" title="建立常量"></a>建立常量</h3><p>用SRAM储存静态信息会对使用空间进行浪费</p><p>此时我们可以用FLASH分担SRAM的压力</p><p>将常量储存在FLASH中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">125</span>;<span class="comment">//储存在SRAM中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PROGMEM a = <span class="number">125</span>；<span class="comment">//储存在Flash中</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>我们可以从下列代码中来体会全局变量和局部变量的特点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVarl；<span class="comment">//全局变量1</span></span><br><span class="line"><span class="type">int</span> globalVar2；<span class="comment">//全局变量2</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line">function_1（）；<span class="comment">//调用函数1</span></span><br><span class="line">function_2（）；<span class="comment">//调用函数2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> function_1（）&#123;</span><br><span class="line"><span class="type">int</span> localVarl；<span class="comment">//函数1局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> function_2&#123;</span><br><span class="line"><span class="type">int</span> localVar2；<span class="comment">//函数2局部变量</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>内存</th><th>特点</th></tr></thead><tbody><tr><td>SRAM</td><td>共享的局部变量</td></tr><tr><td>SRAM</td><td>独享的全局变量</td></tr></tbody></table></div><p>要更好地优化空间我们就需要尽量多使用==局部变量==代替==全局变量==</p><p>&nbsp;</p><h3 id="用bool型的变量代替int型的变量做逻辑判断"><a href="#用bool型的变量代替int型的变量做逻辑判断" class="headerlink" title="用bool型的变量代替int型的变量做逻辑判断"></a>用bool型的变量代替int型的变量做逻辑判断</h3><h4 id="用整形占用两个字节"><a href="#用整形占用两个字节" class="headerlink" title="用整形占用两个字节"></a>用整形占用两个字节</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a；　　<span class="comment">//变量a用于逻辑判断</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line"><span class="keyword">if</span>（a== <span class="number">1</span>）&#123;</span><br><span class="line"><span class="comment">//变量a等于1时执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h4 id="用bool占用一个字节"><a href="#用bool占用一个字节" class="headerlink" title="用bool占用一个字节"></a>用bool占用一个字节</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a；<span class="comment">//变量a用于逻辑判断</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line"><span class="keyword">if</span>（a == <span class="number">1</span>）&#123;</span><br><span class="line"><span class="comment">//变量a等于1时执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>尽量使用占用内存少的数据类型</p><p>具体的数据类型及其相关信息可以参考这个网站<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/data-types/">Arduino常用数据类型简介 – 太极创客 (taichi-maker.com)</a></p><p>（8位微控制器）</p><p>&nbsp;</p><h3 id="优化FLASH"><a href="#优化FLASH" class="headerlink" title="优化FLASH"></a>优化FLASH</h3><p>即优化我们的arduino程序</p><h4 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h4><ul><li>无用库</li><li>无用变量</li><li>无用函数</li><li>无用代码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;arduino内存&quot;&gt;&lt;a href=&quot;#arduino内存&quot; class=&quot;headerlink&quot; title=&quot;arduino内存&quot;&gt;&lt;/a&gt;arduino内存&lt;/h2&gt;&lt;p&gt;内部储存单元由几种不同的介质组成&lt;/p&gt;
&lt;div class=&quot;table-con</summary>
      
    
    
    
    
    <category term="arduino" scheme="https://rozen12123.github.io/tags/arduino/"/>
    
  </entry>
  
  <entry>
    <title>LED</title>
    <link href="https://rozen12123.github.io/posts/undefined.html"/>
    <id>https://rozen12123.github.io/posts/undefined.html</id>
    <published>2023-01-09T16:48:41.000Z</published>
    <updated>2023-01-21T10:10:15.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RGB-LED"><a href="#RGB-LED" class="headerlink" title="RGB-LED"></a>RGB-LED</h2><p><img src="/posts/undefined.htm/image-20230110005138804.png" alt="image-20230110005138804"></p><p>&nbsp;</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> rLedPin = <span class="number">6</span>; <span class="comment">//引脚R</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gLedPin = <span class="number">5</span>; <span class="comment">//引脚G</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bLedPin = <span class="number">3</span>; <span class="comment">//引脚B</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ledR  = <span class="number">0</span>; <span class="comment">//R Led 亮度</span></span><br><span class="line"><span class="type">int</span> ledG  = <span class="number">0</span>; <span class="comment">//G Led 亮度</span></span><br><span class="line"><span class="type">int</span> ledB  = <span class="number">0</span>; <span class="comment">//B Led 亮度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(rLedPin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(gLedPin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(bLedPin, OUTPUT);</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Welcome to Taichi-Maker RGB Led Tutorial.&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Please Input RGB value(eg. r128g100b20).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (Serial.<span class="built_in">available</span>()&gt;<span class="number">0</span>) &#123; </span><br><span class="line">    <span class="type">char</span> serialCmdChar = Serial.<span class="built_in">read</span>();  </span><br><span class="line">    <span class="built_in">serialCmd</span>(serialCmdChar);       </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">50</span>);      </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialCmd</span><span class="params">(<span class="type">char</span> serialCmdChar)</span> </span>&#123;  <span class="comment">//r128g100b20</span></span><br><span class="line">  <span class="keyword">switch</span> (serialCmdChar)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      ledR = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">      ledG = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      ledB = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      ledR = <span class="number">0</span>;</span><br><span class="line">      ledG = <span class="number">0</span>;</span><br><span class="line">      ledB = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">analogWrite</span>(rLedPin, ledR);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">analogWrite</span>(gLedPin, ledG);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">analogWrite</span>(bLedPin, ledB); </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>); </span><br><span class="line">  </span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Red Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledR);</span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Green Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledG);</span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Blue Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledB);</span><br><span class="line">  Serial.<span class="built_in">println</span> (<span class="string">&quot;-------------&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RGB-LED&quot;&gt;&lt;a href=&quot;#RGB-LED&quot; class=&quot;headerlink&quot; title=&quot;RGB-LED&quot;&gt;&lt;/a&gt;RGB-LED&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/undefined.htm/image-2023011000513</summary>
      
    
    
    
    
    <category term="模块" scheme="https://rozen12123.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
</feed>
