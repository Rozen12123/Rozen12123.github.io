<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小江的博客</title>
  
  <subtitle>想成为一个温暖而有趣的人</subtitle>
  <link href="https://rozen12123.github.io/atom.xml" rel="self"/>
  
  <link href="https://rozen12123.github.io/"/>
  <updated>2023-09-16T11:24:01.876Z</updated>
  <id>https://rozen12123.github.io/</id>
  
  <author>
    <name>小江</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字化结构设计</title>
    <link href="https://rozen12123.github.io/posts/3c5c3e03.html"/>
    <id>https://rozen12123.github.io/posts/3c5c3e03.html</id>
    <published>2023-09-13T02:38:58.000Z</published>
    <updated>2023-09-16T11:24:01.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字化结构设计"><a href="#数字化结构设计" class="headerlink" title="数字化结构设计"></a>数字化结构设计</h1><h2 id="层次建模的概念"><a href="#层次建模的概念" class="headerlink" title="层次建模的概念"></a>层次建模的概念</h2><h3 id="设计方法学"><a href="#设计方法学" class="headerlink" title="设计方法学"></a>设计方法学</h3><p>两种基本的设计方法：<code>自底向上</code>和<code>自顶向下</code>设计</p><p>1.自底向上</p><p>2.自顶向下</p><p>通常情况下，两种方法混合使用。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>​     Verilog使用模块（module）的概念来代表一个基本的功能块。</p><p>​    一个模块可以是一个元件，也可以是低层次模块的组合</p><h3 id="1-模块声明"><a href="#1-模块声明" class="headerlink" title="1.模块声明"></a>1.模块声明</h3><p>​    在Verilog中，模块声明是由关键字module开始，关键字endmodule必须出现在模块定义的结尾。每个模块必须有一个模块名，由它唯一的标志这个模块。模块的端口列表则描述这个模块的输入和输出端口</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;模块名&gt;(&lt;模块端口列表&gt;);</span><br><span class="line">...</span><br><span class="line">&lt;模块的内容&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>例如在脉动进位计数器的例子中，T触发器可以定义为：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> T_FF (q, clock ,reset);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&lt;T触发器的功能描述&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字化结构设计&quot;&gt;&lt;a href=&quot;#数字化结构设计&quot; class=&quot;headerlink&quot; title=&quot;数字化结构设计&quot;&gt;&lt;/a&gt;数字化结构设计&lt;/h1&gt;&lt;h2 id=&quot;层次建模的概念&quot;&gt;&lt;a href=&quot;#层次建模的概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="课程" scheme="https://rozen12123.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子信息科学与技术攻略</title>
    <link href="https://rozen12123.github.io/posts/69d7a7f9.html"/>
    <id>https://rozen12123.github.io/posts/69d7a7f9.html</id>
    <published>2023-09-06T14:46:37.000Z</published>
    <updated>2023-09-16T11:24:01.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电子信息科学与技术攻略"><a href="#电子信息科学与技术攻略" class="headerlink" title="电子信息科学与技术攻略"></a>电子信息科学与技术攻略</h1><p>亲爱的学弟学妹们：</p><p>  首先，我要热烈欢迎你们加入电子信息科学与技术专业！恭喜你们顺利踏上了大学的征程，这将是一个充满挑战和成长的旅程。我是电子信息科学与技术专业的一名本科生，非常高兴能在这里与你们分享一些有关入学和大学生活的经验。</p><p>  在你们即将开始的学术和生活冒险中，我相信你们会遇到各种新的机会和挑战。作为学长，我们愿意与你们分享我们的经验，帮助你们更快地适应大学生活。不管你们面临什么问题，都请放心来寻求帮助，我们将竭尽全力支持你们。</p><p>  接下来，让我们一起探讨一些入学后关于学习的一些建议。无论你们有什么疑问或需要，都可以随时私信我。</p><h2 id="关于电子信息科学信息与技术"><a href="#关于电子信息科学信息与技术" class="headerlink" title="关于电子信息科学信息与技术"></a>关于电子信息科学信息与技术</h2><p>  在刚入学时我也对这个专业充满疑问，根本不知道这个专业是什么，要学什么，可以用来干什么。</p><p>  简单来说，电子信息科学与技术是一门涵盖电子工程、计算机科学和信息技术的跨学科领域。它关注的是如何处理、传输和管理信息，以及如何使用电子设备和计算机系统来解决实际问题。</p><p>  具体来说，这个领域包括了以下重要方面：</p><ol><li><strong>电子工程：</strong> 电子信息科学与技术涉及设计、开发和维护各种电子设备和系统，如电路、通信设备、传感器和嵌入式系统。这些技术在现代社会中无处不在，用于各种应用，从智能手机到医疗设备。</li><li><strong>计算机科学：</strong> 这个领域强调计算机系统的设计、编程和软件开发。学生将学习如何编写代码、开发应用程序，并理解计算机硬件和软件之间的相互作用。</li><li><strong>通信技术：</strong> 电子信息科学与技术还涉及到数据通信和网络技术，包括互联网、移动通信和无线传感器网络。这是现代社会中信息传递的关键组成部分。</li><li><strong>信息处理：</strong> 学生将学习如何处理和分析数据，以从中提取有用的信息。这包括数据挖掘、人工智能和机器学习等技术，这些技术在商业、科学和许多其他领域中都有广泛的应用。</li></ol><p>当然如果只这么说的话还是会有些抽象，不过不用担心，接下来的文章里我会对我们的专业做更加详细的解释。</p><p>​    这是一门涉及知识很广的学科，但你不得不说也是一门非常有趣的学科。我最开始知道这个专业并且对此感兴趣是在B站上看到的一个视频。是<strong>稚晖君</strong>做的一个小电视，我当时就被深深得吸引了，如此小的一个小电视上个怎么可以实现这么多功能，完全都可以当作一个电脑来使用。</p><p><a href="https://www.bilibili.com/video/BV1jE41137eu/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【自制】技术宅UP耗时三个月，自制B站最强小电视！【硬核】【3分钟从草图到实物】_哔哩哔哩_bilibili</a></p><p>​    随后，我又在B站发现了更多电子信息专业可以做的很多东西。</p><p><a href="https://www.bilibili.com/video/BV1BW41147kC/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">基于Arduino的十个可以DIY的炫酷项目_哔哩哔哩_bilibili</a></p><p>​    这对还没有开始学习大学知识的你来说可能就像魔法一样，我最开始刚进入大学的时候也是感觉这一切都是那么迷茫，不知道怎办开始，怎么学习才能做出来像这些视频里一样的diy项目。</p><p>​    但是经过一个学期的学习，我在大一上学期结束的那个寒假也用自己所学的东西，做了一个很简易的流水灯，虽然现在看起来是很简单的一个小制作，但是在当时把流水灯点亮的那一刻，心里的成就感是很强烈得，足够开心很久很久。</p><p><a href="https://www.bilibili.com/video/BV1uR4y1u7z5/?spm_id_from=333.999.0.0">做了个流水灯_哔哩哔哩_bilibili</a></p><p>希望你也可以在之后的学习中，做出一些很有趣的小制作。</p><p>&nbsp;</p><h2 id="电子信息科学与技术课程设置及其相关资料"><a href="#电子信息科学与技术课程设置及其相关资料" class="headerlink" title="电子信息科学与技术课程设置及其相关资料"></a>电子信息科学与技术课程设置及其相关资料</h2><h3 id="大一（Freshman-Year）"><a href="#大一（Freshman-Year）" class="headerlink" title="大一（Freshman Year）"></a><strong>大一（Freshman Year）</strong></h3><h4 id="第一学期课程（Curriculum-in-First-Semester）："><a href="#第一学期课程（Curriculum-in-First-Semester）：" class="headerlink" title="第一学期课程（Curriculum in First Semester）："></a>第一学期课程（Curriculum in First Semester）：</h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（一）College Physical Education I</p><p>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</p><p>l 线性代数导论（Introduction to Linear Algebra）</p><p>l 大学物理Ⅰ（University Physics Ⅰ）</p><p>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</p><p>l 编程导论（Introduction to Programming）</p><h4 id="第二学期课程（Curriculum-in-Second-Semester）："><a href="#第二学期课程（Curriculum-in-Second-Semester）：" class="headerlink" title="第二学期课程（Curriculum in Second Semester）："></a><strong>第二学期课程（Curriculum in Second Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（二）College Physical Education II</p><p>l 微积分Ⅱ和III（Calculus Ⅱ and III）</p><p>l 大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</p><p>l 工程学导论Ⅱ（Introduction to Engineering Ⅱ）</p><p>l 电路原理及实验（Electrical Circuit Theory and Lab）</p><h3 id="大二（Sophomore-Year）"><a href="#大二（Sophomore-Year）" class="headerlink" title="大二（Sophomore Year）"></a><strong>大二（Sophomore Year）</strong></h3><h4 id="第三学期课程（Curriculum-in-Third-Semester）："><a href="#第三学期课程（Curriculum-in-Third-Semester）：" class="headerlink" title="第三学期课程（Curriculum in Third Semester）："></a><strong>第三学期课程（Curriculum in Third Semester）：</strong></h4><p>l 英语（English）</p><p>l 思政课（Ideological and Political courses）</p><p>l 大学体育（三）College Physical Education III</p><p>l 常微分方程导论（Introduction to Ordinary Differential）</p><p>l 大学物理III及实验（University Physics III and Lab）</p><p>l 数据结构（Data Structures）</p><p>l 电子学Ⅰ及实验（Electronics Ⅰ and Lab）</p><h4 id="第四学期课程（Curriculum-in-Forth-Semester）"><a href="#第四学期课程（Curriculum-in-Forth-Semester）" class="headerlink" title="第四学期课程（Curriculum in Forth Semester）"></a><strong>第四学期课程（Curriculum in Forth Semester）</strong></h4><p>l 大学体育（四）（College Physical Education IV）</p><p>l 工程概率基础（Introduction to Engineering Probability）</p><p>l 信号与系统（Circuits，Signals and System）</p><p>l 逻辑设计（Logic Design）</p><p>l 数字设计实验（Digital Design Lab）</p><p>l 电子学Ⅱ和实验（Electronics Ⅱ and Lab）</p><p>l 微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</p><p>l 电子电路CAD （Electronic Circuit CAD）</p><h3 id="大三（Junior-Year）"><a href="#大三（Junior-Year）" class="headerlink" title="大三（Junior Year）"></a><strong>大三（Junior Year）</strong></h3><h4 id="第五学期课程（Curriculum-in-Fifth-Semester）"><a href="#第五学期课程（Curriculum-in-Fifth-Semester）" class="headerlink" title="第五学期课程（Curriculum in Fifth Semester）"></a><strong>第五学期课程（Curriculum in Fifth Semester）</strong></h4><p>l 离散时间信号与系统（Discrete-Time Signals and Systems）</p><p>l 电磁场原理（Electromagnetic Field Theory）</p><p>l 固态电子学（Solid-State Electronics）</p><p>l 单片机原理（MCU Principle）</p><p>l 结构化数字设计（含FPGA）Structured Digital Design</p><p>l 创新项目实践（一）Practice of Innovation Project I</p><h4 id="第六学期课程（Curriculum-in-Sixth-Semester）"><a href="#第六学期课程（Curriculum-in-Sixth-Semester）" class="headerlink" title="第六学期课程（Curriculum in Sixth Semester）"></a><strong>第六学期课程（Curriculum in Sixth Semester）</strong></h4><p>l 嵌入式微处理系统设计（Embedded Microprocessor System Design）</p><p>l 通信系统（Communication Systems）</p><p>l 线性控制系统（Linear Control Systems）</p><p>l 电力电子（Power Electronics）</p><p>l VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</p><p>l 模拟集成电路（Analog Integrated Circuit）</p><p>l 创新项目实践（二）Practice of Innovation Project II</p><h3 id="大四（Senior-Year）"><a href="#大四（Senior-Year）" class="headerlink" title="大四（Senior Year）"></a><strong>大四（Senior Year）</strong></h3><h4 id="第七学期课程（Curriculum-in-Seventh-Semester）"><a href="#第七学期课程（Curriculum-in-Seventh-Semester）" class="headerlink" title="第七学期课程（Curriculum in Seventh Semester）"></a><strong>第七学期课程（Curriculum</strong> <strong>in Seventh Semester）</strong></h4><p>l 数字图像处理（Introduction to Digital Image Processing）</p><p>l 现场可编程逻辑阵列（Field programmable logic array）</p><p>l 高级项目设计（Advanced project design）</p><p>l 集成电路EDA（Integrated circuit EDA）</p><p>l 版图设计（Layout design）</p><p>l 专业实习（Internship）</p><h4 id="第八学期课程（Curriculum-in-Eighth-Semester）"><a href="#第八学期课程（Curriculum-in-Eighth-Semester）" class="headerlink" title="第八学期课程（Curriculum in Eighth Semester）"></a><strong>第八学期课程（Curriculum in Eighth Semester）</strong></h4><p>l 毕业设计（Senior Project）</p><p>&nbsp;</p><p>关于大学期间所有能用到得课本已经全部整理出来，链接就放到下面。</p><p>链接：<a href="https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg">https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg</a> 提取码：2038</p><p>​    这一部分要感谢一名学长，将我们所有的文档归纳起来并且分享给大家，我也把这位学长的原博客链接放到下面。这篇博客里还有所有对于我们课程的相关资料的推荐，我个人也是这篇博客的受益者。</p><p><a href="https://y006.github.io/2022/03/23/15-24-59/">电子专业资料共享计划 | Blog (y006.github.io)</a></p><p>​    如果打不开上面的博客，可能是因为博客的地址在GitHub，而你的电脑又没有开vpn。</p><p>关于vpn是什么，怎么使用，你可以去看这个视频。</p><p><a href="https://www.bilibili.com/video/BV1LX4y1E7AS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【科普】VPN到底是什么，你还敢用吗_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="课程部分"><a href="#课程部分" class="headerlink" title="课程部分"></a>课程部分</h2><p>​    大家最关心的莫过于自己将要学习的课程以及如何去学好他们，接下来我将对此讲一些自己的看法，如果你有更好的建议或者发现了错误也希望你及时联系我。</p><p>​    但是大学的知识学习不等同于高中，高中的一贯学习套路是：</p><ol><li>先学会基础知识，了解最基本的概念</li><li>反复练习简单题，中档题及压轴题</li><li>将练习后的题目分类总结，总结成一套自己的方法，直到考试碰到此类问题可以立即有思路，很快地解出题目。</li></ol><p>​    但是在大学如果你仍然按高中的学习方法明显是很吃力的，因为对于三年学习六门科目的学习方法去应对一学期学十几门课的实际情况，明显是不可能的。</p><p>​    我就对大一第一学期的课程做一些简单的介绍。我把课程分为三类，<code>基础类</code>，<code>导论类</code>，<code>应用类</code></p><h3 id="基础类：工程微积分，线性代数导论，大学物理"><a href="#基础类：工程微积分，线性代数导论，大学物理" class="headerlink" title="基础类：工程微积分，线性代数导论，大学物理"></a><em>基础类</em>：工程微积分，线性代数导论，大学物理</h3><p>​    基础类的课程设计了很多的基础概念，公式，和思想。学习这类课程需要你对自己学习过的知识有一个清晰的框架，以至于自己学习完这门课后知道自己都学习了什么内容。</p><p>​    例如你想去做一个平衡车，你学习完这些知识之后你要很清楚知道，微积分中的PID算法可以用来解决调节平衡角度的问题，大学物理的角动量可以让你更加了解平衡的机械部分是如何实现的。</p><h3 id="导论类：工程学导论，编程导论"><a href="#导论类：工程学导论，编程导论" class="headerlink" title="导论类：工程学导论，编程导论"></a><em>导论类</em>：工程学导论，编程导论</h3><p>​    导论类课程一般会带你们使用一种新的技术解决一个问题，这类课程不需要你像基础列课程学习得那么细致，对概念那么精通，你只需要知道这么课大概都讲了什么，用到了什么工具。</p><p>​    例如现在需要你在图纸上画出一个很标准的心形，或者一个零件。这时候你知道，自己在工程学导论中使用CAD可以用来解决这个问题，这个过程中，你不知道软件的工具在哪里，怎么使用，或者使用什么方案，这些都不要紧，你只需要知道有这些工具，并且这些工具可以解决什么问题就可以了。</p><p>​    当然，这也并不代表你就可以只是听故事一样听完整门课程就可以了，上课的例题，或者作业题也需要你去实践一下。</p><p>​    在编程导论中你知道用编程可以解决很多实际问题，它可以帮你计算，管理系统，等等。那你知道这些功能以后去自己写一个学生成绩管理系统是不是也是一个比较有趣的事情</p><p>&nbsp;</p><h3 id="实践类：编程导论"><a href="#实践类：编程导论" class="headerlink" title="实践类：编程导论"></a><em>实践类</em>：编程导论</h3><p>​    大多的实践类课程就是在你有一定的学习基础后，可以用这些基础的知识结合硬件去做一些项目。我们学习的编程导论虽然是一门导论课，但是编程在我们之后的学习生活中是不可或缺的一部分，这门课重要到即使它是一门导论课，也值得我们去把他当作一门实践类课程去学习。</p><p>​    你可以在学习了解完基础知识以后，写一个简单的猜数字游戏，学生成绩管理系统等等。</p><p>​    &nbsp;</p><p>​    或许对于还没有开始上课的你来说看这些内容还有些懵，但是在之后的学习生活中你会对此有更加深刻的体会。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>​    大一的课程是整个大学的基础，十分重要，其中的微积分，线性代数，大学物理，编程导论等也是之后很多课程的基础。</p><p>​    比如：大二你们要学习的常微分的基础就是微积分与线性代数，如果这两门你在最开始就没有学好，那在之后的学习中是很头疼的一件事情，你仍然要返回去学习这些基础课程。所以，希望同学们在最开始的时候就好好学习这些课程。</p><h4 id="l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）"><a href="#l-工程微积分Ⅰ（Calculus-Ⅰ-for-Engineers）" class="headerlink" title="l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）"></a>l 工程微积分Ⅰ（Calculus Ⅰ for Engineers）</h4><p>微积分一中，主要的大方面学习分几部分</p><ol><li><p>对极限的理解</p></li><li><p>导数的进阶应用</p></li><li><p>微积分中重要思想———积分</p></li><li><p>积分方法的学习</p></li></ol><h5 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h5><p>在第二章极限的学习中，相较于初等数学，了解到了极限与无穷的概念，在图形中分析计算垂直与水平渐近线可以加深对与极限的理解。</p><p>要学会对连续性进行判断，从而判断出任意点的类型（如可去间断点，跳跃间断点等）</p><p>其次，在极限式子的计算中，多数较难的式子均可以最终化简为两个重要极限的形式。</p><script type="math/tex; mode=display">\lim _{x \rightarrow 0} \frac{\sin x}{x}=1 \quad \lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e</script><p>由此，对于两个总要的极限的应用就显得及其重要，当然在极限中，熟练运用洛必达法则也是必不可少的</p><p>&nbsp; </p><h5 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h5><p>在高数开始接触导数便移入了很多新的概念，在导数中，很重要的一点就是加深对链法则的理解，这个对以后学习各类积分微分知识都是帮助很大的。</p><p>如果对链法则的理解加深了，关于隐函数求导，符合函数求导，三角函数求导中的一系列问题都可以迎刃而解。</p><p>如果可以，多用导数的概念定义式进行积分的运算，会加深对于极限的理解。</p><p>在导数中有一系列相关的应用问题</p><ol><li><p>求最大最小值</p></li><li><p>求极大极小值</p></li><li><p>凹度与拐点</p></li></ol><p>这些问题无非都是通过1.函数的一阶导2.函数的二阶导3.临界点进行求值</p><p>三个方面进行分析，从而就可以对上诉三个问题进行求解</p><p>熟练理解中值定理，并可以对简单的式子进行推导</p><p> &nbsp;</p><h5 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h5><p>在积分的学习中我也认为是本书中最重要的一个概念，对积分的理解不应该只是会算出各种各样的积分形式，我们当然会学习很多各种各样的积分方法，不限于:<code>分部积分法</code>，<code>三角积分法</code>，<code>三角换元法</code>，<code>分布分式法</code>……..这些方法在大量的练习中我们可以熟练地去解出各种类型的式子，配合506页的公式表，当然效果肯定会更棒。</p><p>对<code>反函数</code>，<code>对数指数</code>模型，<code>反三角函数</code>，在推导过一遍可以对公式进行记背。</p><p>在微积分的应用中，我们不应该仅仅停留在解出图形的<code>面积</code>，<code>体积</code>。</p><p>深刻理解微积分，把整个要计算的图形，分为极限趋向0的无数个点，由点去积分成线，再将由无数的线与一定区间进行积分，可以得到面，对面再积分可以得到体积。这是从一维到三维，我们都是很容易理解的。</p><p>但到四维呢？如果我们对于每个点再赋予一个维度的含义，那么这个式子就可以表达整个图形的质量。</p><p>这样去深刻理解每个维度之间的积分关系，就显得非常奇妙。</p><p>对于中间一些题型呢，如下</p><ol><li><p>求面积</p></li><li><p>求体积</p></li><li><p>求弧长</p></li></ol><p>&nbsp;</p><p>但是总得来说，上述只是对基础知识点的一个概述，微积分在我们的生活中可谓是应用广泛，比如在音乐播放器使用微积分来调整音频信号的音量和频率，以确保音乐听起来和谐而流畅；在电梯系统使用微积分来计算电梯的速度和位置，以便顺利地将你从一楼带到其他楼层；在电子游戏中的物理引擎使用微积分来模拟物体的运动和碰撞，以使游戏更加真实。</p><p>对于微积分，在你学完相关内容后你可以去看这些内容，可以更加加深你对知识的理解。</p><p><a href="https://www.bilibili.com/video/BV1qW411N7FU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">【官方双语/合集】微积分的本质 - 系列合集_哔哩哔哩_bilibili</a></p><p>宋浩老师的视频也很适合你去进行预习或者打基础</p><p><a href="https://www.bilibili.com/video/BV1UW411k7Jv/?spm_id_from=333.337.search-card.all.click">《微积分》《高等数学》全程教学视频—宋浩老师_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-线性代数导论（Introduction-to-Linear-Algebra）"><a href="#l-线性代数导论（Introduction-to-Linear-Algebra）" class="headerlink" title="l 线性代数导论（Introduction to Linear Algebra）"></a>l 线性代数导论（Introduction to Linear Algebra）</h4><p>​    线性代数是一门数学分支，它主要研究向量、向量空间和线性变换等概念。它在电子信息科学与技术领域中具有关键作用，因为它提供了处理多维数据和解决复杂问题的数学工具。</p><p>​    注意，这门线性代数是一个数学工具，就好比你学习了方程以后就可以用使用方程来解决一些数学问题，而同样的，当你学习过线性代数以后，你也可以通过线性代数来解决一些数学或者工程上的问题。</p><ol><li><strong>向量和向量空间：</strong> 线性代数的核心概念之一是向量。向量可以用来表示多维数据，如在图像处理、信号处理和数据分析中常见的数据结构。线性代数还研究了向量空间，这是一组满足特定性质的向量的集合。向量空间理论为我们提供了处理和分析数据的框架。</li><li><strong>线性变换：</strong> 另一个重要的概念是线性变换，它描述了如何将一个向量空间映射到另一个向量空间。线性变换在图像处理、信号处理和控制系统等领域中广泛应用。例如，在通信系统中，线性变换可以用来描述信号的传输和变换。</li><li><strong>矩阵：</strong> 矩阵是线性代数中的另一个核心概念，它用于表示线性变换和解决线性方程组。在电子信息科学与技术中，矩阵常常用于描述电路、信号处理滤波器和数据转换等。</li></ol><p>​    我也在知乎上发现了一篇十分详细的知识点，链接在下方。</p><p><a href="https://zhuanlan.zhihu.com/p/453305373">【数学】线性代数知识点总结（精炼版） - 知乎 (zhihu.com)</a></p><p>​    宋浩老师的视频也是相当经典。</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.337.search-card.all.click">《线性代数》高清教学视频 “惊叹号”系列 宋浩老师_哔哩哔哩_bilibili</a></p><p>​    如果在学习完基础内容，会解一些基本题型后，你可以去看3Blue1Brown的视频，相信你在看完之后会对线性代数有更加深刻的认识。</p><p><a href="https://www.bilibili.com/video/BV1ib411t7YR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">-UP主汉语配音-【线性代数的本质】合集-转载于3Blue1Brown官方双语】_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-大学物理Ⅰ（University-Physics-Ⅰ）"><a href="#l-大学物理Ⅰ（University-Physics-Ⅰ）" class="headerlink" title="l 大学物理Ⅰ（University Physics Ⅰ）"></a>l 大学物理Ⅰ（University Physics Ⅰ）</h4><p>​    大学物理Ⅰ的大部分内容其实我们已经在高中学习过了，但要注意的是，大学的物理相较与初中的物理更贴合实际，更具有普遍性。解决这部分实际问题就需要结合微积分知识和大学物理把很多过程微分成很多很小的过程，然后在把这很多很小的过程累积在一起。</p><p>​    例如下面这个图片</p><p>​    在小球从O到A的过程中，弹簧的力一直在发生变化，如果我们需要求在原点O到A点弹簧的弹性势能，用中学的知识，我们可以用图像法分析出</p><script type="math/tex; mode=display">E = \frac{1}{2} k x ^2</script><p>​    在大学学习了微积分以后我们就可以将每一个微小过程中的做的功微分后积分在一起，结果是一样的</p><script type="math/tex; mode=display">E = \int_{0}^{x} kx dx</script><p>​    </p><p>​    但是假设k的值不是恒定的，用高中的知识就无法解决了，但是我们可以用二重积分来解决这个问题，这也就是为什么大学里解决的问题更具有普遍性的例子。也希望大家在学习物理的过程不要只局限与写题，而是多去思考这个过程。</p><p>​    学习大学物理你可以去看东北大学马文蔚老师的物理课。</p><p><a href="https://www.bilibili.com/video/BV1qW411H7UX/?spm_id_from=333.337.search-card.all.click">【大学物理】东北大学-马文蔚_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h4 id="l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）"><a href="#l-工程学导论Ⅰ（Introduction-to-Engineering-Ⅰ）" class="headerlink" title="l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）"></a>l 工程学导论Ⅰ（Introduction to Engineering Ⅰ）</h4><p>​    工程学导论的主要目标是引导你们进入电子信息科学与技术领域。它将帮助你们了解电子技术、通信系统、计算机科学和信息处理等方面的基本概念。</p><p>​    我们将介绍CAD（计算机辅助设计）工具、MATLAB和C++编程，这些工具在电子信息科学与技术领域中非常重要。</p><p>​    大家在课上认真听讲，积极完成老师布置的课下作业，如果你还有精力，那你可以去B站，谷歌，GitHub去了解更多的内容，这门课不是重点也不是难点，你们只需要知道了解我们上课学习的内容即可。</p><p>&nbsp;</p><h4 id="l-编程导论（Introduction-to-Programming）"><a href="#l-编程导论（Introduction-to-Programming）" class="headerlink" title="l 编程导论（Introduction to Programming）"></a>l 编程导论（Introduction to Programming）</h4><p>​    最开始我对编程的感觉就是黑客在都是黑色的屏幕上敲命令行，感觉就像是拥有魔法一样，敲几行代码就可以实现一些不可思议的功能。后来我开始接触编程，还很清楚得记得我在学习完if和for语句做出一个猜数字的游戏后激动的心情。</p><p>​    包括我之前做的那款心形流水灯也是用c语言进行编程的，学会了编程语言就好比你有了一把利器，解决之前不敢想象的问题。</p><p>​    如果你是刚刚入门，我希望你去看翁恺老师的c语言程序设计，这可谓是大家编程梦开始的地方。</p><p><a href="https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click">浙江大学翁恺教你C语言程序设计！C语言基础入门！_哔哩哔哩_bilibili</a></p><p>​    如果你已经开始了c++语言的学习，那我推荐你去看黑马程序员的视频，这个视频用很简单的语言就可以解释清楚复杂的知识点，也希望你尽可能得把所有视频上的程序都自己敲写一遍。</p><p><a href="https://www.bilibili.com/video/BV1et411b73Z/?spm_id_from=333.337.search-card.all.click">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili</a></p><p>​    工欲善其事必先利其器，当然学习编程你就需要一款好的编译器，我推荐编程小白使用Visual Studio，这一款编译软件不要配置复杂的编译环境，可谓是上手即用，而且关于其的学习资料还比较多。下载方式如下。</p><p><a href="https://www.bilibili.com/video/BV1Xt411g7jT/?spm_id_from=333.337.search-card.all.click">vs2022(Visual Studio 2022)权威指南&amp;&amp;C语言&amp;&amp;软件工程开发的方向&amp;&amp;技巧要领_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>​    很明显，如果我们只学习课堂上教授的这部分内容，我们并没有办法去完成自己的diy项目或者小制作。我在最开始也有着这个疑问，不知道怎么样去动手实践，但是在之后摸索了很多方法之后，我认为初学者去学习arduino入门是很可行的一个道路。</p><p>​    Arduino是一款便捷灵活、方便上手的开源电子原型平台。很多重来没有接触过电子知识的创客也可用通过arduino来制作自己的小发明，更不用说我们这些科班出身的大学生。</p><p>​    你完全可用自己去淘宝买一套arduino的学习套件，跟着<code>太极创客</code>中的视频模仿，一步一步体会自己动手去做出来一个实物的快乐。</p><p><a href="https://www.bilibili.com/video/BV164411J7GE/?spm_id_from=333.337.search-card.all.click">【太极创客】零基础入门学用Arduino 第一部分 合辑_哔哩哔哩_bilibili</a></p><p>​    希望你一定不要把这作为自己的学习任务，自己去制作小发明就好比自己在拼乐高，去给玩偶涂色等等。是激动人心的一件事。我曾寒假在家就碰到了一个问题，屋子的灯只有一个开关，而我每次睡觉前关灯都需要爬下床去关灯然后抹黑爬回床上。于是我就花了一个下午的时间用蓝牙加舵机使用arduino的开发板制作了一个简易的智能开关。</p><p><a href="https://www.bilibili.com/video/BV1JF411r78p/?spm_id_from=333.999.0.0&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">arduino➕舵机➕蓝牙智能灯_哔哩哔哩_bilibili</a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="竞赛部分"><a href="#竞赛部分" class="headerlink" title="竞赛部分"></a>竞赛部分</h2><p>​    我非常建议大一的新生去参加蓝桥杯的单片机赛道，虽然正常情况下大家在大三才会学到单片机的使用，可能在学习中你们并不知道138译码器，与非门等等这些概念，甚至设计功能都不知道这其中的原理是什么，但是这并不妨碍我们先去学习，去接触。</p><p>​    推荐你先去看江科大的单片机以后再去针对比赛看小蜜蜂的比赛视频，蓝桥杯在每年年末报名，次年的四五月份进行比赛。无论如何，只要付出了，这对你绝对是一段很宝贵的学习经历，而且这个比赛的获奖率也是很高的，每年的大一小白参加最后也是有很多获得了省奖。</p><p><a href="https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click">51单片机入门教程-2020版 程序全程纯手打 从零开始入门_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Bt41187hw/?spm_id_from=333.337.search-card.all.click">【小蜜蜂笔记】蓝桥杯大赛-单片机设计与开发基础技能与进阶强化教程_哔哩哔哩_bilibili</a></p><p>​    </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>因为我目前也只是一名刚进入大三的本科生，很多想法见解可能在之后的学习过程中也会有不同的体验，如果你有更好的建议或者发现了一些错误请及时私信我，本文档将持续进行更新……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;电子信息科学与技术攻略&quot;&gt;&lt;a href=&quot;#电子信息科学与技术攻略&quot; class=&quot;headerlink&quot; title=&quot;电子信息科学与技术攻略&quot;&gt;&lt;/a&gt;电子信息科学与技术攻略&lt;/h1&gt;&lt;p&gt;亲爱的学弟学妹们：&lt;/p&gt;
&lt;p&gt;  首先，我要热烈欢迎你们加入电子</summary>
      
    
    
    
    
    <category term="学习攻略" scheme="https://rozen12123.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>cpu制作</title>
    <link href="https://rozen12123.github.io/posts/68d8d011.html"/>
    <id>https://rozen12123.github.io/posts/68d8d011.html</id>
    <published>2023-08-22T10:15:33.000Z</published>
    <updated>2023-09-12T07:55:02.905Z</updated>
    
    <content type="html"><![CDATA[<p>g</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;g&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单cpu的内部结构</title>
    <link href="https://rozen12123.github.io/posts/dee20e4.html"/>
    <id>https://rozen12123.github.io/posts/dee20e4.html</id>
    <published>2023-08-09T16:14:36.000Z</published>
    <updated>2023-08-22T10:14:22.956Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>verilog基础语法</title>
    <link href="https://rozen12123.github.io/posts/20b3f144.html"/>
    <id>https://rozen12123.github.io/posts/20b3f144.html</id>
    <published>2023-08-07T10:56:38.000Z</published>
    <updated>2023-08-09T15:51:29.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="verilog基础语法"><a href="#verilog基础语法" class="headerlink" title="verilog基础语法"></a>verilog基础语法</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Verilog 是区分大小写的。</p><h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><p>标识符（identifier）可以是任意一组字母、数字、<strong>$</strong> 符号和 <strong>_</strong>(下划线)符号的合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元符开始。</p><p>关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。</p><p>Verilog 中关键字全部为小写。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter ; <span class="comment">//reg 为关键字， counter 为标识符</span></span><br><span class="line"><span class="keyword">input</span> clk; <span class="comment">//input 为关键字，clk 为标识符</span></span><br><span class="line"><span class="keyword">input</span> CLK; <span class="comment">//CLK 与 clk是 2 个不同的标识符</span></span><br></pre></td></tr></table></figure><p>Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：</p><ul><li>0：逻辑 0 或 “假”</li><li>1：逻辑 1 或 “真”</li><li>x 或 X：未知</li><li>z 或 Z：高阻</li></ul><p><strong>x</strong> 意味着信号数值的不确定，即在实际电路里，信号可能为 1，也可能为 0。</p><p><strong>z</strong> 意味着信号处于高阻状态，常见于信号（input, reg）没有驱动时的逻辑结果。例如一个 pad 的 input 呈现高阻状态时，其逻辑值和上下拉的状态有关系。上拉则逻辑值为 1，下拉则为 0 。</p><h3 id="整数数值表示方法"><a href="#整数数值表示方法" class="headerlink" title="整数数值表示方法"></a>整数数值表示方法</h3><p>数字声明时，合法的基数格式有 4 种，包括：十进制(‘d 或 ‘D)，十六进制(‘h 或 ‘H)，二进制（’b 或 ‘B），八进制（’o 或 ‘O）。数值可指明位宽，也可不指明位宽。</p><p><strong>指明位宽：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b1011</span>         <span class="comment">// 4bit 数值</span></span><br><span class="line"><span class="number">32&#x27;h3022_c0de</span>   <span class="comment">// 32bit 的数值</span></span><br></pre></td></tr></table></figure><p><strong>不指明位宽:</strong></p><p>一般直接写数字时，默认为十进制表示，例如下面的 3 种写法是等效的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">&#x27;d100</span> ; <span class="comment">//一般会根据编译器自动分频位宽，常见的为32bit</span></span><br><span class="line">counter = <span class="number">100</span> ;</span><br><span class="line">counter = <span class="number">32&#x27;h64</span> ;</span><br></pre></td></tr></table></figure><p><code>位宽就是**内存或显存一次能传输的数据量**。 简单地讲就是一次能传递的数据宽度，就像公路的车道宽度，双向四车道、双向六车道，当然车道越多一次能通过的汽车就越大，所以位宽越大，一次性能舆的数据就越多,对显卡来说对性能的提高很明显。</code></p><p><strong>负数表示</strong></p><p>通常在表示位宽的数字前面加一个减号来表示负数。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6&#x27;d15</span>  </span><br><span class="line">-<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="实数表示方法"><a href="#实数表示方法" class="headerlink" title="实数表示方法"></a>实数表示方法</h3><p>实数表示方法主要有两种方式：</p><p><strong>科学计数法：</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="variable">.2e4</span>         <span class="comment">//大小为12000</span></span><br><span class="line"><span class="number">1_0001</span>e4      <span class="comment">//大小为100010000</span></span><br><span class="line"><span class="number">1</span>E-<span class="number">3</span>          <span class="comment">//大小为0.001</span></span><br></pre></td></tr></table></figure><h3 id="字符串表示方法"><a href="#字符串表示方法" class="headerlink" title="字符串表示方法"></a>字符串表示方法</h3><p>字符串是由双引号包起来的字符队列。字符串不能多行书写，即字符串中不能包含<code>回车符</code>。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。例如，为存储字符串 “www.runoob.com”, 需要 14*8bit 的存储单元。例如：</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;<span class="comment">//先定义字符串的大小14*8bit </span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="Verilog的数据类型"><a href="#Verilog的数据类型" class="headerlink" title="Verilog的数据类型"></a>Verilog的数据类型</h2><p>Verilog 最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。</p><h3 id="线网（wire）"><a href="#线网（wire）" class="headerlink" title="线网（wire）"></a>线网（wire）</h3><p>wire 类型表示硬件单元之间的<code>物理连线</code>，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 “Z”。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>   interrupt ;</span><br><span class="line"><span class="keyword">wire</span>   flag1, flag2 ;</span><br><span class="line"><span class="keyword">wire</span>   gnd = <span class="number">1&#x27;b0</span> ;</span><br></pre></td></tr></table></figure><p>线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等。这些数据类型用的频率不是很高，这里不做介绍。</p><h3 id="寄存器（reg）"><a href="#寄存器（reg）" class="headerlink" title="寄存器（reg）"></a>寄存器（reg）</h3><p>寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。声明举例如下：</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>    clk_temp;</span><br><span class="line"><span class="keyword">reg</span>    flag1, flag2 ;</span><br></pre></td></tr></table></figure><p>例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：</p><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> rstn ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rstn = <span class="number">1&#x27;b0</span> ;</span><br><span class="line">    #<span class="number">100</span> ;</span><br><span class="line">    rstn = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>当位宽大于 1 时，wire 或 reg 即可声明为向量的形式。例如：</p><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]      counter ;    <span class="comment">//声明4bit位宽的寄存器counter</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">32</span>-<span class="number">1</span>:<span class="number">0</span>]  gpio_data;   <span class="comment">//声明32bit位宽的线型变量gpio_data</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">2</span>]     addr ;       <span class="comment">//声明7bit位宽的线型变量addr，位宽范围为8:2</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">31</span>]     data ;       <span class="comment">//声明32bit位宽的寄存器变量data, 最高有效位为0</span></span><br></pre></td></tr></table></figure><p>对于上面的向量，我们可以指定某一位或若干相邻位，作为其他逻辑使用。例如：</p><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">9</span>:<span class="number">0</span>]     data_low = data[<span class="number">0</span>:<span class="number">9</span>] ;</span><br><span class="line">addr_temp[<span class="number">3</span>:<span class="number">2</span>] = addr[<span class="number">8</span>:<span class="number">7</span>] + <span class="number">1&#x27;b1</span> ;</span><br></pre></td></tr></table></figure><p>Verilog 支持可变的向量域选择，例如：</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]     data1 ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]      byte1 [<span class="number">3</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">integer</span> j ;</span><br><span class="line"><span class="keyword">always</span>@* <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=<span class="number">3</span>;j=j+<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        byte1[j] = data1[(j+<span class="number">1</span>)*<span class="number">8</span>-<span class="number">1</span> : j*<span class="number">8</span>]; </span><br><span class="line">        <span class="comment">//把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。</strong></p><ul><li><strong>[bit+: width]</strong> : 从起始 bit 位开始递增，位宽为 width。</li><li><strong>[bit-: width]</strong> : 从起始 bit 位开始递减，位宽为 width。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">A = data1[<span class="number">31</span>-: <span class="number">8</span>] ;</span><br><span class="line">A = data1[<span class="number">31</span>:<span class="number">24</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面 2 种赋值是等效的</span></span><br><span class="line">B = data1[<span class="number">0</span>+ : <span class="number">8</span>] ;</span><br><span class="line">B = data1[<span class="number">0</span>:<span class="number">7</span>] ;</span><br></pre></td></tr></table></figure><p><strong>对信号重新进行组合成新的向量时，需要借助大括号。例如：</strong></p><h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>]    temp1, temp2 ;</span><br><span class="line"><span class="keyword">assign</span> temp1 = &#123;byte1[<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>], data1[<span class="number">31</span>:<span class="number">8</span>]&#125;;  <span class="comment">//数据拼接</span></span><br><span class="line"><span class="keyword">assign</span> temp2 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//赋值32位的数值0</span></span><br></pre></td></tr></table></figure><h2 id="整数，实数，时间寄存器变量"><a href="#整数，实数，时间寄存器变量" class="headerlink" title="整数，实数，时间寄存器变量"></a>整数，实数，时间寄存器变量</h2><p>整数，实数，时间等数据类型实际也属于寄存器类型。</p><p><strong>整数（integer）</strong>(相当于int)</p><p>整数类型用关键字 integer 来声明。声明时不用指明位宽，位宽和编译器有关，一般为32 bit。reg 型变量为无符号数，而 integer 型变量为有符号数。例如：</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reg [31:0]      data1 ;</span><br><span class="line">reg [3:0]       byte1 [7:0]; //数组变量，后续介绍</span><br><span class="line">integer j ;  //整型变量，用来辅助生成数字电路</span><br><span class="line">always@* begin</span><br><span class="line">    for (j=0; j&lt;=3;j=j+1) begin</span><br><span class="line">        byte1[j] = data1[(j+1)*8-1 : j*8]; </span><br><span class="line">        //把data1[7:0]…data1[31:24]依次赋值给byte1[0][7:0]…byte[3][7:0]</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>此例中，integer 信号 j 作为辅助信号，将 data1 的数据依次赋值给数组 byte1。综合后实际电路里并没有 j 这个信号，j 只是辅助生成相应的硬件电路。</p><p><code>always@* begin</code>：</p><ul><li>这是一个组合逻辑块的定义，<code>always@*</code>表示该组合逻辑块会在任何输入变化时执行。</li></ul><p><strong>时序逻辑</strong>：</p><ul><li><code>always @ (posedge clk)</code> 表示在时钟上升沿触发的时序逻辑。</li><li>在时钟上升沿触发时，将执行<code>begin</code>和<code>end</code>之间的代码块。</li></ul><p><strong>实数（real）</strong></p><p>实数用关键字 real 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。例如：</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>        data1 ;</span><br><span class="line"><span class="keyword">integer</span>     temp ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    data1 = <span class="number">2</span>e3 ;</span><br><span class="line">    data1 = <span class="number">3</span><span class="variable">.75</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    temp = data1 ; <span class="comment">//temp 值的大小为3</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>时间（time）</strong></p><p>Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time$ 获取当前仿真时间。例如：</p><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span>       current_time ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">       #<span class="number">100</span> ;</span><br><span class="line">       current_time = <span class="built_in">$time</span> ; <span class="comment">//current_time 的大小为 100</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 Verilog 中允许声明 reg, wire, integer, time, real 及其向量类型的数组。</p><p>数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：<strong>&lt;数组名&gt;[&lt;下标&gt;]</strong>。对于多维数组来讲，用户需要说明其每一维的索引。例如：</p><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>          flag [<span class="number">7</span>:<span class="number">0</span>] ; <span class="comment">//8个整数组成的数组</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       counter [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个4bit计数器组成的数组</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]       addr_bus [<span class="number">3</span>:<span class="number">0</span>] ; <span class="comment">//由4个8bit wire型变量组成的数组</span></span><br><span class="line"><span class="keyword">wire</span>             data_bit[<span class="number">7</span>:<span class="number">0</span>][<span class="number">5</span>:<span class="number">0</span>] ; <span class="comment">//声明1bit wire型变量的二维数组</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]       data_4d[<span class="number">11</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>][<span class="number">255</span>:<span class="number">0</span>] ; <span class="comment">//声明4维的32bit数据变量数组</span></span><br></pre></td></tr></table></figure><p>下面显示了对数组元素的赋值操作：</p><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag [<span class="number">1</span>]   = <span class="number">32&#x27;d0</span> ; <span class="comment">//将flag数组中第二个元素赋值为32bit的0值</span></span><br><span class="line">counter[<span class="number">3</span>] = <span class="number">4&#x27;hF</span> ;  <span class="comment">//将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4&#x27;hF，即可省略宽度; </span></span><br><span class="line"><span class="keyword">assign</span> addr_bus[<span class="number">0</span>]        = <span class="number">8&#x27;b0</span> ; <span class="comment">//将数组addr_bus中第一个元素的值赋值为0</span></span><br><span class="line"><span class="keyword">assign</span> data_bit[<span class="number">0</span>][<span class="number">1</span>]     = <span class="number">1&#x27;b1</span>;  <span class="comment">//将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1&#x27;b1; 是非法的。</span></span><br><span class="line">data_4d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] = <span class="number">15&#x27;d3</span> ;  <span class="comment">//将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3</span></span><br></pre></td></tr></table></figure><p>虽然数组与向量的访问方式在一定程度上类似，但不要将向量和数组混淆。向量是一个单独的元件，位宽为 n；数组由多个元件组成，其中每个元件的位宽为 n 或 1。它们在结构的定义上就有所区别。</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。例如：</p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>               membit[<span class="number">0</span>:<span class="number">255</span>] ;  <span class="comment">//256bit的1bit存储器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>]        mem[<span class="number">0</span>:<span class="number">1023</span>] ;    <span class="comment">//1Kbyte存储器，位宽8bit</span></span><br><span class="line">mem[<span class="number">511</span>] = <span class="number">8&#x27;b0</span> ;                  <span class="comment">//令第512个8bit的存储单元值为0</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span>      data_width = <span class="number">10&#x27;d32</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span> ;</span><br><span class="line"><span class="keyword">parameter</span>      mem_size = data_width * <span class="number">10</span> ;</span><br></pre></td></tr></table></figure><p>但是，通过实例化的方式，可以更改参数在模块中的值。此部分以后会介绍。</p><p>局部参数用 localparam 来声明，其作用和用法与 parameter 相同，区别在于它的值不能被改变。所以当参数只在本模块中调用时，可用 localparam 来说明。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。</p><p>字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。例如，为存储字符串 “run.runoob.com”, 需要 14*8bit 的存储单元：</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">0</span>: <span class="number">14</span>*<span class="number">8</span>-<span class="number">1</span>]       str ;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    str = <span class="string">&quot;run.runoob.com&quot;</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>有一些特殊字符在显示字符串中有特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前面加前缀转义字符 <strong>\</strong> 。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">显示字符</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">%</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">\</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">“</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">1到3个8进制数字字符</td></tr></tbody></table></div><p>其实，在 SystemVerilog（主要用于 Verilog 仿真的编程语言）语言中，已经可以直接用关键字 string 来表示字符串变量类型，这为 Verilog 的仿真带来了极大的便利。有兴趣的学者可以简单学习下 SystemVerilog。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a^b ;          <span class="comment">//a与b进行异或操作</span></span><br><span class="line">address[<span class="number">9</span>:<span class="number">0</span>] + <span class="number">10&#x27;b1</span> ;  <span class="comment">//地址累加</span></span><br><span class="line">flag1 &amp;&amp; flag2 ;  <span class="comment">//逻辑与操作</span></span><br></pre></td></tr></table></figure><h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。</p><p>操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。</p><h2 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//实数</span></span><br><span class="line"><span class="keyword">real</span> a, b, c;</span><br><span class="line">c = a + b ;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">3</span>:<span class="number">0</span>]       cprmu_1, cprmu_2 ;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cprmu_2 = cprmu_1 ^ cprmu_2 ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">reg</span>  flag1 ;</span><br><span class="line">flag = calculate_result(A, B);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//非法操作数</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]         res;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]        temp;</span><br><span class="line"><span class="keyword">always</span>@ （*）<span class="keyword">begin</span></span><br><span class="line">    res    = cprmu_2 – cprmu_1 ;</span><br><span class="line">    <span class="comment">//temp = cprmu_2 – cprmu_1 ; //不合法，always块里赋值对象不能是wire型</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。</p><p>大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符从右往左关联，其余操作符都是自左向右关联。圆括号内表达式优先执行。例如下面每组的 2 种写法都是等价的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自右向左关联，两种写法等价</span></span><br><span class="line">A+B-C ;</span><br><span class="line">(A+B）-C ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法等价，结果为 B、D 或 F</span></span><br><span class="line">A ? B : C ? D : F ;</span><br><span class="line">A ? B : (C ? D : F) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自右向左关联，两种写法不等价</span></span><br><span class="line">(A ? B : C) ? D : F ;  <span class="comment">//结果 D 或 F</span></span><br><span class="line">A ? B : C ? D : F ; <span class="comment">//结果为 B、D 或 F</span></span><br></pre></td></tr></table></figure><p>不同操作符之间，优先级是不同的。下表列出了操作符优先级从高至低的排列顺序。当没有圆括号时，Verilog 会根据操作符优先级对表达式进行计算。为了避免由操作符优先级导致的计算混乱，在不确定优先级时，建议用圆括号将表达式区分开来。</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">操作符号</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">单目运算</td><td style="text-align:left">+ - ! ~</td><td style="text-align:left">最高</td></tr><tr><td style="text-align:left">乘、除、取模</td><td style="text-align:left">* / %</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt;  &gt;&gt;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">等价</td><td style="text-align:left">== != === !===</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">归约</td><td style="text-align:left">&amp; ~&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">^ ~^</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">~\</td><td></td><td></td></tr><tr><td style="text-align:left">逻辑</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">\</td><td style="text-align:left">\</td><td></td><td></td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">最低</td></tr></tbody></table></div><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>算术操作符包括单目操作符和双目操作符。</p><p>双目操作符对 2 个操作数进行算术运算，包括乘（<em>）、除（/）、加（+）、减（-）、求幂（*</em>）、取模（%）。</p><h2 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  a, b;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]  c ;</span><br><span class="line">a = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">b = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">c = a+b;        <span class="comment">//结果为c=b&#x27;b1011</span></span><br><span class="line">c = a/b;          <span class="comment">//结果为c=4，取整</span></span><br></pre></td></tr></table></figure><p>如果操作数某一位为 X，则计算结果也会全部出现 X。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">4&#x27;b100x</span> ;</span><br><span class="line">c = a+b ;       <span class="comment">//结果为c=4&#x27;bxxxx</span></span><br></pre></td></tr></table></figure><p>对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。上述例子中，相加的 2 个变量位宽为 4bit，那么结果寄存器变量位宽最少为 5bit。否则，高位将被截断，导致结果高位丢失。无符号数乘法时，结果变量位宽应该为 2 个操作数位宽之和。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]        mula ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]        mulb;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>]        res ;</span><br><span class="line">mula = <span class="number">4&#x27;he</span>   ;</span><br><span class="line">mulb = <span class="number">2&#x27;h3</span>   ;</span><br><span class="line">res  = mula * mulb ; <span class="comment">//结果为res=6&#x27;h2a, 数据结果没有丢失位数</span></span><br></pre></td></tr></table></figure><p>+ 和 - 也可以作为单目操作符来使用，表示操作数的正负性。此类操作符优先级最高。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">4</span>  <span class="comment">//表示负4</span></span><br><span class="line">+<span class="number">3</span>  <span class="comment">//表示正3</span></span><br></pre></td></tr></table></figure><p>负数表示时，可以直接在十进制数字前面增加一个减号 <strong>-</strong>，也可以指定位宽。因为负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mula = -<span class="number">4&#x27;d4</span> ;</span><br><span class="line">mulb = <span class="number">2</span> ;</span><br><span class="line">res = mula * mulb ;      <span class="comment">//计算结果为res=-6&#x27;d8, 即res=6&#x27;h38，正常</span></span><br><span class="line">res = mula * (-<span class="number">&#x27;d4</span>) ;    <span class="comment">//(4的32次幂-4) * 2, 结果异常</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符有大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=）。</p><p>关系操作符的正常结果有 2 种，真（1）或假（0）。</p><p>如果操作数中有一位为 x 或 z，则关系表达式的结果为 x。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">3</span> ;</span><br><span class="line">X = <span class="number">3&#x27;b1xx</span> ;</span><br><span class="line">    </span><br><span class="line">A &gt; B     <span class="comment">//为真</span></span><br><span class="line">A &lt;= B    <span class="comment">//为假</span></span><br><span class="line">A &gt;= Z    <span class="comment">//为X，不确定</span></span><br></pre></td></tr></table></figure><h3 id="等价操作符"><a href="#等价操作符" class="headerlink" title="等价操作符"></a>等价操作符</h3><p>等价操作符包括逻辑相等（ == ） ，逻辑不等（!=），全等（ ===  ），非全等（  !  ）。</p><p>等价操作符的正常结果有 2 种：为真（1）或假（0）。</p><p>逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。</p><p>全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x。举例如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4</span> ;</span><br><span class="line">B = <span class="number">8&#x27;h04</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bxxxx</span> ;</span><br><span class="line">D = <span class="number">4&#x27;hx</span> ;</span><br><span class="line">A == B        <span class="comment">//为真</span></span><br><span class="line">A == (B + <span class="number">1</span>)  <span class="comment">//为假</span></span><br><span class="line">A == C        <span class="comment">//为X，不确定</span></span><br><span class="line">A === C       <span class="comment">//为假，返回值为0</span></span><br><span class="line">C === D       <span class="comment">//为真，返回值为1</span></span><br></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符主要有 3 个：&amp;&amp;（逻辑与）, ||（逻辑或），!（逻辑非）。</p><p>逻辑操作符的计算结果是一个 1bit 的值，0 表示假，1 表示真，x 表示不确定。</p><p>如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0。如果它任意一位为 x 或 z，它等价于 x。</p><p>如果任意一个操作数包含 x，逻辑操作符运算结果不一定为 x。</p><p>逻辑操作符的操作数可以为变量，也可以为表达式。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">3</span>; </span><br><span class="line">B = <span class="number">0</span>; </span><br><span class="line">C = <span class="number">2&#x27;b1x</span> ;</span><br><span class="line">    </span><br><span class="line">A &amp;&amp; B    <span class="comment">//     为假</span></span><br><span class="line">A || B    <span class="comment">//     为真</span></span><br><span class="line">! A       <span class="comment">//     为假</span></span><br><span class="line">! B       <span class="comment">//     为真</span></span><br><span class="line">A &amp;&amp; C    <span class="comment">//     为X，不确定</span></span><br><span class="line">A || C    <span class="comment">//     为真，因为A为真</span></span><br><span class="line">(A==<span class="number">2</span>) &amp;&amp; (! B)  <span class="comment">//为真，此时第一个操作数为表达式</span></span><br></pre></td></tr></table></figure><h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><p>按位操作符包括：取反（~），与（&amp;），或（|），异或（^），同或（~^）。</p><p>按位操作符对 2 个操作数的每 1bit 数据进行按位操作。</p><p>如果 2 个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。</p><p>取反操作符只有一个操作数，它对操作数的每 1bit 数据进行取反操作。</p><p>下图给出了按位操作符的逻辑规则。</p><div class="table-container"><table><thead><tr><th style="text-align:left">&amp;(与）</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">\</th><th style="text-align:left">(或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th>x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">^(异或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th><th style="text-align:left"></th><th style="text-align:left">~^(同或)</th><th style="text-align:left">0</th><th style="text-align:left">1</th><th style="text-align:left">x</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left"></td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td><td style="text-align:left">x</td></tr></tbody></table></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b0101</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">C = <span class="number">4&#x27;bx010</span> ;</span><br><span class="line">    </span><br><span class="line">~A        <span class="comment">//4&#x27;b1010</span></span><br><span class="line">A &amp; B     <span class="comment">//4&#x27;b0001</span></span><br><span class="line">A | B     <span class="comment">//4&#x27;b1101</span></span><br><span class="line">A^B       <span class="comment">//4&#x27;b1100</span></span><br><span class="line">A ~^ B    <span class="comment">//4&#x27;b0011</span></span><br><span class="line">B | C     <span class="comment">//4&#x27;b1011</span></span><br><span class="line">B&amp;C       <span class="comment">//4&#x27;bx000</span></span><br></pre></td></tr></table></figure><h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><p>归约操作符包括：归约与（&amp;），归约与非（~&amp;），归约或（|），归约或非（~|），归约异或（^），归约同或（~^）。</p><p>归约操作符只有一个操作数，它对这个向量操作数逐位进行操作，最终产生一个 1bit 结果。</p><p>逻辑操作符、按位操作符和归约操作符都使用相同的符号表示，因此有时候容易混淆。区分这些操作符的关键是分清操作数的数目，和计算结果的规则。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">&amp;A ;      <span class="comment">//结果为 1 &amp; 0 &amp; 1 &amp; 0 = 1&#x27;b0，可用来判断变量A是否全1</span></span><br><span class="line">~|A ;     <span class="comment">//结果为 ~(1 | 0 | 1 | 0) = 1&#x27;b0, 可用来判断变量A是否为全0</span></span><br><span class="line">^A ;      <span class="comment">//结果为 1 ^ 0 ^ 1 ^ 0 = 1&#x27;b0</span></span><br></pre></td></tr></table></figure><h3 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h3><p>移位操作符包括左移（&lt;&lt;），右移（&gt;&gt;），算术左移（&lt;&lt;&lt;），算术右移（&gt;&gt;&gt;）。</p><p>移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。</p><p>算术左移和逻辑左移时，右边低位会补 0。</p><p>逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1100</span> ;</span><br><span class="line">B = <span class="number">4&#x27;b0010</span> ;</span><br><span class="line">A = A &gt;&gt; <span class="number">2</span> ;        <span class="comment">//结果为 4&#x27;b0011</span></span><br><span class="line">A = A &lt;&lt; <span class="number">1</span>;         <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">A = A &lt;&lt;&lt; <span class="number">1</span> ;       <span class="comment">//结果为 4&#x27;b1000</span></span><br><span class="line">C = B + (A&gt;&gt;&gt;<span class="number">2</span>);    <span class="comment">//结果为 2 + (-4/4) = 1, 4&#x27;b0001</span></span><br></pre></td></tr></table></figure><h3 id="拼接操作符"><a href="#拼接操作符" class="headerlink" title="拼接操作符"></a>拼接操作符</h3><p>拼接操作符用大括号 <strong>{，}</strong> 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。</p><p>拼接符操作数必须指定位宽，常数的话也需要指定位宽。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">4&#x27;b1010</span> ;</span><br><span class="line">B = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">Y1 = &#123;B, A[<span class="number">3</span>:<span class="number">2</span>], A[<span class="number">0</span>], <span class="number">4&#x27;h3</span> &#125;;  <span class="comment">//结果为Y1=&#x27;b1100_0011</span></span><br><span class="line">Y2 = &#123;<span class="number">4</span>&#123;B&#125;, <span class="number">3&#x27;d4</span>&#125;;  <span class="comment">//结果为 Y2=7&#x27;b111_1100</span></span><br><span class="line">Y3 = &#123;<span class="number">32</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;  <span class="comment">//结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值</span></span><br></pre></td></tr></table></figure><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件表达式有 3 个操作符，结构描述如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition_expression ? true_expression : false_expression</span><br></pre></td></tr></table></figure><p>计算时，如果 condition_expression 为真（逻辑值为 1），则运算结果为 true_expression；如果 condition_expression 为假（逻辑值为 0），则计算结果为 false_expression。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> hsel    = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b0</span>) ? hsel_p1 : hsel_p2 ;</span><br><span class="line"><span class="comment">//当信号 addr 高 2bit 为 0 时，hsel 赋值为 hsel_p1; 否则，将 hsel_p2 赋值给 hsel。</span></span><br></pre></td></tr></table></figure><p>其实，条件表达式类似于 2 路（或多路）选择器，其描述方式完全可以用 if-else 语句代替。</p><p>当然条件操作符也能进行嵌套，完成一个多次选择的逻辑。例如：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span>   hsel = (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b00</span>) ? hsel_p1 : </span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b01</span>) ? hsel_p2 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b10</span>) ? hsel_p3 :</span><br><span class="line">                (addr[<span class="number">9</span>:<span class="number">8</span>] == <span class="number">2&#x27;b11</span>) ? hsel_p4 ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;verilog基础语法&quot;&gt;&lt;a href=&quot;#verilog基础语法&quot; class=&quot;headerlink&quot; title=&quot;verilog基础语法&quot;&gt;&lt;/a&gt;verilog基础语法&lt;/h1&gt;&lt;h2 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>verilog</title>
    <link href="https://rozen12123.github.io/posts/ffaf1e77.html"/>
    <id>https://rozen12123.github.io/posts/ffaf1e77.html</id>
    <published>2023-08-07T09:51:42.000Z</published>
    <updated>2023-08-09T15:51:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartus"><a href="#Quartus" class="headerlink" title="Quartus"></a>Quartus</h1><h3 id="使用—全加器"><a href="#使用—全加器" class="headerlink" title="使用—全加器"></a>使用—全加器</h3><h3 id="原理图方式（而输入或门）"><a href="#原理图方式（而输入或门）" class="headerlink" title="原理图方式（而输入或门）"></a>原理图方式（而输入或门）</h3><p><img src="/posts/ffaf1e77.htm/image-20230807180738812.png" alt="image-20230807180738812" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181223960.png" alt="image-20230807181223960" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181408224.png" alt="image-20230807181408224" style="zoom:50%;"></p><p>然后完成一个2选1的原理图</p><p><img src="/posts/ffaf1e77.htm/image-20230807181746258.png" alt="image-20230807181746258" style="zoom:50%;"></p><p>然后点击new选择University Program VWF</p><p><img src="/posts/ffaf1e77.htm/image-20230807181829430.png" alt="image-20230807181829430" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807181944693.png" alt="image-20230807181944693" style="zoom:50%;"></p><p><img src="/posts/ffaf1e77.htm/image-20230807182059221.png" alt="image-20230807182059221" style="zoom:50%;"></p><p>将其全部移入</p><p><img src="/posts/ffaf1e77.htm/image-20230807182228594.png" alt="image-20230807182228594" style="zoom:50%;"></p><p>选择器件然后点击设置时间。</p><p><img src="/posts/ffaf1e77.htm/image-20230807182426708.png" alt="image-20230807182426708" style="zoom:50%;"></p><h3 id="用verilog进行电路设计"><a href="#用verilog进行电路设计" class="headerlink" title="用verilog进行电路设计"></a>用verilog进行电路设计</h3><p><img src="/posts/ffaf1e77.htm/image-20230807183308472.png" alt="image-20230807183308472" style="zoom:50%;"></p><p>右击选择Insert Template</p><p><img src="/posts/ffaf1e77.htm/image-20230807183728558.png" alt="image-20230807183728558" style="zoom:50%;"></p><p>！！Verilog HDL要求module描述的实例名称必须与储存文件名一致，我们将程序性稍做修改</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quartus II Verilog Template</span></span><br><span class="line"><span class="comment">// Signed adder/subtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder_sub</span><br><span class="line">#(<span class="keyword">parameter</span> WIDTH=<span class="number">16</span>)</span><br><span class="line">(</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] datab,</span><br><span class="line"><span class="keyword">input</span> add_sub,  <span class="comment">// if this is 1, add; else subtract</span></span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (add_sub)</span><br><span class="line">result &lt;= dataa + datab;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result &lt;= dataa - datab;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>Verilog HDL程序是以module为基本单位的，形式上以$module<name>$开头,以$endmodule$结尾，模块名称$name$可以由设计者自定，并要求和文件存储名称一致。</name></p></li><li><p>$module<name>$和$endmodule$之间成为<code>模块实体</code>，其包括输入输出端口及数据类型描述，接下来是实际语句体描述。输入输出端口数据名称和类型的描述，要放在模块名称后面，并且用括号括起来。</name></p></li><li><p>输入/输出/双向端口变量描述一般以如下形式，不同端口之间要用逗号<code>，</code>隔开</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">signed</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] dataa,</span><br><span class="line"><span class="comment">//output 变量宽度 变量名称</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH:<span class="number">0</span>] result</span><br><span class="line"><span class="comment">//bidir 变量宽度 变量名称</span></span><br></pre></td></tr></table></figure></li><li><p>Verilog HDL中主要有两种类型<code>导线型</code>$wire$和<code>寄存器型</code>$reg$。在端口变量描述中$wire$可以省略。</p><p>各种类型容纳变量都是容纳的二进制数，他们能够纳二进制数的位数称之为<code>线宽</code></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如[7:0],表示有8位宽度的向量，内部的二进制数或存放二进制数的位置编号是7，6，5，4，3，2，1，0</span></span><br></pre></td></tr></table></figure></li><li><p>形参要用parameter保留字来定义，形式为：$parameter 形参名称 = 常数$，大多数情况下形参都用大写字母来表示</p></li><li><p>$lways @ (posedge clk)$是一个结构体语句的头，有多个语句时要用$begin … end$语句括起来，其代表只要clk上升沿到来，该$begin … end$语句体的内容就会被执行一遍。always语句括号内的变量成为敏感变量，多个敏感变量同时存在，用<code>or</code>或者<code>，</code>分开。$posedge$和$negedge$必须在每个敏感变量之前修饰，如果下降沿有效则用$negedge$修饰。</p></li><li><p>$always$中的语句都是按顺序执行的。</p></li><li><p>这个Add_Sub程序中设计了一个16位的加减法运算器，输入输出端口有两个16位的数据导线$dataa$和$datab$一个时钟输入导线$clk$，一个控制选择加减法运算的导线Sub，输出端口是一个16位的寄存器$result$。每当时钟上升沿到来的时刻，依据Sub为0还是1进行加法或者减法运算，并且将结果送到$result$寄存器。</p></li></ol><p>&nbsp;</p><p><img src="/posts/ffaf1e77.htm/image-20230807220923070.png" alt="image-20230807220923070" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartus&quot;&gt;&lt;a href=&quot;#Quartus&quot; class=&quot;headerlink&quot; title=&quot;Quartus&quot;&gt;&lt;/a&gt;Quartus&lt;/h1&gt;&lt;h3 id=&quot;使用—全加器&quot;&gt;&lt;a href=&quot;#使用—全加器&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="verilog" scheme="https://rozen12123.github.io/tags/verilog/"/>
    
  </entry>
  
  <entry>
    <title>acfly飞控</title>
    <link href="https://rozen12123.github.io/posts/a4e8942.html"/>
    <id>https://rozen12123.github.io/posts/a4e8942.html</id>
    <published>2023-07-29T13:25:07.000Z</published>
    <updated>2023-08-09T15:51:29.039Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>立创eda专业版</title>
    <link href="https://rozen12123.github.io/posts/9c8613dc.html"/>
    <id>https://rozen12123.github.io/posts/9c8613dc.html</id>
    <published>2023-07-25T09:58:36.000Z</published>
    <updated>2023-08-11T12:26:02.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="立创eda专业版"><a href="#立创eda专业版" class="headerlink" title="立创eda专业版"></a>立创eda专业版</h1><h2 id="1-新建文档"><a href="#1-新建文档" class="headerlink" title="1.新建文档"></a>1.新建文档</h2><p>创建工程，命名规则如下</p><p>文件名-版本-日期</p><p>例如：GD32F230C8T6-V1.0.0-20230725</p><p>&nbsp;</p><h2 id="2-原理图设计环境设置"><a href="#2-原理图设计环境设置" class="headerlink" title="2.原理图设计环境设置"></a>2.原理图设计环境设置</h2><p>设置—&gt;常规—&gt;设置原理图尺寸为0.1</p><p>保存—&gt;自动保存</p><p><img src="/posts/9c8613dc.htm/image-20230725180844637.png" alt="image-20230725180844637" style="zoom: 50%;"></p><p><img src="/posts/9c8613dc.htm/image-20230725181110414.png" alt="image-20230725181110414" style="zoom:50%;"></p><p>右方图页中可以更改相关信息，例如图纸尺寸，以及右下角的各种信息。</p><p><img src="/posts/9c8613dc.htm/image-20230725182334274.png" alt="image-20230725182334274" style="zoom:50%;"></p><p>&nbsp;</p><h2 id="3-电源转换电路"><a href="#3-电源转换电路" class="headerlink" title="3.电源转换电路"></a>3.电源转换电路</h2><p>在库中，选择器件进行原理图绘制，同时在绘制原理图时要注意对应的封装。</p><p>寻找元器件不仅可以通过==元器件的名称==去找，还可以通过==供应商编号==去找。</p><p><img src="/posts/9c8613dc.htm/image-20230725184044652.png" alt="image-20230725184044652" style="zoom:50%;"></p><p>并且通过折线和文本进行模块化的标注。</p><h2 id="4-查找元器件"><a href="#4-查找元器件" class="headerlink" title="4.查找元器件"></a>4.查找元器件</h2><p>当供应商编号查找不到元器件时，假如是0.1uf的电容，我们可以在立创商城中找到响应的替代品，复制其的器件型号，在专业版的库中进行查找。</p><p>&nbsp;</p><h2 id="5-更改网络标签"><a href="#5-更改网络标签" class="headerlink" title="5.更改网络标签"></a>5.更改网络标签</h2><p>点击网络标签出现预览按钮以后按住tab键即可</p><p>&nbsp;</p><h2 id="原理图转pcb"><a href="#原理图转pcb" class="headerlink" title="原理图转pcb"></a>原理图转pcb</h2><h3 id="1-设置板框"><a href="#1-设置板框" class="headerlink" title="1.设置板框"></a>1.设置板框</h3><p>放置—&gt;板框—&gt;矩形</p><p><img src="/posts/9c8613dc.htm/image-20230725203709836.png" alt="image-20230725203709836" style="zoom:50%;"></p><p>当然我们也可用通过右侧的矩形轮廓，修改板框的大小。</p><p>单击板框右键—&gt;添加—&gt;添加圆角，即可设置板框为圆角</p><p>&nbsp;</p><h3 id="2-规则设置"><a href="#2-规则设置" class="headerlink" title="2.规则设置"></a>2.规则设置</h3><p>设计—&gt;设计规则—&gt;导线设置为8mil—&gt;全部设置为8mil</p><p>设置导线，最小，默认，最大分别为10，10，30</p><p><img src="/posts/9c8613dc.htm/image-20230725205824273.png" alt="image-20230725205824273" style="zoom:50%;"></p><p>添加一个导线规则，最小，默认，最大分别设为10，30，30</p><p><img src="/posts/9c8613dc.htm/image-20230725210044705.png" alt="image-20230725210044705" style="zoom:50%;"></p><p>过孔尺寸按如下设置即可</p><p><img src="/posts/9c8613dc.htm/image-20230725210222093.png" alt="image-20230725210222093" style="zoom:50%;"></p><p>铺铜规则—-&gt;网络间隔和到边框均改为20</p><p><img src="/posts/9c8613dc.htm/image-20230725211405979.png" alt="image-20230725211405979" style="zoom:50%;"></p><p>之后，在网络规则中进行设置</p><p>&nbsp;</p><h3 id="3-绘制定位孔"><a href="#3-绘制定位孔" class="headerlink" title="3.绘制定位孔"></a>3.绘制定位孔</h3><p><code>放置</code>——&gt;<code>挖槽区域</code>——&gt;<code>圆孔</code></p><p><img src="/posts/9c8613dc.htm/image-20230811190718746.png" alt="image-20230811190718746" style="zoom:50%;"></p><p>在右侧可以设置相关参数</p><p><img src="/posts/9c8613dc.htm/image-20230811190950371.png" alt="image-20230811190950371" style="zoom:50%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="4-绘制OLED模块定位孔"><a href="#4-绘制OLED模块定位孔" class="headerlink" title="4.绘制OLED模块定位孔"></a>4.绘制OLED模块定位孔</h3><h4 id="丝印边框"><a href="#丝印边框" class="headerlink" title="丝印边框"></a>丝印边框</h4><p><img src="/posts/9c8613dc.htm/image-20230811191917326.png" alt="image-20230811191917326" style="zoom:67%;"></p><p>1.选择顶层丝印层—&gt;2.网格类型选用正方形—&gt;3.选择为矩形</p><p>&nbsp;</p><h3 id="5-布局"><a href="#5-布局" class="headerlink" title="5.布局"></a>5.布局</h3><p>在原理图中选择<code>对应元器件</code>—-&gt;<code>设计</code>—&gt;<code>布局传递</code></p><p>这样回到pcb图就会自动选择相关元器件</p><p><img src="/posts/9c8613dc.htm/image-20230811192421560.png" alt="image-20230811192421560" style="zoom:67%;"></p><p>ps：丝印放置规则，横着为从左到右，竖着为从上到下</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="6-布线"><a href="#6-布线" class="headerlink" title="6.布线"></a>6.布线</h3><p>常用<code>焊盘</code>，<code>过孔</code>,<code>单路布线</code></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="7-修改位号丝印大小"><a href="#7-修改位号丝印大小" class="headerlink" title="7.修改位号丝印大小"></a>7.修改位号丝印大小</h3><p>右键丝印点击查找</p><p><img src="/posts/9c8613dc.htm/image-20230811201254714.png" alt="image-20230811201254714" style="zoom:50%;"></p><p>查找—-&gt;查找全部—&gt;线宽8mil—&gt;线高70mil</p><p>&nbsp;</p><h3 id="8-添加丝印"><a href="#8-添加丝印" class="headerlink" title="8.添加丝印"></a>8.添加丝印</h3><p><img src="/posts/9c8613dc.htm/image-20230811201619036.png" alt="image-20230811201619036" style="zoom:67%;"></p><p><img src="/posts/9c8613dc.htm/image-20230811201740095.png" alt="image-20230811201740095" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="9-泪滴"><a href="#9-泪滴" class="headerlink" title="9.泪滴"></a>9.泪滴</h3><p><img src="/posts/9c8613dc.htm/image-20230811201848466.png" alt="image-20230811201848466" style="zoom:67%;"></p><p>&nbsp;</p><h3 id="10-铺铜"><a href="#10-铺铜" class="headerlink" title="10.铺铜"></a>10.铺铜</h3><p>点击选择矩形</p><p><img src="/posts/9c8613dc.htm/image-20230811202050096.png" alt="image-20230811202050096" style="zoom:67%;"></p><p>网络选择GND</p><p>图层顶层和底层分别进行铺铜，如果顶层有大面积没有铺铜，在此区域添加过孔然后继续铺铜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;立创eda专业版&quot;&gt;&lt;a href=&quot;#立创eda专业版&quot; class=&quot;headerlink&quot; title=&quot;立创eda专业版&quot;&gt;&lt;/a&gt;立创eda专业版&lt;/h1&gt;&lt;h2 id=&quot;1-新建文档&quot;&gt;&lt;a href=&quot;#1-新建文档&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="eda" scheme="https://rozen12123.github.io/tags/eda/"/>
    
  </entry>
  
  <entry>
    <title>k210与esp32串口通信</title>
    <link href="https://rozen12123.github.io/posts/bfa0354e.html"/>
    <id>https://rozen12123.github.io/posts/bfa0354e.html</id>
    <published>2023-07-07T07:22:55.000Z</published>
    <updated>2023-07-12T13:50:22.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k210与esp32串口通信"><a href="#k210与esp32串口通信" class="headerlink" title="k210与esp32串口通信"></a>k210与esp32串口通信</h1><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO，<strong>外部I对应上图K210的IO而非Maxiduino</strong></p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>&nbsp;</p><h2 id="maxiduino与电脑串口进行通信"><a href="#maxiduino与电脑串口进行通信" class="headerlink" title="maxiduino与电脑串口进行通信"></a>maxiduino与电脑串口进行通信</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">11</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">10</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello word!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="esp32-s3与电脑串口进行通信"><a href="#esp32-s3与电脑串口进行通信" class="headerlink" title="esp32_s3与电脑串口进行通信"></a>esp32_s3与电脑串口进行通信</h2><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://blog.csdn.net/Naisu_kun/article/details/86004049">(8条消息) 使用Arduino开发ESP32（02）：串口（Serial port）使用说明_arduino esp32 serial_Naisu Xu的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_50064262/article/details/119006749">(8条消息) ESP32 之 ESP-IDF 教学（九）—— 串口通信（UART）_esp32 idf 串口_Augtons正(单片机)的博客-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1A3411Z7gd/?spm_id_from=333.880.my_history.page.click&amp;vd_source=db4533a45f532ba6c1133faafbf7f171">40 ESP32之UART串口简介 - 基于Arduino_哔哩哔哩_bilibili</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k210与esp32串口通信&quot;&gt;&lt;a href=&quot;#k210与esp32串口通信&quot; class=&quot;headerlink&quot; title=&quot;k210与esp32串口通信&quot;&gt;&lt;/a&gt;k210与esp32串口通信&lt;/h1&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32_s3多任务处理</title>
    <link href="https://rozen12123.github.io/posts/a1417d5c.html"/>
    <id>https://rozen12123.github.io/posts/a1417d5c.html</id>
    <published>2023-07-05T13:07:40.000Z</published>
    <updated>2023-07-06T07:47:38.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-S3多任务处理"><a href="#esp32-S3多任务处理" class="headerlink" title="esp32_S3多任务处理"></a>esp32_S3多任务处理</h1><h2 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2><ul><li>多任务的概念：同一时间内执行多个任务，它充分利用CPU资源，提高程序的执行效率。</li><li>对于单核CPU处理多任务，操作系统会给每个运行的任务一小段运行的时间，时间一到，然后立马切换任务，由于交替切换的速度过快，以人的眼光去看感觉每个程序都是同时执行的错觉。</li><li>相对于多核CPU，操作系统会给每个内核安排一个执行的软件同时运行，从而达到同一个时间内执行多任务的效果。</li><li>ESP32的任务和操作系统的进程的概念是一样的</li></ul><ul><li>ESP32有两颗CPU，包含ProtocolcPU（称为CPUO或PRO_CPU）和ApplicationcPu（称为CPU1或APP_CPU）。这两个核实际上是相同的，并且共享相同的内存</li><li>我们之前用的setup和loop方法都是在CPU1上执行的CPUO一直不干活，我们要使用多任务让它动起来。</li><li>保证所有的任务都以合理正确的速率推进，不被其它任务所阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void1oop（）&#123;</span><br><span class="line">task1（）<span class="comment">//这个需要较长的操作，比如59oms</span></span><br><span class="line">task2（）；<span class="comment">//这个需要50ms执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如上代码，任务一的时间较长，但任务二时间较短，就会有一定冲突。此时就适合双线程来完成任务。</p><h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>参考：<a href="https://blog.csdn.net/a568713197/article/details/81542772">(8条消息) UCOS学习笔记（四）时间片轮转调度_ucosii时间片轮转调度_爱吃肉的大高个的博客-CSDN博客</a></p><h3 id="多任务处理相关函数"><a href="#多任务处理相关函数" class="headerlink" title="多任务处理相关函数"></a>多任务处理相关函数</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">tXTaskCreatePinnedToCore</span><span class="params">(TaskFunctiont_t pvTaskcode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="type">const</span> <span class="type">uint32_t</span> usstackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> pvParameters,UBaseType_t uxPriority,TaskHandle_t <span class="type">const</span> pvCreatedTask,<span class="type">const</span> BaseType_t xCoreID)</span>；</span><br></pre></td></tr></table></figure><ul><li>pvTaskCode：指向任务输入函数的指针。任务必须被实现为永不Return（如：死循环），或者应该使用</li><li>vtTaskDelete:函数终止</li><li>pcName：该任务的描述性名称，最大长度16字节</li><li>usStackDepth：指定为字节数的任务堆栈的大小</li><li>pvParameters：将用作所创建的任务的参数的指针，在创建任务的时候可以向任务传递参数。</li><li>uxPriority：任务运行的优先级。目前ESP32的优先级有25级，0-24，数字越大优先级越高，Idle为0，loop任务的优先级是1</li><li>pvCreatedTask：用于传递回所创建任务的句柄</li><li>xCoreID：如果值为tskNOAFFINITY，则创建的任务不会固定到任何CPU，调度程序可以在任何可用的核心上运行。值0或1表示任务应固定到的CPU的索引编号。指定大于（portNUMPROCESSORS-1）的值将导致函数失败</li><li>函数成功返回pdPASS，其它值都是失败。</li></ul><h4 id="任务函数原型"><a href="#任务函数原型" class="headerlink" title="任务函数原型"></a>任务函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> task（<span class="type">void</span>* param）;</span><br></pre></td></tr></table></figure><h4 id="获取任务的优先级"><a href="#获取任务的优先级" class="headerlink" title="获取任务的优先级"></a>获取任务的优先级</h4><p>如果在任务函数里获取本任务的优先级可以使用uxTaskPriorityGet（NULL）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(<span class="type">const</span> TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure><h4 id="获取本任务在哪个CPU上运行"><a href="#获取本任务在哪个CPU上运行" class="headerlink" title="获取本任务在哪个CPU上运行"></a>获取本任务在哪个CPU上运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t IRAM_ATTR <span class="title function_">xPortGetcoreID</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h4><p>如果在任务函数体内使用vTaskDelete（NULL）来结束本任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="互斤量（xSemaphoreHandle）"><a href="#互斤量（xSemaphoreHandle）" class="headerlink" title="互斤量（xSemaphoreHandle）"></a>互斤量（xSemaphoreHandle）</h3><p>互压量又称互床信号量（本质是信号量），是一种特殊的二值信号量，它用于实现对临界资源的独占式处理（它不会屏蔽CPU的中断处理）任意时刻互压量的状态只有两种，开锁或闭锁。当互斤量被任务持有时，该互压量处于闭锁状态，这个任务获得互压量的所有权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle<span class="comment">//互斤锁，也算是一种信号量</span></span><br></pre></td></tr></table></figure><p>创建一个互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle xMutex = xSemaphoreCreateMutex()</span><br></pre></td></tr></table></figure><p>获取互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake (xSemaphore,xBlockTime)</span><br></pre></td></tr></table></figure><p>功能：在普通任务中获取信号量<br>参数：xSemaphore信号量句柄<br>           xBlockTime等待的节拍数，立即返回，portMAX_DELAY等待到信号到来<br>ESP32默认的一节拍是1ms<br>返回值：pdTRUE：获取成功1pdFALSE：获取失败</p><p>释放互压锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive（xSemaphore）</span><br></pre></td></tr></table></figure><p>功能：在普通任务中释放信号量，也就是将信号量设为有信号的状态返回值：pdTRUE：设置成功 ，pdFALSE：设置失败</p><p>&nbsp;</p><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (xSemaphoreTake(xMutex,portMAX_DELAY))</span><br><span class="line">//临界资源处理</span><br><span class="line">xSemaphoreGive(xMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line">xSemaphoreHandle xMutex; <span class="comment">//互斥量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;          <span class="comment">//互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = *((<span class="type">int</span>*)param);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.print(<span class="string">&quot;I am task1, Param: &quot;</span>);</span><br><span class="line">    Serial.print(p);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot; number: %d&quot;</span>, number);</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println();</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.println(<span class="string">&quot;I am task2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      number++;</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  </span><br><span class="line">  TaskHandle_t handle1;</span><br><span class="line">  <span class="type">int</span> param = <span class="number">30</span>;</span><br><span class="line">  xMutex = xSemaphoreCreateMutex();</span><br><span class="line">  xTaskCreatePinnedToCore(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;param, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line">  xTaskCreatePinnedToCore(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; I am loop &quot;</span>, core);</span><br><span class="line">  <span class="keyword">auto</span> pri = uxTaskPriorityGet(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot; priority: %d&quot;</span>, pri);</span><br><span class="line">  Serial.println();</span><br><span class="line">  delay(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">//一个任务的delay不会影响到其它任务的运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY))&#123; </span><br><span class="line"><span class="comment">//临界资源处理</span></span><br><span class="line">xSemaphoreGive（xMutex）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多并行任务创建"><a href="#多并行任务创建" class="headerlink" title="多并行任务创建"></a>多并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_FREERTOS_UNICORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FreeRTOS任务优先级：任务优先级数值越小，任务优先级越低。</span></span><br><span class="line"><span class="comment">一、 FreeRTOS 中任务的最高优先级是通过 FreeRTOSConfig.h 文件中的 configMAX_PRIORITIES 进行</span></span><br><span class="line"><span class="comment">配置的，用户实际可以使用的优先级范围是 0 到 configMAX_PRIORITIES – 1。比如我们配置此宏定</span></span><br><span class="line"><span class="comment">义为 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5。</span></span><br><span class="line"><span class="comment">二、用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0。</span></span><br><span class="line"><span class="comment">三、用户配置宏定义 configMAX_PRIORITIES 的最大值不要超过 32，即用户任务可以使用的优先级</span></span><br><span class="line"><span class="comment">范围是0到31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// define two tasks for Blink &amp; AnalogRead</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the setup function runs once when you press reset or power the board</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize serial communication at 115200 bits per second:</span></span><br><span class="line">  USBSerial.begin(<span class="number">115200</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Now set up two tasks to run independently.</span></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskBlink</span><br><span class="line">    ,  <span class="string">&quot;TaskBlink&quot;</span>   <span class="comment">// A name just for humans</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// This stack size can be checked &amp; adjusted by reading the Stack Highwater</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">2</span>  <span class="comment">// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskAnalogReadA3</span><br><span class="line">    ,  <span class="string">&quot;AnalogReadA3&quot;</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// Stack size</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">1</span>  <span class="comment">// Priority</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Empty. Things are done in Tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*---------------------- Tasks ---------------------*/</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Blink</span></span><br><span class="line"><span class="comment">  Turns on an LED on for one second, then off for one second, repeatedly.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  If you want to know what pin the on-board LED is connected to on your ESP32 model, check</span></span><br><span class="line"><span class="comment">  the Technical Specs of your board.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize digital LED_BUILTIN on pin 13 as an output.</span></span><br><span class="line">  pinMode(<span class="number">45</span>, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="comment">// A Task shall never return or exit.</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(<span class="number">45</span>, HIGH);   <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">    digitalWrite(<span class="number">45</span>, LOW);    <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AnalogReadSerial</span></span><br><span class="line"><span class="comment">  Reads an analog input on pin A3, prints the result to the serial monitor.</span></span><br><span class="line"><span class="comment">  Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)</span></span><br><span class="line"><span class="comment">  Attach the center pin of a potentiometer to pin A3, and the outside pins to +5V and ground.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// read the input on analog pin A3:</span></span><br><span class="line">    <span class="type">int</span> sensorValueA3 = analogRead(A3);</span><br><span class="line">    <span class="comment">// print out the value you read:</span></span><br><span class="line">    USBSerial.print(<span class="string">&quot;A3-&gt;&quot;</span>);</span><br><span class="line">    USBSerial.println(sensorValueA3);</span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="基于多核并行任务创建"><a href="#基于多核并行任务创建" class="headerlink" title="基于多核并行任务创建"></a>基于多核并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//  多线程基于FreeRTOS，可以多个任务并行处理；</span></span><br><span class="line"><span class="comment">//  ESP32具有两个32位Tensilica Xtensa LX6微处理器；</span></span><br><span class="line"><span class="comment">//  实际上我们用Arduino进行编程时只使用到了第一个核（大核），第0核并没有使用</span></span><br><span class="line"><span class="comment">//  多线程可以指定在那个核运行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_MULTCORE 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskOne</span><span class="params">(<span class="type">void</span> *xTask1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task1 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskTwo</span><span class="params">(<span class="type">void</span> *xTask2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task2 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    USBSerial.begin(<span class="number">115200</span>);</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !USE_MULTCORE</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskOne,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskOne&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">1</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskTwo,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskTwo&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">2</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个参数至关重要，决定这个任务创建在哪个核上.PRO_CPU 为 0, APP_CPU 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</span></span><br><span class="line">    xTaskCreatePinnedToCore(xTaskOne, <span class="string">&quot;TaskOne&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(xTaskTwo, <span class="string">&quot;TaskTwo&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial.<span class="built_in">printf</span>(<span class="string">&quot;XTask is running\r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32-S3多任务处理&quot;&gt;&lt;a href=&quot;#esp32-S3多任务处理&quot; class=&quot;headerlink&quot; title=&quot;esp32_S3多任务处理&quot;&gt;&lt;/a&gt;esp32_S3多任务处理&lt;/h1&gt;&lt;h2 id=&quot;多任务介绍&quot;&gt;&lt;a href=&quot;#多任务介</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32开发环境搭建（arduino）</title>
    <link href="https://rozen12123.github.io/posts/ec4b5731.html"/>
    <id>https://rozen12123.github.io/posts/ec4b5731.html</id>
    <published>2023-07-05T06:56:01.000Z</published>
    <updated>2023-07-06T07:47:56.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32开发环境搭建（arduino）"><a href="#esp32开发环境搭建（arduino）" class="headerlink" title="esp32开发环境搭建（arduino）"></a>esp32开发环境搭建（arduino）</h1><h2 id="首先下载arduino-IDE最新版"><a href="#首先下载arduino-IDE最新版" class="headerlink" title="首先下载arduino IDE最新版"></a>首先下载arduino IDE最新版</h2><p>网址：<a href="https://www.arduino.cc/en/software">Software | Arduino</a></p><p><img src="https://i.imgtg.com/2023/07/05/Oxe1Rb.png" alt="Oxe1Rb.png" border="0"></p><p>点击windows win10</p><p><img src="https://i.imgtg.com/2023/07/05/Oxehu6.png" alt="Oxehu6.png" border="0"></p><p>点击just download</p><p>此时即可下载到电脑。</p><h3 id="方法二（github）"><a href="#方法二（github）" class="headerlink" title="方法二（github）"></a>方法二（github）</h3><p>打开网址<a href="https://github.com/arduino/arduino-ide">arduino/arduino-ide: Arduino IDE 2.x (github.com)</a></p><p>点击code<img src="/posts/ec4b5731.htm/OxenFP.png" alt="OxenFP.png" border="0"></p><p>点击Download ZIP下载压缩包，下载完压缩即可。</p><p><a href="https://imgtg.com/image/Oxe79l"><img src="/posts/ec4b5731.htm/Oxe79l.png" alt="Oxe79l.png" border="0"></a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="安装esp32开发环境"><a href="#安装esp32开发环境" class="headerlink" title="安装esp32开发环境"></a>安装esp32开发环境</h2><p>你需要向 Arduino IDE 板管理器添加一个额外的源，然后安装 ESP32。</p><p>打开<code>文件</code> 菜单下的 <code>首选项</code>。</p><p><img src="https://i.imgtg.com/2023/07/05/OxeFEF.png" alt="OxeFEF.png" border="0"></p><p>把下面的链接复制粘贴到 <code>附加开发板管理网址</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/05/OxeeUg.png" alt="OxeeUg.png" border="0"></p><p>再安装 ESP32 开发板，选择 <code>工具</code> 菜单中的 <code>开发板</code> -&gt; <code>开发板管理器...</code></p><p><img src="https://i.imgtg.com/2023/07/05/OxeryB.png" alt="OxeryB.png" border="0"></p><p>在搜索栏搜索esp32，点击安装即可</p><p><img src="https://i.imgtg.com/2023/07/05/OxeAds.png" alt="OxeAds.png" border="0"></p><p>完成安装后即可在 工具—-&gt;开发板中发现esp32</p><p><img src="https://i.imgtg.com/2023/07/05/OxeZaK.png" alt="OxeZaK.png" border="0"></p><p>&nbsp;</p><h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>如果在连接esp32后没有反应则需要下载驱动</p><p>链接：<a href="https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc">https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc</a><br>提取码：m1bc</p><p>下在完可以在<strong>设备管理器</strong>中查看到设备</p><p><img src="https://i.imgtg.com/2023/07/05/Oxevea.png" alt="Oxevea.png" border="0"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;a href=&quot;#esp32开发环境搭建（arduino）&quot; class=&quot;headerlink&quot; title=&quot;esp32开发环境搭建（arduino）&quot;&gt;&lt;/a&gt;esp32开发环境搭建（arduino）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32WIFI</title>
    <link href="https://rozen12123.github.io/posts/e7f7981b.html"/>
    <id>https://rozen12123.github.io/posts/e7f7981b.html</id>
    <published>2023-07-02T06:20:25.000Z</published>
    <updated>2023-07-06T07:46:04.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WiFi-应用"><a href="#WiFi-应用" class="headerlink" title="WiFi 应用"></a><strong>WiFi</strong> <strong>应用</strong></h1><p>通过前面的实验，我们已经对 ESP32-S2 有了一定的了解。从本章开始，将迎来非常重要实用的内容，那就是 WIFI 应用。ESP32-S2 就是为 WIFI 无线连接而生的。通过本章内容，我们可以看到基于 MicroPython 的 WIFI 开发是多么的简单而美妙。物联网的学习变得非常简单有趣！事不宜迟，马上开始学习。</p><h2 id="连接无线路由器"><a href="#连接无线路由器" class="headerlink" title="连接无线路由器"></a><strong>连接无线路由器</strong></h2><p>⚫ <strong>前言：</strong></p><p>WIFI 是物联网中非常重要的角色，现在基本上家家户户都有 WIFI 网络了，通过 WIFI 接入到互联网，成了智能家居产品普遍的选择。而要想上网，首先需要连接上无线路由器。这一节我们就来学习如何通过 MicroPython 编程连上路由器。</p><p>⚫ <strong>实验目的：</strong></p><p>编程实现连接路由器，将 IP 地址等相关信息通过 OLED 显示（只支持 2.4G网络）。</p><p>⚫ <strong>实验讲解：</strong></p><p>连接路由器上网是我们每天都做的事情，日常生活中我们只需要知道路由器的账号和密码，就能使用电脑或者手机连接到无线路由器，然后上网冲浪。</p><p>MicroPython 已经集成了 network 模块，开发者使用内置的 network 模块函数可以非常方便地连接上路由器。但往往也有各种连接失败的情况，如密码不正确等。这时候我们只需要再加上一些简单的判断机制，避免陷入连接失败的死循环即可！</p><p>我们先来看看 network 基于 WiFi（WLAN 模块）的构造函数和使用方法。</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>wlan = network.WLAN(interface_id)</p><p>构建 WIFI 连接对象。interface_id:分为热点 network.AP_IF 和客户端</p><p>network.STA_IF 模式。</p><p><strong>使用方法</strong></p><p>wlan.active([is_active])</p><p>激活 wlan 接口。Ture：激活；False:关闭。</p><p>wlan.scan ()</p><p>扫描允许访问的 SSID。</p><p>wlan.isconnected()</p><p>检查设备是否已经连接上。返回 Ture:已连接；False：未连接。</p><p>wlan.connected(ssid,passwork)</p><p>WIFI 连接。ssid:账号；passwork：密码。</p><p>wlan.ifconfig([ip,subnet,gateway,dns])</p><p>设备信息配置。ip：IP 地址；subnet:子网掩码；gateway:网关地址；dns:DNS</p><p>信息。<strong>（如果参数为空，则返回当前连接信息。）</strong></p><p>wlan.disconnected()</p><p>断开连接。</p><p>&nbsp;</p><p>从上表可以看到 MicroPython 通过模块封装，让 WIFI 联网变得非常简单。模块包含热点 AP 模块和客户端 STA 模式，热点 AP 是指电脑端直接连接 ESP32-S2发出的热点实现连接，但这样你的电脑就不能上网了，因此我们一般情况下都是使用 STA 模式。也就是电脑和设备同时连接到相同网段的路由器上。模块上电后可以先判断是否已经连接到网络，如果是则无需再次连接，否的话则进入 WIFI 连接状态，指示灯闪烁，连接成功后指示灯常亮，IP 等相关信息通过 OLED 显示和串口打印。另外需要配置超时 15 秒还没连接成功时执行取消连接，避免因无法连接而陷入死循环。代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702142321217.png" alt="image-20230702142321217" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：编程实现连接路由器，将IP地址等相关信息通过OLED显示（只支持2.4G网络）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> network,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;01Studio&#x27;</span>, <span class="string">&#x27;88888888&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行WIFI连接函数</span></span><br><span class="line">WIFI_Connect()</span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>本节是 WIFI 应用的基础，成功连接到无线路由器的实验后，后面就可以做socket 等相关网络通信的应用了。</p><p>&nbsp;</p><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a><strong>Socket</strong> <strong>通信</strong></h2><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了如何通过 MicroPython 编程实现 pyWiFi-ESP32-S2 模块连接到无线路由器。这一节我们则来学习一下 Socket 通信实验。Socket 几乎是整个互联网通信的基础。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 Socket 编程实现 pyWiFi-ESP32-S2 与电脑服务器助手建立连接，相互收发数据。</p><p>⚫ <strong>实验讲解：</strong></p><p>Socket 我们听得非常多了，但由于网络工程是一门系统工程，涉及的知识非常广，概念也很多，任何一个知识点都能找出一堆厚厚的的书，因此我们经常会混淆。在这里，我们尝试以最容易理解的方式来讲述 Socket，如果需要全面了解，可以自行查阅相关资料学习。</p><p>我们先来看看网络层级模型图，这是构成网络通信的基础：</p><p>我们看看 TCP/IP 模型的传输层和应用层，传输层比较熟悉的概念是 TCP 和UDP，UPD 协议基本就没有对 IP 层的数据进行任何的处理了。而 TCP 协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。应用层中网页常用的则是 HTTP。那么我们先来解析一下这 TCP 和 HTTP 两者的关系。我们知道网络通信是最基础是依赖于 IP 和端口的，HTTP 一般情况下默认使用端口 80。举个简单的例子：我们逛淘宝，浏览器会向淘宝网的网址（本质是IP）和端口发起请求，而淘宝网收到请求后响应，向我们手机返回相关网页数据信息，实现了网页交互的过程。而这里就会引出一个多人连接的问题，很多人访问淘宝网，实际上接收到网页信息后就断开连接，否则淘宝网的服务器是无法支撑这么多人长时间的连接的，哪怕能支持，也非常占资源。</p><p>也就是应用层的 HTTP 通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。简单来说，Socket 抽象层介于传输层和应用层之间，跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p>套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议（通常是 <strong>TCP</strong> <strong>或</strong> <strong>UDP</strong>），本地主机的 <strong>IP</strong> <strong>地址，本地进程的协议端**</strong>口，远地主机的<strong>IP</strong> <strong>地址，远地进程的协议端口。</strong></p><p>所以，socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，简单理解就是其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等等。以下是通讯流程：</p><p><img src="/posts/e7f7981b.htm/image-20230702143005669.png" alt="image-20230702143005669" style="zoom:70%;"></p><p>从上图可以看到，建了 Socket 通信需要一个服务器端和一个客户端，以本实验为例，pyWiFi-ESP32-S2 作为客户端，电脑使用网络调试助手作为服务器端，双方使用 TCP 协议传输。对于客户端，则需要知道电脑端的 IP 和端口即可建立连接。（端口可以自定义，范围在 0~65535，注意不占用常用的 80 等端口即可。）以上的内容，简单来说就是如果用户面向应用来说，那么 ESP32-S2 只需要知道<strong>通讯协议是</strong> <strong>TCP</strong> <strong>或</strong> <strong>UDP**</strong>、服务器的<strong> </strong>IP<strong> </strong>和端口号**这 3 个信息，即可向服务器发起连接和发送信息。就这么简单。</p><p>MicroPython 已经封装好相关模块 usocket,跟传统的 socket 大部分兼容，两者均可使用，本实验使用 usocket，对象如下介绍：</p><p><strong>构造函数</strong></p><p>s=usocket.socekt(af=AF_INET, type=SOCK_STREAM,proto=IPPROTO_TCP)</p><p>构建 usocket 对象。</p><p>af: AF_INET→IPV4，AF_INET6 → IPV6；</p><p>type: SCOK_STREAM→TCP，SOCK_DGRAM→UDP；</p><p>proto: IPPROTO_TCP→TCP 协议，IPPROTO_UDP→UDP 协议。</p><p>（如果要构建 TCP 连接，可以使用默认参数配置，即不输入任何参数。）</p><p><strong>使用方法</strong></p><p>addr=usocket.getaddrinfo(‘www.01studio.org’, 80)[0][-1]</p><p>获取 Socket 通信格式地址。返回：(‘47.91.208.161’,80)</p><p>s.connect(address)</p><p>创建连接。address:地址格式为 IP+端口。例：(‘192.168.1.115’,10000)</p><p>s.send(bytes)</p><p>发送。bytes：发送内容格式为字节</p><p>s.recv(bufsize)</p><p>接收数据。bufsize：单次最大接收字节个数。</p><p>s.bind(address)</p><p>绑定，用于服务器角色</p><p>s.listen([backlog])</p><p>监听，用于服务器角色。backlog:允许连接个数，必须大于 0。</p><p>s.accept()</p><p>接受连接，用于服务器角色。</p><p>&nbsp;</p><p>本实验中 pyWiFi-ESP32-S2 属于客户端，因此只用到客户端的函数即可。实验代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702143126631.png" alt="image-20230702143126631" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过Socket编程实现pyWiFi-ESP32与电脑服务器助手建立TCP连接，相互收发数据。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">import</span> network,usocket,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;henu-student&#x27;</span>, <span class="string">&#x27;hbwz12138&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断WIFI是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> WIFI_Connect():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建socket连接TCP类似，连接成功后发送“Hello 01Studio！”给服务器。</span></span><br><span class="line">    s=usocket.socket()</span><br><span class="line">    addr=(<span class="string">&#x27;192.168.1.115&#x27;</span>,<span class="number">10000</span>) <span class="comment">#服务器IP和端口</span></span><br><span class="line">    s.connect(addr)</span><br><span class="line">    s.send(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">    text=s.recv(<span class="number">128</span>) <span class="comment">#单次最多接收128字节</span></span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打印接收到的信息为字节，可以通过decode(&#x27;utf-8&#x27;)转成字符串</span></span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        s.send(<span class="string">&#x27;I got:&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    time.sleep_ms(<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>WIFI 连接代码在上一节已经讲解，这里不再重复，WIFI 连接成功后返回 True，否则返回 False。程序在返回连接成功后建了 Socket 连接，连接成功发送‘Hello 01Studio!’信息到服务器。另外 RTOS 定时器设定了了每 300ms 处理从服务器接收到的数据。将接收到数据通过串口打印和发送给服务器。</p><p>⚫ <strong>实验结果：</strong></p><p>先在电脑端打开网络调试助手并建立服务器，软件在 零一科技（01Studio）MicroPython 开发套件配套资料_latest\01-开发工具\01-Windows\网络调试助手下的 NetAssist.exe ，直接双击打开即可！</p><p><img src="/posts/e7f7981b.htm/image-20230702143433653.png" alt="image-20230702143433653" style="zoom:67%;"></p><p>以下是新建服务器的方法，打开网络调试助手后在左上角协议类型选择 TCP Server；中间的本地 IP 地址是自动识别的，不要修改，这个就是服务器的 IP 地址。然后端口写 10000（0-65535 都可以。），点击连接，成功后红点亮。如下图：</p><p><img src="/posts/e7f7981b.htm/image-20230702143452690.png" alt="image-20230702143452690" style="zoom:80%;"></p><p>在时候服务器已经在监听状态！用户需要根据自己的实际情况自己输入 WIFI信息和服务器 IP 地址+端口。即修改上面的代码以下部分内容。（服务器 IP 和端口可以在网络调试助手找到。）</p><p>WiFi 网络信息：</p><p>wlan.connect(‘01Studio’, ‘88888888’) #输入 WIFI 账号密码</p><p>服务器信息：</p><p>addr=(‘192.168.1.115’,10000) #服务器 IP 和端口</p><p>下载程序，开发板成功连接 WIFI 后，发起了 socket 连接，连接成功可以可以看到网络调试助手收到了开发板发来的信息。在下方列表多了一个连接对象，点击选中</p><p>选中后我们在发送框输入信息“Hi”，点击发送，可以看到开发板的 REPL 打印出来信息 Hi。为字节数据。另外由于程序将收到的信息发回给服务器，所以在网络调试助手中也接收到开发板返回的信息：I got:Hi。</p><p><img src="/posts/e7f7981b.htm/image-20230702143554343.png" alt="image-20230702143554343" style="zoom:60%;"></p><p><img src="/posts/e7f7981b.htm/image-20230702143618314.png" alt="image-20230702143618314" style="zoom:80%;"></p><p>⚫ <strong>总结：</strong></p><p>通过本节学习，我们了解了socket通信原理以及使用MicroPython进行socket编程并且通信的实验。得益于优秀的封装，让我们可以直接面向 socket 对象编程就可以快速实现 socket 通信，从而开发更多的网络应用，例如将前面采集到的传感器数据发送到服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WiFi-应用&quot;&gt;&lt;a href=&quot;#WiFi-应用&quot; class=&quot;headerlink&quot; title=&quot;WiFi 应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;WiFi&lt;/strong&gt; &lt;strong&gt;应用&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通过前面的实验，我们已经对 ES</summary>
      
    
    
    
    
    <category term="espe32" scheme="https://rozen12123.github.io/tags/espe32/"/>
    
  </entry>
  
  <entry>
    <title>esp32传感器</title>
    <link href="https://rozen12123.github.io/posts/30e8a1b9.html"/>
    <id>https://rozen12123.github.io/posts/30e8a1b9.html</id>
    <published>2023-07-02T04:20:30.000Z</published>
    <updated>2023-07-06T07:47:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传感器实验"><a href="#传感器实验" class="headerlink" title="传感器实验"></a><strong>传感器实验</strong></h1><p>日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程师驱动一款未接触过的传感器的一般流程是：了解传感器原理、设计电路图、信号时序分析和编程。没个几天折腾不出来。生活中有很多传感器已经是非常通用了，前人已经做好封装函数模块，我们直接调用函数即可。我们不需要将时间花在“怎么用”上，而更多的是考虑“用到什么地方”！</p><h3 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a><strong>温度传感器</strong> <strong>DS18B20</strong></h3><p>⚫ <strong>前言：</strong></p><p>相信没有电子爱好者不知道 DS18B20 的，DS18B20 是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。DS18B20 数字温度传感器接线方便，封装成后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式，型号多种多样。主要根据应用场合的不同而改变其外观。封装后的 DS18B20 可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我，们来看看原理图：</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我们来看看原理图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140646041.png" alt="image-20230702140646041" style="zoom:50%;"></p><p>可以看到 DS18B20 传感器连接到了 pyBase 的 X11 引脚上。也就是连接到pyWiFi-ESP32-S2 的引脚 41，如下图所示：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140747976.png" alt="image-20230702140747976" style="zoom:50%;"></p><p>也就是说我们需要针对引脚 41 编写程序来驱动 DS18B20。那么我们需要自己来编写驱动么？如果你有兴趣的可以自己尝试一下。这部分我们 01Studio 已经收集整理和编写好了，单总线模块文件是：onewire.py，DS18B20 模块的文件是 ds18x20.py。如果你学习过前面基于 STM32 平台应该不陌生。而对于 ESP32-S2,这两个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可！单总线模块（onewire）和 ds18x20 模块说明如下：</p><p><strong>构造函数</strong></p><p>ow=onewire.OneWire(machine.Pin(id))</p><p>构建单总线对象。id:引脚编号；</p><p><strong>使用方法</strong></p><p>ow.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ow.reset()</p><p>总线设备复位。</p><p>ow.readbyte()</p><p>读 1 个字节。</p><p>ow.writebyte(0x12)</p><p>写入 1 个字节。</p><p>ow.write(‘123’)</p><p>写入多个字节。</p><p>ow.select_rom(b’12345678’)</p><p>根据 ROM 编号选择总线上指定设备</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>ds=ds18x20.DS18X20(ow)</p><p>构建 DS18B20 传感器对象。ow:定义好的单总线对象；</p><p><strong>使用方法</strong></p><p>ds.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ds.convert_temp()</p><p>温度转换。</p><p>ds.read_temp(rom)</p><p>获取温度值。rom：表示对应的设备号。</p><p>&nbsp;</p><p>大部分场景下温度的变化不会太频繁，我们可以每隔 1 秒采集一次，显示精度为小数点后 2 位，基本满足大部分应用需求。编程逻辑如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140853444.png" alt="image-20230702140853444" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：温度传感器DS18B20</span></span><br><span class="line"><span class="string">说明：通过编程采集温度数据，并在OLED上显示。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"><span class="keyword">import</span> onewire,ds18x20,time</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化DS18B20</span></span><br><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) <span class="comment">#使能单总线</span></span><br><span class="line">ds = ds18x20.DS18X20(ow)        <span class="comment">#传感器是DS18B20</span></span><br><span class="line">rom = ds.scan()         <span class="comment">#扫描单总线上的传感器地址，支持多个传感器同时连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_get</span>(<span class="params">tim</span>):</span><br><span class="line">    ds.convert_temp()</span><br><span class="line">    temp = ds.read_temp(rom[<span class="number">0</span>]) <span class="comment">#温度显示,rom[0]为第1个DS18B20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#OLED数据显示</span></span><br><span class="line">    oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">    oled.text(<span class="string">&#x27;MicroPython&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;Temp test:&#x27;</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%temp)+<span class="string">&#x27; C&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>) <span class="comment">#显示temp,保留2位小数</span></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(-<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=temp_get) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验拓展：</strong></p><p>pyBase 开发底板预留了外界传感器接口，只要接线正确就可以进行更多的传感器实验。我们将带金属探头的 DS18B20 传感器接到 pyBase 右侧上面的传感器母座，其连接到 pyBase 的“Y11”引脚,也就是对应 pyWiFi-ESP32-S2 的引脚 10。</p><p>所以只要将原程序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) </span><br></pre></td></tr></table></figure><p>改成 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">10</span>))，</span><br></pre></td></tr></table></figure><p>即可驱动外接的 DS18B20。</p><p>⚫ <strong>总结</strong></p><p>DS18B20 作为我们第一个实验传感器，使用 MicroPython 编程非常容易就用起来了，而且精度和稳定性丝毫没有影响。温度传感器只是一个敲门砖，接下来我们将会学习更多的传感器应用。</p><p>&nbsp;</p><h3 id="温湿度传感器-DHT11"><a href="#温湿度传感器-DHT11" class="headerlink" title="温湿度传感器 DHT11"></a><strong>温湿度传感器</strong> <strong>DHT11</strong></h3><p>⚫ <strong>前言：</strong></p><p>温湿度也是我们日常非常常见的指标，我们使用的是 DHT11 数字温湿度传感器。这是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。</p><p>DHT11 具有小体积、极低的功耗，信号传输距离可达 20 米以上，使其成为给类应用甚至最为苛刻的应用场合的最佳选择。产品为 4 针单排引脚封装，连接方便。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温湿度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DHT11 虽然有 4 个引脚，但其中第 3 个引脚是悬空的，也就是说 DHT11 也是单总线的传感器，只占用 1 个 IO 口。</p><p><img src="/posts/30e8a1b9.htm/image-20230702141333793.png" alt="image-20230702141333793" style="zoom:80%;"></p><p>我们来看看 DHT11 在开发板上的接线图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141347945.png" alt="image-20230702141347945" style="zoom:67%;"></p><p>可以看到 DHT11 连接到 pyBase 的‘X12’引脚，也就是连接到 pyWiFi-ESP32-S2 的引脚 42，如下图所示：</p><p>因此可以针对引脚 42 编程来驱动 DHT11 传感器，模块文件是 dht.py。而对于 pyWiFi-ESP32-S2,这个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可。函数模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>d = dht.DHT11(machine.Pin(id))</p><p>构建 DHT11 传感器对象。id:传感器所连接的引脚；</p><p><strong>使用方法</strong></p><p>d.measure()</p><p>测量温湿度。</p><p>d.temperature()</p><p>获取温度值。</p><p>d.humidity()</p><p>获取湿度值</p><p>建议上电先延时 1 秒，让 DHT11 稳定后再开始读取。代码编写流程如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141458320.png" alt="image-20230702141458320" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="人体感应传感器"><a href="#人体感应传感器" class="headerlink" title="人体感应传感器"></a><strong>人体感应传感器</strong></h3><p>⚫ <strong>前言：</strong></p><p>人体感应传感器，在室内安防应用非常普遍，其原理是由探测元件将探测到人体的红外辐射转变成微弱的电压信号，经过放大后输出。为了提高探测器的探测灵敏度以增大探测距离，一般在探测器的前方装设一个塑料的菲涅尔透镜，它和放大电路相配合，可将信号放大 70dB 以上，这样就可以测出 5~10 米范围内人的行动。</p><p>⚫ <strong>实验目的：</strong></p><p>通过外部中断编程来检测人体感应模块，当有人出现时候 OLED 通过“GetPeople!！！”闪烁提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传感器实验&quot;&gt;&lt;a href=&quot;#传感器实验&quot; class=&quot;headerlink&quot; title=&quot;传感器实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;传感器实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32基础实验</title>
    <link href="https://rozen12123.github.io/posts/7fbb683d.html"/>
    <id>https://rozen12123.github.io/posts/7fbb683d.html</id>
    <published>2023-07-01T14:34:17.000Z</published>
    <updated>2023-07-06T07:47:50.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a><strong>基础实验</strong></h1><p>MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的实现，也就是说我们只要理解和熟练相关的函数用法，就可以很好</p><p>的玩转 MicroPython。它让我们可以做到不关心硬件和底层原理（当然有兴趣和能力的小伙伴可以深入研究）而直接跑起硬件。</p><h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 上有 1 个 LED（蓝色），控制 LED 使用 machine 中的 Pin 对</p><p>象，其构造函数和使用方法如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>led=machine.Pin(id,mode,pull)</td></tr><tr><td>构建 led 对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>led.value([x])</td></tr><tr><td>引脚电平值。输出状态：x=0 表示低电平，x=1 表示高电平；输入状态：无须</td></tr><tr><td>参数，返回当前引脚值。</td></tr><tr><td>led.on()</td></tr><tr><td>使引脚输出高电平“1”。</td></tr><tr><td>led.off()</td></tr><tr><td>使引脚输出低电平“0”。</td></tr><tr><td>更详细内容，请查看 micropython 库文档：<a href="https://docs.01studio.cc/">https://docs.01studio.cc/</a></td></tr></tbody></table></div><p>上表对 MicroPython 的 machine 中 Pin 对象做了详细的说明，machine 是大</p><p>模块，Pin 是 machine 下面的其中一个小模块，在 python 编程里有两种方式引用</p><p>相关模块:</p><p><strong>方式</strong> <strong>1</strong> <strong>是</strong>：import machine，然后通过 machine.Pin 来操作；</p><p><strong>方式</strong> <strong>2</strong> <strong>是</strong>：from machine import Pin,意思是直接从 machine 中引入 Pin 模块，</p><p>然后直接通过构建 led 对象来操作。显然方式 2 会显得更直观和方便，本实验也</p><p>是使用方式 2 来编程。代码编写流程如下：</p><p>从原理图可以看到 LED 跟模块引脚 2 相连，通过输出高电平方式点亮</p><p><img src="/posts/7fbb683d.htm/image-20230701223726651.png" alt="image-20230701223726651" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮 LED 蓝灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入 Pin 模块</span></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 led 对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮 LED，也可以使用 led.on()</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>从第一个实验我们可以看到，使用 MicroPython 来开发关键是要学会构造函</p><p>数和其使用方法，便可完成对相关对象的操作，在强大的模块函数支持下，实验</p><p>只用了简单的两行代码便实现了点亮 LED 灯。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h2><p>⚫ <strong>前言：</strong></p><p>按键是最简单也最常见的输入设备，很多产品都离不开按键，包括早期的iPhone。有了按键输入功能，我们就可以做很多好玩的东西了。</p><p>⚫ <strong>实验目的：</strong></p><p>使用按键功能，通过检测按键被按下后，改变 LED（蓝灯）的亮灭状态。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板上有 2 个按键，RST 和 KEY，RST 顾名思义是复位用的，所以真正自带可以用的就只有 1 个按键 KEY。</p><p>让我们先来搞清楚 MicroPython 里面 Pin 模块实现按键的构造函数和使用方法。</p><p>&nbsp;</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>KEY.value()</td></tr><tr><td>引脚电平值。输入状态：无须参数，返回当前引脚值 0 或者 1。</td></tr></tbody></table></div><p>可以看到跟上一节 LED 一样，只是输入/输出状态的一个改变。从下面原理图可以看到，我们只需要在开发板上电后判断 KEY 引脚的电平，当被按下时候引</p><p>脚为低电平“0</p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p><img src="/posts/7fbb683d.htm/image-20230701224121294.png" alt="image-20230701224121294" style="zoom:67%;"></p><p>常用的方法就是当检测按键值为 0 时，延时一段时间，大约 10ms，再判断按键引脚值仍然是 0，是的话说明按键被按下。延时使用 time 模块，使用方法如</p><p>下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 睡眠 1 秒</span></span><br><span class="line">time.sleep_ms(<span class="number">500</span>) <span class="comment"># 睡眠 500 毫秒</span></span><br><span class="line">time.sleep_us(<span class="number">10</span>) <span class="comment"># 睡眠 10 微妙</span></span><br><span class="line">start = time.ticks_ms() <span class="comment"># 获取毫秒计时器开始值</span></span><br><span class="line">delta = time.ticks_diff(time.ticks_ms(), start) <span class="comment"># 计算从上电开始到当前时间</span></span><br><span class="line">的差值</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：按键</span></span><br><span class="line"><span class="string">说明：通过按键改变 LED 的亮灭状态</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 LED 对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建 KEY 对象</span></span><br><span class="line">state=<span class="number">0</span> <span class="comment">#LED 引脚状态</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下</span></span><br><span class="line"> time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state=<span class="keyword">not</span> state <span class="comment">#使用 not 语句而非~语句</span></span><br><span class="line"> LED.value(state) <span class="comment">#LED 状态翻转</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;KEY&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">not</span> KEY.value(): <span class="comment">#检测按键是否松开</span></span><br><span class="line"> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看到，初始化各个对象后，进入循环，当检测到 KEY 的值为0（按键被按下）时候，先做了 10ms 的延时，再次判断；</p><p>state 为 LED 状态的值，每次按键按下后通过使用 not 来改变。这里注意的是在 python 里使用‘not’而不是‘~’的方式。not 返回的是 True 和 False，即</p><p>0,1。而~ 是取反操作，会导致出错。</p><p>&nbsp;</p><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h2><p>⚫ <strong>前言：</strong></p><p>前面我们在做普通的 GPIO 时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如</p><p>某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断</p><p>的在实际项目的应用非常普遍.</p><p>⚫ <strong>实验目的：</strong></p><p>利用中断方式来检查按键 KEY 状态，被按键被按下（产生外部中断）后使 LED</p><p>的亮灭状态翻转</p><p>⚫ <strong>实验讲解：</strong></p><p>外部中断也是通过 machine 模块的 Pin 子模块来配置，我们先来看看其配构</p><p>造函数和使用方法</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th><th></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td><td></td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td><td></td></tr><tr><td><strong>使用方法</strong></td><td></td></tr><tr><td>KEY.irq(handler,trigger)</td><td></td></tr><tr><td>配置中断模式。</td><td></td></tr><tr><td>handler:中断执行的回调函数；</td><td></td></tr><tr><td>trigger: 触发中断的方式，共 4 种，分别是 Pin.IRQ_FALLING（下降沿触发）、</td><td></td></tr><tr><td>Pin.IRQ_RISING（上升沿触发）、Pin.IRQ_LOW_LEVEL（低电平触发）、</td><td></td></tr><tr><td>Pin.IRQ_HIGH_LEVEL（高电平触发）</td></tr></tbody></table></div><p>上升沿和下降沿触发统称边沿触发。从上一节按键可以看到，按键被按下时一个引脚值从 1 到 0 变化的过程，边沿触发就是指这个过程。</p><p><img src="/posts/7fbb683d.htm/image-20230701224921935.png" alt="image-20230701224921935" style="zoom:50%;"></p><p>由此可见，我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产生中断。</p><p>编程思路中断跟按键章节类似，在初始化中断后，当系统检测到外部终端时候，执行 LED 亮灭状态反转的代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：外部中断</span></span><br><span class="line"><span class="string">说明：通过按键改变LED的亮灭状态（外部中断方式）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建LED对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">state=<span class="number">0</span>  <span class="comment">#LED引脚状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LED状态翻转函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state = <span class="keyword">not</span> state</span><br><span class="line">        LED.value(state)</span><br><span class="line"></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中需要注意的地方：</p><p>1、state 是全局变量，因此在 fun 函数里面用该变量必须添加 globalstate 代码，否则会在函数里面新建一个样的变量造成冲突。</p><p>2、在定义回调函数 fun 的时候，需要将 Pin 对象 KEY 传递进去。</p><p>⚫ <strong>总结：</strong></p><p>从参考代码来看，只是用了几行代码就实现了实验功能，而且相对于使用while True 实时检测函数来看，代码的效率大大增强。外部中断的应用非常广，</p><p>出来普通的按键输入和电平检测外，很大一部分输入设备，比如传感器也是通过外部中断方式来实时检测.</p><p>&nbsp;</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><p>⚫ <strong>前言：</strong></p><p>定时器，顾名思义就是用来计时的，我们常常会设定计时或闹钟，然后时间到了就告诉我们要做什么了。单片机也是这样，通过定时器可以完成各种预设好</p><p>的任务。</p><p>⚫ <strong>实验目的：</strong></p><p>通过定时器让 LED 周期性每秒闪烁 1 次。</p><p>⚫ <strong>实验讲解：</strong></p><p>ESP32-S2 内置 RTOS（实时操作系统）定时器，在 machine 的 Timer 模块中。通过 MicroPython 可以轻松编程使用。我们也是只需要了解其构造对象函数和使</p><p>用方法即可！</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>tim=machine.Timer(id)</td></tr><tr><td>构建定时器对象。</td></tr><tr><td>【id】ESP32-S2 有 2 路硬件定时器，id=0~1，也可以定义成-1，即RTOS 虚拟定时器</td></tr><tr><td></td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>tim.init(period,mode,callback)</td></tr><tr><td>定时器初始化。</td></tr><tr><td>period:单位为 ms；</td></tr><tr><td>mode：2 种工作模式，Timer.ONE_SHOT（执行一次）、Timer.PERIODIC（周期性）；callback:定时器中断后的回调函数。</td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类似，代码编程流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701225642158.png" alt="image-20230701225642158" style="zoom:75%;"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：定时器</span></span><br><span class="line"><span class="string">说明：通过定时器让LED周期性每秒闪烁1次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,Timer</span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line">Counter = <span class="number">0</span></span><br><span class="line">Fun_Num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> Counter</span><br><span class="line">    Counter = Counter + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(Counter)</span><br><span class="line">    led.value(Counter%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=fun) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="I2C-总线（OLED-显示屏）"><a href="#I2C-总线（OLED-显示屏）" class="headerlink" title="I2C 总线（OLED 显示屏）"></a><strong>I2C</strong> <strong>总线（</strong>OLED <strong>显示屏）</strong></h3><p>前面学习了按键输入设备后，这一节我们来学习输出设备 OLED 显示屏，其实之前的 LED 灯也算是输出设备，因为它们确切地告诉了我们硬件的状态。只是</p><p>相对于只有亮灭的 LED 而言，显示屏可以显示更多的信息，体验更好。</p><p>⚫ <strong>实验讲解：</strong></p><p><strong>什么是</strong> <strong>I2C**</strong>？**</p><p>I2C 是用于设备之间通信的双线协议，在物理层面，它由 2 条线组成：SCL 和SDA，分别是时钟线和数据线。也就是说不通设备间通过这两根线就可以进行通</p><p>信。</p><p><strong>什么是</strong> <strong>OLED</strong> <strong>显示屏？</strong></p><p>OLED 的特性是自己发光，不像 TFT LCD 需要背光，因此可视度和亮度均高，其次是电压需求低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成</p><p>本低等特点。简单来说跟传统液晶的区别就是里面像素的材料是由一个个发光二极管组成，因为密度不高导致像素分辨率低，所以早期一般用作户外 LED 广告</p><p>牌。随着技术的成熟，使得集成度越来越高。小屏也可以制作出较高的分辨率。</p><p><img src="/posts/7fbb683d.htm/image-20230701230249879.png" alt="image-20230701230249879" style="zoom:50%;"></p><p>在了解完 I2C 和 OLED 显示屏后，我们先来看看 pyBase 开发板的原理图，也就是上面的 OLED 接口是如何连线的。</p><p><img src="/posts/7fbb683d.htm/image-20230701230306218.png" alt="image-20230701230306218" style="zoom:50%;"></p><p>我们从 pyWiFi-ESP32-S2 和 pyBase 相结合的原理图可以看到 GPIO38—Y6—SCL, GPIO40—Y8—SDA 的连接关系：</p><p><img src="/posts/7fbb683d.htm/image-20230701230321167.png" alt="image-20230701230321167" style="zoom:50%;"></p><p>本实验将使用 MicroPython 的 Machine 模块来定义 Pin 口和 I2C 初始化。具体如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>i2c = machine.I2C(scl,sda)i2c = machine.I2C(scl,sda)</td></tr><tr><td>构建 I2C 对象。scl:时钟引脚；sda:数据引脚。构建 I2C 对象。scl:时钟引脚；sda:数据引脚。</td></tr><tr><td><strong>使用方法**</strong>使用方法**</td></tr><tr><td>i2c.scan()i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,nbytes)i2c.readfrom(addr,nbytes)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；</td></tr><tr><td>i2c.write(buf)</td></tr><tr><td>写数据。buf:数据内容；</td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306.py 文件里面。开发者只需要拷贝到 pyBoard 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306.py 文件代码。OLED 显示屏对象介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>oled = SSD1306_I2C(width, height, i2c, addr)</td></tr><tr><td>构 OLED 显示屏对象。width:屏幕宽像素；height: 屏幕高像素；i2c:定义好的</td></tr><tr><td>I2C 对象; addr:显示屏设备地址。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>oled.text(string,x,y)</td></tr><tr><td>将 string 字符写在指定为位置。string：字符；x:横坐标；y:纵坐标。</td></tr><tr><td>oled.show()</td></tr><tr><td>执行显示。</td></tr><tr><td>oled.fill(RGB)</td></tr><tr><td>清屏。RGB：0 表示黑色，1 表示白色。</td></tr></tbody></table></div><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><p><img src="/posts/7fbb683d.htm/image-20230701231539182.png" alt="image-20230701231539182" style="zoom:80%;"></p><h4 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：I2C总线(OLED显示屏)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin         <span class="comment">#从machine模块导入I2C、Pin子模块</span></span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C     <span class="comment">#从ssd1306模块中导入SSD1306_I2C子模块</span></span><br><span class="line"></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))   <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>) <span class="comment">#OLED显示屏初始化：128*64分辨率,OLED的I2C地址是0x3c</span></span><br><span class="line"></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>,  <span class="number">0</span>)      <span class="comment">#写入第1行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>,  <span class="number">0</span>, <span class="number">20</span>)      <span class="comment">#写入第2行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>,  <span class="number">0</span>, <span class="number">50</span>)      <span class="comment">#写入第3行内容</span></span><br><span class="line"></span><br><span class="line">oled.show()   <span class="comment">#OLED执行显示</span></span><br></pre></td></tr></table></figure><p>上述代码中 OLED 的 I2C 地址是 0x3C,不同厂家的产品地址可能预设不一样，具体参考厂家的说明书。或者也可以通过 I2C.scan()来获取设备地址。另外记得将我们提供的示例代码中的 ssd1306.py 驱动文件拷贝到 pyWiFiESP32-S2 的文件系统下，跟 main.py 保持同一个路径。</p><p><img src="/posts/7fbb683d.htm/image-20230701231632416.png" alt="image-20230701231632416" style="zoom:50%;"></p><p>⚫ <strong>总结：</strong></p><p>这一节我们学会了驱动 OLED 显示屏，换着以往如果从使用单片机从 0 开发的话你需要了解 I2C 总线原理，了解 OLED 显示屏的使用手册，编程 I2C 代码，有经验的嵌入式工程师搞不好也要弄个几天。现在基本半个小时解决问题。当然前提是别人已经给你搭好桥了，有了强大的底层驱动代码支持，我们只做好应用就好。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="RTC-实时时钟"><a href="#RTC-实时时钟" class="headerlink" title="RTC 实时时钟"></a><strong>RTC</strong> <strong>实时时钟</strong></h3><p>⚫ <strong>前言：</strong></p><p>时钟可以说我们日常最常用的东西了，手表、电脑、手机等等无时无刻不显示当前的时间。可以说每一个电子爱好者心中都希望拥有属于自己制作的一个电子时钟，接下来我们就用 MicroPython 开发板来制作一个属于自己的电子时钟。</p><p>⚫ <strong>实验讲解：</strong></p><p>实验的原理是读取 RTC 数据，然后通过 OLED 显示。毫无疑问，强大的MicroPython 已经集成了内置时钟函数模块。位于 machine 的 RTC 模块中，具体介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>rtc=machine.RTC()</td></tr><tr><td>构建 RTC 对象。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>rtc.datetime((2019, 4, 1, 0, 0, 0, 0, 0))</td></tr><tr><td>设置日期和时间。按顺序分别是：（年，月，日，星期，时，分，秒，微秒），</td></tr><tr><td>其中星期使用 0-6 表示周一至周日。</td></tr><tr><td>rtc.datetime()</td></tr><tr><td>获取当前日期和时间</td></tr></tbody></table></div><p>从上表可以看到 RTC()的使用方法，我们需要做的就是先设定时间，然后再获取当前芯片里的时间，通过 OLED 显示屏显示，如此循环。在循环里，如果一直获取日期时间数据会造成资源浪费，所以可以每隔第一段时间获取一次数据，又由于肉眼需要看到至少每秒刷新一次即可，这里每隔 300ms 获取一次数据，使用前面学习过的 RTOS 定时器来计时，具体编程流程如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701232806658.png" alt="image-20230701232806658" style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：RTC实时时钟</span></span><br><span class="line"><span class="string">说明：使用Thonny连接开发板会自动更新RTC时间</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, SoftI2C, RTC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义星期和时间（时分秒）显示字符列表</span></span><br><span class="line">week = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tues&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">time_list = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化所有相关对象</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>)) <span class="comment">#I2C初始化：sda--&gt;40, scl--&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">rtc = RTC()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次上电配置时间，按顺序分别是：年，月，日，星期，时，分，秒，次秒级；这里做了</span></span><br><span class="line"><span class="comment"># 一个简单的判断，检查到当前年份不对就修改当前时间，开发者可以根据自己实际情况来</span></span><br><span class="line"><span class="comment"># 修改。</span></span><br><span class="line"><span class="keyword">if</span> rtc.datetime()[<span class="number">0</span>] != <span class="number">2023</span>:</span><br><span class="line">    rtc.datetime((<span class="number">2021</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RTC_Run</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    datetime = rtc.datetime()  <span class="comment"># 获取当前时间</span></span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;RTC Clock&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)  <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示日期，字符串可以直接用“+”来连接</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(datetime[<span class="number">0</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">1</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">2</span>]) + <span class="string">&#x27; &#x27;</span> + week[datetime[<span class="number">3</span>]], <span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间需要判断时、分、秒的值否小于10，如果小于10，则在显示前面补“0”以达</span></span><br><span class="line">    <span class="comment"># 到较佳的显示效果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">if</span> datetime[i] &lt; <span class="number">10</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间</span></span><br><span class="line">    oled.text(time_list[<span class="number">0</span>] + <span class="built_in">str</span>(datetime[<span class="number">4</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">1</span>] + <span class="built_in">str</span>(datetime[<span class="number">5</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">2</span>] + <span class="built_in">str</span>(datetime[<span class="number">6</span>]), <span class="number">0</span>, <span class="number">55</span>)</span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器</span></span><br><span class="line">tim = Timer(<span class="number">0</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=RTC_Run) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于实验要用到 OLED 显示屏，所以同样别忘了将示例代码该实验文件夹下的 ssd1306.py 文件复制到 pyWiFi-ESP32-S2 的文件系统里面。</p><p>由于 ESP32-S2 没有后备电池引脚，所以不支持掉电保存。因此 pybase 上面的纽扣电池是不起作用的。</p><p>⚫ <strong>总结：</strong></p><p>细心的用户或许已经发现运行程序后 RTC 时间自动更新，那是因为 thonny每次连接 MicroPython 开发板会自动更新开发板的 RTC 时间。</p><p>RTC 实时时钟的可玩性很强，我们还可以根据自己的风格来设定数字显示位置，以及加上一些属于自己的字符标识。打造自己的电子时钟。</p><p>&nbsp;</p><h3 id="ADC（电位器）"><a href="#ADC（电位器）" class="headerlink" title="ADC（电位器）"></a><strong>ADC</strong>（电位器）</h3><p>⚫ <strong>前言：</strong></p><p>ADC(analog to digital conversion) 模拟数字转换。意思就是将模拟信号转化成数字信号，由于单片机只能识别二级制数字，所以外界模拟信号常常会通过 ADC转换成其可以识别的数字信息。常见的应用就是将变化的电压转成数字信号。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程调用 MicroPython 的内置 ADC 函数，实现测量输入电压，并显示到屏幕上。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyBase 开发底板的 X7 引脚连接到了电位器，通过电位器的调节可以使得 X7引脚上的电压变化范围实现从 0-3.3V。</p><p><img src="/posts/7fbb683d.htm/image-20230701233122746.png" alt="image-20230701233122746" style="zoom:50%;"></p><p><img src="/posts/7fbb683d.htm/image-20230701233132565.png" alt="image-20230701233132565" style="zoom:50%;"></p><p>从上图可以看到，电位器引脚对应 pyBase 的 X7,实际是跟 pyWiFi-ESP32-S2</p><p>的‘</p><p>6’引脚 ADC 输入引脚相连。ESP32-S2 的 ADC 默认只能测量 0-1V 的量程，</p><p>但 ESP32-S2 内部集成了衰减器，最大支持 11dB 衰减，通过配置衰减器最多能测</p><p>量 3V 左右的电压。我们来看看 ADC 模块的构造函数和使用方法。</p><p><strong>构造函数</strong></p><p>adc=machine.ADC(Pin(id))</p><p>构建 ADC 对象。</p><p>【id】目前仅支持 ESP32-S2 的 ADC1，共 10 个通道：</p><p>GPIO1: ADC1_0</p><p>GPIO2: ADC1_1</p><p>GPIO3: ADC1_2</p><p>GPIO4: ADC1_3</p><p>GPIO5: ADC1_4</p><p>GPIO6: ADC1_5</p><p>GPIO7: ADC1_6</p><p>GPIO8: ADC1_7</p><p>GPIO9: ADC1_8</p><p>GPIO10: ADC1_9</p><p><strong>使用方法</strong></p><p>adc.read()</p><p>获取 ADC 值。测量精度是 13 位，返回 0- 8191（表示 0-1V）。</p><p>adc.atten(attenuation)</p><p>配置衰减器。配置衰减器能增加电压测量范围，但是以精度为代价的。</p><p>attenuation:衰减设置</p><p>ADC.ATTN_0DB： 0dB 衰减, 最大输入电压为 1.00v - 这是默认配置；</p><p>ADC.ATTN_2_5DB： 2.5dB 衰减, 最大输入电压约为 1.34v；</p><p>ADC.ATTN_6DB：6dB 衰减, 最大输入电压约为 2.00v；</p><p>ADC.ATTN_11DB：11dB 衰减, 最大输入电压约为 3.3v。</p><p>你没看错，就这么简单，两句函数就可以获得 ADC 数值。我们将在本实验中以默认的量程 0-1V 来测试。让我们来理顺一下编程逻辑。先导入相关模块，然后初始化模块。在循环中不断读取 ADC 的值，转化成电压值后在 OLED 上面显示，每隔 300 毫秒读取一次，具体如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701233235973.png" alt="image-20230701233235973" style="zoom:75%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：ADC-电压测量</span></span><br><span class="line"><span class="string">说明：通过对ADC数据采集，转化成电压在显示屏上显示。ADC精度13位（0~8191），默认电压0-1V。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,ADC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))  <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">adc = ADC(Pin(<span class="number">6</span>)) <span class="comment">#6引脚跟pyBase的电位器相连接</span></span><br><span class="line">adc.atten(ADC.ATTN_11DB) <span class="comment">#开启衰减，测量量程增大到3.3V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ADC_Test</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;ADC&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)      <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取ADC数值</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(adc.read()),<span class="number">0</span>,<span class="number">40</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;(8191)&#x27;</span>,<span class="number">60</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算电压值，获得的数据0-4095相当于0-1V，（&#x27;%.2f&#x27;%）表示保留2位小数</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%(adc.read()/<span class="number">8191</span>*<span class="number">3.3</span>)),<span class="number">0</span>,<span class="number">55</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;V&#x27;</span>,<span class="number">40</span>,<span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启定时器</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=ADC_Test) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>这一节我们学习了 ADC 的应用，主要用于电压的检测。有兴趣的用户可以尝试使用其衰减器测试，可以扩充电压量程，但精度会有所下降。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM（无源蜂鸣器）"><a href="#PWM（无源蜂鸣器）" class="headerlink" title="PWM（无源蜂鸣器）"></a><strong>PWM</strong>（无源蜂鸣器）</h3><p>⚫ <strong>前言：</strong></p><p>上一节的 ADC 是信号输入，这节的 PWM 就是一个信号输出。PWM（脉冲宽度调制），主要用于输出不同频率、占空比（一个周期内高电平出现时间占总时间比例）的方波。以实现固定频率或平均电压输出。</p><p>⚫ <strong>实验目的：</strong></p><p>通过不同频率的 PWM 信号输出，驱动无源蜂鸣器发出不同频率的声音。</p><p>⚫ <strong>实验讲解：</strong></p><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyWiFi-ESP32-S2 的 PWM 输出频率是在变化的。pyBase 开发底板上的无源蜂鸣器连接到 pyBase 引脚 X5。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702110722346.png" alt="image-20230702110722346" style="zoom:50%;"></p><p>从 pyWiFi-ESP32-S2 原理图可以看到由底板蜂鸣器 X5 连接到 ESP32-S2 的引脚 4。</p><p><img src="/posts/7fbb683d.htm/image-20230702110739134.png" alt="image-20230702110739134" style="zoom:50%;"></p><p>PWM 可以通过 ESP32-S2 所有 GPIO 引脚输出. 所有通道都有 1 个特定的频率，从 0 到 40M 之间（单位是 Hz）。占空比的值为 0 至 1023 之间。在本实验中我们用到引脚 4。</p><p>先看看 PWM 模块对象：</p><p><strong>构造函数</strong></p><p>pwm=machine.PWM(machine.Pin(id),freq,duty)</p><p>构建 PWM 对象。id:引脚编号；freq:频率值；duty:占空比；配置完后 PWM 自</p><p>动生效。</p><p><strong>使用方法</strong></p><p>pwm.freq(freq)</p><p>设置频率。freq:频率值在 1-1000 之间，freq 为空时表示获取当前频率值。</p><p>pwm.duty(duty)</p><p>设置占空比。duty:占空比在 0-1023 之间，duty 为空时表示获取当前占空比值。</p><p>pwm.deinit()</p><p>关闭 PWM。</p><p>无源蜂鸣器我们可以用特定频率的方波来驱动，方波的原理很简单，就是一定频率的高低电平转换，可以简单理解成占空比为 50%的 PWM 输出。</p><p>结合上述讲解，总结出代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：PWM</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过不同频率的PWM信号输出，驱动无源蜂鸣器发出不同频率的声音。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">Beep = PWM(Pin(<span class="number">4</span>), freq=<span class="number">0</span>, duty=<span class="number">512</span>) <span class="comment"># 在同一语句下创建和配置PWM,占空比50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率200Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">200</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率400Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">400</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率600Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">600</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率800Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">800</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率1000Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">1000</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">Beep.deinit()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART</strong>（串口通信）</h3><p>⚫ <strong>前言：</strong></p><p>串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板一共有 2 个串口，编号是 0-1，如下表：</p><div class="table-container"><table><thead><tr><th>UART(0)</th><th>TX</th><th>43</th></tr></thead><tbody><tr><td></td><td>RT</td><td>44</td></tr><tr><td>UART(1)</td><td>TX</td><td>任意映射IO</td></tr><tr><td></td><td>RX</td><td>任意映射IO</td></tr></tbody></table></div><p>由于 UART0 用于下载和 REPL 调试，因此我们使用 UART1 来进行本节实验。</p><p>我们先来了解一下串口对象的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>uart=machine.UART(id,baudrate,tx=None,rx=None bits=8, parity=None, stop=1,…)</p><p>创建 UART 对象。</p><p>【id】0-1</p><p>【baudrate】波特率，常用 115200、9600</p><p>【tx】自定义 IO</p><p>【rx】自定义 IO</p><p>【bits】数据位</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>…</p><p>特别说明： ESP32-S2 的 UART 引脚映射到其它 IO 来使用，用户可以通过构造</p><p>函数时候指定如 tx=8,rx=9 的方式来改变串口引脚，实现更灵活的应用。</p><p><strong>使用方法</strong></p><p>uart.deinit()</p><p>关闭串口</p><p>uart.any()</p><p>返回等待读取的字节数据，0 表示没有</p><p>uart.read([<em>nbytes</em>])</p><p>【nbytes】读取字节数</p><p>UART.readline()</p><p>读行</p><p>UART.write(<em>buf</em>)</p><p>【buf】串口 TX 写数据</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p><img src="/posts/7fbb683d.htm/image-20230702111650095.png" alt="image-20230702111650095" style="zoom:50%;"></p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用串口 2，也就是 8（TX）和 9（RX），接线示意图如下：</p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：串口通信</span></span><br><span class="line"><span class="string">说明：通过编程实现串口通信，跟电脑串口助手实现数据收发。</span></span><br><span class="line"><span class="string">平台：pyWiFi-ESP32</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入串口模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line">uart=UART(<span class="number">1</span>,<span class="number">115200</span>,rx=<span class="number">9</span>,tx=<span class="number">8</span>) <span class="comment">#设置串口号1和波特率</span></span><br><span class="line"></span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)<span class="comment">#发送一条数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断有无收到信息</span></span><br><span class="line">    <span class="keyword">if</span> uart.<span class="built_in">any</span>():</span><br><span class="line"></span><br><span class="line">        text=uart.read(<span class="number">128</span>) <span class="comment">#接收128个字符</span></span><br><span class="line">        <span class="built_in">print</span>(text) <span class="comment">#通过REPL打印串口3接收的数据</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>我们按照上述方式将 USB 转 TTL 的 TX 接到开发板的 RX（</p><p>9），USB 转 TTL 的</p><p>RX 接到开发板的 TX（</p><p>8）。GND 接一起，3.3V 可以选择接或不接。</p><p>根据上图设备管理器里面的信息，将串口工具配置成 COM14，REPL 串口配置成 COM27（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到开发板上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到 pyWiFi-ESP32-S2 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702111909798.png" alt="image-20230702111909798" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="LCD-显示屏"><a href="#LCD-显示屏" class="headerlink" title="LCD 显示屏"></a><strong>LCD</strong> <strong>显示屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>前面用到的 OLED 显示屏虽然能显示信息，但是颜色只有黑白，而且分辨率也比较低 128x64，本节我们来学习 3.2 寸 TFT_LCD 彩色显示屏的使用方法。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 MicorPython 编程方式实现 LCD 的各种显示功能，包括画点、线、矩形、圆形、显示英文、显示图片等</p><p>&nbsp;</p><p>实验用的 LCD 是 3.2 寸，驱动是的 ILI9341，使用 SPI 方式跟 ESP32-S2 通信，按以往嵌入式 C 语言开发，我们需要对 ILI9341 进行编程实现驱动，然后再建立各种描点、划线、以及显示图片函数。</p><p>使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点我们只需要搞清各个对象函数使如何使用即可。总的来说和前面实验一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉开发板该外设是怎么接线，初始化参数如何，而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！</p><p>我们管这些函数的集合叫<strong>驱动</strong>，驱动可以是预先在固件里面，也可以通过.py文件存放在开发板文件系统。也就是说工程师已经将复杂的底层代码封装好，我们顶层直接使用 python 开发即可，人生苦短。我们来看看 pyWiFi-ESP32-S2P 开发板 3.2 寸 LCD 的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>tftlcd.LCD32(portrait=1)</p><p>构建 3.2 寸 LCD 对象。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p>LCD32.fill(color)</p><p>【color】RGB 颜色数据；如(255,0,0)表示红色。</p><p>LCD32.drawPixel(x,y,color)</p><p>画点。</p><p>【x】:横坐标，</p><p>【y】:纵坐标，</p><p>【color】:颜色。</p><p>LCD32.drawLine(x0,y0,x1,y1,color)</p><p>画线段。</p><p>【x0,y0】:起始坐标，</p><p>【x1,y1】:终点坐标，</p><p>【color】:颜色</p><p>LCD32.drawRect(x,y,width,height,color,border=1,fillcolor=None)</p><p>画矩形。</p><p>【</p><p>x,y】:起始坐标，</p><p>【width】:宽度，</p><p>【height】:高度，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.drawCircle(x,y,radius,color,border=1,fillcolor=None)</p><p>画圆。</p><p>【x, y】:圆心，</p><p>【radius】:半径，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.printStr(text,x,y,color,backcolor=None,size=2)</p><p>写字符。</p><p>【text】:字符，</p><p>【x,y】:起始坐标,</p><p>【color】:字体颜色；</p><p>【backcolor】:字体背景颜色；</p><p>【size】:字体尺寸（1-小号，2-标准，3-中号，4-大号）</p><p>LCD32.Picture(x,y,filename)</p><p>显示图片。支持图片格式类型：jpg、bmp</p><p>【x,y】:起始坐标。</p><p>【filename】: 图片路径+名称，如：”/cat.jpg”</p><p><strong>（‘</strong>/<strong>’表示开发板的板载</strong> <strong>flash</strong> <strong>的根目录。）</strong></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们在使用中将以上功能都跑一遍先看看编程流程图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：3.2寸LCD液晶显示屏</span></span><br><span class="line"><span class="string">说明：通过编程实现LCD的各种显示功能，包括填充、画点、线、矩形、圆形、显示英文、显示图片等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义常用颜色</span></span><br><span class="line">RED = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">GREEN = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">BLUE = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line"><span class="comment"># 构建3.2寸LCD对象并初始化</span></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认方向竖屏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充白色</span></span><br><span class="line">d.fill(WHITE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画点</span></span><br><span class="line">d.drawPixel(<span class="number">5</span>, <span class="number">5</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画线段</span></span><br><span class="line">d.drawLine(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画矩形</span></span><br><span class="line">d.drawRect(<span class="number">5</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">40</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画圆</span></span><br><span class="line">d.drawCircle(<span class="number">100</span>, <span class="number">120</span>, <span class="number">30</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写字符,4种尺寸</span></span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">200</span>, RED, size=<span class="number">1</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">230</span>, GREEN, size=<span class="number">2</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">270</span>, BLUE, size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment">#等待5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/1.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/2.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/01studio.jpg&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>将示例程序的素材文件上传到 pyWiFi-ESP32-S2P 开发板。<strong>（也可以只上传单</strong>张图片，注意修改代码中文件的路径即可。）</p><p>&nbsp;</p><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了 LCD 实验，但 LCD 只能显示相关内容，跟人是缺乏交互的。好比我们的智能手机，如果只有显示不能触碰，那么就没有可玩性了。因此本节学习一下 3.2 寸 LCD 的电阻触摸屏使用方法。</p><p>⚫ <strong>实验讲解：</strong></p><p>01Studio 配套的 3.2 寸 LCD 上带电阻触摸屏,驱动芯片为 XPT2046。当手指按下时候，通过简单的编程即可返回一个坐标，我们来看看其 micropython 构造函数和使用方法：</p><p><strong>构造函数</strong></p><p><strong>touch.XPT2046(portrait=1)</strong></p><p>构建触摸屏对象。<strong>XPT2046</strong> 表示驱动芯片型号。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p><strong>XPT2046.tick_inc()</strong></p><p>手动刷新触摸。</p><p><strong>XPT2046.read()</strong></p><p>读取触摸屏数据，返回（states,x,y）</p><p>【states】-当前触摸状态：0：按下；1：移动；2：松开。</p><p>【x】:触摸横坐标</p><p>【y】:触摸纵坐标</p><p>&nbsp;</p><p>学会了触摸对象用法后，我们可以编程实现触摸后屏幕打点表示，然后左上角显示当前触摸的坐标。另外再加入一个按键，按下清空屏幕。编程流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：电阻触摸屏</span></span><br><span class="line"><span class="string">说明：电阻触摸屏采集触摸信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> touch <span class="keyword">import</span> XPT2046</span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色</span></span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line">RED=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认竖屏</span></span><br><span class="line">d.fill(WHITE) <span class="comment">#填充白色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#电阻触摸屏初始化，方向和LCD一致</span></span><br><span class="line">t = XPT2046(portrait=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    </span><br><span class="line">    d.fill(WHITE) <span class="comment">#清屏</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#USR按键初始化</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    data = t.read() <span class="comment">#获取触摸屏坐标</span></span><br><span class="line">    <span class="built_in">print</span>(data) <span class="comment">#REPL打印</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当产生触摸时</span></span><br><span class="line">    <span class="keyword">if</span> data[<span class="number">0</span>]!=<span class="number">2</span>: <span class="comment">#0：按下； 1：移动； 2：松开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#触摸坐标画圆</span></span><br><span class="line">        d.drawCircle(data[<span class="number">1</span>], data[<span class="number">2</span>], <span class="number">5</span>, BLACK, fillcolor=BLACK)</span><br><span class="line">        d.printStr(<span class="string">&#x27;(X:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">1</span>])+<span class="string">&#x27; Y:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">2</span>])+<span class="string">&#x27;)&#x27;</span>,<span class="number">10</span>,<span class="number">10</span>,RED,size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep_ms(<span class="number">20</span>) <span class="comment">#触摸响应间隔</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>运行程序，首次运行会自动提示进行触摸校准（电阻屏需要校准），按提示分别点击四个角落进行校准，如校准失败会自动重复。校准成功会自动保存一个“touch.cail”文件到开发板 flash，下次无须再校准。</p><p>成功后出现空白画面，用手指触摸屏幕或者在屏幕上滑动，可以看到描点并在 LCD 左上角显示当前坐标。</p><p>重启开发板，可以看到文件系统多了一个“touch.cail”，在运行电阻屏初始化时候会检测这个文件，如果存在则不进行校准，若想重新校准的用户可以把这个文件删除即可！</p><p>⚫ <strong>总结：</strong></p><p>没有触摸屏的 LCD 就失去了灵魂，有了触摸屏，跟开发板的交互就变得有意思了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础实验&quot;&gt;&lt;a href=&quot;#基础实验&quot; class=&quot;headerlink&quot; title=&quot;基础实验&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础实验&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>esp32</title>
    <link href="https://rozen12123.github.io/posts/86375cb2.html"/>
    <id>https://rozen12123.github.io/posts/86375cb2.html</id>
    <published>2023-07-01T13:55:14.000Z</published>
    <updated>2023-07-06T07:47:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32"><a href="#esp32" class="headerlink" title="esp32"></a>esp32</h1><h2 id="ESP32-S2-平台"><a href="#ESP32-S2-平台" class="headerlink" title="ESP32-S2 平台"></a><strong>ESP32-S2</strong> <strong>平台</strong></h2><h3 id="pyWiFi-ESP32-S2"><a href="#pyWiFi-ESP32-S2" class="headerlink" title="pyWiFi-ESP32-S2"></a><strong>pyWiFi-ESP32-S2</strong></h3><p>pyWiFi-ESP32-S2 是由 01Studio 设计研发，基于 ESP32-S2 平台的 MicroPython</p><p>开发板，主要特点如下：</p><p> 自动下载电路</p><p> 板载锂电池输入接口和充电电路</p><p> 标准 24P 摄像头接口</p><p> USB OTG 接口</p><p> 全 IO 引出</p><p> 按键和 LED 排列整齐，丝印清晰</p><p> 兼容 pyBoard 接口</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701220231747.png" class title="image-20230701220231747"><img src="/posts/86375cb2.htm/86375cb2/image-20230701220244595.png" class title="image-20230701220244595"><h3 id="开发环境快速建立"><a href="#开发环境快速建立" class="headerlink" title="开发环境快速建立"></a><strong>开发环境快速建立</strong></h3><p>ESP32-S2 是基于是继 ESP32 普遍板后推出的一个版本，主要特点是引脚数量非常多。还支持标准 USB HOST。</p><h4 id="安装开发软件-Thonny"><a href="#安装开发软件-Thonny" class="headerlink" title="安装开发软件 Thonny"></a><strong>安装开发软件</strong> <strong>Thonny</strong></h4><p>Thonny Python IDE 是一款开源软件，以极简方式设计，对 MicroPython 的兼容性非常友善。而且支持 Windows、Mac OS、Linux、树莓派。由于开源，所以软</p><p>件迭代速度非常快，功能日趋成熟。具体安装方法如下：在 <a href="https://thonny.org/">https://thonny.org/</a> 下载最新版，选择自己的开发平台进行下载安装即可(这里选择 Windows！)：</p><p>&nbsp;</p><h3 id="REPL-串口交互调试"><a href="#REPL-串口交互调试" class="headerlink" title="REPL 串口交互调试"></a><strong>REPL</strong> <strong>串口交互调试</strong></h3><p>yWiFi-ESP32-S2 的 MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试开发板。我们打开 Thonny，将开发板连接到电脑。点击右下角：</p><p><img src="/posts/86375cb2.htm/image-20230701221427314.png" alt="image-20230701221427314" style="zoom:50%;"></p><p>在弹出的列表选择：<strong>Configure interpreter</strong></p><img src="/posts/86375cb2.htm/86375cb2/image-20230701221436676.png" class title="image-20230701221436676"><p>选择“MicroPython（ESP32）”和开发板对应的串口号，点击确认。</p><p><img src="/posts/86375cb2.htm/image-20230701221656057.png" alt="image-20230701221656057" style="zoom:50%;"></p><p>连接成功后可以在 shell（串口终端）看到固件的相关信息：</p><p><img src="/posts/86375cb2.htm/image-20230701221713389.png" alt="image-20230701221713389" style="zoom:50%;"></p><p>我们在 Shell 里面输入 print(“Hello 01Studio!”) , 按回车，可以看到打印出Hello 01Studio 字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">LED = Pin(<span class="number">2</span>, Pin.OUT) </span><br><span class="line">LED.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/posts/86375cb2.htm/image-20230701221806760.png" alt="image-20230701221806760" style="zoom:50%;"></p><p>接下来我们将上一节的三行代码逐行输入和逐行按回车，可以看到 LED 灯也被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701222057224.png" alt="image-20230701222057224" style="zoom:50%;"></p><p>REPL 还有一个强大的功能就是打印错误的代码来调试程序，在后面代码运行时候，如果程序出错，出错信息将通过 REPL 打印。</p><p><img src="/posts/86375cb2.htm/image-20230701222115947.png" alt="image-20230701222115947" style="zoom:50%;"></p><p><strong>REPL</strong> <strong>终端常用键盘按键：</strong></p><p>Ctrl + C : 打断正在运行的程序（特别是含 While True: 的代码）；</p><p>Ctrl + D : 软件复位开发板</p><p>&nbsp;</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p>pyWiFi-ESP32-S2 里面内置了文件系统，可以简单理解成上电后运行的 python文件，这个可以通过 Thonny 非常方便地读写。</p><p>点击 <strong>视图</strong>—<strong>文件</strong> ：</p><p><img src="/posts/86375cb2.htm/image-20230701222203009.png" style="zoom:50%;"></p><p>可以看到左边出现本地和开发板的实时文件浏览窗口：</p><p><img src="/posts/86375cb2.htm/image-20230701222237796.png" alt="image-20230701222237796" style="zoom:50%;"></p><p>在本地文件点击右键—上传到即可将相关文件发送到开发板，也可以将开发板上的文件发送到本地，非常方便。</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><strong>代码测试</strong></h3><p>前面已经安装好了 Thonny IDE 和配置，接下来使用最简单的方式来做一个点亮 LED 蓝灯的实验。具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮LED蓝灯</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入Pin模块</span></span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建led对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮LED，也可以使用led.on()</span></span><br></pre></td></tr></table></figure><p>运行功能代码是保存在开发板的 RAM（内存）里面，断电后丢失，那么如何实现开发板上电运行我们的代码呢？方法如下：</p><p>Micropython 上电默认先运行名字为 boot.py 文件，然后在运行 main.py 文件，如果没有 boot.py 那么直接运行 main.py。</p><p><strong>boot.py:</strong> <strong>一般用于配置初始化参数；</strong></p><p><strong>main.py**</strong>：主程序**</p><p>也就是我们只需要将代码以 main.py 文件发送到开发板，那么开发板就可以实现上电运行相关程序。</p><p>我们将 LED 例程的 main.py 发送到开发板</p><p><img src="/posts/86375cb2.htm/image-20230701222956537.png" alt="image-20230701222956537" style="zoom:50%;"></p><p>按下开发板的复位键，可以看到 LED 蓝灯被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701223032307.png" alt="image-20230701223032307" style="zoom:50%;"></p><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>固件更新是指重新烧写开发板的出厂文件或者是升级的固件，使用上海乐鑫提供的官方软件烧录：</p><p><img src="/posts/86375cb2.htm/image-20230701223127927.png" alt="image-20230701223127927" style="zoom:50%;"></p><p>芯片这里选择 ESP32-S2，develop 开发者模式，然后点击 OK :</p><p><img src="/posts/86375cb2.htm/image-20230701223146766.png" alt="image-20230701223146766" style="zoom:50%;"></p><p>选择 SPIDownload，在下图箭头位置点击，选择要烧录固件。</p><p>其它配置选项也请参考下图，注意下载地址是 <strong>0x1000</strong>。（COM 串口是选择自己的串口，在设备管理器查询。）</p><p><img src="/posts/86375cb2.htm/image-20230701223234252.png" alt="image-20230701223234252" style="zoom:50%;"></p><p>配置好后，先点击“ERASE”按钮刷除模块里面内容。点击软件下方“ERASE”按钮，刷除成功后，左边绿色框出现完成字样</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223253705.png" class title="image-20230701223253705"><p>刷除成功后，点击“START”按钮开始烧录，烧录完成有左边绿色框出现“完成”字样。完成后记得点”stop”按钮或者关闭软件释放串口。</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223316527.png" class title="image-20230701223316527">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;esp32&quot;&gt;&lt;a href=&quot;#esp32&quot; class=&quot;headerlink&quot; title=&quot;esp32&quot;&gt;&lt;/a&gt;esp32&lt;/h1&gt;&lt;h2 id=&quot;ESP32-S2-平台&quot;&gt;&lt;a href=&quot;#ESP32-S2-平台&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="esp32" scheme="https://rozen12123.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>k210项目</title>
    <link href="https://rozen12123.github.io/posts/384e6f73.html"/>
    <id>https://rozen12123.github.io/posts/384e6f73.html</id>
    <published>2023-03-19T10:30:52.000Z</published>
    <updated>2023-07-06T07:52:19.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="照相机"><a href="#照相机" class="headerlink" title="照相机"></a>照相机</h2><p>本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复</p><p>外部中断按键实验：请参阅 <strong>4.4</strong> <strong>外部中断</strong> 章节内容；</p><p>拍摄照片实验：请参阅 <strong>5.9</strong> <strong>图片拍摄</strong> 章节内容。</p><p>拍照后我们应该让图片停留一段时间，让用户观察照片的拍摄情况，然后再进行继续拍摄。代码编写流程如下：</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, utime</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 KEY 的外部 IO</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建 KEY 对象</span></span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># or sensor.GRAYSCALE</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># or sensor.QVGA (or others)</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #摄像头后置模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">key_node = <span class="number">0</span> <span class="comment">#按键标志位</span></span><br><span class="line">name_num = <span class="number">0</span> <span class="comment">#照片名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 按键和其回调函数</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"></span><br><span class="line"> <span class="keyword">global</span> key_node</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">  key_node = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> lcd.display(sensor.snapshot()) <span class="comment"># LCD 实时显示</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> key_node==<span class="number">1</span>: <span class="comment">#按键被按下</span></span><br><span class="line">  key_node = <span class="number">0</span> <span class="comment">#清空按键标志位</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#拍照并保存，保存文件用时间来命名。</span></span><br><span class="line">  lcd.display(sensor.snapshot().save(<span class="built_in">str</span>(name_num)+<span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line">  name_num=name_num+<span class="number">1</span> <span class="comment">#名字编码加 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Done! Reset the camera to see the saved image.&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#延时 3 秒，观看拍摄图片</span></span><br><span class="line"></span><br><span class="line">  utime.sleep_ms(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a><strong>视频播放器</strong></h2><p>音视频解码是一个复杂的过程，但 K210 底层 MicroPython 库写好后，着重应用来编程就变得非常简单了。和以往一样，我们只需要熟悉模块用法即可。</p><p>本实验实验 01Studio 音频模块，基于 PAM8403 的一款 D 类功放 IC，和麦克风一样使用 I2S 接口通信，这里不再重复 I2S 内容。</p><p>而视频播放被封装成 video 模块，在前面视频录制章节内容已经介绍过，这里重温一下，模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：视频播放器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">翻译和注释：01Studio</span></span><br><span class="line"><span class="string">说明：AVI视频播放。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> video,time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">    audio_en=GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频控制IO</span></span><br><span class="line">fm.register(<span class="number">34</span>,  fm.fpioa.I2S0_OUT_D1, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">35</span>,  fm.fpioa.I2S0_SCLK, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">33</span>,  fm.fpioa.I2S0_WS, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#播放avi文件</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/badapple.avi&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印视频文件信息</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音量调节</span></span><br><span class="line">v.volume(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v.play() == <span class="number">0</span>: <span class="comment">#播放完毕</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;play end&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">v.__del__() <span class="comment">#销毁对象，释放内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本实验播放的视频是 badapple.avi，文件在本例程文件夹中，先将该文件拷贝到 sd 卡。然后将 sd 卡插到 pyAI-K210。</p><p>接上 01Studio 音频模块，运行本实验程序代码，可以见到串口终端打印了avi 视频信息后，开发板便开始播放视频。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="NES-游戏机"><a href="#NES-游戏机" class="headerlink" title="NES 游戏机"></a><strong>NES</strong> <strong>游戏机</strong></h2><p>MaixPy 集成了 NES 的 MicroPython 模块,用户通过几行代码就可以实现游戏的加载，已经使用键盘或者标准游戏手柄来操控。NES 对象如下：</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nes</span><br></pre></td></tr></table></figure><p>导入 nes 模块；</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=<span class="number">16</span>,vol=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>初始化 nes 游戏模拟器；</p><p>【rc_type】遥控类型。nes.KEYBOARD:REPL 中使用键盘；nes.JOYSTICK:PS2 手柄。</p><p>【cs,mosi,miso,clk】使用 PS2 手柄时的引脚配置；</p><p>【repeat】键盘按键重复率；</p><p>【vol】音量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.run(xx.nes)</span><br></pre></td></tr></table></figure><p>运行 nes 文件。</p><p>*更多使用说明请阅读官方文档：</p><p>&nbsp;</p><p>键盘和手柄的快捷键如下：</p><h4 id="键盘（串口）"><a href="#键盘（串口）" class="headerlink" title="键盘（串口）"></a>键盘（串口）</h4><p>【移动】：WSAD(上下左右)</p><p>【A】：J</p><p>【B】：K</p><p>【start】：M 或 Enter</p><p>【option】：N 或\</p><p>【退出】：ESC</p><p>【音量-】：-</p><p>【音量+】：=</p><p>【运行速度-】：R</p><p>【运行速度+】：F</p><h4 id="PS2-手柄"><a href="#PS2-手柄" class="headerlink" title="PS2 手柄"></a>PS2 手柄</h4><p>【移动】：方向键(上下左右)</p><p>【A】：口</p><p>【B】：X</p><p>【start】：START</p><p>【option】：SELECT</p><p>【退出】：暂无</p><p>【音量-】：R2</p><p>【音量+】：R1</p><p>【运行速度-】：L1</p><p>【运行速度+】：L2</p><p>从上表 NES 对象看到，只需要简单的初始化和运行语句，即可运行 NES 游戏模拟器，编程思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> nes, lcd</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化nes，配置为键盘控制</span></span><br><span class="line">nes.init(nes.KEYBOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行游戏</span></span><br><span class="line">nes.run(<span class="string">&quot;/sd/Bomberman.nes&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;照相机&quot;&gt;&lt;a href=&quot;#照相机&quot; class=&quot;headerlink&quot; title=&quot;照相机&quot;&gt;&lt;/a&gt;照相机&lt;/h2&gt;&lt;p&gt;本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复&lt;/p&gt;
&lt;p&gt;外部中断按键实验：请参阅 &lt;stron</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210拓展模块</title>
    <link href="https://rozen12123.github.io/posts/a4696bae.html"/>
    <id>https://rozen12123.github.io/posts/a4696bae.html</id>
    <published>2023-03-19T07:25:35.000Z</published>
    <updated>2023-07-06T07:52:10.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拓展模块"><a href="#拓展模块" class="headerlink" title="拓展模块"></a><strong>拓展模块</strong></h2><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>本实验 LCD 触摸屏上使用 NS2009 芯片，将电阻触摸屏信号转化为 I2C 信号跟 K210 通信，而 MaixPy 已经集成了触摸屏应用的相关函数模块，具体介绍如下：</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br></pre></td></tr></table></figure><p>导入 touchscreen 模块;</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.init(i2c=<span class="literal">None</span>,cal=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>初始化触摸屏。</p><p>【i2c】I2C 总线；</p><p>【cal】一个 7 个整型值的元组，触摸校准数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.calibrate()</span><br></pre></td></tr></table></figure><p>触摸校准。返回一个 7 个整型值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.read()</span><br></pre></td></tr></table></figure><p>读取屏幕状态和坐标信息。返回（status,x,y）</p><p>【status】: 触摸状态，取值有如下</p><p>touchscreen.STATUS_RELEASE,值为 1，触摸屏没动作；</p><p>touchscreen.STATUS_PRESS,值为 2，触摸屏被按下；</p><p>touchscreen.STATUS_MOVE,值为 3，触摸屏在滑动；</p><p>【x】x 轴坐标</p><p>【y】y 轴坐标</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">import</span> lcd, image</span><br><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br><span class="line"></span><br><span class="line"><span class="comment">#按键 KEY 用于清屏</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">btn_clear = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸使用 I2C 控制（NS2009）</span></span><br><span class="line">i2c = I2C(I2C.I2C0, freq=<span class="number">400000</span>, scl=<span class="number">30</span>, sda=<span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸屏初始化</span></span><br><span class="line">ts.init(i2c)</span><br><span class="line"><span class="comment">#ts.calibrate() #触摸校准</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">lcd.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建图像和触摸屏相关参数变量</span></span><br><span class="line">img = image.Image()</span><br><span class="line">status_last = ts.STATUS_IDLE</span><br><span class="line">x_last = <span class="number">0</span></span><br><span class="line">y_last = <span class="number">0</span></span><br><span class="line">draw = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#获取触摸屏状态</span></span><br><span class="line"> (status,x,y) = ts.read()</span><br><span class="line"> <span class="built_in">print</span>(status, x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line"> <span class="keyword">if</span> draw:</span><br><span class="line">  img.draw_line((x_last, y_last, x, y))</span><br><span class="line"></span><br><span class="line"> <span class="comment">#更新最后坐标</span></span><br><span class="line"> x_last = x</span><br><span class="line"> y_last = y</span><br><span class="line"></span><br><span class="line"> <span class="comment">#根据触摸屏状态判断是否继续执行画图功能</span></span><br><span class="line"> <span class="keyword">if</span> status_last!=status:</span><br><span class="line">  <span class="keyword">if</span> (status==ts.STATUS_PRESS <span class="keyword">or</span> status == ts.STATUS_MOVE):</span><br><span class="line">   draw = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#松开</span></span><br><span class="line">   draw = <span class="literal">False</span></span><br><span class="line">  status_last = status</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#按键 KEY 按下清屏</span></span><br><span class="line"> <span class="keyword">if</span> btn_clear.value() == <span class="number">0</span>:</span><br><span class="line">  img.clear()</span><br></pre></td></tr></table></figure><p>固件用如下所示固件，其中含有touchscreen库</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a><strong>舵机</strong></h3><p>伺服电机对象通过 3 线（信号，电源，地）控制，pyBase 上有 4 个位置可以插这些电机，分别是 X1-X4 引脚。对应 pyAI-K210 的 17、35、34、33 脚。</p><p>180°舵机的控制一般需要一个 20ms 左右的时基脉冲，该脉冲的高电平部分一般为 0.5ms-2.5ms 范围内的角度控制脉冲部分，总间隔为 2ms。以 180 度角度伺服为例，在 MicroPython 编程对应的控制关系是从-90°至 90°，示例图如下</p><p>而对于 360°连续旋转舵机，上面的脉冲表则对应从正向最大速度旋转到反向最大速度旋转的过程。</p><p>如果过你学习过前面基于 STM32 平台的舵机实验，那就知道在 STM32 平台集成了舵机模块，使用起来非常方便。当前的 ESP32 平台并没有集成 Servo 模块，但从上面可以看到上面是通过 PWM 来控制的，我们可以直接写 PWM 函数驱动即可。代码编程流程图如下：</p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO17 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">S1 = PWM(tim, freq=<span class="number">50</span>, duty=<span class="number">0</span>, pin=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">说明：舵机控制函数</span></span><br><span class="line"><span class="string">功能：180 度舵机：angle:-90 至 90 表示相应的角度</span></span><br><span class="line"><span class="string"> 360 连续旋转度舵机：angle:-90 至 90 旋转方向和速度值。</span></span><br><span class="line"><span class="string"> 【duty】占空比值：0-100</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Servo</span>(<span class="params">servo,angle</span>):</span><br><span class="line"> S1.duty((angle+<span class="number">90</span>)/<span class="number">180</span>*<span class="number">10</span>+<span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#-90 度</span></span><br><span class="line"> Servo(S1,-<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#-45 度</span></span><br><span class="line"> Servo(S1,-<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#0 度</span></span><br><span class="line"> Servo(S1,<span class="number">0</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#45 度</span></span><br><span class="line"> Servo(S1,<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#90 度</span></span><br><span class="line"> Servo(S1,<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将 180°舵机插到 pyBase 的 X1 的三线接口，运行程序。可以看到舵机依次旋转至不同角度。</p><p>⚫ <strong>实验拓展：</strong></p><p>我们刚刚实现了 180°舵机的角度控制，现在来做一下 360°连续旋转舵机的实验，360°连续旋转舵机可以实现直流减速电机功能，用在小车或者航模上。</p><p>实验的代码不变，参数【-90 至 90】代表旋转方向和速度值大小。插上 360°连续旋转舵机。可以看到舵机的旋转速度和方向逐渐变变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拓展模块&quot;&gt;&lt;a href=&quot;#拓展模块&quot; class=&quot;headerlink&quot; title=&quot;拓展模块&quot;&gt;&lt;/a&gt;&lt;strong&gt;拓展模块&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;电阻触摸屏&quot;&gt;&lt;a href=&quot;#电阻触摸屏&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>机器听觉</title>
    <link href="https://rozen12123.github.io/posts/e06f755d.html"/>
    <id>https://rozen12123.github.io/posts/e06f755d.html</id>
    <published>2023-03-19T05:38:31.000Z</published>
    <updated>2023-07-06T07:55:59.679Z</updated>
    
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210机器视觉</title>
    <link href="https://rozen12123.github.io/posts/210a3ee2.html"/>
    <id>https://rozen12123.github.io/posts/210a3ee2.html</id>
    <published>2023-03-18T14:32:27.000Z</published>
    <updated>2023-07-06T07:51:57.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a><strong>LCD</strong></h3><p>LCD 液晶显示屏是非常常见的一个外接显示设备，跟前面的 OLED 显示屏相比，LCD 会更常用一些，我们看到的手持设备、小型电器，很多都用到 LCD，部分配合触摸屏应用，能实现非常多的功能。</p><p>除此之外，LCD 还是 pyAI-K210 机器视觉应用中显示的重要工具。</p><p>本实验用的 LCD 是 2.8 寸，驱动是常见的 ST7789V，使用 8 位接口跟 pyAIK210 通信，按以往嵌入式 C 语言开发，我们需要对 ST7789 进行编程实现驱动，然后再建立各种字符显示及显示图片等函数。使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点，我们只需要搞清各个对象函数使如何使用即可。总的来说和之前一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉 pyAI-K210 外设是怎么接线，是什么样的；而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！我们管这些函数的集合叫驱动，MaixPy 已经将这 LCD.py 驱动写好了，我们学会如何使用即可。其构造函数和使用方法如下：</p><p>&nbsp;</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.init(<span class="built_in">type</span>=<span class="number">1</span>,freq=<span class="number">15000000</span>,color=lcd.BLACK)</span><br></pre></td></tr></table></figure><p>初始化 LCD。</p><p>【type】LCD 类型；</p><p>【freq】通信频率；</p><p>【color】LCD 初始化的颜色。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.deinit()</span><br></pre></td></tr></table></figure><p>注销 LCD 驱动，释放 IO 引脚。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.clear(color)</span><br></pre></td></tr></table></figure><p>填充指定颜色。默认是黑色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.draw_string(x,y,<span class="built_in">str</span>,color,bg_color)</span><br></pre></td></tr></table></figure><p>写字符</p><p>【x,y】起始坐标；</p><p>【str】字符内容</p><p>【color】字体颜色</p><p>【bg_color】字体背景颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.display(image,roi=Auto)</span><br></pre></td></tr></table></figure><p>显示图片。</p><p>【image】RGB565 或 GRAYSCALE 图片。</p><p>【ROI】显示的感兴趣区域，未指定则为图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.rotation(<span class="built_in">dir</span>)</span><br></pre></td></tr></table></figure><p>LCD 屏幕方向设定。</p><p>【dir】取值范围[0-3]，从 0 到 3 依顺时钟旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.mirror(invert)</span><br></pre></td></tr></table></figure><p>镜面显示。</p><p>【invert】=True 则为镜面显示；=False 则否。</p><p>更多 LCD 模块说明请看 MaxiPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html</a></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们来跑</p><p>一下其主要功能显示字符和图像，代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lcd,image,utime</span><br><span class="line">lcd.init() <span class="comment">#初始化 LCD</span></span><br><span class="line">lcd.clear(lcd.WHITE) <span class="comment">#清屏白色</span></span><br><span class="line"><span class="comment">#显示字符</span></span><br><span class="line">lcd.draw_string(<span class="number">110</span>, <span class="number">120</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>,lcd.BLACK, lcd.WHITE) <span class="comment">#显示字符</span></span><br><span class="line">utime.sleep(<span class="number">2</span>) <span class="comment">#延时 2 秒</span></span><br><span class="line">lcd.rotation(<span class="number">1</span>) <span class="comment">#由于图像默认是 240*320，因此顺时钟旋转 90°。</span></span><br><span class="line"><span class="comment">#显示图像，必须先将 01Studio.bmp 文件发送到开发板才能正常运行</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;01Studio.bmp&quot;</span>))</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="摄像头应用"><a href="#摄像头应用" class="headerlink" title="摄像头应用"></a><strong>摄像头应用</strong></h3><p>从前面的基础实验我们熟悉了 K210 基于 MicroPython 的编程方法，但那可以说是只发挥了 K210 冰山一角的性能应用，摄像头是整个机器视觉应用的基础。今天我们就通过示例代码来看看 pyAI-K210 是如何使用摄像头的。</p><p>&nbsp;</p><p>MaixPy 机器视觉库代码大部分都是参考 OpenMV 移植过来，其已经将所有的摄像头功能封装到 sersor 模块中，用户可以通过调用轻松使用。这也是使用MicroPython 编程的魅力所在。</p><p>&nbsp;</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>sensor</p><p>摄像头对象，通过 import 直接调用</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.reset()</span><br></pre></td></tr></table></figure><p>初始化摄像头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_pixformat(*pixformat*)</span><br></pre></td></tr></table></figure><p>设置像素格式。pixformat 有 3 个参数。</p><p>sensor.GRAYSCAL：灰度图像，每像素 8 位（1 字节），处理速度快；</p><p>sensor.RGB565: 每像素为 16 位（2 字节），5 位用于红色，6 位用于绿色，5 位用于蓝色，处理速度比灰度图像要慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_framesize(*framesize*)</span><br></pre></td></tr></table></figure><p>设置每帧大小（即图像尺寸）。常用的 <em>framesize</em> 参数有下面这些：</p><p>sensor.QQVGA: 160*120;</p><p>sensor.QVGA: 320*240;</p><p>sensor.VGA: 640*480;</p><p>sensor.skip_frames([<em>n</em>, <em>time</em>])</p><p>摄像头配置后跳过 n 帧或者等待时间 time 让其变稳定。n:跳过帧数；time：等待</p><p>时间,单位 ms。</p><p>（如果 n 和 time 均没指定，则默认跳过 300 毫秒的帧。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.snapshot()</span><br></pre></td></tr></table></figure><p>使用相机拍摄一张照片，并返回 image 对象。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio</a></p><p>n/sensor.html</p><p>&nbsp;</p><p>我们再来看看本例程用于计算 FPS（每秒帧数）的 clock 模块。</p><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock=time.clock()</span><br></pre></td></tr></table></figure><p>创建一个时钟。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.tick()</span><br></pre></td></tr></table></figure><p>开始追踪运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.fps ()</span><br></pre></td></tr></table></figure><p>停止追踪运行时间，并返回当前 FPS（每秒帧数）。</p><p>在调用该函数前始终首先调用 tick 。</p><p>*其它更多用法请阅读 Maixpy 官方文档：</p><p>文档链接：<a href="http://docs.openmv.io/library/omv.time.html">http://docs.openmv.io/library/omv.time.html</a></p><p>&nbsp;</p><p>&nbsp;</p><p>我们来看看 helloword 代码的编写流程图：</p><p>这个实验运行的就是编辑框里面的 helloworld 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>) <span class="comment">#初始化 LCD</span></span><br><span class="line">sensor.reset() <span class="comment">#复位和初始化摄像头，执行 sensor.run(0)停止。</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式为彩色 RGB565 (或灰色)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧大小为 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 等待设置生效.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 创建一个时钟来追踪 FPS（每秒拍摄帧数）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() <span class="comment"># 更新 FPS 时钟.</span></span><br><span class="line"> img = sensor.snapshot() <span class="comment"># 拍摄一个图片并保存.</span></span><br><span class="line"> lcd.display(img) <span class="comment"># 在 LCD 上显示</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># 注意: 当 K210 连接到 IDE 时候，运行速度减</span></span><br><span class="line"> <span class="comment">#半，因此当断开 IDE 时 FPS 会提升。</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a><strong>画图</strong></h3><p>通过摄像头采集到照片后，我们会进行一些处理，而这时候往往需要一些图形来指示，比如在图片某个位置标记箭头、人脸识别后用矩形框提示等。本节就是学习在图形上画图的使用功能。</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot() 或 img=image.Image(path[, copy_to_fb=<span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>创建图像，通过拍摄或者读取文件路径获取。</p><p><em>copy_to_fb=True**：可以加载大图片；</em></p><p>copy_to_fb=False：不可以加载大图片。</p><p>示例：img = image.Image(“01Studio.bmp”, copy_to_fb=True),表示加载根</p><p>目录下的 01Studio.bmp 图片。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_line(*x0*, *y0*, *x1*, *y1*[, *color*[, *thickness=<span class="number">1</span>*]])</span><br></pre></td></tr></table></figure><p>画线段。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色，如</p><p>（255,0,0）表示红色；thickness：粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_rectangle(*x*, *y*, *w*, *h*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画矩形。（x,y）:起始坐标；w:宽度；h:长度；color：颜色；thickness：边框粗细；fill:是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_circle(*x*, *y*, *radius*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画圆。（x,y）:圆心； radius:半径； color：颜色；thickness:线条粗细；</p><p>fill：是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_arrow(*x0*, *y0*, *x1*, *y1*[, *color*[, size,[thickness*=<span class="number">1</span>]*]])</span><br></pre></td></tr></table></figure><p>画箭头。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色；size:箭头位置大小。thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_cross(*x*, *y*[, *color*[, *size=<span class="number">5</span>*[, *thickness=<span class="number">1</span>*]]])</span><br></pre></td></tr></table></figure><p>画十字交叉。（x,y）:交叉坐标；color:颜色；size:尺寸；thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_string(*x*, *y*, *text*[, *color*[, *scale=*<span class="number">1</span>[,*mono_space=<span class="literal">True</span>*…]]]])</span><br></pre></td></tr></table></figure><p>写字符。(x,y): 起始坐标；text:字符内容；color：颜色；scale：字体大小；</p><p>mono_space:强制间距。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>&nbsp;</p><p>熟悉了 image 对象的画图功能后，我们尝试在摄像头采集到的画面依次画出线段、矩形、圆形、箭头、十字交叉和字符。具体编程思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>)</span><br><span class="line">sensor.reset() <span class="comment">#复位摄像头</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式 RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧尺寸 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 灯带设置响应.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 新建一个时钟对象计算 FPS.</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() </span><br><span class="line"> img = sensor.snapshot() </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 画线段：从 x0, y0 到 x1, y1 坐标的线段，颜色红色，线宽度 2。</span></span><br><span class="line"> img.draw_line(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>, color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画矩形：绿色不填充。</span></span><br><span class="line"> img.draw_rectangle(<span class="number">150</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line"> thickness = <span class="number">2</span>, fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画圆：蓝色不填充。</span></span><br><span class="line"> img.draw_circle(<span class="number">60</span>, <span class="number">120</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness = <span class="number">2</span>,</span><br><span class="line"> fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画箭头：白色。</span></span><br><span class="line"> img.draw_arrow(<span class="number">150</span>, <span class="number">120</span>, <span class="number">250</span>, <span class="number">120</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size =</span><br><span class="line"> <span class="number">20</span>, thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画十字交叉。</span></span><br><span class="line"> img.draw_cross(<span class="number">60</span>, <span class="number">200</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size = <span class="number">20</span>,</span><br><span class="line"> thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#写字符。</span></span><br><span class="line"> img.draw_string(<span class="number">150</span>, <span class="number">200</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>, color = (<span class="number">255</span>, <span class="number">255</span>,</span><br><span class="line"> <span class="number">255</span>), scale = <span class="number">2</span>,mono_space = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment"># Display on LCD</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># Note: MaixPy&#x27;s Cam runs about half as fast when connected</span></span><br><span class="line"> <span class="comment"># to the IDE. The FPS should increase once disconnected</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a><strong>颜色识别</strong></h3><p>我们活在一个色彩斑斓的世界里。本节我们来学习机器视觉中的颜色识别。我们会预先设定颜色阈值，如红、绿、蓝。这样 K210 摄像头采集图像后就能自动识别了。</p><p>&nbsp;</p><p>通过编程实现 pyAI-K210 识别程序预先设定的颜色色块，分别是红、绿、蓝三种颜色。</p><p>MaixPy 集成了 RGB565 颜色块识别 find_blobs 函数，主要是基于 LAB 颜色模型（每个颜色都是用一组 LAB 阈值表示，有兴趣的用户可以自行查阅相关模型资料）。其位于 image 模块下，因此我们直接将拍摄到的图片进行处理即可，那么我们像以往一样像看一下本实验相关对象和函数说明，具体如下：</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_blobs(thresholds[,invert=<span class="literal">False</span>[,roi[,x_stride=<span class="number">2</span>[,y_stride=<span class="number">1</span>[,area_threshold=<span class="number">10</span>[,pixels_threshold=<span class="number">10</span>[,merge=<span class="literal">False</span>[,margin=<span class="number">0</span>[, threshold_cb=<span class="literal">None</span>[, merge_cb=<span class="literal">None</span>]]]]]]]]]])</span><br></pre></td></tr></table></figure><p>查找图像中指定的色块。返回 image.blog 对象列表；</p><p>【thresholds】 必须是元组列表。 [(lo, hi), (lo, hi), …, (lo, hi)] 定义你想追踪的颜</p><p>色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰</p><p>度值。 仅考虑落在这些阈值之间的像素区域。 对于 RGB565 图像，每个元</p><p>组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是 LAB L，A 和 B</p><p>通道的最小值和最大值。</p><p>【area_threshold】若色块的边界框区域小于此参数值，则会被过滤掉；</p><p>【pixels_threshold】若色块的像素数量小于此参数值，则会被过滤掉；</p><p>【merge】若为 True,则合并所有没有被过滤的色块；</p><p>【margin】调整合并色块的边缘。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.blob。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.rect()</span><br></pre></td></tr></table></figure><p>返回一个矩形元组（x,y,w,h）,如色块边界。可以通过索引[0-3]来获得这些值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cx()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 x 位置。可以通过索引[5]来获得这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cy()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 y 位置。可以通过索引[6]来获得这个值。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>了解了找色块函数应用方法后，我们可以理清一下编程思路，代码编写流程如下：</p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式，所见即所得</span></span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock=time.clock()</span><br><span class="line"><span class="comment"># 颜色识别阈值 (L Min, L Max, A Min, A Max, B Min, B Max) LAB 模型</span></span><br><span class="line"><span class="comment"># 下面的阈值元组是用来识别 红、绿、蓝三种颜色，当然你也可以调整让识别变得更好。</span></span><br><span class="line">thresholds = [(<span class="number">30</span>, <span class="number">100</span>, <span class="number">15</span>, <span class="number">127</span>, <span class="number">15</span>, <span class="number">127</span>), <span class="comment"># 红色阈值</span></span><br><span class="line"> (<span class="number">30</span>, <span class="number">100</span>, -<span class="number">64</span>, -<span class="number">8</span>, -<span class="number">32</span>, <span class="number">32</span>), <span class="comment"># 绿色阈值</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">64</span>, -<span class="number">128</span>, -<span class="number">20</span>)] <span class="comment"># 蓝色阈值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> clock.tick()</span><br><span class="line"> </span><br><span class="line"> img=sensor.snapshot()</span><br><span class="line"> </span><br><span class="line"> blobs = img.find_blobs([thresholds[<span class="number">2</span>]]) <span class="comment"># 0,1,2 分别表示红，绿，蓝色。</span></span><br><span class="line"> <span class="keyword">if</span> blobs:</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> blobs:</span><br><span class="line">   tmp=img.draw_rectangle(b[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">   tmp=img.draw_cross(b[<span class="number">5</span>], b[<span class="number">6</span>])</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment">#LCD 显示图片</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>在 IDE 中运行代码，代码默认检测的是蓝色，用户可以自行修改 find_blobs()参数的阈值数组编号来切换识别颜色</p><p>&nbsp;</p><h3 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a><strong>二维码识别</strong></h3><p>相信大家都知道二维码了，特别是在扫描支付越来越流行的今天，二维码的应用非常广泛。今天我们就来学习如何使用 pyAI-K210 开发套件实现二维码信息识别</p><p>而对于 pyAI-K210 而言，直接使用 MicroPython 中的 find_qrcodes()即可获取摄像头采集图像中二维码的相关信息。具体说明如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_qrcodes([roi])</span><br></pre></td></tr></table></figure><p>查找 roi 区域内的所有二维码并返回一个 image.qrcode 的对象列表。</p><h4 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.qrcode 对象列表。</p><p>qrcode.rect()</p><p>返回一个矩形元组（</p><p>x,y,w,h）;</p><p>qrcode.payload()</p><p>返回二维码字符串信息。可以通过索引[4]来获得这个值。</p><p>qrcode.verison()</p><p>返回二维码版本号。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29</a></p><p>&nbsp;</p><p>从上表可以看到，使用 MicroPython 编程我们只需要简单地调find_qrcodes()函数，对得到的结果再进行处理即可，非常方便。代码编写流程如下图所示:</p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头模块初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> res = img.find_qrcodes() <span class="comment">#寻找二维码</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span>: <span class="comment">#在图片和终端显示二维码信息</span></span><br><span class="line">  img.draw_rectangle(res[<span class="number">0</span>].rect())</span><br><span class="line">  img.draw_string(<span class="number">2</span>,<span class="number">2</span>, res[<span class="number">0</span>].payload(), color=(<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(res[<span class="number">0</span>].payload())</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> <span class="built_in">print</span>(clock.fps())</span><br></pre></td></tr></table></figure><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><p>pyAI-K210 开发套件，配 SD 卡放模型文件。</p><p>我们来简单介绍一下 K210 的 KPU。KPU 是 K210 内部一个神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，实时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。</p><p>KPU 具备以下几个特点：</p><p>➢ 支持主流训练框架按照特定限制规则训练出来的定点化模型</p><p>➢ 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输</p><p>入输出通道数目、输入输 出行宽列高</p><p>➢ 支持两种卷积内核 1x1 和 3x3</p><p>➢ 支持任意形式的激活函数</p><p>➢ 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB</p><p>➢ 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积）</p><p>简单来说就是 KPU 能加载和运行各种现成的 AI 算法模型，实现各种机器视</p><p>觉等功能。</p><p>MaixPy 中人脸识别本质是目标检测，主要通过在 K210 的 KPU 上跑 YOLO（You Only Look Once）目标检测算法来实现。我们来看一下 KPU 在 MaixPy 下的用法</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><p>&nbsp;</p><p>从上表可以看到通过 KPU 模块直接加载 YOLO2 网络，再结合人脸检测模型</p><p>来实现人脸识别。具体编程思路如下：</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#设置摄像头</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #设置摄像头后置</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#需要将模型（face.kfpkg）烧写到 flash 的 0x300000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x300000) </span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/facedetect.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#模型描参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="comment">#识别到人脸就画矩形表示</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line">   b = img.draw_rectangle(i.rect())</span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>有了代码后我们还需要将模型放在文件系统中。这里介绍 2 个方法：</p><p><strong>方法一：将模型放在</strong> <strong>SD</strong> <strong>卡中。</strong></p><p>在本节示例程序路径中可以看到有 1 个件夹 <strong>face_model_at_0x300000</strong>将里面的 <strong>facedetect.kmodel</strong> 文件移动到 SD 卡，运行上述代码即可。</p><p><strong>方法二：将模型烧录到</strong> <strong>K210</strong> <strong>的</strong> <strong>Flash</strong> <strong>中。</strong></p><p>打开本节示例程序路径的件夹<strong>face_model_at_0x300000</strong>里面的<strong>flash-list.json</strong>文件，内容如下（告诉烧录软件烧写地址和文件名）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line"> &quot;files&quot;: [</span><br><span class="line"> &#123;</span><br><span class="line"> &quot;address&quot;: 0x00300000,</span><br><span class="line"> &quot;bin&quot;: &quot;facedetect.kmodel&quot;,</span><br><span class="line"> &quot;sha256Prefix&quot;: false</span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来直接将</strong> <strong>kmodel</strong> <strong>和</strong> <strong>json</strong> <strong>这两个文件用</strong> <strong>zip</strong> <strong>方式压缩（不要用文件夹）</strong>，然后将 zip 后缀名改成 kfpkg，得到一个可以用 K210 固件烧录工具烧录的文件。</p><p>再使用 K210 固件烧录工具烧录直接烧录该文件即可，烧录软件会根据上述的 json 文件自动调整烧录地址，无需再次填写。</p><p>当我们去识别图片时候，可以将摄像头设置成后置，sensor 初始化时增加以</p><p>下代码：(LCD 装在 pyAI-K210 核心板背面，横屏测试。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#设置摄像头后置</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a><strong>物体识别</strong></h3><p>在上一节人脸检测章节我们已经介绍过 KPU 的用法，这里不再重复。本实验还是使用到 YOLO2 网络，结合 20class 模型（20 种物体分类模型）来识别图像中的物体。下面重温一下 KPU 的用法</p><h4 id="构造函数-7"><a href="#构造函数-7" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,image,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#摄像头后置方式</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#模型分类，按照 20class 顺序</span></span><br><span class="line">classes = [<span class="string">&#x27;aeroplane&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;diningtable&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;motorbike&#x27;</span>, <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;pottedplant&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;sofa&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;tvmonitor&#x27;</span>]</span><br><span class="line"><span class="comment">#下面语句需要将模型（20class.kfpkg）烧写到 flash 的 0x500000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x500000)</span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/20class.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#网络参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络，识别可信概率为 0.7（70%）</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   a=img.draw_rectangle(i.rect())</span><br><span class="line">   a = lcd.display(img)</span><br><span class="line">   lcd.draw_string(i.x(), i.y(),classes[i.classid()],lcd.RED, lcd.WHITE)</span><br><span class="line">   lcd.draw_string(i.x(), i.y()+<span class="number">12</span>,<span class="string">&#x27;%f1.3&#x27;</span>%i.value(),lcd.RED,lcd.WHITE)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  a = lcd.display(img)</span><br><span class="line"><span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="在线训练模型"><a href="#在线训练模型" class="headerlink" title="在线训练模型"></a><strong>在线训练模型</strong></h3><p>当我们想自己学习识别自</p><p>己的东西（比如键盘和鼠标的区分），就可以通过在线训练平台训练自己的模型。</p><p>在线训练上有完整的教程，这里不再重复</p><p>MaixHub 在线训练链接：<a href="https://maixhub.com/">https://maixhub.com/</a></p><p>当然上面也有很多现成别人训练好的模型可以直接使用，在模型库中选择</p><p>nncase 即可以看到适合 K210 使用的模型</p><p>&nbsp;</p><h3 id="图片拍摄"><a href="#图片拍摄" class="headerlink" title="图片拍摄"></a><strong>图片拍摄</strong></h3><p>我们在前面摄像头应用章节已经学习过拍摄是使用 image=sensor.snapshot()函数模块，那么我们只需要学会将图片保存即可。保存也是可以直接使用 image下的 save 模块，具体如下：</p><h4 id="构造函数-8"><a href="#构造函数-8" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot()</span><br></pre></td></tr></table></figure><p>通过拍摄创建图像 img</p><h4 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.save(*path*[, *roi*[, *quality=<span class="number">50</span>*]])</span><br></pre></td></tr></table></figure><p>保存图片。</p><p>path：保存路径；</p><p>roi:指定保存区域(x, y, w, h)，默认全图保存；</p><p>quality:仅针对 JPEG 格式的质量控制，有效值为 0-100。</p><p>&nbsp;</p><p>掌握了拍照和保存功能，我们就可以编程实现了，例程编程代码流程图如下：</p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, image</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#配置 LED 蓝、红引脚</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO1,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.skip_frames(<span class="number">40</span>)</span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line"><span class="comment">#红灯亮提示拍照开始</span></span><br><span class="line">LED_R.value(<span class="number">0</span>)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 给 2 秒时间用户准备.</span></span><br><span class="line">LED_R.value(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#蓝灯亮提示正在拍照</span></span><br><span class="line">LED_B.value(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You&#x27;re on camera!&quot;</span>)</span><br><span class="line"><span class="comment"># 拍摄并保存相关文件，也可以用&quot;example.bmp&quot;或其它文件方式。</span></span><br><span class="line">sensor.snapshot().save(<span class="string">&quot;/sd/example.jpg&quot;</span>)</span><br><span class="line">LED_B.value(<span class="number">1</span>) <span class="comment">#l 蓝灯灭提示拍照完成</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;/sd/example.jpg&quot;</span>)) <span class="comment">#LCD 显示照片</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="视频录制"><a href="#视频录制" class="headerlink" title="视频录制"></a><strong>视频录制</strong></h3><p>pyAI-K210 使用的 MaixPy 集成了 vedio 视频模块，也就是通过 MicroPython编程可以轻松实现录制视频功能，我们来看看 vedio 对象：</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vedio</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h4 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><p>&nbsp;</p><p>学习了 vedio 的相关用法后，我们整理思路，代码编写流程如下：</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video, sensor, image, lcd, time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置拍摄模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"><span class="comment">#指定录制文件路径和文件名</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/example.avi&quot;</span>, record=<span class="number">1</span>)</span><br><span class="line">i = <span class="number">0</span> <span class="comment">#计算录制帧数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> tim = time.ticks_ms()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> img_len = v.record(img) <span class="comment">#img_len 为返回的录制帧长度。</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;record&quot;</span>,time.ticks_ms() - tim) <span class="comment">#打印录制的每帧间隔</span></span><br><span class="line"> <span class="comment">#录制 100 帧,每帧默认 100ms，即 10 秒视频。</span></span><br><span class="line"> i += <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span> i &gt; <span class="number">100</span>:</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">v.record_finish() <span class="comment">#停止录制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>) <span class="comment">#录制完成提示</span></span><br></pre></td></tr></table></figure><h3 id="人脸识别-1"><a href="#人脸识别-1" class="headerlink" title="人脸识别"></a>人脸识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sensor</span><br><span class="line"><span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> FPIOA, GPIO</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment"># task_fd = kpu.load(0x300000)</span></span><br><span class="line"><span class="comment"># task_ld = kpu.load(0x400000)</span></span><br><span class="line"><span class="comment"># task_fe = kpu.load(0x500000)</span></span><br><span class="line"></span><br><span class="line">task_fd = kpu.load(<span class="string">&quot;/sd/FaceDetection.smodel&quot;</span>)</span><br><span class="line">task_ld = kpu.load(<span class="string">&quot;/sd/FaceLandmarkDetection.smodel&quot;</span>)</span><br><span class="line">task_fe = kpu.load(<span class="string">&quot;/sd/FeatureExtraction.smodel&quot;</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line">fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0)</span><br><span class="line">key_gpio = GPIO(GPIO.GPIOHS0, GPIO.IN)</span><br><span class="line">start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">BOUNCE_PROTECTION = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_key_state</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="keyword">global</span> start_processing</span><br><span class="line">    start_processing = <span class="literal">True</span></span><br><span class="line">    utime.sleep_ms(BOUNCE_PROTECTION)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_gpio.irq(set_key_state, GPIO.IRQ_RISING, GPIO.WAKEUP_NOT_SUPPORT)</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_hmirror(<span class="number">1</span>)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>)</span><br><span class="line">sensor.run(<span class="number">1</span>)</span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>,</span><br><span class="line">          <span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)  <span class="comment"># anchor for face detect</span></span><br><span class="line">dst_point = [(<span class="number">44</span>, <span class="number">59</span>), (<span class="number">84</span>, <span class="number">59</span>), (<span class="number">64</span>, <span class="number">82</span>), (<span class="number">47</span>, <span class="number">105</span>),</span><br><span class="line">             (<span class="number">81</span>, <span class="number">105</span>)]  <span class="comment"># standard face key point position</span></span><br><span class="line">a = kpu.init_yolo2(task_fd, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line">img_lcd = image.Image()</span><br><span class="line">img_face = image.Image(size=(<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">a = img_face.pix_to_ai()</span><br><span class="line">record_ftr = []</span><br><span class="line">record_ftrs = []</span><br><span class="line">names = [<span class="string">&#x27;Mr.1&#x27;</span>, <span class="string">&#x27;Mr.2&#x27;</span>, <span class="string">&#x27;Mr.3&#x27;</span>, <span class="string">&#x27;Mr.4&#x27;</span>, <span class="string">&#x27;Mr.5&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;Mr.6&#x27;</span>, <span class="string">&#x27;Mr.7&#x27;</span>, <span class="string">&#x27;Mr.8&#x27;</span>, <span class="string">&#x27;Mr.9&#x27;</span>, <span class="string">&#x27;Mr.10&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ACCURACY = <span class="number">85</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    clock.tick()</span><br><span class="line">    code = kpu.run_yolo2(task_fd, img)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">            <span class="comment"># Cut face and resize to 128x128</span></span><br><span class="line">            a = img.draw_rectangle(i.rect())</span><br><span class="line">            face_cut = img.cut(i.x(), i.y(), i.w(), i.h())</span><br><span class="line">            face_cut_128 = face_cut.resize(<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">            a = face_cut_128.pix_to_ai()</span><br><span class="line">            <span class="comment"># a = img.draw_image(face_cut_128, (0,0))</span></span><br><span class="line">            <span class="comment"># Landmark for face 5 points</span></span><br><span class="line">            fmap = kpu.forward(task_ld, face_cut_128)</span><br><span class="line">            plist = fmap[:]</span><br><span class="line">            le = (i.x() + <span class="built_in">int</span>(plist[<span class="number">0</span>] * i.w() - <span class="number">10</span>), i.y() + <span class="built_in">int</span>(plist[<span class="number">1</span>] * i.h()))</span><br><span class="line">            re = (i.x() + <span class="built_in">int</span>(plist[<span class="number">2</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">3</span>] * i.h()))</span><br><span class="line">            nose = (i.x() + <span class="built_in">int</span>(plist[<span class="number">4</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">5</span>] * i.h()))</span><br><span class="line">            lm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">6</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">7</span>] * i.h()))</span><br><span class="line">            rm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">8</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">9</span>] * i.h()))</span><br><span class="line">            a = img.draw_circle(le[<span class="number">0</span>], le[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(re[<span class="number">0</span>], re[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(nose[<span class="number">0</span>], nose[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(lm[<span class="number">0</span>], lm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(rm[<span class="number">0</span>], rm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            <span class="comment"># align face to standard position</span></span><br><span class="line">            src_point = [le, re, nose, lm, rm]</span><br><span class="line">            T = image.get_affine_transform(src_point, dst_point)</span><br><span class="line">            a = image.warp_affine_ai(img, img_face, T)</span><br><span class="line">            a = img_face.ai_to_pix()</span><br><span class="line">            <span class="comment"># a = img.draw_image(img_face, (128,0))</span></span><br><span class="line">            <span class="keyword">del</span> (face_cut_128)</span><br><span class="line">            <span class="comment"># calculate face feature vector</span></span><br><span class="line">            fmap = kpu.forward(task_fe, img_face)</span><br><span class="line">            feature = kpu.face_encode(fmap[:])</span><br><span class="line">            reg_flag = <span class="literal">False</span></span><br><span class="line">            scores = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(record_ftrs)):</span><br><span class="line">                score = kpu.face_compare(record_ftrs[j], feature)</span><br><span class="line">                scores.append(score)</span><br><span class="line">            max_score = <span class="number">0</span></span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):</span><br><span class="line">                <span class="keyword">if</span> max_score &lt; scores[k]:</span><br><span class="line">                    max_score = scores[k]</span><br><span class="line">                    index = k</span><br><span class="line">            <span class="keyword">if</span> max_score &gt; ACCURACY:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;%s :%2.1f&quot;</span> % (</span><br><span class="line">                    names[index], max_score)), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;X :%2.1f&quot;</span> % (</span><br><span class="line">                    max_score)), color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> start_processing:</span><br><span class="line">                record_ftr = feature</span><br><span class="line">                record_ftrs.append(record_ftr)</span><br><span class="line">                start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    fps = clock.fps()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2.1f fps&quot;</span> % fps)</span><br><span class="line">    a = lcd.display(img)</span><br><span class="line">    gc.collect()</span><br><span class="line">    <span class="comment"># kpu.memtest()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fe)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_ld)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fd)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机器视觉&quot;&gt;&lt;a href=&quot;#机器视觉&quot; class=&quot;headerlink&quot; title=&quot;机器视觉&quot;&gt;&lt;/a&gt;机器视觉&lt;/h2&gt;&lt;h3 id=&quot;LCD&quot;&gt;&lt;a href=&quot;#LCD&quot; class=&quot;headerlink&quot; title=&quot;LCD&quot;&gt;&lt;/a&gt;&lt;s</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
  <entry>
    <title>k210基础实验</title>
    <link href="https://rozen12123.github.io/posts/abdf738c.html"/>
    <id>https://rozen12123.github.io/posts/abdf738c.html</id>
    <published>2023-03-17T07:16:09.000Z</published>
    <updated>2023-07-06T07:52:04.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>其连接到 pyAI-K210 的外部 IO 引脚如下（可以看开发板原理图），LED 蓝灯对应的外部 IO 为 IO12，从电路可以看到当 IO12 为低电平时，蓝灯被点亮。</p><p>K210 为外部 IO 和内部 IO，其片上外设（比如 GPIO、I2C 等）对应的引脚是可以任意设置的，而传统大部分 MCU 片上外设和引脚对应关系已经固定了， 只有部分引脚可以复用， 相比之下 K210 自由度更大。</p><p>因此我们在编程使用 GPIO 的时候需要注册一下硬件 IO 和 K210 内部 IO 的对应关系。注册方式使用 fpioa_manager：简称 fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO</p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>更多有关引脚和功能注册信息请看官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html</a></p><p>注册成功后我们就可以通过 GPIO 对象模块来控制外部 IO，从而控制 LED。</p><p>GPIO 对象说明如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GPIO 对象。</span><br><span class="line"></span><br><span class="line">【ID】内部 GPIO 编号;</span><br><span class="line"></span><br><span class="line">【MODE】GPIO 模式；</span><br><span class="line"></span><br><span class="line">GPIO.IN ：输入模式</span><br><span class="line"></span><br><span class="line">GPIO.OUT ：输出模式</span><br><span class="line"></span><br><span class="line">【PULL】</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_UP ：上拉</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">GPIO.PULL_</span>DOWN ：下拉</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_NONE ：无</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">【value】GPIO 初始化电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1：高电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">0：低电平</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>方式 1 是：import Maix，然后通过 Maix.GPIO 来操作；</p><p>方式 2 是：from Maix import GPIO，意思是直接从 Maix 中引入 GPIO 模块，然后直接通过 GPIO 来操作。显然方式 2 会显得更直观和方便，本实验也是使用</p><p>方式 2 来编程。代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">实验名称：点亮 LED_B 蓝灯</span></span><br><span class="line"><span class="string">实验目的：学习 led 点亮。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#将蓝灯引脚 IO12 配置到 GPIO0，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br></pre></td></tr></table></figure><p>关于python中from和import</p><p><a href="https://www.cnblogs.com/keenajiao/p/15336312.html">Python的from和import用法 - keena_jiao - 博客园 (cnblogs.com)</a></p><h3 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utime()</span><br><span class="line"><span class="comment">#时间模块</span></span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">utime.sleep(seconds)</span><br><span class="line">秒级颜色。seconds:延时秒数</span><br><span class="line">utime.sleep_ms(ms)</span><br><span class="line">毫秒级延时。ms：延时毫秒数。</span><br><span class="line">utime.sleep_us(us)</span><br><span class="line">微秒级延时。us：延时微秒数。</span><br></pre></td></tr></table></figure><p>*更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html</a></p><p>知道了延时函数的使用方法后，我们可以简单的梳理一下流程，首先导入LED 和 utime 模块，程序开始先让 RGB LED 灭掉，开启循环，依次点亮每个 LED，延时 1 秒，关闭 LED。流程如下：</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#蓝灯亮 1 秒</span></span><br><span class="line"> LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_B.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#绿灯亮 1 秒</span></span><br><span class="line"> LED_G.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line">    utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_G.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> <span class="comment">#红灯亮 1 秒</span></span><br><span class="line"> LED_R.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line">LED_R.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><p>上述代码没错是完整地按照编程思路来编写，但可以见到有很多格式相似的地方，这显得代码非常冗余。我们可以通过 for 函数来编写程序，由于是对 3 个LED 的操作，因此我们可以用 for i in range(0,3): 语句来修改，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line"><span class="comment">#构建 LED 对象，并初始化输出高电平，关闭 LED</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#定义数组方便循环语句调用</span></span><br><span class="line">LED=[LED_B, LED_G, LED_R]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">  LED[i].value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED[i].value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h3><p>从原理图可以看到，按键 KEY 的一端连接到 K210 的外部 IO16，另一端连接到 GND。所以按键在没按下时候输入高电平（1），按下时候输入低电平（0）。和 LED 一样，按键的输入检测也是用到 GPIO 对象模块，具体如下：</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><p>GPIO 对象。</p><p>【ID】内部 GPIO 编号;</p><p>【MODE】GPIO 模式；</p><p>GPIO.IN ：输入模式</p><p>GPIO.OUT ：输出模式</p><p>【PULL】</p><p>GPIO.PULL_UP ：上拉</p><p>GPIO.PULL_DOWN ：下拉</p><p>GPIO.PULL_NONE ：无</p><p>【value】GPIO 初始化电平</p><p>1：高电平</p><p>0：低电平</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>*输入模式时候参数为空，表示获取当前 IO 输入电平值。</p><p>GPIO 对象使用非常简单，我们将按键即外部“IO16”引脚配置成输入，实现当检测到按键被按下时候点亮 LED 蓝灯，松开时关闭 LED 蓝灯来做指示。代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#注册 IO，蓝灯--&gt;IO12,KEY--&gt;IO16</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1)</span><br><span class="line"><span class="comment">#初始化 IO</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line">KEY = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下接地</span></span><br><span class="line">  LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED_B,蓝灯</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  LED_B.value(<span class="number">1</span>) <span class="comment">#熄灭 LED</span></span><br></pre></td></tr></table></figure><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h3><p>前面我们在做普通的按键（GPIO）时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断的在实际项目的应用非常普遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION)</span><br></pre></td></tr></table></figure><p>配置中断。</p><p>【CALLBACK_FUNC】中断执行的回调函数；</p><p>【TRIGGER_CONDITION】中断触发方式；</p><p>GPIO.IRQ_RISING：上升沿触发</p><p>GPIO.IRQ_FALLING：下降沿沿触发</p><p>GPIO.IRQ_BOTH：都触发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.disirq()</span><br></pre></td></tr></table></figure><p>关闭中断。</p><p>我们先来了解一下上升沿和下降沿的概念，由于按键 KEY 引脚是通过按键接到 GND，也就是我们所说的低电平“0”，所以当按键被按下再松开时，引脚先获得下降沿，再获得上升沿，如下图所示：</p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p>我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产</p><p>生中断。</p><p>需要注意的是 K210 只有高速 GPIO 才有外部中断，GPIO 常量表如下：</p><div class="table-container"><table><thead><tr><th><strong>K210 - GPIO</strong></th></tr></thead><tbody><tr><td>普通 GPIO</td></tr><tr><td>GPIO0 - GPIO7</td></tr><tr><td>高速 GPIO</td></tr><tr><td>GPIOHS0 – GPIOHS31</td></tr></tbody></table></div><p>编程思路中断跟 GPIO 按键章节类似，在初始化中断后，当系统检测到外部</p><p>中断时候，执行 LED 状态反转的代码即可。流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO，注意高速 GPIO 口才有中断</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0)</span><br><span class="line"><span class="comment">#构建 lED 和 KEY 对象</span></span><br><span class="line"></span><br><span class="line">LED_B=GPIO(GPIO.GPIO0,GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LED 状态表示</span></span><br><span class="line">state = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#中断回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"> <span class="keyword">global</span> state</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line"> state = <span class="keyword">not</span> state</span><br><span class="line"> LED_B.value(state)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.Timer(<span class="built_in">id</span>,channel,mode=Timer.MODE_ONE_SHOT,period=<span class="number">1000</span>,unit=Timer.UNIT_MS, callback=<span class="literal">None</span>, arg=<span class="literal">None</span>, start=<span class="literal">True</span>,</span><br><span class="line">priority=<span class="number">1</span>, div=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>定时器对象 Timer 对象在 machine 模块下。</p><p>【id】定时器编号, [Timer.TIMER0~TIMER2] 定时器 0-2;</p><p>【channel】Timer 通道，[Timer.CHANNEL0~Timer.CHANNEL3]</p><p>【mode】定时器模式</p><p>MODE_ONE_SHOT: 一次性</p><p>MODE_PERIODIC: 周期性</p><p>MODE_PWM</p><p>【period】定时器为周期性模块时每个周期时间值</p><p>【unit】周期的单位</p><p>Timer.UNIT_S：秒</p><p>Timer.UNIT_MS：毫秒</p><p>Timer.UNIT_US：微妙</p><p>Timer.UNIT_NS：纳秒</p><p>【callback】定时器中断执行的回调函数；<strong>注意：回调函数是在中断中调用</strong></p><p><strong>的，所以在回调函数中请不要占用太长时间以及做动态内存分配开关中断等</strong></p><p><strong>动作。</strong></p><p>【arg】回调函数第 2 个参数</p><p>【start】是否在构建对象后立即开始定时器，</p><p>=True: 立即开始；</p><p>=False: 不立即开始，需要调用 start()来开启。</p><p>【priority】硬件中断优先级，在 K210 中，取值范围是[1,7],值越小优先级越高</p><p>【div】硬件分频器。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>Timer.callback(fun)</th></tr></thead><tbody><tr><td>定义回调函数。</td></tr><tr><td>Timer.period([value])</td></tr><tr><td>配置周期。</td></tr><tr><td>Timer.start()</td></tr><tr><td>启动定时器。</td></tr><tr><td>Timer.stop()</td></tr><tr><td>停止定时器。</td></tr><tr><td>Timer.deinit()</td></tr><tr><td>注销定时器。</td></tr><tr><td>*更多用法请阅读 MaixPy 官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html</a></td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类</p><p>似，代码编程流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO 和构建 LED 对象</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数变量</span></span><br><span class="line">Counter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定时器回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"> <span class="keyword">global</span> Counter</span><br><span class="line"> Counter = Counter + <span class="number">1</span></span><br><span class="line"> <span class="built_in">print</span>(Counter)</span><br><span class="line"> LED_B.value(Counter%<span class="number">2</span>)<span class="comment">#LED 循环亮灭。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#定时器 0 初始化，周期 1 秒</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, </span><br><span class="line">period=<span class="number">1000</span>, callback=fun)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a><strong>PWM</strong></h3><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需</p><p>要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyAI-K210 的 PWM 输出频率是在变化的。</p><p>pyBase 开发底板上的无源蜂鸣器连接到引脚 X5。如下图所示：</p><p>而 pyAI-K210 并没有引脚直接连接到 pyBase 的 X5（主要避免影响 IO 复用。）而 IO15 连接到 pyBase 开发底板的 X6 引脚，因此我们可以用跳线帽或者跳线来连接 pyBase 的 X5 和 X6 引脚。相当于将无源蜂鸣器接到 pyAI-K210 的外部 IO15引脚。</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.PWM(tim, freq, duty, pin, enable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>PWM 对象在 machine 模块下。</p><p>【tim】K210 的 PWM 依赖于定时器来产生波形</p><p>【freq】PWM 频率</p><p>【duty】PWM 占空比</p><p>【pin】PWM 输出引脚</p><p>【enable】是否在构建对象后立即产生波形，默认 True。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>PWM.freq(freq)</th></tr></thead><tbody><tr><td>设置频率。不传参数返回当前频率值。</td></tr><tr><td>PWM.duty(duty)</td></tr><tr><td>设置占空比。不传参数返回当前占空比值。[0-100]表示占空比百分比<strong>107</strong></td></tr><tr><td>PWM.enable()</td></tr><tr><td>使能 PWM 输出。</td></tr><tr><td>PWM.disable()</td></tr><tr><td>暂停 PWM 输出。</td></tr><tr><td>PWM.deinit()</td></tr><tr><td>注销 PWM。</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO15 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">beep = PWM(tim, freq=<span class="number">1</span>, duty=<span class="number">50</span>, pin=<span class="number">15</span>)</span><br><span class="line"><span class="comment">#循环发出不同频率响声。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> beep.freq(<span class="number">200</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">400</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">600</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">800</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">1000</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有条件的朋友可以使用示波器测量 pyAI-K210 的 IO15 引脚或 pyBase 的 X5 引脚，观察信号波形的变化：</p><p>&nbsp;</p><h3 id="I2C-总线（OLED显示屏）"><a href="#I2C-总线（OLED显示屏）" class="headerlink" title="I2C 总线（OLED显示屏）"></a><strong>I2C</strong> <strong>总线（OLED显示屏）</strong></h3><p>我们先来看看开发板的原理图，也就是MicroPython 上的 OLED 接口是如何连线的。下图是 pyBase 开发底板的原理图。</p><p>我们再来看看 pyAI-K210 转接板的原理图接口部分。</p><p>结合以上可以得知 pyBase 底板连接到 OLED 的对应关系是 Y6→SCL 和Y8→SDA。对应 pyAI-K210 的关系是：IO27→Y6→SCL，IO28→Y8→SDA。本例程将使用 MicroPython 的 Machine 模块的 I2C 来定义 Pin 口和 I2C 初始化。具体如下：</p><p>&nbsp;</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.I2C(<span class="built_in">id</span>, mode=I2C.MODE_MASTER, scl=<span class="literal">None</span>, sda=<span class="literal">None</span>,</span><br><span class="line">freq=<span class="number">400000</span>, timeout=<span class="number">1000</span>, addr=<span class="number">0</span>, addr_size=<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>构建 I2C 对象。</p><p>【id】I2C ID,[ I2C.I2C0~I2C.I2C2 ]</p><p>【scl】时钟引脚；直接传引脚编号；</p><p>【sda】数据引脚; 直接传引脚编号；</p><p>【freq】通信频率，即速度；</p><p>【timeout】参数保留，设置无效；</p><p>【addr】从机地址；</p><p>【addr_size】地址长度， 支持 7 位寻址和 10 位寻址， 取值 7 或者 10。</p><div class="table-container"><table><thead><tr><th><strong>使用方法</strong></th></tr></thead><tbody><tr><td>i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,len)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；len:读取字节数；</td></tr><tr><td>i2c.writeto(addr,buf)</td></tr><tr><td>写数据。addr:从机地址；buf:数据内容；</td></tr><tr><td>i2c.deinit()</td></tr><tr><td>注销 I2C。</td></tr><tr><td>*其它更多用法请阅读官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h</a></td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306k.py 文件里面。开发者只需要将改 py 文件拷贝到 pyAI-K210 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306k.py 文件代码。OLED 显示屏对象介绍如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oled = SSD1306_I2C(i2c, addr)</span><br></pre></td></tr></table></figure><p>构 OLED 显示屏对象。默认分辨率 128*64；</p><p>【i2c】定义好的 I2C 对象;</p><p>【addr】显示屏设备地址。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><p>oled.fill([value])</p><p>清屏</p><p>value=0x00 (黑屏)；value=0xFF(白屏)</p><p>oled.text(string,x,y)</p><p>将 string 字符写在指定为位置。</p><p>【string】：字符；</p><p>【x】横坐标；[0-127]；</p><p>【y】纵坐标。[0-7] 共 8 行</p><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> ssd1306k <span class="keyword">import</span> SSD1306</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 I2C 接口和 OLED 对象</span></span><br><span class="line">i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER,scl=<span class="number">27</span>, sda=<span class="number">28</span>)</span><br><span class="line">oled = SSD1306(i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"><span class="comment">#清屏,0x00(白屏)，0xff(黑屏)</span></span><br><span class="line">oled.fill(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#显示字符。参数格式为（str,x,y）,其中 x 范围是 0-127，y 范围是 0-7（共 8 行）</span></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">#写入第 0 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">#写入第 2 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">#写入第 5 行内容</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART（串口通信）</strong></h3><p>  串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>&nbsp;</p><p>K210 一共有 3 个串口，每个串口可以自由映射引脚。 例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IO6→RX1，IO7→TX1</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len)</span><br></pre></td></tr></table></figure><p>创建 UART 对象。</p><p>【uart】串口编号。[UART.UART1~UART3]</p><p>【baudrate】波特率，常用 115200、9600</p><p>【bits】数据位,默认 8</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>【timeout】串口接收超时时间</p><p>【read_buf_len】串口接收缓冲大小。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>UART.read(num)</p><p>读取串口缓冲数据</p><p>【num】读取字节数</p><p>UART.readline(num)</p><p>读取串口缓冲数据的行</p><p>【num】行数</p><p>UART.write(buf)</p><p>串口发送数据</p><p>【buf】需要发送的数据</p><p>UART.deinit()</p><p>注销串口</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用 pyBase 的外</p><p>接串口引脚，也就是 Y9（TX）和 Y10（RX），接线示意图如下：</p><p>从 pyAI-K210 原理图可以看到外部 IO6→Y9→RX ，IO7→Y10→TX。</p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>这时候打开电脑的设备管理器，能看到 2 个 COM。写着 CH340 的是串口工具，另外一个则是 pyAI-K210 的 REPL。如果 CH340 驱动没安装，则需要手动安装，驱动在：配套资料包→开发工具→windows→串口终端→CH340 文件夹下。</p><p>本实验要用到串口助手，打开配套资料包→开发工具→windows→串口终端工具下的【UartAssist.exe】软件。</p><p>将串口工具配置成 COM14（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到 pyAI-K210 上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到pyAI-K210 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a><strong>thread（线程）</strong></h3><p>我们看到前面的编程都是一个循环来完成，但当我们需要分时完成不同任务时候，线程编程就派上用场了。这有点像 RTOS(实时操作系统)，今天我们就来学习一下如何通过 MicroPython 编程实现多线程。</p><p>&nbsp;</p><p>pyAI-K210 的 MicroPython 固件已经集成了_thread 线程模块。我们直接调用即可。该模块衍生于 python3，属于低级线程，详情可以看官网介绍：<a href="https://docs.python.org/3.5/library/_thread.html#module-thread">https://docs.python.org/3.5/library/_thread.html#module-thread</a></p><p>编程流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread <span class="comment">#导入线程模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#线程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name)) </span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> _thread.start_new_thread(func,(<span class="string">&quot;1&quot;</span>,)) <span class="comment">#开启线程 1，参数必须是元组</span></span><br><span class="line">_thread.start_new_thread(func,(<span class="string">&quot;2&quot;</span>,)) <span class="comment">#开启线程 2，参数必须是元组</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;点亮第一个-LED&quot;&gt;&lt;a href=&quot;#点亮第一个-LED&quot; class=&quot;headerlink&quot; title=&quot;点亮第一个 LED&quot;&gt;&lt;/a&gt;&lt;strong&gt;点亮第一个&lt;/strong&gt; &lt;strong&gt;LED&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;其连接到 pyA</summary>
      
    
    
    
    
    <category term="k210" scheme="https://rozen12123.github.io/tags/k210/"/>
    
  </entry>
  
</feed>
