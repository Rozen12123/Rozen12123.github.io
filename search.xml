<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>esp32_s3多任务处理</title>
      <link href="/posts/a1417d5c.html"/>
      <url>/posts/a1417d5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="esp32-S3多任务处理"><a href="#esp32-S3多任务处理" class="headerlink" title="esp32_S3多任务处理"></a>esp32_S3多任务处理</h1><h2 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h2><ul><li>多任务的概念：同一时间内执行多个任务，它充分利用CPU资源，提高程序的执行效率。</li><li>对于单核CPU处理多任务，操作系统会给每个运行的任务一小段运行的时间，时间一到，然后立马切换任务，由于交替切换的速度过快，以人的眼光去看感觉每个程序都是同时执行的错觉。</li><li>相对于多核CPU，操作系统会给每个内核安排一个执行的软件同时运行，从而达到同一个时间内执行多任务的效果。</li><li>ESP32的任务和操作系统的进程的概念是一样的</li></ul><ul><li>ESP32有两颗CPU，包含ProtocolcPU（称为CPUO或PRO_CPU）和ApplicationcPu（称为CPU1或APP_CPU）。这两个核实际上是相同的，并且共享相同的内存</li><li>我们之前用的setup和loop方法都是在CPU1上执行的CPUO一直不干活，我们要使用多任务让它动起来。</li><li>保证所有的任务都以合理正确的速率推进，不被其它任务所阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void1oop（）&#123;</span><br><span class="line">task1（）<span class="comment">//这个需要较长的操作，比如59oms</span></span><br><span class="line">task2（）；<span class="comment">//这个需要50ms执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如上代码，任务一的时间较长，但任务二时间较短，就会有一定冲突。此时就适合双线程来完成任务。</p><h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><p>参考：<a href="https://blog.csdn.net/a568713197/article/details/81542772">(8条消息) UCOS学习笔记（四）时间片轮转调度_ucosii时间片轮转调度_爱吃肉的大高个的博客-CSDN博客</a></p><h3 id="多任务处理相关函数"><a href="#多任务处理相关函数" class="headerlink" title="多任务处理相关函数"></a>多任务处理相关函数</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">tXTaskCreatePinnedToCore</span><span class="params">(TaskFunctiont_t pvTaskcode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,<span class="type">const</span> <span class="type">uint32_t</span> usstackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span>* <span class="type">const</span> pvParameters,UBaseType_t uxPriority,TaskHandle_t <span class="type">const</span> pvCreatedTask,<span class="type">const</span> BaseType_t xCoreID)</span>；</span><br></pre></td></tr></table></figure><ul><li>pvTaskCode：指向任务输入函数的指针。任务必须被实现为永不Return（如：死循环），或者应该使用</li><li>vtTaskDelete:函数终止</li><li>pcName：该任务的描述性名称，最大长度16字节</li><li>usStackDepth：指定为字节数的任务堆栈的大小</li><li>pvParameters：将用作所创建的任务的参数的指针，在创建任务的时候可以向任务传递参数。</li><li>uxPriority：任务运行的优先级。目前ESP32的优先级有25级，0-24，数字越大优先级越高，Idle为0，loop任务的优先级是1</li><li>pvCreatedTask：用于传递回所创建任务的句柄</li><li>xCoreID：如果值为tskNOAFFINITY，则创建的任务不会固定到任何CPU，调度程序可以在任何可用的核心上运行。值0或1表示任务应固定到的CPU的索引编号。指定大于（portNUMPROCESSORS-1）的值将导致函数失败</li><li>函数成功返回pdPASS，其它值都是失败。</li></ul><h4 id="任务函数原型"><a href="#任务函数原型" class="headerlink" title="任务函数原型"></a>任务函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> task（<span class="type">void</span>* param）;</span><br></pre></td></tr></table></figure><h4 id="获取任务的优先级"><a href="#获取任务的优先级" class="headerlink" title="获取任务的优先级"></a>获取任务的优先级</h4><p>如果在任务函数里获取本任务的优先级可以使用uxTaskPriorityGet（NULL）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">(<span class="type">const</span> TaskHandle_t xTask)</span>;</span><br></pre></td></tr></table></figure><h4 id="获取本任务在哪个CPU上运行"><a href="#获取本任务在哪个CPU上运行" class="headerlink" title="获取本任务在哪个CPU上运行"></a>获取本任务在哪个CPU上运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t IRAM_ATTR <span class="title function_">xPortGetcoreID</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h4><p>如果在任务函数体内使用vTaskDelete（NULL）来结束本任务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">(TaskHandle_t xTaskToDelete)</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="互斤量（xSemaphoreHandle）"><a href="#互斤量（xSemaphoreHandle）" class="headerlink" title="互斤量（xSemaphoreHandle）"></a>互斤量（xSemaphoreHandle）</h3><p>互压量又称互床信号量（本质是信号量），是一种特殊的二值信号量，它用于实现对临界资源的独占式处理（它不会屏蔽CPU的中断处理）任意时刻互压量的状态只有两种，开锁或闭锁。当互斤量被任务持有时，该互压量处于闭锁状态，这个任务获得互压量的所有权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle<span class="comment">//互斤锁，也算是一种信号量</span></span><br></pre></td></tr></table></figure><p>创建一个互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreHandle xMutex = xSemaphoreCreateMutex()</span><br></pre></td></tr></table></figure><p>获取互斤锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake (xSemaphore,xBlockTime)</span><br></pre></td></tr></table></figure><p>功能：在普通任务中获取信号量<br>参数：xSemaphore信号量句柄<br>           xBlockTime等待的节拍数，立即返回，portMAX_DELAY等待到信号到来<br>ESP32默认的一节拍是1ms<br>返回值：pdTRUE：获取成功1pdFALSE：获取失败</p><p>释放互压锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive（xSemaphore）</span><br></pre></td></tr></table></figure><p>功能：在普通任务中释放信号量，也就是将信号量设为有信号的状态返回值：pdTRUE：设置成功 ，pdFALSE：设置失败</p><p>&nbsp;</p><p>使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (xSemaphoreTake(xMutex,portMAX_DELAY))</span><br><span class="line">//临界资源处理</span><br><span class="line">xSemaphoreGive(xMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="综合例子"><a href="#综合例子" class="headerlink" title="综合例子"></a>综合例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FreeRTOSConfig.h&gt;</span></span></span><br><span class="line">xSemaphoreHandle xMutex; <span class="comment">//互斥量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;          <span class="comment">//互斥资源</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> p = *((<span class="type">int</span>*)param);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.print(<span class="string">&quot;I am task1, Param: &quot;</span>);</span><br><span class="line">    Serial.print(p);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot; number: %d&quot;</span>, number);</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println();</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(count++ &lt; <span class="number">200</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; &quot;</span>, core);</span><br><span class="line">    Serial.println(<span class="string">&quot;I am task2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(xMutex, portMAX_DELAY))</span><br><span class="line">    &#123;</span><br><span class="line">      number++;</span><br><span class="line">      xSemaphoreGive(xMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">//结束任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  </span><br><span class="line">  TaskHandle_t handle1;</span><br><span class="line">  <span class="type">int</span> param = <span class="number">30</span>;</span><br><span class="line">  xMutex = xSemaphoreCreateMutex();</span><br><span class="line">  xTaskCreatePinnedToCore(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">2048</span>, (<span class="type">void</span>*)&amp;param, <span class="number">15</span>, &amp;handle1, <span class="number">0</span>);</span><br><span class="line">  xTaskCreatePinnedToCore(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">15</span>, <span class="literal">NULL</span>, <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> core = xPortGetCoreID();  <span class="comment">//获取当前核</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Core %d -&gt; I am loop &quot;</span>, core);</span><br><span class="line">  <span class="keyword">auto</span> pri = uxTaskPriorityGet(<span class="literal">NULL</span>);</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot; priority: %d&quot;</span>, pri);</span><br><span class="line">  Serial.println();</span><br><span class="line">  delay(<span class="number">2000</span>);</span><br><span class="line">  <span class="comment">//一个任务的delay不会影响到其它任务的运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xSemaphoreTake(xMutex, portMAX_DELAY))&#123; </span><br><span class="line"><span class="comment">//临界资源处理</span></span><br><span class="line">xSemaphoreGive（xMutex）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多并行任务创建"><a href="#多并行任务创建" class="headerlink" title="多并行任务创建"></a>多并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_FREERTOS_UNICORE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARDUINO_RUNNING_CORE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FreeRTOS任务优先级：任务优先级数值越小，任务优先级越低。</span></span><br><span class="line"><span class="comment">一、 FreeRTOS 中任务的最高优先级是通过 FreeRTOSConfig.h 文件中的 configMAX_PRIORITIES 进行</span></span><br><span class="line"><span class="comment">配置的，用户实际可以使用的优先级范围是 0 到 configMAX_PRIORITIES – 1。比如我们配置此宏定</span></span><br><span class="line"><span class="comment">义为 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5。</span></span><br><span class="line"><span class="comment">二、用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0。</span></span><br><span class="line"><span class="comment">三、用户配置宏定义 configMAX_PRIORITIES 的最大值不要超过 32，即用户任务可以使用的优先级</span></span><br><span class="line"><span class="comment">范围是0到31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// define two tasks for Blink &amp; AnalogRead</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the setup function runs once when you press reset or power the board</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize serial communication at 115200 bits per second:</span></span><br><span class="line">  USBSerial.begin(<span class="number">115200</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Now set up two tasks to run independently.</span></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskBlink</span><br><span class="line">    ,  <span class="string">&quot;TaskBlink&quot;</span>   <span class="comment">// A name just for humans</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// This stack size can be checked &amp; adjusted by reading the Stack Highwater</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">2</span>  <span class="comment">// Priority, with 3 (configMAX_PRIORITIES - 1) being the highest, and 0 being the lowest.</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  xTaskCreatePinnedToCore(</span><br><span class="line">    TaskAnalogReadA3</span><br><span class="line">    ,  <span class="string">&quot;AnalogReadA3&quot;</span></span><br><span class="line">    ,  <span class="number">1024</span>  <span class="comment">// Stack size</span></span><br><span class="line">    ,  <span class="literal">NULL</span></span><br><span class="line">    ,  <span class="number">1</span>  <span class="comment">// Priority</span></span><br><span class="line">    ,  <span class="literal">NULL</span> </span><br><span class="line">    ,  ARDUINO_RUNNING_CORE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Empty. Things are done in Tasks.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*---------------------- Tasks ---------------------*/</span></span><br><span class="line"><span class="comment">/*--------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskBlink</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Blink</span></span><br><span class="line"><span class="comment">  Turns on an LED on for one second, then off for one second, repeatedly.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  If you want to know what pin the on-board LED is connected to on your ESP32 model, check</span></span><br><span class="line"><span class="comment">  the Technical Specs of your board.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize digital LED_BUILTIN on pin 13 as an output.</span></span><br><span class="line">  pinMode(<span class="number">45</span>, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) <span class="comment">// A Task shall never return or exit.</span></span><br><span class="line">  &#123;</span><br><span class="line">    digitalWrite(<span class="number">45</span>, HIGH);   <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">    digitalWrite(<span class="number">45</span>, LOW);    <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TaskAnalogReadA3</span><span class="params">(<span class="type">void</span> *pvParameters)</span>  <span class="comment">// This is a task.</span></span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) pvParameters;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  AnalogReadSerial</span></span><br><span class="line"><span class="comment">  Reads an analog input on pin A3, prints the result to the serial monitor.</span></span><br><span class="line"><span class="comment">  Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)</span></span><br><span class="line"><span class="comment">  Attach the center pin of a potentiometer to pin A3, and the outside pins to +5V and ground.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// read the input on analog pin A3:</span></span><br><span class="line">    <span class="type">int</span> sensorValueA3 = analogRead(A3);</span><br><span class="line">    <span class="comment">// print out the value you read:</span></span><br><span class="line">    USBSerial.print(<span class="string">&quot;A3-&gt;&quot;</span>);</span><br><span class="line">    USBSerial.println(sensorValueA3);</span><br><span class="line">    vTaskDelay(<span class="number">100</span>);  <span class="comment">// one tick delay (15ms) in between reads for stability</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="基于多核并行任务创建"><a href="#基于多核并行任务创建" class="headerlink" title="基于多核并行任务创建"></a>基于多核并行任务创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//  多线程基于FreeRTOS，可以多个任务并行处理；</span></span><br><span class="line"><span class="comment">//  ESP32具有两个32位Tensilica Xtensa LX6微处理器；</span></span><br><span class="line"><span class="comment">//  实际上我们用Arduino进行编程时只使用到了第一个核（大核），第0核并没有使用</span></span><br><span class="line"><span class="comment">//  多线程可以指定在那个核运行；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_MULTCORE 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskOne</span><span class="params">(<span class="type">void</span> *xTask1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task1 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xTaskTwo</span><span class="params">(<span class="type">void</span> *xTask2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        USBSerial.<span class="built_in">printf</span>(<span class="string">&quot;Task2 \r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    USBSerial.begin(<span class="number">115200</span>);</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !USE_MULTCORE</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskOne,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskOne&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">1</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line">    xTaskCreate(</span><br><span class="line">        xTaskTwo,  <span class="comment">/* Task function. */</span></span><br><span class="line">        <span class="string">&quot;TaskTwo&quot;</span>, <span class="comment">/* String with name of task. */</span></span><br><span class="line">        <span class="number">4096</span>,      <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">        <span class="literal">NULL</span>,      <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">        <span class="number">2</span>,         <span class="comment">/* Priority of the task.(configMAX_PRIORITIES - 1 being the highest, and 0 being the lowest.) */</span></span><br><span class="line">        <span class="literal">NULL</span>);     <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个参数至关重要，决定这个任务创建在哪个核上.PRO_CPU 为 0, APP_CPU 为 1,或者 tskNO_AFFINITY 允许任务在两者上运行.</span></span><br><span class="line">    xTaskCreatePinnedToCore(xTaskOne, <span class="string">&quot;TaskOne&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(xTaskTwo, <span class="string">&quot;TaskTwo&quot;</span>, <span class="number">4096</span>, <span class="literal">NULL</span>, <span class="number">2</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial.<span class="built_in">printf</span>(<span class="string">&quot;XTask is running\r\n&quot;</span>);</span><br><span class="line">        delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32开发环境搭建（arduino）</title>
      <link href="/posts/ec4b5731.html"/>
      <url>/posts/ec4b5731.html</url>
      
        <content type="html"><![CDATA[<h1 id="esp32开发环境搭建（arduino）"><a href="#esp32开发环境搭建（arduino）" class="headerlink" title="esp32开发环境搭建（arduino）"></a>esp32开发环境搭建（arduino）</h1><h2 id="首先下载arduino-IDE最新版"><a href="#首先下载arduino-IDE最新版" class="headerlink" title="首先下载arduino IDE最新版"></a>首先下载arduino IDE最新版</h2><p>网址：<a href="https://www.arduino.cc/en/software">Software | Arduino</a></p><p><img src="https://i.imgtg.com/2023/07/05/Oxe1Rb.png" alt="Oxe1Rb.png" border="0"></p><p>点击windows win10</p><p><img src="https://i.imgtg.com/2023/07/05/Oxehu6.png" alt="Oxehu6.png" border="0"></p><p>点击just download</p><p>此时即可下载到电脑。</p><h3 id="方法二（github）"><a href="#方法二（github）" class="headerlink" title="方法二（github）"></a>方法二（github）</h3><p>打开网址<a href="https://github.com/arduino/arduino-ide">arduino/arduino-ide: Arduino IDE 2.x (github.com)</a></p><p>点击code<img src="/posts/ec4b5731.htm/OxenFP.png" alt="OxenFP.png" border="0"></p><p>点击Download ZIP下载压缩包，下载完压缩即可。</p><p><a href="https://imgtg.com/image/Oxe79l"><img src="/posts/ec4b5731.htm/Oxe79l.png" alt="Oxe79l.png" border="0"></a></p><p>&nbsp;</p><p>&nbsp;</p><h2 id="安装esp32开发环境"><a href="#安装esp32开发环境" class="headerlink" title="安装esp32开发环境"></a>安装esp32开发环境</h2><p>你需要向 Arduino IDE 板管理器添加一个额外的源，然后安装 ESP32。</p><p>打开<code>文件</code> 菜单下的 <code>首选项</code>。</p><p><img src="https://i.imgtg.com/2023/07/05/OxeFEF.png" alt="OxeFEF.png" border="0"></p><p>把下面的链接复制粘贴到 <code>附加开发板管理网址</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2023/07/05/OxeeUg.png" alt="OxeeUg.png" border="0"></p><p>再安装 ESP32 开发板，选择 <code>工具</code> 菜单中的 <code>开发板</code> -&gt; <code>开发板管理器...</code></p><p><img src="https://i.imgtg.com/2023/07/05/OxeryB.png" alt="OxeryB.png" border="0"></p><p>在搜索栏搜索esp32，点击安装即可</p><p><img src="https://i.imgtg.com/2023/07/05/OxeAds.png" alt="OxeAds.png" border="0"></p><p>完成安装后即可在 工具—-&gt;开发板中发现esp32</p><p><img src="https://i.imgtg.com/2023/07/05/OxeZaK.png" alt="OxeZaK.png" border="0"></p><p>&nbsp;</p><h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>如果在连接esp32后没有反应则需要下载驱动</p><p>链接：<a href="https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc">https://pan.baidu.com/s/1IJa40kU_MtdsdDK8BgEnHg?pwd=m1bc</a><br>提取码：m1bc</p><p>下在完可以在<strong>设备管理器</strong>中查看到设备</p><p><img src="https://i.imgtg.com/2023/07/05/Oxevea.png" alt="Oxevea.png" border="0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32WIFI</title>
      <link href="/posts/e7f7981b.html"/>
      <url>/posts/e7f7981b.html</url>
      
        <content type="html"><![CDATA[<h1 id="WiFi-应用"><a href="#WiFi-应用" class="headerlink" title="WiFi 应用"></a><strong>WiFi</strong> <strong>应用</strong></h1><p>通过前面的实验，我们已经对 ESP32-S2 有了一定的了解。从本章开始，将迎来非常重要实用的内容，那就是 WIFI 应用。ESP32-S2 就是为 WIFI 无线连接而生的。通过本章内容，我们可以看到基于 MicroPython 的 WIFI 开发是多么的简单而美妙。物联网的学习变得非常简单有趣！事不宜迟，马上开始学习。</p><h2 id="连接无线路由器"><a href="#连接无线路由器" class="headerlink" title="连接无线路由器"></a><strong>连接无线路由器</strong></h2><p>⚫ <strong>前言：</strong></p><p>WIFI 是物联网中非常重要的角色，现在基本上家家户户都有 WIFI 网络了，通过 WIFI 接入到互联网，成了智能家居产品普遍的选择。而要想上网，首先需要连接上无线路由器。这一节我们就来学习如何通过 MicroPython 编程连上路由器。</p><p>⚫ <strong>实验目的：</strong></p><p>编程实现连接路由器，将 IP 地址等相关信息通过 OLED 显示（只支持 2.4G网络）。</p><p>⚫ <strong>实验讲解：</strong></p><p>连接路由器上网是我们每天都做的事情，日常生活中我们只需要知道路由器的账号和密码，就能使用电脑或者手机连接到无线路由器，然后上网冲浪。</p><p>MicroPython 已经集成了 network 模块，开发者使用内置的 network 模块函数可以非常方便地连接上路由器。但往往也有各种连接失败的情况，如密码不正确等。这时候我们只需要再加上一些简单的判断机制，避免陷入连接失败的死循环即可！</p><p>我们先来看看 network 基于 WiFi（WLAN 模块）的构造函数和使用方法。</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>wlan = network.WLAN(interface_id)</p><p>构建 WIFI 连接对象。interface_id:分为热点 network.AP_IF 和客户端</p><p>network.STA_IF 模式。</p><p><strong>使用方法</strong></p><p>wlan.active([is_active])</p><p>激活 wlan 接口。Ture：激活；False:关闭。</p><p>wlan.scan ()</p><p>扫描允许访问的 SSID。</p><p>wlan.isconnected()</p><p>检查设备是否已经连接上。返回 Ture:已连接；False：未连接。</p><p>wlan.connected(ssid,passwork)</p><p>WIFI 连接。ssid:账号；passwork：密码。</p><p>wlan.ifconfig([ip,subnet,gateway,dns])</p><p>设备信息配置。ip：IP 地址；subnet:子网掩码；gateway:网关地址；dns:DNS</p><p>信息。<strong>（如果参数为空，则返回当前连接信息。）</strong></p><p>wlan.disconnected()</p><p>断开连接。</p><p>&nbsp;</p><p>从上表可以看到 MicroPython 通过模块封装，让 WIFI 联网变得非常简单。模块包含热点 AP 模块和客户端 STA 模式，热点 AP 是指电脑端直接连接 ESP32-S2发出的热点实现连接，但这样你的电脑就不能上网了，因此我们一般情况下都是使用 STA 模式。也就是电脑和设备同时连接到相同网段的路由器上。模块上电后可以先判断是否已经连接到网络，如果是则无需再次连接，否的话则进入 WIFI 连接状态，指示灯闪烁，连接成功后指示灯常亮，IP 等相关信息通过 OLED 显示和串口打印。另外需要配置超时 15 秒还没连接成功时执行取消连接，避免因无法连接而陷入死循环。代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702142321217.png" alt="image-20230702142321217" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：编程实现连接路由器，将IP地址等相关信息通过OLED显示（只支持2.4G网络）。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> network,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;01Studio&#x27;</span>, <span class="string">&#x27;88888888&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行WIFI连接函数</span></span><br><span class="line">WIFI_Connect()</span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>本节是 WIFI 应用的基础，成功连接到无线路由器的实验后，后面就可以做socket 等相关网络通信的应用了。</p><p>&nbsp;</p><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a><strong>Socket</strong> <strong>通信</strong></h2><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了如何通过 MicroPython 编程实现 pyWiFi-ESP32-S2 模块连接到无线路由器。这一节我们则来学习一下 Socket 通信实验。Socket 几乎是整个互联网通信的基础。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 Socket 编程实现 pyWiFi-ESP32-S2 与电脑服务器助手建立连接，相互收发数据。</p><p>⚫ <strong>实验讲解：</strong></p><p>Socket 我们听得非常多了，但由于网络工程是一门系统工程，涉及的知识非常广，概念也很多，任何一个知识点都能找出一堆厚厚的的书，因此我们经常会混淆。在这里，我们尝试以最容易理解的方式来讲述 Socket，如果需要全面了解，可以自行查阅相关资料学习。</p><p>我们先来看看网络层级模型图，这是构成网络通信的基础：</p><p>我们看看 TCP/IP 模型的传输层和应用层，传输层比较熟悉的概念是 TCP 和UDP，UPD 协议基本就没有对 IP 层的数据进行任何的处理了。而 TCP 协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。应用层中网页常用的则是 HTTP。那么我们先来解析一下这 TCP 和 HTTP 两者的关系。我们知道网络通信是最基础是依赖于 IP 和端口的，HTTP 一般情况下默认使用端口 80。举个简单的例子：我们逛淘宝，浏览器会向淘宝网的网址（本质是IP）和端口发起请求，而淘宝网收到请求后响应，向我们手机返回相关网页数据信息，实现了网页交互的过程。而这里就会引出一个多人连接的问题，很多人访问淘宝网，实际上接收到网页信息后就断开连接，否则淘宝网的服务器是无法支撑这么多人长时间的连接的，哪怕能支持，也非常占资源。</p><p>也就是应用层的 HTTP 通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP／IP 协议交互提供了套接字(Socket)接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。简单来说，Socket 抽象层介于传输层和应用层之间，跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p>套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议（通常是 <strong>TCP</strong> <strong>或</strong> <strong>UDP</strong>），本地主机的 <strong>IP</strong> <strong>地址，本地进程的协议端**</strong>口，远地主机的<strong>IP</strong> <strong>地址，远地进程的协议端口。</strong></p><p>所以，socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，简单理解就是其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等等。以下是通讯流程：</p><p><img src="/posts/e7f7981b.htm/image-20230702143005669.png" alt="image-20230702143005669" style="zoom:70%;"></p><p>从上图可以看到，建了 Socket 通信需要一个服务器端和一个客户端，以本实验为例，pyWiFi-ESP32-S2 作为客户端，电脑使用网络调试助手作为服务器端，双方使用 TCP 协议传输。对于客户端，则需要知道电脑端的 IP 和端口即可建立连接。（端口可以自定义，范围在 0~65535，注意不占用常用的 80 等端口即可。）以上的内容，简单来说就是如果用户面向应用来说，那么 ESP32-S2 只需要知道<strong>通讯协议是</strong> <strong>TCP</strong> <strong>或</strong> <strong>UDP**</strong>、服务器的<strong> </strong>IP<strong> </strong>和端口号**这 3 个信息，即可向服务器发起连接和发送信息。就这么简单。</p><p>MicroPython 已经封装好相关模块 usocket,跟传统的 socket 大部分兼容，两者均可使用，本实验使用 usocket，对象如下介绍：</p><p><strong>构造函数</strong></p><p>s=usocket.socekt(af=AF_INET, type=SOCK_STREAM,proto=IPPROTO_TCP)</p><p>构建 usocket 对象。</p><p>af: AF_INET→IPV4，AF_INET6 → IPV6；</p><p>type: SCOK_STREAM→TCP，SOCK_DGRAM→UDP；</p><p>proto: IPPROTO_TCP→TCP 协议，IPPROTO_UDP→UDP 协议。</p><p>（如果要构建 TCP 连接，可以使用默认参数配置，即不输入任何参数。）</p><p><strong>使用方法</strong></p><p>addr=usocket.getaddrinfo(‘www.01studio.org’, 80)[0][-1]</p><p>获取 Socket 通信格式地址。返回：(‘47.91.208.161’,80)</p><p>s.connect(address)</p><p>创建连接。address:地址格式为 IP+端口。例：(‘192.168.1.115’,10000)</p><p>s.send(bytes)</p><p>发送。bytes：发送内容格式为字节</p><p>s.recv(bufsize)</p><p>接收数据。bufsize：单次最大接收字节个数。</p><p>s.bind(address)</p><p>绑定，用于服务器角色</p><p>s.listen([backlog])</p><p>监听，用于服务器角色。backlog:允许连接个数，必须大于 0。</p><p>s.accept()</p><p>接受连接，用于服务器角色。</p><p>&nbsp;</p><p>本实验中 pyWiFi-ESP32-S2 属于客户端，因此只用到客户端的函数即可。实验代码编写流程如下：</p><p><img src="/posts/e7f7981b.htm/image-20230702143126631.png" alt="image-20230702143126631" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：连接无线路由器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过Socket编程实现pyWiFi-ESP32与电脑服务器助手建立TCP连接，相互收发数据。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">import</span> network,usocket,time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIFI连接函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WIFI_Connect</span>():</span><br><span class="line"></span><br><span class="line">    WIFI_LED=Pin(<span class="number">2</span>, Pin.OUT) <span class="comment">#初始化WIFI指示灯</span></span><br><span class="line"></span><br><span class="line">    wlan = network.WLAN(network.STA_IF) <span class="comment">#STA模式</span></span><br><span class="line">    wlan.active(<span class="literal">True</span>)                   <span class="comment">#激活接口</span></span><br><span class="line">    start_time=time.time()              <span class="comment">#记录时间做超时判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Connecting to network...&#x27;</span>)</span><br><span class="line">        wlan.connect(<span class="string">&#x27;henu-student&#x27;</span>, <span class="string">&#x27;hbwz12138&#x27;</span>) <span class="comment">#输入WIFI账号密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> wlan.isconnected():</span><br><span class="line"></span><br><span class="line">            <span class="comment">#LED闪烁提示</span></span><br><span class="line">            WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line">            WIFI_LED.value(<span class="number">0</span>)</span><br><span class="line">            time.sleep_ms(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#超时判断,15秒没连接成功判定为超时</span></span><br><span class="line">            <span class="keyword">if</span> time.time()-start_time &gt; <span class="number">15</span> :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WIFI Connected Timeout!&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wlan.isconnected():</span><br><span class="line">        <span class="comment">#LED点亮</span></span><br><span class="line">        WIFI_LED.value(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#串口打印信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;network information:&#x27;</span>, wlan.ifconfig())</span><br><span class="line"></span><br><span class="line">        <span class="comment">#OLED数据显示</span></span><br><span class="line">        oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">        oled.text(<span class="string">&#x27;IP/Subnet/GW:&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">0</span>], <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">1</span>],<span class="number">0</span>,<span class="number">38</span>)</span><br><span class="line">        oled.text(wlan.ifconfig()[<span class="number">2</span>],<span class="number">0</span>,<span class="number">56</span>)</span><br><span class="line">        oled.show()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断WIFI是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> WIFI_Connect():</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建socket连接TCP类似，连接成功后发送“Hello 01Studio！”给服务器。</span></span><br><span class="line">    s=usocket.socket()</span><br><span class="line">    addr=(<span class="string">&#x27;192.168.1.115&#x27;</span>,<span class="number">10000</span>) <span class="comment">#服务器IP和端口</span></span><br><span class="line">    s.connect(addr)</span><br><span class="line">    s.send(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    </span><br><span class="line">    text=s.recv(<span class="number">128</span>) <span class="comment">#单次最多接收128字节</span></span><br><span class="line">    <span class="keyword">if</span> text == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打印接收到的信息为字节，可以通过decode(&#x27;utf-8&#x27;)转成字符串</span></span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        s.send(<span class="string">&#x27;I got:&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    time.sleep_ms(<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p>WIFI 连接代码在上一节已经讲解，这里不再重复，WIFI 连接成功后返回 True，否则返回 False。程序在返回连接成功后建了 Socket 连接，连接成功发送‘Hello 01Studio!’信息到服务器。另外 RTOS 定时器设定了了每 300ms 处理从服务器接收到的数据。将接收到数据通过串口打印和发送给服务器。</p><p>⚫ <strong>实验结果：</strong></p><p>先在电脑端打开网络调试助手并建立服务器，软件在 零一科技（01Studio）MicroPython 开发套件配套资料_latest\01-开发工具\01-Windows\网络调试助手下的 NetAssist.exe ，直接双击打开即可！</p><p><img src="/posts/e7f7981b.htm/image-20230702143433653.png" alt="image-20230702143433653" style="zoom:67%;"></p><p>以下是新建服务器的方法，打开网络调试助手后在左上角协议类型选择 TCP Server；中间的本地 IP 地址是自动识别的，不要修改，这个就是服务器的 IP 地址。然后端口写 10000（0-65535 都可以。），点击连接，成功后红点亮。如下图：</p><p><img src="/posts/e7f7981b.htm/image-20230702143452690.png" alt="image-20230702143452690" style="zoom:80%;"></p><p>在时候服务器已经在监听状态！用户需要根据自己的实际情况自己输入 WIFI信息和服务器 IP 地址+端口。即修改上面的代码以下部分内容。（服务器 IP 和端口可以在网络调试助手找到。）</p><p>WiFi 网络信息：</p><p>wlan.connect(‘01Studio’, ‘88888888’) #输入 WIFI 账号密码</p><p>服务器信息：</p><p>addr=(‘192.168.1.115’,10000) #服务器 IP 和端口</p><p>下载程序，开发板成功连接 WIFI 后，发起了 socket 连接，连接成功可以可以看到网络调试助手收到了开发板发来的信息。在下方列表多了一个连接对象，点击选中</p><p>选中后我们在发送框输入信息“Hi”，点击发送，可以看到开发板的 REPL 打印出来信息 Hi。为字节数据。另外由于程序将收到的信息发回给服务器，所以在网络调试助手中也接收到开发板返回的信息：I got:Hi。</p><p><img src="/posts/e7f7981b.htm/image-20230702143554343.png" alt="image-20230702143554343" style="zoom:60%;"></p><p><img src="/posts/e7f7981b.htm/image-20230702143618314.png" alt="image-20230702143618314" style="zoom:80%;"></p><p>⚫ <strong>总结：</strong></p><p>通过本节学习，我们了解了socket通信原理以及使用MicroPython进行socket编程并且通信的实验。得益于优秀的封装，让我们可以直接面向 socket 对象编程就可以快速实现 socket 通信，从而开发更多的网络应用，例如将前面采集到的传感器数据发送到服务器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> espe32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32传感器</title>
      <link href="/posts/30e8a1b9.html"/>
      <url>/posts/30e8a1b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="传感器实验"><a href="#传感器实验" class="headerlink" title="传感器实验"></a><strong>传感器实验</strong></h1><p>日常生活中我们会用到各式各样的外设或者传感器，还是那句，一个有经验的嵌入式开发工程师驱动一款未接触过的传感器的一般流程是：了解传感器原理、设计电路图、信号时序分析和编程。没个几天折腾不出来。生活中有很多传感器已经是非常通用了，前人已经做好封装函数模块，我们直接调用函数即可。我们不需要将时间花在“怎么用”上，而更多的是考虑“用到什么地方”！</p><h3 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a><strong>温度传感器</strong> <strong>DS18B20</strong></h3><p>⚫ <strong>前言：</strong></p><p>相信没有电子爱好者不知道 DS18B20 的，DS18B20 是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。DS18B20 数字温度传感器接线方便，封装成后可应用于多种场合，如管道式，螺纹式，磁铁吸附式，不锈钢封装式，型号多种多样。主要根据应用场合的不同而改变其外观。封装后的 DS18B20 可用于电缆沟测温，高炉水循环测温，锅炉测温，机房测温，农业大棚测温，洁净室测温，弹药库测温等各种非极限温度场合。耐磨耐碰，体积小，使用方便，封装形式多样，适用于各种狭小空间设备数字测温和控制领域。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我，们来看看原理图：</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DS18B20 是单总线驱动（onewire）传感器，也就是说只占用 1 个 IO 口。我们来看看原理图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140646041.png" alt="image-20230702140646041" style="zoom:50%;"></p><p>可以看到 DS18B20 传感器连接到了 pyBase 的 X11 引脚上。也就是连接到pyWiFi-ESP32-S2 的引脚 41，如下图所示：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140747976.png" alt="image-20230702140747976" style="zoom:50%;"></p><p>也就是说我们需要针对引脚 41 编写程序来驱动 DS18B20。那么我们需要自己来编写驱动么？如果你有兴趣的可以自己尝试一下。这部分我们 01Studio 已经收集整理和编写好了，单总线模块文件是：onewire.py，DS18B20 模块的文件是 ds18x20.py。如果你学习过前面基于 STM32 平台应该不陌生。而对于 ESP32-S2,这两个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可！单总线模块（onewire）和 ds18x20 模块说明如下：</p><p><strong>构造函数</strong></p><p>ow=onewire.OneWire(machine.Pin(id))</p><p>构建单总线对象。id:引脚编号；</p><p><strong>使用方法</strong></p><p>ow.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ow.reset()</p><p>总线设备复位。</p><p>ow.readbyte()</p><p>读 1 个字节。</p><p>ow.writebyte(0x12)</p><p>写入 1 个字节。</p><p>ow.write(‘123’)</p><p>写入多个字节。</p><p>ow.select_rom(b’12345678’)</p><p>根据 ROM 编号选择总线上指定设备</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>ds=ds18x20.DS18X20(ow)</p><p>构建 DS18B20 传感器对象。ow:定义好的单总线对象；</p><p><strong>使用方法</strong></p><p>ds.scan()</p><p>扫描总线上的设备。返回设备地址，支持多设备同时挂载。</p><p>ds.convert_temp()</p><p>温度转换。</p><p>ds.read_temp(rom)</p><p>获取温度值。rom：表示对应的设备号。</p><p>&nbsp;</p><p>大部分场景下温度的变化不会太频繁，我们可以每隔 1 秒采集一次，显示精度为小数点后 2 位，基本满足大部分应用需求。编程逻辑如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702140853444.png" alt="image-20230702140853444" style="zoom:80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：温度传感器DS18B20</span></span><br><span class="line"><span class="string">说明：通过编程采集温度数据，并在OLED上显示。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引用相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"><span class="keyword">import</span> onewire,ds18x20,time</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))</span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化DS18B20</span></span><br><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) <span class="comment">#使能单总线</span></span><br><span class="line">ds = ds18x20.DS18X20(ow)        <span class="comment">#传感器是DS18B20</span></span><br><span class="line">rom = ds.scan()         <span class="comment">#扫描单总线上的传感器地址，支持多个传感器同时连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">temp_get</span>(<span class="params">tim</span>):</span><br><span class="line">    ds.convert_temp()</span><br><span class="line">    temp = ds.read_temp(rom[<span class="number">0</span>]) <span class="comment">#温度显示,rom[0]为第1个DS18B20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#OLED数据显示</span></span><br><span class="line">    oled.fill(<span class="number">0</span>)   <span class="comment">#清屏背景黑色</span></span><br><span class="line">    oled.text(<span class="string">&#x27;MicroPython&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;Temp test:&#x27;</span>,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%temp)+<span class="string">&#x27; C&#x27;</span>,<span class="number">0</span>,<span class="number">40</span>) <span class="comment">#显示temp,保留2位小数</span></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(-<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=temp_get) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验拓展：</strong></p><p>pyBase 开发底板预留了外界传感器接口，只要接线正确就可以进行更多的传感器实验。我们将带金属探头的 DS18B20 传感器接到 pyBase 右侧上面的传感器母座，其连接到 pyBase 的“Y11”引脚,也就是对应 pyWiFi-ESP32-S2 的引脚 10。</p><p>所以只要将原程序代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">41</span>)) </span><br></pre></td></tr></table></figure><p>改成 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ow= onewire.OneWire(Pin(<span class="number">10</span>))，</span><br></pre></td></tr></table></figure><p>即可驱动外接的 DS18B20。</p><p>⚫ <strong>总结</strong></p><p>DS18B20 作为我们第一个实验传感器，使用 MicroPython 编程非常容易就用起来了，而且精度和稳定性丝毫没有影响。温度传感器只是一个敲门砖，接下来我们将会学习更多的传感器应用。</p><p>&nbsp;</p><h3 id="温湿度传感器-DHT11"><a href="#温湿度传感器-DHT11" class="headerlink" title="温湿度传感器 DHT11"></a><strong>温湿度传感器</strong> <strong>DHT11</strong></h3><p>⚫ <strong>前言：</strong></p><p>温湿度也是我们日常非常常见的指标，我们使用的是 DHT11 数字温湿度传感器。这是一款含有已校准数字信号输出的温湿度复合传感器，它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性和卓越的长期稳定性。</p><p>DHT11 具有小体积、极低的功耗，信号传输距离可达 20 米以上，使其成为给类应用甚至最为苛刻的应用场合的最佳选择。产品为 4 针单排引脚封装，连接方便。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程采集温湿度数据，并在 OLED 上显示。</p><p>⚫ <strong>实验讲解：</strong></p><p>DHT11 虽然有 4 个引脚，但其中第 3 个引脚是悬空的，也就是说 DHT11 也是单总线的传感器，只占用 1 个 IO 口。</p><p><img src="/posts/30e8a1b9.htm/image-20230702141333793.png" alt="image-20230702141333793" style="zoom:80%;"></p><p>我们来看看 DHT11 在开发板上的接线图：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141347945.png" alt="image-20230702141347945" style="zoom:67%;"></p><p>可以看到 DHT11 连接到 pyBase 的‘X12’引脚，也就是连接到 pyWiFi-ESP32-S2 的引脚 42，如下图所示：</p><p>因此可以针对引脚 42 编程来驱动 DHT11 传感器，模块文件是 dht.py。而对于 pyWiFi-ESP32-S2,这个模块已经集成到了初始化固件中，也就是说我们可以直接在 main.py 导入模块并调用即可。函数模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>d = dht.DHT11(machine.Pin(id))</p><p>构建 DHT11 传感器对象。id:传感器所连接的引脚；</p><p><strong>使用方法</strong></p><p>d.measure()</p><p>测量温湿度。</p><p>d.temperature()</p><p>获取温度值。</p><p>d.humidity()</p><p>获取湿度值</p><p>建议上电先延时 1 秒，让 DHT11 稳定后再开始读取。代码编写流程如下：</p><p><img src="/posts/30e8a1b9.htm/image-20230702141458320.png" alt="image-20230702141458320" style="zoom:80%;"></p><p>&nbsp;</p><h3 id="人体感应传感器"><a href="#人体感应传感器" class="headerlink" title="人体感应传感器"></a><strong>人体感应传感器</strong></h3><p>⚫ <strong>前言：</strong></p><p>人体感应传感器，在室内安防应用非常普遍，其原理是由探测元件将探测到人体的红外辐射转变成微弱的电压信号，经过放大后输出。为了提高探测器的探测灵敏度以增大探测距离，一般在探测器的前方装设一个塑料的菲涅尔透镜，它和放大电路相配合，可将信号放大 70dB 以上，这样就可以测出 5~10 米范围内人的行动。</p><p>⚫ <strong>实验目的：</strong></p><p>通过外部中断编程来检测人体感应模块，当有人出现时候 OLED 通过“GetPeople!！！”闪烁提示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32基础实验</title>
      <link href="/posts/7fbb683d.html"/>
      <url>/posts/7fbb683d.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a><strong>基础实验</strong></h1><p>MicroPython 更强调的是针对应用的学习，强大的底层库函数让我们可以直接关心功能的实现，也就是说我们只要理解和熟练相关的函数用法，就可以很好</p><p>的玩转 MicroPython。它让我们可以做到不关心硬件和底层原理（当然有兴趣和能力的小伙伴可以深入研究）而直接跑起硬件。</p><h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 上有 1 个 LED（蓝色），控制 LED 使用 machine 中的 Pin 对</p><p>象，其构造函数和使用方法如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>led=machine.Pin(id,mode,pull)</td></tr><tr><td>构建 led 对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>led.value([x])</td></tr><tr><td>引脚电平值。输出状态：x=0 表示低电平，x=1 表示高电平；输入状态：无须</td></tr><tr><td>参数，返回当前引脚值。</td></tr><tr><td>led.on()</td></tr><tr><td>使引脚输出高电平“1”。</td></tr><tr><td>led.off()</td></tr><tr><td>使引脚输出低电平“0”。</td></tr><tr><td>更详细内容，请查看 micropython 库文档：<a href="https://docs.01studio.cc/">https://docs.01studio.cc/</a></td></tr></tbody></table></div><p>上表对 MicroPython 的 machine 中 Pin 对象做了详细的说明，machine 是大</p><p>模块，Pin 是 machine 下面的其中一个小模块，在 python 编程里有两种方式引用</p><p>相关模块:</p><p><strong>方式</strong> <strong>1</strong> <strong>是</strong>：import machine，然后通过 machine.Pin 来操作；</p><p><strong>方式</strong> <strong>2</strong> <strong>是</strong>：from machine import Pin,意思是直接从 machine 中引入 Pin 模块，</p><p>然后直接通过构建 led 对象来操作。显然方式 2 会显得更直观和方便，本实验也</p><p>是使用方式 2 来编程。代码编写流程如下：</p><p>从原理图可以看到 LED 跟模块引脚 2 相连，通过输出高电平方式点亮</p><p><img src="/posts/7fbb683d.htm/image-20230701223726651.png" alt="image-20230701223726651" style="zoom:50%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮 LED 蓝灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入 Pin 模块</span></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 led 对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮 LED，也可以使用 led.on()</span></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>从第一个实验我们可以看到，使用 MicroPython 来开发关键是要学会构造函</p><p>数和其使用方法，便可完成对相关对象的操作，在强大的模块函数支持下，实验</p><p>只用了简单的两行代码便实现了点亮 LED 灯。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h2><p>⚫ <strong>前言：</strong></p><p>按键是最简单也最常见的输入设备，很多产品都离不开按键，包括早期的iPhone。有了按键输入功能，我们就可以做很多好玩的东西了。</p><p>⚫ <strong>实验目的：</strong></p><p>使用按键功能，通过检测按键被按下后，改变 LED（蓝灯）的亮灭状态。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板上有 2 个按键，RST 和 KEY，RST 顾名思义是复位用的，所以真正自带可以用的就只有 1 个按键 KEY。</p><p>让我们先来搞清楚 MicroPython 里面 Pin 模块实现按键的构造函数和使用方法。</p><p>&nbsp;</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>KEY.value()</td></tr><tr><td>引脚电平值。输入状态：无须参数，返回当前引脚值 0 或者 1。</td></tr></tbody></table></div><p>可以看到跟上一节 LED 一样，只是输入/输出状态的一个改变。从下面原理图可以看到，我们只需要在开发板上电后判断 KEY 引脚的电平，当被按下时候引</p><p>脚为低电平“0</p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p><img src="/posts/7fbb683d.htm/image-20230701224121294.png" alt="image-20230701224121294" style="zoom:67%;"></p><p>常用的方法就是当检测按键值为 0 时，延时一段时间，大约 10ms，再判断按键引脚值仍然是 0，是的话说明按键被按下。延时使用 time 模块，使用方法如</p><p>下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>) <span class="comment"># 睡眠 1 秒</span></span><br><span class="line">time.sleep_ms(<span class="number">500</span>) <span class="comment"># 睡眠 500 毫秒</span></span><br><span class="line">time.sleep_us(<span class="number">10</span>) <span class="comment"># 睡眠 10 微妙</span></span><br><span class="line">start = time.ticks_ms() <span class="comment"># 获取毫秒计时器开始值</span></span><br><span class="line">delta = time.ticks_diff(time.ticks_ms(), start) <span class="comment"># 计算从上电开始到当前时间</span></span><br><span class="line">的差值</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：按键</span></span><br><span class="line"><span class="string">说明：通过按键改变 LED 的亮灭状态</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建 LED 对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建 KEY 对象</span></span><br><span class="line">state=<span class="number">0</span> <span class="comment">#LED 引脚状态</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下</span></span><br><span class="line"> time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state=<span class="keyword">not</span> state <span class="comment">#使用 not 语句而非~语句</span></span><br><span class="line"> LED.value(state) <span class="comment">#LED 状态翻转</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;KEY&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">not</span> KEY.value(): <span class="comment">#检测按键是否松开</span></span><br><span class="line"> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看到，初始化各个对象后，进入循环，当检测到 KEY 的值为0（按键被按下）时候，先做了 10ms 的延时，再次判断；</p><p>state 为 LED 状态的值，每次按键按下后通过使用 not 来改变。这里注意的是在 python 里使用‘not’而不是‘~’的方式。not 返回的是 True 和 False，即</p><p>0,1。而~ 是取反操作，会导致出错。</p><p>&nbsp;</p><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h2><p>⚫ <strong>前言：</strong></p><p>前面我们在做普通的 GPIO 时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如</p><p>某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断</p><p>的在实际项目的应用非常普遍.</p><p>⚫ <strong>实验目的：</strong></p><p>利用中断方式来检查按键 KEY 状态，被按键被按下（产生外部中断）后使 LED</p><p>的亮灭状态翻转</p><p>⚫ <strong>实验讲解：</strong></p><p>外部中断也是通过 machine 模块的 Pin 子模块来配置，我们先来看看其配构</p><p>造函数和使用方法</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th><th></th></tr></thead><tbody><tr><td>KEY=machine.Pin(id,mode,pull)</td><td></td></tr><tr><td>构建按键对象。id:引脚编号；mode:输入输出方式；pull:上下拉电阻配置。</td><td></td></tr><tr><td><strong>使用方法</strong></td><td></td></tr><tr><td>KEY.irq(handler,trigger)</td><td></td></tr><tr><td>配置中断模式。</td><td></td></tr><tr><td>handler:中断执行的回调函数；</td><td></td></tr><tr><td>trigger: 触发中断的方式，共 4 种，分别是 Pin.IRQ_FALLING（下降沿触发）、</td><td></td></tr><tr><td>Pin.IRQ_RISING（上升沿触发）、Pin.IRQ_LOW_LEVEL（低电平触发）、</td><td></td></tr><tr><td>Pin.IRQ_HIGH_LEVEL（高电平触发）</td></tr></tbody></table></div><p>上升沿和下降沿触发统称边沿触发。从上一节按键可以看到，按键被按下时一个引脚值从 1 到 0 变化的过程，边沿触发就是指这个过程。</p><p><img src="/posts/7fbb683d.htm/image-20230701224921935.png" alt="image-20230701224921935" style="zoom:50%;"></p><p>由此可见，我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产生中断。</p><p>编程思路中断跟按键章节类似，在初始化中断后，当系统检测到外部终端时候，执行 LED 亮灭状态反转的代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：外部中断</span></span><br><span class="line"><span class="string">说明：通过按键改变LED的亮灭状态（外部中断方式）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">LED=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建LED对象,开始熄灭</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">state=<span class="number">0</span>  <span class="comment">#LED引脚状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LED状态翻转函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    <span class="keyword">global</span> state</span><br><span class="line">    time.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">        state = <span class="keyword">not</span> state</span><br><span class="line">        LED.value(state)</span><br><span class="line"></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中需要注意的地方：</p><p>1、state 是全局变量，因此在 fun 函数里面用该变量必须添加 globalstate 代码，否则会在函数里面新建一个样的变量造成冲突。</p><p>2、在定义回调函数 fun 的时候，需要将 Pin 对象 KEY 传递进去。</p><p>⚫ <strong>总结：</strong></p><p>从参考代码来看，只是用了几行代码就实现了实验功能，而且相对于使用while True 实时检测函数来看，代码的效率大大增强。外部中断的应用非常广，</p><p>出来普通的按键输入和电平检测外，很大一部分输入设备，比如传感器也是通过外部中断方式来实时检测.</p><p>&nbsp;</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><p>⚫ <strong>前言：</strong></p><p>定时器，顾名思义就是用来计时的，我们常常会设定计时或闹钟，然后时间到了就告诉我们要做什么了。单片机也是这样，通过定时器可以完成各种预设好</p><p>的任务。</p><p>⚫ <strong>实验目的：</strong></p><p>通过定时器让 LED 周期性每秒闪烁 1 次。</p><p>⚫ <strong>实验讲解：</strong></p><p>ESP32-S2 内置 RTOS（实时操作系统）定时器，在 machine 的 Timer 模块中。通过 MicroPython 可以轻松编程使用。我们也是只需要了解其构造对象函数和使</p><p>用方法即可！</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>tim=machine.Timer(id)</td></tr><tr><td>构建定时器对象。</td></tr><tr><td>【id】ESP32-S2 有 2 路硬件定时器，id=0~1，也可以定义成-1，即RTOS 虚拟定时器</td></tr><tr><td></td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>tim.init(period,mode,callback)</td></tr><tr><td>定时器初始化。</td></tr><tr><td>period:单位为 ms；</td></tr><tr><td>mode：2 种工作模式，Timer.ONE_SHOT（执行一次）、Timer.PERIODIC（周期性）；callback:定时器中断后的回调函数。</td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类似，代码编程流程图如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701225642158.png" alt="image-20230701225642158" style="zoom:75%;"></p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：定时器</span></span><br><span class="line"><span class="string">说明：通过定时器让LED周期性每秒闪烁1次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,Timer</span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line">Counter = <span class="number">0</span></span><br><span class="line">Fun_Num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> Counter</span><br><span class="line">    Counter = Counter + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(Counter)</span><br><span class="line">    led.value(Counter%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器，编号为-1</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">1000</span>, mode=Timer.PERIODIC,callback=fun) <span class="comment">#周期为1000ms</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="I2C-总线（OLED-显示屏）"><a href="#I2C-总线（OLED-显示屏）" class="headerlink" title="I2C 总线（OLED 显示屏）"></a><strong>I2C</strong> <strong>总线（</strong>OLED <strong>显示屏）</strong></h3><p>前面学习了按键输入设备后，这一节我们来学习输出设备 OLED 显示屏，其实之前的 LED 灯也算是输出设备，因为它们确切地告诉了我们硬件的状态。只是</p><p>相对于只有亮灭的 LED 而言，显示屏可以显示更多的信息，体验更好。</p><p>⚫ <strong>实验讲解：</strong></p><p><strong>什么是</strong> <strong>I2C**</strong>？**</p><p>I2C 是用于设备之间通信的双线协议，在物理层面，它由 2 条线组成：SCL 和SDA，分别是时钟线和数据线。也就是说不通设备间通过这两根线就可以进行通</p><p>信。</p><p><strong>什么是</strong> <strong>OLED</strong> <strong>显示屏？</strong></p><p>OLED 的特性是自己发光，不像 TFT LCD 需要背光，因此可视度和亮度均高，其次是电压需求低且省电效率高，加上反应快、重量轻、厚度薄，构造简单，成</p><p>本低等特点。简单来说跟传统液晶的区别就是里面像素的材料是由一个个发光二极管组成，因为密度不高导致像素分辨率低，所以早期一般用作户外 LED 广告</p><p>牌。随着技术的成熟，使得集成度越来越高。小屏也可以制作出较高的分辨率。</p><p><img src="/posts/7fbb683d.htm/image-20230701230249879.png" alt="image-20230701230249879" style="zoom:50%;"></p><p>在了解完 I2C 和 OLED 显示屏后，我们先来看看 pyBase 开发板的原理图，也就是上面的 OLED 接口是如何连线的。</p><p><img src="/posts/7fbb683d.htm/image-20230701230306218.png" alt="image-20230701230306218" style="zoom:50%;"></p><p>我们从 pyWiFi-ESP32-S2 和 pyBase 相结合的原理图可以看到 GPIO38—Y6—SCL, GPIO40—Y8—SDA 的连接关系：</p><p><img src="/posts/7fbb683d.htm/image-20230701230321167.png" alt="image-20230701230321167" style="zoom:50%;"></p><p>本实验将使用 MicroPython 的 Machine 模块来定义 Pin 口和 I2C 初始化。具体如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>i2c = machine.I2C(scl,sda)i2c = machine.I2C(scl,sda)</td></tr><tr><td>构建 I2C 对象。scl:时钟引脚；sda:数据引脚。构建 I2C 对象。scl:时钟引脚；sda:数据引脚。</td></tr><tr><td><strong>使用方法**</strong>使用方法**</td></tr><tr><td>i2c.scan()i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,nbytes)i2c.readfrom(addr,nbytes)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；从指定地址读数据。addr:指定设备地址；nbytes:读取字节数；</td></tr><tr><td>i2c.write(buf)</td></tr><tr><td>写数据。buf:数据内容；</td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306.py 文件里面。开发者只需要拷贝到 pyBoard 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306.py 文件代码。OLED 显示屏对象介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>oled = SSD1306_I2C(width, height, i2c, addr)</td></tr><tr><td>构 OLED 显示屏对象。width:屏幕宽像素；height: 屏幕高像素；i2c:定义好的</td></tr><tr><td>I2C 对象; addr:显示屏设备地址。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>oled.text(string,x,y)</td></tr><tr><td>将 string 字符写在指定为位置。string：字符；x:横坐标；y:纵坐标。</td></tr><tr><td>oled.show()</td></tr><tr><td>执行显示。</td></tr><tr><td>oled.fill(RGB)</td></tr><tr><td>清屏。RGB：0 表示黑色，1 表示白色。</td></tr></tbody></table></div><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><p><img src="/posts/7fbb683d.htm/image-20230701231539182.png" alt="image-20230701231539182" style="zoom:80%;"></p><h4 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：I2C总线(OLED显示屏)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> SoftI2C,Pin         <span class="comment">#从machine模块导入I2C、Pin子模块</span></span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C     <span class="comment">#从ssd1306模块中导入SSD1306_I2C子模块</span></span><br><span class="line"></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))   <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>) <span class="comment">#OLED显示屏初始化：128*64分辨率,OLED的I2C地址是0x3c</span></span><br><span class="line"></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>,  <span class="number">0</span>)      <span class="comment">#写入第1行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>,  <span class="number">0</span>, <span class="number">20</span>)      <span class="comment">#写入第2行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>,  <span class="number">0</span>, <span class="number">50</span>)      <span class="comment">#写入第3行内容</span></span><br><span class="line"></span><br><span class="line">oled.show()   <span class="comment">#OLED执行显示</span></span><br></pre></td></tr></table></figure><p>上述代码中 OLED 的 I2C 地址是 0x3C,不同厂家的产品地址可能预设不一样，具体参考厂家的说明书。或者也可以通过 I2C.scan()来获取设备地址。另外记得将我们提供的示例代码中的 ssd1306.py 驱动文件拷贝到 pyWiFiESP32-S2 的文件系统下，跟 main.py 保持同一个路径。</p><p><img src="/posts/7fbb683d.htm/image-20230701231632416.png" alt="image-20230701231632416" style="zoom:50%;"></p><p>⚫ <strong>总结：</strong></p><p>这一节我们学会了驱动 OLED 显示屏，换着以往如果从使用单片机从 0 开发的话你需要了解 I2C 总线原理，了解 OLED 显示屏的使用手册，编程 I2C 代码，有经验的嵌入式工程师搞不好也要弄个几天。现在基本半个小时解决问题。当然前提是别人已经给你搭好桥了，有了强大的底层驱动代码支持，我们只做好应用就好。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="RTC-实时时钟"><a href="#RTC-实时时钟" class="headerlink" title="RTC 实时时钟"></a><strong>RTC</strong> <strong>实时时钟</strong></h3><p>⚫ <strong>前言：</strong></p><p>时钟可以说我们日常最常用的东西了，手表、电脑、手机等等无时无刻不显示当前的时间。可以说每一个电子爱好者心中都希望拥有属于自己制作的一个电子时钟，接下来我们就用 MicroPython 开发板来制作一个属于自己的电子时钟。</p><p>⚫ <strong>实验讲解：</strong></p><p>实验的原理是读取 RTC 数据，然后通过 OLED 显示。毫无疑问，强大的MicroPython 已经集成了内置时钟函数模块。位于 machine 的 RTC 模块中，具体介绍如下：</p><div class="table-container"><table><thead><tr><th><strong>构造函数</strong></th></tr></thead><tbody><tr><td>rtc=machine.RTC()</td></tr><tr><td>构建 RTC 对象。</td></tr><tr><td><strong>使用方法</strong></td></tr><tr><td>rtc.datetime((2019, 4, 1, 0, 0, 0, 0, 0))</td></tr><tr><td>设置日期和时间。按顺序分别是：（年，月，日，星期，时，分，秒，微秒），</td></tr><tr><td>其中星期使用 0-6 表示周一至周日。</td></tr><tr><td>rtc.datetime()</td></tr><tr><td>获取当前日期和时间</td></tr></tbody></table></div><p>从上表可以看到 RTC()的使用方法，我们需要做的就是先设定时间，然后再获取当前芯片里的时间，通过 OLED 显示屏显示，如此循环。在循环里，如果一直获取日期时间数据会造成资源浪费，所以可以每隔第一段时间获取一次数据，又由于肉眼需要看到至少每秒刷新一次即可，这里每隔 300ms 获取一次数据，使用前面学习过的 RTOS 定时器来计时，具体编程流程如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701232806658.png" alt="image-20230701232806658" style="zoom:67%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：RTC实时时钟</span></span><br><span class="line"><span class="string">说明：使用Thonny连接开发板会自动更新RTC时间</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, SoftI2C, RTC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义星期和时间（时分秒）显示字符列表</span></span><br><span class="line">week = [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tues&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thur&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">time_list = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化所有相关对象</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>)) <span class="comment">#I2C初始化：sda--&gt;40, scl--&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">rtc = RTC()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次上电配置时间，按顺序分别是：年，月，日，星期，时，分，秒，次秒级；这里做了</span></span><br><span class="line"><span class="comment"># 一个简单的判断，检查到当前年份不对就修改当前时间，开发者可以根据自己实际情况来</span></span><br><span class="line"><span class="comment"># 修改。</span></span><br><span class="line"><span class="keyword">if</span> rtc.datetime()[<span class="number">0</span>] != <span class="number">2023</span>:</span><br><span class="line">    rtc.datetime((<span class="number">2021</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RTC_Run</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    datetime = rtc.datetime()  <span class="comment"># 获取当前时间</span></span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)    <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;RTC Clock&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)  <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示日期，字符串可以直接用“+”来连接</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(datetime[<span class="number">0</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">1</span>]) + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(datetime[<span class="number">2</span>]) + <span class="string">&#x27; &#x27;</span> + week[datetime[<span class="number">3</span>]], <span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间需要判断时、分、秒的值否小于10，如果小于10，则在显示前面补“0”以达</span></span><br><span class="line">    <span class="comment"># 到较佳的显示效果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">if</span> datetime[i] &lt; <span class="number">10</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time_list[i - <span class="number">4</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示时间</span></span><br><span class="line">    oled.text(time_list[<span class="number">0</span>] + <span class="built_in">str</span>(datetime[<span class="number">4</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">1</span>] + <span class="built_in">str</span>(datetime[<span class="number">5</span>]) + <span class="string">&#x27;:&#x27;</span> + time_list[<span class="number">2</span>] + <span class="built_in">str</span>(datetime[<span class="number">6</span>]), <span class="number">0</span>, <span class="number">55</span>)</span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启RTOS定时器</span></span><br><span class="line">tim = Timer(<span class="number">0</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=RTC_Run) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于实验要用到 OLED 显示屏，所以同样别忘了将示例代码该实验文件夹下的 ssd1306.py 文件复制到 pyWiFi-ESP32-S2 的文件系统里面。</p><p>由于 ESP32-S2 没有后备电池引脚，所以不支持掉电保存。因此 pybase 上面的纽扣电池是不起作用的。</p><p>⚫ <strong>总结：</strong></p><p>细心的用户或许已经发现运行程序后 RTC 时间自动更新，那是因为 thonny每次连接 MicroPython 开发板会自动更新开发板的 RTC 时间。</p><p>RTC 实时时钟的可玩性很强，我们还可以根据自己的风格来设定数字显示位置，以及加上一些属于自己的字符标识。打造自己的电子时钟。</p><p>&nbsp;</p><h3 id="ADC（电位器）"><a href="#ADC（电位器）" class="headerlink" title="ADC（电位器）"></a><strong>ADC</strong>（电位器）</h3><p>⚫ <strong>前言：</strong></p><p>ADC(analog to digital conversion) 模拟数字转换。意思就是将模拟信号转化成数字信号，由于单片机只能识别二级制数字，所以外界模拟信号常常会通过 ADC转换成其可以识别的数字信息。常见的应用就是将变化的电压转成数字信号。</p><p>⚫ <strong>实验目的：</strong></p><p>通过编程调用 MicroPython 的内置 ADC 函数，实现测量输入电压，并显示到屏幕上。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyBase 开发底板的 X7 引脚连接到了电位器，通过电位器的调节可以使得 X7引脚上的电压变化范围实现从 0-3.3V。</p><p><img src="/posts/7fbb683d.htm/image-20230701233122746.png" alt="image-20230701233122746" style="zoom:50%;"></p><p><img src="/posts/7fbb683d.htm/image-20230701233132565.png" alt="image-20230701233132565" style="zoom:50%;"></p><p>从上图可以看到，电位器引脚对应 pyBase 的 X7,实际是跟 pyWiFi-ESP32-S2</p><p>的‘</p><p>6’引脚 ADC 输入引脚相连。ESP32-S2 的 ADC 默认只能测量 0-1V 的量程，</p><p>但 ESP32-S2 内部集成了衰减器，最大支持 11dB 衰减，通过配置衰减器最多能测</p><p>量 3V 左右的电压。我们来看看 ADC 模块的构造函数和使用方法。</p><p><strong>构造函数</strong></p><p>adc=machine.ADC(Pin(id))</p><p>构建 ADC 对象。</p><p>【id】目前仅支持 ESP32-S2 的 ADC1，共 10 个通道：</p><p>GPIO1: ADC1_0</p><p>GPIO2: ADC1_1</p><p>GPIO3: ADC1_2</p><p>GPIO4: ADC1_3</p><p>GPIO5: ADC1_4</p><p>GPIO6: ADC1_5</p><p>GPIO7: ADC1_6</p><p>GPIO8: ADC1_7</p><p>GPIO9: ADC1_8</p><p>GPIO10: ADC1_9</p><p><strong>使用方法</strong></p><p>adc.read()</p><p>获取 ADC 值。测量精度是 13 位，返回 0- 8191（表示 0-1V）。</p><p>adc.atten(attenuation)</p><p>配置衰减器。配置衰减器能增加电压测量范围，但是以精度为代价的。</p><p>attenuation:衰减设置</p><p>ADC.ATTN_0DB： 0dB 衰减, 最大输入电压为 1.00v - 这是默认配置；</p><p>ADC.ATTN_2_5DB： 2.5dB 衰减, 最大输入电压约为 1.34v；</p><p>ADC.ATTN_6DB：6dB 衰减, 最大输入电压约为 2.00v；</p><p>ADC.ATTN_11DB：11dB 衰减, 最大输入电压约为 3.3v。</p><p>你没看错，就这么简单，两句函数就可以获得 ADC 数值。我们将在本实验中以默认的量程 0-1V 来测试。让我们来理顺一下编程逻辑。先导入相关模块，然后初始化模块。在循环中不断读取 ADC 的值，转化成电压值后在 OLED 上面显示，每隔 300 毫秒读取一次，具体如下：</p><p><img src="/posts/7fbb683d.htm/image-20230701233235973.png" alt="image-20230701233235973" style="zoom:75%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：ADC-电压测量</span></span><br><span class="line"><span class="string">说明：通过对ADC数据采集，转化成电压在显示屏上显示。ADC精度13位（0~8191），默认电压0-1V。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin,SoftI2C,ADC,Timer</span><br><span class="line"><span class="keyword">from</span> ssd1306 <span class="keyword">import</span> SSD1306_I2C</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化相关模块</span></span><br><span class="line">i2c = SoftI2C(sda=Pin(<span class="number">40</span>), scl=Pin(<span class="number">38</span>))  <span class="comment">#I2C初始化：sda--&gt;40, scl --&gt;38</span></span><br><span class="line">oled = SSD1306_I2C(<span class="number">128</span>, <span class="number">64</span>, i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line">adc = ADC(Pin(<span class="number">6</span>)) <span class="comment">#6引脚跟pyBase的电位器相连接</span></span><br><span class="line">adc.atten(ADC.ATTN_11DB) <span class="comment">#开启衰减，测量量程增大到3.3V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ADC_Test</span>(<span class="params">tim</span>):</span><br><span class="line"></span><br><span class="line">    oled.fill(<span class="number">0</span>)  <span class="comment"># 清屏显示黑色背景</span></span><br><span class="line">    oled.text(<span class="string">&#x27;01Studio&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 首行显示01Studio</span></span><br><span class="line">    oled.text(<span class="string">&#x27;ADC&#x27;</span>, <span class="number">0</span>, <span class="number">15</span>)      <span class="comment"># 次行显示实验名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取ADC数值</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(adc.read()),<span class="number">0</span>,<span class="number">40</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;(8191)&#x27;</span>,<span class="number">60</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算电压值，获得的数据0-4095相当于0-1V，（&#x27;%.2f&#x27;%）表示保留2位小数</span></span><br><span class="line">    oled.text(<span class="built_in">str</span>(<span class="string">&#x27;%.2f&#x27;</span>%(adc.read()/<span class="number">8191</span>*<span class="number">3.3</span>)),<span class="number">0</span>,<span class="number">55</span>)</span><br><span class="line">    oled.text(<span class="string">&#x27;V&#x27;</span>,<span class="number">40</span>,<span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">    oled.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启定时器</span></span><br><span class="line">tim = Timer(<span class="number">1</span>)</span><br><span class="line">tim.init(period=<span class="number">300</span>, mode=Timer.PERIODIC, callback=ADC_Test) <span class="comment">#周期300ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>总结：</strong></p><p>这一节我们学习了 ADC 的应用，主要用于电压的检测。有兴趣的用户可以尝试使用其衰减器测试，可以扩充电压量程，但精度会有所下降。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM（无源蜂鸣器）"><a href="#PWM（无源蜂鸣器）" class="headerlink" title="PWM（无源蜂鸣器）"></a><strong>PWM</strong>（无源蜂鸣器）</h3><p>⚫ <strong>前言：</strong></p><p>上一节的 ADC 是信号输入，这节的 PWM 就是一个信号输出。PWM（脉冲宽度调制），主要用于输出不同频率、占空比（一个周期内高电平出现时间占总时间比例）的方波。以实现固定频率或平均电压输出。</p><p>⚫ <strong>实验目的：</strong></p><p>通过不同频率的 PWM 信号输出，驱动无源蜂鸣器发出不同频率的声音。</p><p>⚫ <strong>实验讲解：</strong></p><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyWiFi-ESP32-S2 的 PWM 输出频率是在变化的。pyBase 开发底板上的无源蜂鸣器连接到 pyBase 引脚 X5。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702110722346.png" alt="image-20230702110722346" style="zoom:50%;"></p><p>从 pyWiFi-ESP32-S2 原理图可以看到由底板蜂鸣器 X5 连接到 ESP32-S2 的引脚 4。</p><p><img src="/posts/7fbb683d.htm/image-20230702110739134.png" alt="image-20230702110739134" style="zoom:50%;"></p><p>PWM 可以通过 ESP32-S2 所有 GPIO 引脚输出. 所有通道都有 1 个特定的频率，从 0 到 40M 之间（单位是 Hz）。占空比的值为 0 至 1023 之间。在本实验中我们用到引脚 4。</p><p>先看看 PWM 模块对象：</p><p><strong>构造函数</strong></p><p>pwm=machine.PWM(machine.Pin(id),freq,duty)</p><p>构建 PWM 对象。id:引脚编号；freq:频率值；duty:占空比；配置完后 PWM 自</p><p>动生效。</p><p><strong>使用方法</strong></p><p>pwm.freq(freq)</p><p>设置频率。freq:频率值在 1-1000 之间，freq 为空时表示获取当前频率值。</p><p>pwm.duty(duty)</p><p>设置占空比。duty:占空比在 0-1023 之间，duty 为空时表示获取当前占空比值。</p><p>pwm.deinit()</p><p>关闭 PWM。</p><p>无源蜂鸣器我们可以用特定频率的方波来驱动，方波的原理很简单，就是一定频率的高低电平转换，可以简单理解成占空比为 50%的 PWM 输出。</p><p>结合上述讲解，总结出代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：PWM</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2021.8</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">说明：通过不同频率的PWM信号输出，驱动无源蜂鸣器发出不同频率的声音。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin, PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">Beep = PWM(Pin(<span class="number">4</span>), freq=<span class="number">0</span>, duty=<span class="number">512</span>) <span class="comment"># 在同一语句下创建和配置PWM,占空比50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率200Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">200</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率400Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">400</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率600Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">600</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率800Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">800</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#蜂鸣器发出频率1000Hz响声</span></span><br><span class="line">Beep.freq(<span class="number">1000</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">Beep.deinit()</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART</strong>（串口通信）</h3><p>⚫ <strong>前言：</strong></p><p>串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>⚫ <strong>实验讲解：</strong></p><p>pyWiFi-ESP32-S2 开发板一共有 2 个串口，编号是 0-1，如下表：</p><div class="table-container"><table><thead><tr><th>UART(0)</th><th>TX</th><th>43</th></tr></thead><tbody><tr><td></td><td>RT</td><td>44</td></tr><tr><td>UART(1)</td><td>TX</td><td>任意映射IO</td></tr><tr><td></td><td>RX</td><td>任意映射IO</td></tr></tbody></table></div><p>由于 UART0 用于下载和 REPL 调试，因此我们使用 UART1 来进行本节实验。</p><p>我们先来了解一下串口对象的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>uart=machine.UART(id,baudrate,tx=None,rx=None bits=8, parity=None, stop=1,…)</p><p>创建 UART 对象。</p><p>【id】0-1</p><p>【baudrate】波特率，常用 115200、9600</p><p>【tx】自定义 IO</p><p>【rx】自定义 IO</p><p>【bits】数据位</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>…</p><p>特别说明： ESP32-S2 的 UART 引脚映射到其它 IO 来使用，用户可以通过构造</p><p>函数时候指定如 tx=8,rx=9 的方式来改变串口引脚，实现更灵活的应用。</p><p><strong>使用方法</strong></p><p>uart.deinit()</p><p>关闭串口</p><p>uart.any()</p><p>返回等待读取的字节数据，0 表示没有</p><p>uart.read([<em>nbytes</em>])</p><p>【nbytes】读取字节数</p><p>UART.readline()</p><p>读行</p><p>UART.write(<em>buf</em>)</p><p>【buf】串口 TX 写数据</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p><img src="/posts/7fbb683d.htm/image-20230702111650095.png" alt="image-20230702111650095" style="zoom:50%;"></p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用串口 2，也就是 8（TX）和 9（RX），接线示意图如下：</p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：串口通信</span></span><br><span class="line"><span class="string">说明：通过编程实现串口通信，跟电脑串口助手实现数据收发。</span></span><br><span class="line"><span class="string">平台：pyWiFi-ESP32</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入串口模块</span></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART</span><br><span class="line"></span><br><span class="line">uart=UART(<span class="number">1</span>,<span class="number">115200</span>,rx=<span class="number">9</span>,tx=<span class="number">8</span>) <span class="comment">#设置串口号1和波特率</span></span><br><span class="line"></span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)<span class="comment">#发送一条数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断有无收到信息</span></span><br><span class="line">    <span class="keyword">if</span> uart.<span class="built_in">any</span>():</span><br><span class="line"></span><br><span class="line">        text=uart.read(<span class="number">128</span>) <span class="comment">#接收128个字符</span></span><br><span class="line">        <span class="built_in">print</span>(text) <span class="comment">#通过REPL打印串口3接收的数据</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>我们按照上述方式将 USB 转 TTL 的 TX 接到开发板的 RX（</p><p>9），USB 转 TTL 的</p><p>RX 接到开发板的 TX（</p><p>8）。GND 接一起，3.3V 可以选择接或不接。</p><p>根据上图设备管理器里面的信息，将串口工具配置成 COM14，REPL 串口配置成 COM27（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到开发板上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到 pyWiFi-ESP32-S2 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p><img src="/posts/7fbb683d.htm/image-20230702111909798.png" alt="image-20230702111909798" style="zoom:67%;"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="LCD-显示屏"><a href="#LCD-显示屏" class="headerlink" title="LCD 显示屏"></a><strong>LCD</strong> <strong>显示屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>前面用到的 OLED 显示屏虽然能显示信息，但是颜色只有黑白，而且分辨率也比较低 128x64，本节我们来学习 3.2 寸 TFT_LCD 彩色显示屏的使用方法。</p><p>⚫ <strong>实验目的：</strong></p><p>通过 MicorPython 编程方式实现 LCD 的各种显示功能，包括画点、线、矩形、圆形、显示英文、显示图片等</p><p>&nbsp;</p><p>实验用的 LCD 是 3.2 寸，驱动是的 ILI9341，使用 SPI 方式跟 ESP32-S2 通信，按以往嵌入式 C 语言开发，我们需要对 ILI9341 进行编程实现驱动，然后再建立各种描点、划线、以及显示图片函数。</p><p>使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点我们只需要搞清各个对象函数使如何使用即可。总的来说和前面实验一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉开发板该外设是怎么接线，初始化参数如何，而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！</p><p>我们管这些函数的集合叫<strong>驱动</strong>，驱动可以是预先在固件里面，也可以通过.py文件存放在开发板文件系统。也就是说工程师已经将复杂的底层代码封装好，我们顶层直接使用 python 开发即可，人生苦短。我们来看看 pyWiFi-ESP32-S2P 开发板 3.2 寸 LCD 的构造函数和使用方法</p><p>&nbsp;</p><p><strong>构造函数</strong></p><p>tftlcd.LCD32(portrait=1)</p><p>构建 3.2 寸 LCD 对象。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p>LCD32.fill(color)</p><p>【color】RGB 颜色数据；如(255,0,0)表示红色。</p><p>LCD32.drawPixel(x,y,color)</p><p>画点。</p><p>【x】:横坐标，</p><p>【y】:纵坐标，</p><p>【color】:颜色。</p><p>LCD32.drawLine(x0,y0,x1,y1,color)</p><p>画线段。</p><p>【x0,y0】:起始坐标，</p><p>【x1,y1】:终点坐标，</p><p>【color】:颜色</p><p>LCD32.drawRect(x,y,width,height,color,border=1,fillcolor=None)</p><p>画矩形。</p><p>【</p><p>x,y】:起始坐标，</p><p>【width】:宽度，</p><p>【height】:高度，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.drawCircle(x,y,radius,color,border=1,fillcolor=None)</p><p>画圆。</p><p>【x, y】:圆心，</p><p>【radius】:半径，</p><p>【color】:颜色，</p><p>【border】:边宽，</p><p>【fillcolor】:填充颜色，默认 None 为不填充</p><p>LCD32.printStr(text,x,y,color,backcolor=None,size=2)</p><p>写字符。</p><p>【text】:字符，</p><p>【x,y】:起始坐标,</p><p>【color】:字体颜色；</p><p>【backcolor】:字体背景颜色；</p><p>【size】:字体尺寸（1-小号，2-标准，3-中号，4-大号）</p><p>LCD32.Picture(x,y,filename)</p><p>显示图片。支持图片格式类型：jpg、bmp</p><p>【x,y】:起始坐标。</p><p>【filename】: 图片路径+名称，如：”/cat.jpg”</p><p><strong>（‘</strong>/<strong>’表示开发板的板载</strong> <strong>flash</strong> <strong>的根目录。）</strong></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们在使用中将以上功能都跑一遍先看看编程流程图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：3.2寸LCD液晶显示屏</span></span><br><span class="line"><span class="string">说明：通过编程实现LCD的各种显示功能，包括填充、画点、线、矩形、圆形、显示英文、显示图片等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入相关模块</span></span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义常用颜色</span></span><br><span class="line">RED = (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">GREEN = (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">BLUE = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line"><span class="comment"># 构建3.2寸LCD对象并初始化</span></span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认方向竖屏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填充白色</span></span><br><span class="line">d.fill(WHITE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画点</span></span><br><span class="line">d.drawPixel(<span class="number">5</span>, <span class="number">5</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画线段</span></span><br><span class="line">d.drawLine(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, RED)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#画矩形</span></span><br><span class="line">d.drawRect(<span class="number">5</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">40</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画圆</span></span><br><span class="line">d.drawCircle(<span class="number">100</span>, <span class="number">120</span>, <span class="number">30</span>, RED, border=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写字符,4种尺寸</span></span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">200</span>, RED, size=<span class="number">1</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">230</span>, GREEN, size=<span class="number">2</span>)</span><br><span class="line">d.printStr(<span class="string">&#x27;Hello 01Studio&#x27;</span>, <span class="number">10</span>, <span class="number">270</span>, BLUE, size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>) <span class="comment">#等待5秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#显示图片</span></span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/1.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/2.jpg&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">d.Picture(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/picture/01studio.jpg&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>将示例程序的素材文件上传到 pyWiFi-ESP32-S2P 开发板。<strong>（也可以只上传单</strong>张图片，注意修改代码中文件的路径即可。）</p><p>&nbsp;</p><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>⚫ <strong>前言：</strong></p><p>上一节我们学习了 LCD 实验，但 LCD 只能显示相关内容，跟人是缺乏交互的。好比我们的智能手机，如果只有显示不能触碰，那么就没有可玩性了。因此本节学习一下 3.2 寸 LCD 的电阻触摸屏使用方法。</p><p>⚫ <strong>实验讲解：</strong></p><p>01Studio 配套的 3.2 寸 LCD 上带电阻触摸屏,驱动芯片为 XPT2046。当手指按下时候，通过简单的编程即可返回一个坐标，我们来看看其 micropython 构造函数和使用方法：</p><p><strong>构造函数</strong></p><p><strong>touch.XPT2046(portrait=1)</strong></p><p>构建触摸屏对象。<strong>XPT2046</strong> 表示驱动芯片型号。</p><p>【portrait】 设置屏幕方向：</p><p>⚫ 1 - 竖屏，240*320 ，默认</p><p>⚫ 2 - 横屏，320*240 ，1 基础上顺时针旋转 90° </p><p>⚫ 3 - 竖屏，240*320 ，1 基础上顺时针旋转 180° </p><p>⚫ 4 - 横屏，320*240 ，1 基础上顺时针旋转 270°</p><p><strong>使用方法</strong></p><p><strong>XPT2046.tick_inc()</strong></p><p>手动刷新触摸。</p><p><strong>XPT2046.read()</strong></p><p>读取触摸屏数据，返回（states,x,y）</p><p>【states】-当前触摸状态：0：按下；1：移动；2：松开。</p><p>【x】:触摸横坐标</p><p>【y】:触摸纵坐标</p><p>&nbsp;</p><p>学会了触摸对象用法后，我们可以编程实现触摸后屏幕打点表示，然后左上角显示当前触摸的坐标。另外再加入一个按键，按下清空屏幕。编程流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：电阻触摸屏</span></span><br><span class="line"><span class="string">说明：电阻触摸屏采集触摸信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> touch <span class="keyword">import</span> XPT2046</span><br><span class="line"><span class="keyword">from</span> tftlcd <span class="keyword">import</span> LCD32</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义颜色</span></span><br><span class="line">BLACK = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">WHITE = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line">RED=(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">d = LCD32(portrait=<span class="number">1</span>) <span class="comment">#默认竖屏</span></span><br><span class="line">d.fill(WHITE) <span class="comment">#填充白色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#电阻触摸屏初始化，方向和LCD一致</span></span><br><span class="line">t = XPT2046(portrait=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line">    </span><br><span class="line">    d.fill(WHITE) <span class="comment">#清屏</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#USR按键初始化</span></span><br><span class="line">KEY=Pin(<span class="number">0</span>,Pin.IN,Pin.PULL_UP) <span class="comment">#构建KEY对象</span></span><br><span class="line">KEY.irq(fun,Pin.IRQ_FALLING) <span class="comment">#定义中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    data = t.read() <span class="comment">#获取触摸屏坐标</span></span><br><span class="line">    <span class="built_in">print</span>(data) <span class="comment">#REPL打印</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#当产生触摸时</span></span><br><span class="line">    <span class="keyword">if</span> data[<span class="number">0</span>]!=<span class="number">2</span>: <span class="comment">#0：按下； 1：移动； 2：松开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#触摸坐标画圆</span></span><br><span class="line">        d.drawCircle(data[<span class="number">1</span>], data[<span class="number">2</span>], <span class="number">5</span>, BLACK, fillcolor=BLACK)</span><br><span class="line">        d.printStr(<span class="string">&#x27;(X:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">1</span>])+<span class="string">&#x27; Y:&#x27;</span>+<span class="built_in">str</span>(<span class="string">&#x27;%03d&#x27;</span>%data[<span class="number">2</span>])+<span class="string">&#x27;)&#x27;</span>,<span class="number">10</span>,<span class="number">10</span>,RED,size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep_ms(<span class="number">20</span>) <span class="comment">#触摸响应间隔</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⚫ <strong>实验结果：</strong></p><p>运行程序，首次运行会自动提示进行触摸校准（电阻屏需要校准），按提示分别点击四个角落进行校准，如校准失败会自动重复。校准成功会自动保存一个“touch.cail”文件到开发板 flash，下次无须再校准。</p><p>成功后出现空白画面，用手指触摸屏幕或者在屏幕上滑动，可以看到描点并在 LCD 左上角显示当前坐标。</p><p>重启开发板，可以看到文件系统多了一个“touch.cail”，在运行电阻屏初始化时候会检测这个文件，如果存在则不进行校准，若想重新校准的用户可以把这个文件删除即可！</p><p>⚫ <strong>总结：</strong></p><p>没有触摸屏的 LCD 就失去了灵魂，有了触摸屏，跟开发板的交互就变得有意思了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32</title>
      <link href="/posts/86375cb2.html"/>
      <url>/posts/86375cb2.html</url>
      
        <content type="html"><![CDATA[<h1 id="esp32"><a href="#esp32" class="headerlink" title="esp32"></a>esp32</h1><h2 id="ESP32-S2-平台"><a href="#ESP32-S2-平台" class="headerlink" title="ESP32-S2 平台"></a><strong>ESP32-S2</strong> <strong>平台</strong></h2><h3 id="pyWiFi-ESP32-S2"><a href="#pyWiFi-ESP32-S2" class="headerlink" title="pyWiFi-ESP32-S2"></a><strong>pyWiFi-ESP32-S2</strong></h3><p>pyWiFi-ESP32-S2 是由 01Studio 设计研发，基于 ESP32-S2 平台的 MicroPython</p><p>开发板，主要特点如下：</p><p> 自动下载电路</p><p> 板载锂电池输入接口和充电电路</p><p> 标准 24P 摄像头接口</p><p> USB OTG 接口</p><p> 全 IO 引出</p><p> 按键和 LED 排列整齐，丝印清晰</p><p> 兼容 pyBoard 接口</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701220231747.png" class title="image-20230701220231747"><img src="/posts/86375cb2.htm/86375cb2/image-20230701220244595.png" class title="image-20230701220244595"><h3 id="开发环境快速建立"><a href="#开发环境快速建立" class="headerlink" title="开发环境快速建立"></a><strong>开发环境快速建立</strong></h3><p>ESP32-S2 是基于是继 ESP32 普遍板后推出的一个版本，主要特点是引脚数量非常多。还支持标准 USB HOST。</p><h4 id="安装开发软件-Thonny"><a href="#安装开发软件-Thonny" class="headerlink" title="安装开发软件 Thonny"></a><strong>安装开发软件</strong> <strong>Thonny</strong></h4><p>Thonny Python IDE 是一款开源软件，以极简方式设计，对 MicroPython 的兼容性非常友善。而且支持 Windows、Mac OS、Linux、树莓派。由于开源，所以软</p><p>件迭代速度非常快，功能日趋成熟。具体安装方法如下：在 <a href="https://thonny.org/">https://thonny.org/</a> 下载最新版，选择自己的开发平台进行下载安装即可(这里选择 Windows！)：</p><p>&nbsp;</p><h3 id="REPL-串口交互调试"><a href="#REPL-串口交互调试" class="headerlink" title="REPL 串口交互调试"></a><strong>REPL</strong> <strong>串口交互调试</strong></h3><p>yWiFi-ESP32-S2 的 MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试开发板。我们打开 Thonny，将开发板连接到电脑。点击右下角：</p><p><img src="/posts/86375cb2.htm/image-20230701221427314.png" alt="image-20230701221427314" style="zoom:50%;"></p><p>在弹出的列表选择：<strong>Configure interpreter</strong></p><img src="/posts/86375cb2.htm/86375cb2/image-20230701221436676.png" class title="image-20230701221436676"><p>选择“MicroPython（ESP32）”和开发板对应的串口号，点击确认。</p><p><img src="/posts/86375cb2.htm/image-20230701221656057.png" alt="image-20230701221656057" style="zoom:50%;"></p><p>连接成功后可以在 shell（串口终端）看到固件的相关信息：</p><p><img src="/posts/86375cb2.htm/image-20230701221713389.png" alt="image-20230701221713389" style="zoom:50%;"></p><p>我们在 Shell 里面输入 print(“Hello 01Studio!”) , 按回车，可以看到打印出Hello 01Studio 字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">LED = Pin(<span class="number">2</span>, Pin.OUT) </span><br><span class="line">LED.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/posts/86375cb2.htm/image-20230701221806760.png" alt="image-20230701221806760" style="zoom:50%;"></p><p>接下来我们将上一节的三行代码逐行输入和逐行按回车，可以看到 LED 灯也被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701222057224.png" alt="image-20230701222057224" style="zoom:50%;"></p><p>REPL 还有一个强大的功能就是打印错误的代码来调试程序，在后面代码运行时候，如果程序出错，出错信息将通过 REPL 打印。</p><p><img src="/posts/86375cb2.htm/image-20230701222115947.png" alt="image-20230701222115947" style="zoom:50%;"></p><p><strong>REPL</strong> <strong>终端常用键盘按键：</strong></p><p>Ctrl + C : 打断正在运行的程序（特别是含 While True: 的代码）；</p><p>Ctrl + D : 软件复位开发板</p><p>&nbsp;</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p>pyWiFi-ESP32-S2 里面内置了文件系统，可以简单理解成上电后运行的 python文件，这个可以通过 Thonny 非常方便地读写。</p><p>点击 <strong>视图</strong>—<strong>文件</strong> ：</p><p><img src="/posts/86375cb2.htm/image-20230701222203009.png" style="zoom:50%;"></p><p>可以看到左边出现本地和开发板的实时文件浏览窗口：</p><p><img src="/posts/86375cb2.htm/image-20230701222237796.png" alt="image-20230701222237796" style="zoom:50%;"></p><p>在本地文件点击右键—上传到即可将相关文件发送到开发板，也可以将开发板上的文件发送到本地，非常方便。</p><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a><strong>代码测试</strong></h3><p>前面已经安装好了 Thonny IDE 和配置，接下来使用最简单的方式来做一个点亮 LED 蓝灯的实验。具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：点亮LED蓝灯</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin <span class="comment">#导入Pin模块</span></span><br><span class="line"></span><br><span class="line">led=Pin(<span class="number">2</span>,Pin.OUT) <span class="comment">#构建led对象，GPIO2,输出</span></span><br><span class="line">led.value(<span class="number">1</span>) <span class="comment">#点亮LED，也可以使用led.on()</span></span><br></pre></td></tr></table></figure><p>运行功能代码是保存在开发板的 RAM（内存）里面，断电后丢失，那么如何实现开发板上电运行我们的代码呢？方法如下：</p><p>Micropython 上电默认先运行名字为 boot.py 文件，然后在运行 main.py 文件，如果没有 boot.py 那么直接运行 main.py。</p><p><strong>boot.py:</strong> <strong>一般用于配置初始化参数；</strong></p><p><strong>main.py**</strong>：主程序**</p><p>也就是我们只需要将代码以 main.py 文件发送到开发板，那么开发板就可以实现上电运行相关程序。</p><p>我们将 LED 例程的 main.py 发送到开发板</p><p><img src="/posts/86375cb2.htm/image-20230701222956537.png" alt="image-20230701222956537" style="zoom:50%;"></p><p>按下开发板的复位键，可以看到 LED 蓝灯被点亮：</p><p><img src="/posts/86375cb2.htm/image-20230701223032307.png" alt="image-20230701223032307" style="zoom:50%;"></p><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>固件更新是指重新烧写开发板的出厂文件或者是升级的固件，使用上海乐鑫提供的官方软件烧录：</p><p><img src="/posts/86375cb2.htm/image-20230701223127927.png" alt="image-20230701223127927" style="zoom:50%;"></p><p>芯片这里选择 ESP32-S2，develop 开发者模式，然后点击 OK :</p><p><img src="/posts/86375cb2.htm/image-20230701223146766.png" alt="image-20230701223146766" style="zoom:50%;"></p><p>选择 SPIDownload，在下图箭头位置点击，选择要烧录固件。</p><p>其它配置选项也请参考下图，注意下载地址是 <strong>0x1000</strong>。（COM 串口是选择自己的串口，在设备管理器查询。）</p><p><img src="/posts/86375cb2.htm/image-20230701223234252.png" alt="image-20230701223234252" style="zoom:50%;"></p><p>配置好后，先点击“ERASE”按钮刷除模块里面内容。点击软件下方“ERASE”按钮，刷除成功后，左边绿色框出现完成字样</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223253705.png" class title="image-20230701223253705"><p>刷除成功后，点击“START”按钮开始烧录，烧录完成有左边绿色框出现“完成”字样。完成后记得点”stop”按钮或者关闭软件释放串口。</p><img src="/posts/86375cb2.htm/86375cb2/image-20230701223316527.png" class title="image-20230701223316527">]]></content>
      
      
      
        <tags>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k210项目</title>
      <link href="/posts/384e6f73.html"/>
      <url>/posts/384e6f73.html</url>
      
        <content type="html"><![CDATA[<h2 id="照相机"><a href="#照相机" class="headerlink" title="照相机"></a>照相机</h2><p>本项目主要是按键应用和拍照的相结合，这些内容可以在前面的实验找到，这里不再重复</p><p>外部中断按键实验：请参阅 <strong>4.4</strong> <strong>外部中断</strong> 章节内容；</p><p>拍摄照片实验：请参阅 <strong>5.9</strong> <strong>图片拍摄</strong> 章节内容。</p><p>拍照后我们应该让图片停留一段时间，让用户观察照片的拍摄情况，然后再进行继续拍摄。代码编写流程如下：</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, utime</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 KEY 的外部 IO</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建 KEY 对象</span></span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment"># Initialize the camera sensor.</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># or sensor.GRAYSCALE</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># or sensor.QVGA (or others)</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>) <span class="comment"># Let new settings take affect.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #摄像头后置模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line">key_node = <span class="number">0</span> <span class="comment">#按键标志位</span></span><br><span class="line">name_num = <span class="number">0</span> <span class="comment">#照片名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 按键和其回调函数</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"></span><br><span class="line"> <span class="keyword">global</span> key_node</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line">  key_node = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line"></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> lcd.display(sensor.snapshot()) <span class="comment"># LCD 实时显示</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> key_node==<span class="number">1</span>: <span class="comment">#按键被按下</span></span><br><span class="line">  key_node = <span class="number">0</span> <span class="comment">#清空按键标志位</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#拍照并保存，保存文件用时间来命名。</span></span><br><span class="line">  lcd.display(sensor.snapshot().save(<span class="built_in">str</span>(name_num)+<span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line">  name_num=name_num+<span class="number">1</span> <span class="comment">#名字编码加 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Done! Reset the camera to see the saved image.&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#延时 3 秒，观看拍摄图片</span></span><br><span class="line"></span><br><span class="line">  utime.sleep_ms(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a><strong>视频播放器</strong></h2><p>音视频解码是一个复杂的过程，但 K210 底层 MicroPython 库写好后，着重应用来编程就变得非常简单了。和以往一样，我们只需要熟悉模块用法即可。</p><p>本实验实验 01Studio 音频模块，基于 PAM8403 的一款 D 类功放 IC，和麦克风一样使用 I2S 接口通信，这里不再重复 I2S 内容。</p><p>而视频播放被封装成 video 模块，在前面视频录制章节内容已经介绍过，这里重温一下，模块说明如下</p><p>&nbsp;</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：视频播放器</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">翻译和注释：01Studio</span></span><br><span class="line"><span class="string">说明：AVI视频播放。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> video,time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">    audio_en=GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频控制IO</span></span><br><span class="line">fm.register(<span class="number">34</span>,  fm.fpioa.I2S0_OUT_D1, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">35</span>,  fm.fpioa.I2S0_SCLK, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">33</span>,  fm.fpioa.I2S0_WS, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#播放avi文件</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/badapple.avi&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印视频文件信息</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">#音量调节</span></span><br><span class="line">v.volume(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> v.play() == <span class="number">0</span>: <span class="comment">#播放完毕</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;play end&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">v.__del__() <span class="comment">#销毁对象，释放内存</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本实验播放的视频是 badapple.avi，文件在本例程文件夹中，先将该文件拷贝到 sd 卡。然后将 sd 卡插到 pyAI-K210。</p><p>接上 01Studio 音频模块，运行本实验程序代码，可以见到串口终端打印了avi 视频信息后，开发板便开始播放视频。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="NES-游戏机"><a href="#NES-游戏机" class="headerlink" title="NES 游戏机"></a><strong>NES</strong> <strong>游戏机</strong></h2><p>MaixPy 集成了 NES 的 MicroPython 模块,用户通过几行代码就可以实现游戏的加载，已经使用键盘或者标准游戏手柄来操控。NES 对象如下：</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nes</span><br></pre></td></tr></table></figure><p>导入 nes 模块；</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=<span class="number">16</span>,vol=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>初始化 nes 游戏模拟器；</p><p>【rc_type】遥控类型。nes.KEYBOARD:REPL 中使用键盘；nes.JOYSTICK:PS2 手柄。</p><p>【cs,mosi,miso,clk】使用 PS2 手柄时的引脚配置；</p><p>【repeat】键盘按键重复率；</p><p>【vol】音量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nes.run(xx.nes)</span><br></pre></td></tr></table></figure><p>运行 nes 文件。</p><p>*更多使用说明请阅读官方文档：</p><p>&nbsp;</p><p>键盘和手柄的快捷键如下：</p><h4 id="键盘（串口）"><a href="#键盘（串口）" class="headerlink" title="键盘（串口）"></a>键盘（串口）</h4><p>【移动】：WSAD(上下左右)</p><p>【A】：J</p><p>【B】：K</p><p>【start】：M 或 Enter</p><p>【option】：N 或\</p><p>【退出】：ESC</p><p>【音量-】：-</p><p>【音量+】：=</p><p>【运行速度-】：R</p><p>【运行速度+】：F</p><h4 id="PS2-手柄"><a href="#PS2-手柄" class="headerlink" title="PS2 手柄"></a>PS2 手柄</h4><p>【移动】：方向键(上下左右)</p><p>【A】：口</p><p>【B】：X</p><p>【start】：START</p><p>【option】：SELECT</p><p>【退出】：暂无</p><p>【音量-】：R2</p><p>【音量+】：R1</p><p>【运行速度-】：L1</p><p>【运行速度+】：L2</p><p>从上表 NES 对象看到，只需要简单的初始化和运行语句，即可运行 NES 游戏模拟器，编程思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> nes, lcd</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频使能IO</span></span><br><span class="line">AUDIO_PA_EN_PIN = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册音频使能IO</span></span><br><span class="line"><span class="keyword">if</span> AUDIO_PA_EN_PIN:</span><br><span class="line">    fm.register(AUDIO_PA_EN_PIN, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化nes，配置为键盘控制</span></span><br><span class="line">nes.init(nes.KEYBOARD)</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行游戏</span></span><br><span class="line">nes.run(<span class="string">&quot;/sd/Bomberman.nes&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k210拓展模块</title>
      <link href="/posts/a4696bae.html"/>
      <url>/posts/a4696bae.html</url>
      
        <content type="html"><![CDATA[<h2 id="拓展模块"><a href="#拓展模块" class="headerlink" title="拓展模块"></a><strong>拓展模块</strong></h2><h3 id="电阻触摸屏"><a href="#电阻触摸屏" class="headerlink" title="电阻触摸屏"></a><strong>电阻触摸屏</strong></h3><p>本实验 LCD 触摸屏上使用 NS2009 芯片，将电阻触摸屏信号转化为 I2C 信号跟 K210 通信，而 MaixPy 已经集成了触摸屏应用的相关函数模块，具体介绍如下：</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br></pre></td></tr></table></figure><p>导入 touchscreen 模块;</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.init(i2c=<span class="literal">None</span>,cal=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>初始化触摸屏。</p><p>【i2c】I2C 总线；</p><p>【cal】一个 7 个整型值的元组，触摸校准数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.calibrate()</span><br></pre></td></tr></table></figure><p>触摸校准。返回一个 7 个整型值的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts.read()</span><br></pre></td></tr></table></figure><p>读取屏幕状态和坐标信息。返回（status,x,y）</p><p>【status】: 触摸状态，取值有如下</p><p>touchscreen.STATUS_RELEASE,值为 1，触摸屏没动作；</p><p>touchscreen.STATUS_PRESS,值为 2，触摸屏被按下；</p><p>touchscreen.STATUS_MOVE,值为 3，触摸屏在滑动；</p><p>【x】x 轴坐标</p><p>【y】y 轴坐标</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">import</span> lcd, image</span><br><span class="line"><span class="keyword">import</span> touchscreen <span class="keyword">as</span> ts</span><br><span class="line"></span><br><span class="line"><span class="comment">#按键 KEY 用于清屏</span></span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1, force=<span class="literal">True</span>)</span><br><span class="line">btn_clear = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸使用 I2C 控制（NS2009）</span></span><br><span class="line">i2c = I2C(I2C.I2C0, freq=<span class="number">400000</span>, scl=<span class="number">30</span>, sda=<span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触摸屏初始化</span></span><br><span class="line">ts.init(i2c)</span><br><span class="line"><span class="comment">#ts.calibrate() #触摸校准</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">lcd.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建图像和触摸屏相关参数变量</span></span><br><span class="line">img = image.Image()</span><br><span class="line">status_last = ts.STATUS_IDLE</span><br><span class="line">x_last = <span class="number">0</span></span><br><span class="line">y_last = <span class="number">0</span></span><br><span class="line">draw = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#获取触摸屏状态</span></span><br><span class="line"> (status,x,y) = ts.read()</span><br><span class="line"> <span class="built_in">print</span>(status, x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line"> <span class="keyword">if</span> draw:</span><br><span class="line">  img.draw_line((x_last, y_last, x, y))</span><br><span class="line"></span><br><span class="line"> <span class="comment">#更新最后坐标</span></span><br><span class="line"> x_last = x</span><br><span class="line"> y_last = y</span><br><span class="line"></span><br><span class="line"> <span class="comment">#根据触摸屏状态判断是否继续执行画图功能</span></span><br><span class="line"> <span class="keyword">if</span> status_last!=status:</span><br><span class="line">  <span class="keyword">if</span> (status==ts.STATUS_PRESS <span class="keyword">or</span> status == ts.STATUS_MOVE):</span><br><span class="line">   draw = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>: <span class="comment">#松开</span></span><br><span class="line">   draw = <span class="literal">False</span></span><br><span class="line">  status_last = status</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">#按键 KEY 按下清屏</span></span><br><span class="line"> <span class="keyword">if</span> btn_clear.value() == <span class="number">0</span>:</span><br><span class="line">  img.clear()</span><br></pre></td></tr></table></figure><p>固件用如下所示固件，其中含有touchscreen库</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a><strong>舵机</strong></h3><p>伺服电机对象通过 3 线（信号，电源，地）控制，pyBase 上有 4 个位置可以插这些电机，分别是 X1-X4 引脚。对应 pyAI-K210 的 17、35、34、33 脚。</p><p>180°舵机的控制一般需要一个 20ms 左右的时基脉冲，该脉冲的高电平部分一般为 0.5ms-2.5ms 范围内的角度控制脉冲部分，总间隔为 2ms。以 180 度角度伺服为例，在 MicroPython 编程对应的控制关系是从-90°至 90°，示例图如下</p><p>而对于 360°连续旋转舵机，上面的脉冲表则对应从正向最大速度旋转到反向最大速度旋转的过程。</p><p>如果过你学习过前面基于 STM32 平台的舵机实验，那就知道在 STM32 平台集成了舵机模块，使用起来非常方便。当前的 ESP32 平台并没有集成 Servo 模块，但从上面可以看到上面是通过 PWM 来控制的，我们可以直接写 PWM 函数驱动即可。代码编程流程图如下：</p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO17 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">S1 = PWM(tim, freq=<span class="number">50</span>, duty=<span class="number">0</span>, pin=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">说明：舵机控制函数</span></span><br><span class="line"><span class="string">功能：180 度舵机：angle:-90 至 90 表示相应的角度</span></span><br><span class="line"><span class="string"> 360 连续旋转度舵机：angle:-90 至 90 旋转方向和速度值。</span></span><br><span class="line"><span class="string"> 【duty】占空比值：0-100</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Servo</span>(<span class="params">servo,angle</span>):</span><br><span class="line"> S1.duty((angle+<span class="number">90</span>)/<span class="number">180</span>*<span class="number">10</span>+<span class="number">2.5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"> <span class="comment">#-90 度</span></span><br><span class="line"> Servo(S1,-<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#-45 度</span></span><br><span class="line"> Servo(S1,-<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#0 度</span></span><br><span class="line"> Servo(S1,<span class="number">0</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#45 度</span></span><br><span class="line"> Servo(S1,<span class="number">45</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#90 度</span></span><br><span class="line"> Servo(S1,<span class="number">90</span>)</span><br><span class="line"> time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>将 180°舵机插到 pyBase 的 X1 的三线接口，运行程序。可以看到舵机依次旋转至不同角度。</p><p>⚫ <strong>实验拓展：</strong></p><p>我们刚刚实现了 180°舵机的角度控制，现在来做一下 360°连续旋转舵机的实验，360°连续旋转舵机可以实现直流减速电机功能，用在小车或者航模上。</p><p>实验的代码不变，参数【-90 至 90】代表旋转方向和速度值大小。插上 360°连续旋转舵机。可以看到舵机的旋转速度和方向逐渐变变化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器听觉</title>
      <link href="/posts/e06f755d.html"/>
      <url>/posts/e06f755d.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k210机器视觉</title>
      <link href="/posts/210a3ee2.html"/>
      <url>/posts/210a3ee2.html</url>
      
        <content type="html"><![CDATA[<h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a><strong>LCD</strong></h3><p>LCD 液晶显示屏是非常常见的一个外接显示设备，跟前面的 OLED 显示屏相比，LCD 会更常用一些，我们看到的手持设备、小型电器，很多都用到 LCD，部分配合触摸屏应用，能实现非常多的功能。</p><p>除此之外，LCD 还是 pyAI-K210 机器视觉应用中显示的重要工具。</p><p>本实验用的 LCD 是 2.8 寸，驱动是常见的 ST7789V，使用 8 位接口跟 pyAIK210 通信，按以往嵌入式 C 语言开发，我们需要对 ST7789 进行编程实现驱动，然后再建立各种字符显示及显示图片等函数。使用 MicroPython 其实也需要做以上工作，但由于可读性和移植性强的特点，我们只需要搞清各个对象函数使如何使用即可。总的来说和之前一样，有构造函数和功能函数。构造函数解决的是初始化问题，告诉 pyAI-K210 外设是怎么接线，是什么样的；而功能函数解决的则是使用问题，我们基于自己的需求直接调用相关功能函数，实现自己的功能即可！我们管这些函数的集合叫驱动，MaixPy 已经将这 LCD.py 驱动写好了，我们学会如何使用即可。其构造函数和使用方法如下：</p><p>&nbsp;</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.init(<span class="built_in">type</span>=<span class="number">1</span>,freq=<span class="number">15000000</span>,color=lcd.BLACK)</span><br></pre></td></tr></table></figure><p>初始化 LCD。</p><p>【type】LCD 类型；</p><p>【freq】通信频率；</p><p>【color】LCD 初始化的颜色。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.deinit()</span><br></pre></td></tr></table></figure><p>注销 LCD 驱动，释放 IO 引脚。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.clear(color)</span><br></pre></td></tr></table></figure><p>填充指定颜色。默认是黑色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.draw_string(x,y,<span class="built_in">str</span>,color,bg_color)</span><br></pre></td></tr></table></figure><p>写字符</p><p>【x,y】起始坐标；</p><p>【str】字符内容</p><p>【color】字体颜色</p><p>【bg_color】字体背景颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.display(image,roi=Auto)</span><br></pre></td></tr></table></figure><p>显示图片。</p><p>【image】RGB565 或 GRAYSCALE 图片。</p><p>【ROI】显示的感兴趣区域，未指定则为图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.rotation(<span class="built_in">dir</span>)</span><br></pre></td></tr></table></figure><p>LCD 屏幕方向设定。</p><p>【dir】取值范围[0-3]，从 0 到 3 依顺时钟旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd.mirror(invert)</span><br></pre></td></tr></table></figure><p>镜面显示。</p><p>【invert】=True 则为镜面显示；=False 则否。</p><p>更多 LCD 模块说明请看 MaxiPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/lcd.html</a></p><p>有了上面的对象构造函数和使用说明，编程可以说是信手拈来了，我们来跑</p><p>一下其主要功能显示字符和图像，代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lcd,image,utime</span><br><span class="line">lcd.init() <span class="comment">#初始化 LCD</span></span><br><span class="line">lcd.clear(lcd.WHITE) <span class="comment">#清屏白色</span></span><br><span class="line"><span class="comment">#显示字符</span></span><br><span class="line">lcd.draw_string(<span class="number">110</span>, <span class="number">120</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>,lcd.BLACK, lcd.WHITE) <span class="comment">#显示字符</span></span><br><span class="line">utime.sleep(<span class="number">2</span>) <span class="comment">#延时 2 秒</span></span><br><span class="line">lcd.rotation(<span class="number">1</span>) <span class="comment">#由于图像默认是 240*320，因此顺时钟旋转 90°。</span></span><br><span class="line"><span class="comment">#显示图像，必须先将 01Studio.bmp 文件发送到开发板才能正常运行</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;01Studio.bmp&quot;</span>))</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="摄像头应用"><a href="#摄像头应用" class="headerlink" title="摄像头应用"></a><strong>摄像头应用</strong></h3><p>从前面的基础实验我们熟悉了 K210 基于 MicroPython 的编程方法，但那可以说是只发挥了 K210 冰山一角的性能应用，摄像头是整个机器视觉应用的基础。今天我们就通过示例代码来看看 pyAI-K210 是如何使用摄像头的。</p><p>&nbsp;</p><p>MaixPy 机器视觉库代码大部分都是参考 OpenMV 移植过来，其已经将所有的摄像头功能封装到 sersor 模块中，用户可以通过调用轻松使用。这也是使用MicroPython 编程的魅力所在。</p><p>&nbsp;</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>sensor</p><p>摄像头对象，通过 import 直接调用</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.reset()</span><br></pre></td></tr></table></figure><p>初始化摄像头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_pixformat(*pixformat*)</span><br></pre></td></tr></table></figure><p>设置像素格式。pixformat 有 3 个参数。</p><p>sensor.GRAYSCAL：灰度图像，每像素 8 位（1 字节），处理速度快；</p><p>sensor.RGB565: 每像素为 16 位（2 字节），5 位用于红色，6 位用于绿色，5 位用于蓝色，处理速度比灰度图像要慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_framesize(*framesize*)</span><br></pre></td></tr></table></figure><p>设置每帧大小（即图像尺寸）。常用的 <em>framesize</em> 参数有下面这些：</p><p>sensor.QQVGA: 160*120;</p><p>sensor.QVGA: 320*240;</p><p>sensor.VGA: 640*480;</p><p>sensor.skip_frames([<em>n</em>, <em>time</em>])</p><p>摄像头配置后跳过 n 帧或者等待时间 time 让其变稳定。n:跳过帧数；time：等待</p><p>时间,单位 ms。</p><p>（如果 n 和 time 均没指定，则默认跳过 300 毫秒的帧。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.snapshot()</span><br></pre></td></tr></table></figure><p>使用相机拍摄一张照片，并返回 image 对象。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_visio</a></p><p>n/sensor.html</p><p>&nbsp;</p><p>我们再来看看本例程用于计算 FPS（每秒帧数）的 clock 模块。</p><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock=time.clock()</span><br></pre></td></tr></table></figure><p>创建一个时钟。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.tick()</span><br></pre></td></tr></table></figure><p>开始追踪运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock.fps ()</span><br></pre></td></tr></table></figure><p>停止追踪运行时间，并返回当前 FPS（每秒帧数）。</p><p>在调用该函数前始终首先调用 tick 。</p><p>*其它更多用法请阅读 Maixpy 官方文档：</p><p>文档链接：<a href="http://docs.openmv.io/library/omv.time.html">http://docs.openmv.io/library/omv.time.html</a></p><p>&nbsp;</p><p>&nbsp;</p><p>我们来看看 helloword 代码的编写流程图：</p><p>这个实验运行的就是编辑框里面的 helloworld 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>) <span class="comment">#初始化 LCD</span></span><br><span class="line">sensor.reset() <span class="comment">#复位和初始化摄像头，执行 sensor.run(0)停止。</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式为彩色 RGB565 (或灰色)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧大小为 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 等待设置生效.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 创建一个时钟来追踪 FPS（每秒拍摄帧数）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() <span class="comment"># 更新 FPS 时钟.</span></span><br><span class="line"> img = sensor.snapshot() <span class="comment"># 拍摄一个图片并保存.</span></span><br><span class="line"> lcd.display(img) <span class="comment"># 在 LCD 上显示</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># 注意: 当 K210 连接到 IDE 时候，运行速度减</span></span><br><span class="line"> <span class="comment">#半，因此当断开 IDE 时 FPS 会提升。</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a><strong>画图</strong></h3><p>通过摄像头采集到照片后，我们会进行一些处理，而这时候往往需要一些图形来指示，比如在图片某个位置标记箭头、人脸识别后用矩形框提示等。本节就是学习在图形上画图的使用功能。</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot() 或 img=image.Image(path[, copy_to_fb=<span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>创建图像，通过拍摄或者读取文件路径获取。</p><p><em>copy_to_fb=True**：可以加载大图片；</em></p><p>copy_to_fb=False：不可以加载大图片。</p><p>示例：img = image.Image(“01Studio.bmp”, copy_to_fb=True),表示加载根</p><p>目录下的 01Studio.bmp 图片。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_line(*x0*, *y0*, *x1*, *y1*[, *color*[, *thickness=<span class="number">1</span>*]])</span><br></pre></td></tr></table></figure><p>画线段。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色，如</p><p>（255,0,0）表示红色；thickness：粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_rectangle(*x*, *y*, *w*, *h*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画矩形。（x,y）:起始坐标；w:宽度；h:长度；color：颜色；thickness：边框粗细；fill:是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_circle(*x*, *y*, *radius*[, *color*[, thickness*=<span class="number">1</span>*[, *fill=<span class="literal">False</span>*]]])</span><br></pre></td></tr></table></figure><p>画圆。（x,y）:圆心； radius:半径； color：颜色；thickness:线条粗细；</p><p>fill：是否填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_arrow(*x0*, *y0*, *x1*, *y1*[, *color*[, size,[thickness*=<span class="number">1</span>]*]])</span><br></pre></td></tr></table></figure><p>画箭头。（x0,y0）:起始坐标；（x1,y1）:终点坐标；color:颜色；size:箭头位置大小。thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_cross(*x*, *y*[, *color*[, *size=<span class="number">5</span>*[, *thickness=<span class="number">1</span>*]]])</span><br></pre></td></tr></table></figure><p>画十字交叉。（x,y）:交叉坐标；color:颜色；size:尺寸；thickness：线粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.draw_string(*x*, *y*, *text*[, *color*[, *scale=*<span class="number">1</span>[,*mono_space=<span class="literal">True</span>*…]]]])</span><br></pre></td></tr></table></figure><p>写字符。(x,y): 起始坐标；text:字符内容；color：颜色；scale：字体大小；</p><p>mono_space:强制间距。</p><p>*其它更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>&nbsp;</p><p>熟悉了 image 对象的画图功能后，我们尝试在摄像头采集到的画面依次画出线段、矩形、圆形、箭头、十字交叉和字符。具体编程思路如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time, lcd</span><br><span class="line">lcd.init(freq=<span class="number">15000000</span>)</span><br><span class="line">sensor.reset() <span class="comment">#复位摄像头</span></span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #将摄像头设置成后置方式（所见即所得）</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565) <span class="comment"># 设置像素格式 RGB565 (or GRAYSCALE)</span></span><br><span class="line">sensor.set_framesize(sensor.QVGA) <span class="comment"># 设置帧尺寸 QVGA (320x240)</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 灯带设置响应.</span></span><br><span class="line">clock = time.clock() <span class="comment"># 新建一个时钟对象计算 FPS.</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick() </span><br><span class="line"> img = sensor.snapshot() </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 画线段：从 x0, y0 到 x1, y1 坐标的线段，颜色红色，线宽度 2。</span></span><br><span class="line"> img.draw_line(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">20</span>, color = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画矩形：绿色不填充。</span></span><br><span class="line"> img.draw_rectangle(<span class="number">150</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line"> thickness = <span class="number">2</span>, fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画圆：蓝色不填充。</span></span><br><span class="line"> img.draw_circle(<span class="number">60</span>, <span class="number">120</span>, <span class="number">30</span>, color = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness = <span class="number">2</span>,</span><br><span class="line"> fill = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画箭头：白色。</span></span><br><span class="line"> img.draw_arrow(<span class="number">150</span>, <span class="number">120</span>, <span class="number">250</span>, <span class="number">120</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size =</span><br><span class="line"> <span class="number">20</span>, thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#画十字交叉。</span></span><br><span class="line"> img.draw_cross(<span class="number">60</span>, <span class="number">200</span>, color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), size = <span class="number">20</span>,</span><br><span class="line"> thickness = <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#写字符。</span></span><br><span class="line"> img.draw_string(<span class="number">150</span>, <span class="number">200</span>, <span class="string">&quot;Hello 01Studio!&quot;</span>, color = (<span class="number">255</span>, <span class="number">255</span>,</span><br><span class="line"> <span class="number">255</span>), scale = <span class="number">2</span>,mono_space = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment"># Display on LCD</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment"># Note: MaixPy&#x27;s Cam runs about half as fast when connected</span></span><br><span class="line"> <span class="comment"># to the IDE. The FPS should increase once disconnected</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a><strong>颜色识别</strong></h3><p>我们活在一个色彩斑斓的世界里。本节我们来学习机器视觉中的颜色识别。我们会预先设定颜色阈值，如红、绿、蓝。这样 K210 摄像头采集图像后就能自动识别了。</p><p>&nbsp;</p><p>通过编程实现 pyAI-K210 识别程序预先设定的颜色色块，分别是红、绿、蓝三种颜色。</p><p>MaixPy 集成了 RGB565 颜色块识别 find_blobs 函数，主要是基于 LAB 颜色模型（每个颜色都是用一组 LAB 阈值表示，有兴趣的用户可以自行查阅相关模型资料）。其位于 image 模块下，因此我们直接将拍摄到的图片进行处理即可，那么我们像以往一样像看一下本实验相关对象和函数说明，具体如下：</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_blobs(thresholds[,invert=<span class="literal">False</span>[,roi[,x_stride=<span class="number">2</span>[,y_stride=<span class="number">1</span>[,area_threshold=<span class="number">10</span>[,pixels_threshold=<span class="number">10</span>[,merge=<span class="literal">False</span>[,margin=<span class="number">0</span>[, threshold_cb=<span class="literal">None</span>[, merge_cb=<span class="literal">None</span>]]]]]]]]]])</span><br></pre></td></tr></table></figure><p>查找图像中指定的色块。返回 image.blog 对象列表；</p><p>【thresholds】 必须是元组列表。 [(lo, hi), (lo, hi), …, (lo, hi)] 定义你想追踪的颜</p><p>色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰</p><p>度值。 仅考虑落在这些阈值之间的像素区域。 对于 RGB565 图像，每个元</p><p>组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是 LAB L，A 和 B</p><p>通道的最小值和最大值。</p><p>【area_threshold】若色块的边界框区域小于此参数值，则会被过滤掉；</p><p>【pixels_threshold】若色块的像素数量小于此参数值，则会被过滤掉；</p><p>【merge】若为 True,则合并所有没有被过滤的色块；</p><p>【margin】调整合并色块的边缘。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.blob。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.rect()</span><br></pre></td></tr></table></figure><p>返回一个矩形元组（x,y,w,h）,如色块边界。可以通过索引[0-3]来获得这些值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cx()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 x 位置。可以通过索引[5]来获得这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob.cy()</span><br></pre></td></tr></table></figure><p>返回色块(int)的中心 y 位置。可以通过索引[6]来获得这个值。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html</a></p><p>了解了找色块函数应用方法后，我们可以理清一下编程思路，代码编写流程如下：</p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式，所见即所得</span></span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock=time.clock()</span><br><span class="line"><span class="comment"># 颜色识别阈值 (L Min, L Max, A Min, A Max, B Min, B Max) LAB 模型</span></span><br><span class="line"><span class="comment"># 下面的阈值元组是用来识别 红、绿、蓝三种颜色，当然你也可以调整让识别变得更好。</span></span><br><span class="line">thresholds = [(<span class="number">30</span>, <span class="number">100</span>, <span class="number">15</span>, <span class="number">127</span>, <span class="number">15</span>, <span class="number">127</span>), <span class="comment"># 红色阈值</span></span><br><span class="line"> (<span class="number">30</span>, <span class="number">100</span>, -<span class="number">64</span>, -<span class="number">8</span>, -<span class="number">32</span>, <span class="number">32</span>), <span class="comment"># 绿色阈值</span></span><br><span class="line"> (<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">64</span>, -<span class="number">128</span>, -<span class="number">20</span>)] <span class="comment"># 蓝色阈值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> clock.tick()</span><br><span class="line"> </span><br><span class="line"> img=sensor.snapshot()</span><br><span class="line"> </span><br><span class="line"> blobs = img.find_blobs([thresholds[<span class="number">2</span>]]) <span class="comment"># 0,1,2 分别表示红，绿，蓝色。</span></span><br><span class="line"> <span class="keyword">if</span> blobs:</span><br><span class="line">  <span class="keyword">for</span> b <span class="keyword">in</span> blobs:</span><br><span class="line">   tmp=img.draw_rectangle(b[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">   tmp=img.draw_cross(b[<span class="number">5</span>], b[<span class="number">6</span>])</span><br><span class="line"> </span><br><span class="line"> lcd.display(img) <span class="comment">#LCD 显示图片</span></span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>在 IDE 中运行代码，代码默认检测的是蓝色，用户可以自行修改 find_blobs()参数的阈值数组编号来切换识别颜色</p><p>&nbsp;</p><h3 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a><strong>二维码识别</strong></h3><p>相信大家都知道二维码了，特别是在扫描支付越来越流行的今天，二维码的应用非常广泛。今天我们就来学习如何使用 pyAI-K210 开发套件实现二维码信息识别</p><p>而对于 pyAI-K210 而言，直接使用 MicroPython 中的 find_qrcodes()即可获取摄像头采集图像中二维码的相关信息。具体说明如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.find_qrcodes([roi])</span><br></pre></td></tr></table></figure><p>查找 roi 区域内的所有二维码并返回一个 image.qrcode 的对象列表。</p><h4 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h4><p>以上函数返回 image.qrcode 对象列表。</p><p>qrcode.rect()</p><p>返回一个矩形元组（</p><p>x,y,w,h）;</p><p>qrcode.payload()</p><p>返回二维码字符串信息。可以通过索引[4]来获得这个值。</p><p>qrcode.verison()</p><p>返回二维码版本号。</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine_vision/image/image.html#image.find_qrcodes%28%5Broi%5D%29</a></p><p>&nbsp;</p><p>从上表可以看到，使用 MicroPython 编程我们只需要简单地调find_qrcodes()函数，对得到的结果再进行处理即可，非常方便。代码编写流程如下图所示:</p><p>参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="comment">#摄像头模块初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#lcd 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> res = img.find_qrcodes() <span class="comment">#寻找二维码</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span>: <span class="comment">#在图片和终端显示二维码信息</span></span><br><span class="line">  img.draw_rectangle(res[<span class="number">0</span>].rect())</span><br><span class="line">  img.draw_string(<span class="number">2</span>,<span class="number">2</span>, res[<span class="number">0</span>].payload(), color=(<span class="number">0</span>,<span class="number">128</span>,<span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print</span>(res[<span class="number">0</span>].payload())</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> <span class="built_in">print</span>(clock.fps())</span><br></pre></td></tr></table></figure><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><p>pyAI-K210 开发套件，配 SD 卡放模型文件。</p><p>我们来简单介绍一下 K210 的 KPU。KPU 是 K210 内部一个神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，实时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。</p><p>KPU 具备以下几个特点：</p><p>➢ 支持主流训练框架按照特定限制规则训练出来的定点化模型</p><p>➢ 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输</p><p>入输出通道数目、输入输 出行宽列高</p><p>➢ 支持两种卷积内核 1x1 和 3x3</p><p>➢ 支持任意形式的激活函数</p><p>➢ 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB</p><p>➢ 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积）</p><p>简单来说就是 KPU 能加载和运行各种现成的 AI 算法模型，实现各种机器视</p><p>觉等功能。</p><p>MaixPy 中人脸识别本质是目标检测，主要通过在 K210 的 KPU 上跑 YOLO（You Only Look Once）目标检测算法来实现。我们来看一下 KPU 在 MaixPy 下的用法</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><p>&nbsp;</p><p>从上表可以看到通过 KPU 模块直接加载 YOLO2 网络，再结合人脸检测模型</p><p>来实现人脸识别。具体编程思路如下：</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#设置摄像头</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line"><span class="comment">#sensor.set_vflip(1) #设置摄像头后置</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#需要将模型（face.kfpkg）烧写到 flash 的 0x300000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x300000) </span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/facedetect.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#模型描参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="comment">#识别到人脸就画矩形表示</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line">   b = img.draw_rectangle(i.rect())</span><br><span class="line"> <span class="comment">#LCD 显示</span></span><br><span class="line"> lcd.display(img)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>有了代码后我们还需要将模型放在文件系统中。这里介绍 2 个方法：</p><p><strong>方法一：将模型放在</strong> <strong>SD</strong> <strong>卡中。</strong></p><p>在本节示例程序路径中可以看到有 1 个件夹 <strong>face_model_at_0x300000</strong>将里面的 <strong>facedetect.kmodel</strong> 文件移动到 SD 卡，运行上述代码即可。</p><p><strong>方法二：将模型烧录到</strong> <strong>K210</strong> <strong>的</strong> <strong>Flash</strong> <strong>中。</strong></p><p>打开本节示例程序路径的件夹<strong>face_model_at_0x300000</strong>里面的<strong>flash-list.json</strong>文件，内容如下（告诉烧录软件烧写地址和文件名）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line"> &quot;files&quot;: [</span><br><span class="line"> &#123;</span><br><span class="line"> &quot;address&quot;: 0x00300000,</span><br><span class="line"> &quot;bin&quot;: &quot;facedetect.kmodel&quot;,</span><br><span class="line"> &quot;sha256Prefix&quot;: false</span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来直接将</strong> <strong>kmodel</strong> <strong>和</strong> <strong>json</strong> <strong>这两个文件用</strong> <strong>zip</strong> <strong>方式压缩（不要用文件夹）</strong>，然后将 zip 后缀名改成 kfpkg，得到一个可以用 K210 固件烧录工具烧录的文件。</p><p>再使用 K210 固件烧录工具烧录直接烧录该文件即可，烧录软件会根据上述的 json 文件自动调整烧录地址，无需再次填写。</p><p>当我们去识别图片时候，可以将摄像头设置成后置，sensor 初始化时增加以</p><p>下代码：(LCD 装在 pyAI-K210 核心板背面，横屏测试。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#设置摄像头后置</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="物体识别"><a href="#物体识别" class="headerlink" title="物体识别"></a><strong>物体识别</strong></h3><p>在上一节人脸检测章节我们已经介绍过 KPU 的用法，这里不再重复。本实验还是使用到 YOLO2 网络，结合 20class 模型（20 种物体分类模型）来识别图像中的物体。下面重温一下 KPU 的用法</p><h4 id="构造函数-7"><a href="#构造函数-7" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br></pre></td></tr></table></figure><p>常用的 KPU 模块导入方法。</p><h4 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.load(offset <span class="keyword">or</span> file_path)</span><br></pre></td></tr></table></figure><p>加载模型。</p><p>【offset】模型存放在 flash 的偏移量，如 0x300000;</p><p>【file_path】模型在文件系统为文件名，如“xxx.kmodel”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.init_yolo2(kpu_net,threshold,nms_value,anchor_num,anchor)</span><br></pre></td></tr></table></figure><p>初始化 yolo2 网络；</p><p>【kpu_net】kpu 网络对象；</p><p>【threshold】概率阈值；</p><p>【nms_value】box_iou 门限；</p><p>【anchor_num】描点数；</p><p>【anchor】描点参数与模型参数一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.run_yolo2(kpu_net,image)</span><br></pre></td></tr></table></figure><p>运行 yolo2 网络；</p><p>【kpu_net】从 kpu_load()中返回的网络对象；</p><p>【image】从 sensor 中采集到的图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kpu.deinit(kpu_net)</span><br></pre></td></tr></table></figure><p>反初始化。</p><p>【kpu_net】kpu 网络对象；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor,image,lcd,time</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#摄像头后置方式</span></span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="comment">#模型分类，按照 20class 顺序</span></span><br><span class="line">classes = [<span class="string">&#x27;aeroplane&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;diningtable&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;motorbike&#x27;</span>, <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;pottedplant&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;sofa&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;tvmonitor&#x27;</span>]</span><br><span class="line"><span class="comment">#下面语句需要将模型（20class.kfpkg）烧写到 flash 的 0x500000 位置</span></span><br><span class="line"><span class="comment">#task = kpu.load(0x500000)</span></span><br><span class="line"><span class="comment">#将模型放在 SD 卡中。</span></span><br><span class="line">task = kpu.load(<span class="string">&quot;/sd/20class.kmodel&quot;</span>) <span class="comment">#模型 SD 卡上</span></span><br><span class="line"><span class="comment">#网络参数</span></span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>, </span><br><span class="line"><span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)</span><br><span class="line"><span class="comment">#初始化 yolo2 网络，识别可信概率为 0.7（70%）</span></span><br><span class="line">a = kpu.init_yolo2(task, <span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"> clock.tick()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> code = kpu.run_yolo2(task, img) <span class="comment">#运行 yolo2 网络</span></span><br><span class="line"> <span class="keyword">if</span> code:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">   a=img.draw_rectangle(i.rect())</span><br><span class="line">   a = lcd.display(img)</span><br><span class="line">   lcd.draw_string(i.x(), i.y(),classes[i.classid()],lcd.RED, lcd.WHITE)</span><br><span class="line">   lcd.draw_string(i.x(), i.y()+<span class="number">12</span>,<span class="string">&#x27;%f1.3&#x27;</span>%i.value(),lcd.RED,lcd.WHITE)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  a = lcd.display(img)</span><br><span class="line"><span class="built_in">print</span>(clock.fps()) <span class="comment">#打印 FPS</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="在线训练模型"><a href="#在线训练模型" class="headerlink" title="在线训练模型"></a><strong>在线训练模型</strong></h3><p>当我们想自己学习识别自</p><p>己的东西（比如键盘和鼠标的区分），就可以通过在线训练平台训练自己的模型。</p><p>在线训练上有完整的教程，这里不再重复</p><p>MaixHub 在线训练链接：<a href="https://maixhub.com/">https://maixhub.com/</a></p><p>当然上面也有很多现成别人训练好的模型可以直接使用，在模型库中选择</p><p>nncase 即可以看到适合 K210 使用的模型</p><p>&nbsp;</p><h3 id="图片拍摄"><a href="#图片拍摄" class="headerlink" title="图片拍摄"></a><strong>图片拍摄</strong></h3><p>我们在前面摄像头应用章节已经学习过拍摄是使用 image=sensor.snapshot()函数模块，那么我们只需要学会将图片保存即可。保存也是可以直接使用 image下的 save 模块，具体如下：</p><h4 id="构造函数-8"><a href="#构造函数-8" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img=sensor.snapshot()</span><br></pre></td></tr></table></figure><p>通过拍摄创建图像 img</p><h4 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.save(*path*[, *roi*[, *quality=<span class="number">50</span>*]])</span><br></pre></td></tr></table></figure><p>保存图片。</p><p>path：保存路径；</p><p>roi:指定保存区域(x, y, w, h)，默认全图保存；</p><p>quality:仅针对 JPEG 格式的质量控制，有效值为 0-100。</p><p>&nbsp;</p><p>掌握了拍照和保存功能，我们就可以编程实现了，例程编程代码流程图如下：</p><h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, lcd, image</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#配置 LED 蓝、红引脚</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO1,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.skip_frames(<span class="number">40</span>)</span><br><span class="line">lcd.init() <span class="comment">#LCD 初始化</span></span><br><span class="line"><span class="comment">#红灯亮提示拍照开始</span></span><br><span class="line">LED_R.value(<span class="number">0</span>)</span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>) <span class="comment"># 给 2 秒时间用户准备.</span></span><br><span class="line">LED_R.value(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#蓝灯亮提示正在拍照</span></span><br><span class="line">LED_B.value(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You&#x27;re on camera!&quot;</span>)</span><br><span class="line"><span class="comment"># 拍摄并保存相关文件，也可以用&quot;example.bmp&quot;或其它文件方式。</span></span><br><span class="line">sensor.snapshot().save(<span class="string">&quot;/sd/example.jpg&quot;</span>)</span><br><span class="line">LED_B.value(<span class="number">1</span>) <span class="comment">#l 蓝灯灭提示拍照完成</span></span><br><span class="line">lcd.display(image.Image(<span class="string">&quot;/sd/example.jpg&quot;</span>)) <span class="comment">#LCD 显示照片</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="视频录制"><a href="#视频录制" class="headerlink" title="视频录制"></a><strong>视频录制</strong></h3><p>pyAI-K210 使用的 MaixPy 集成了 vedio 视频模块，也就是通过 MicroPython编程可以轻松实现录制视频功能，我们来看看 vedio 对象：</p><p><strong>构造函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vedio</span><br><span class="line"></span><br><span class="line">v=vedio.<span class="built_in">open</span>((path, record=<span class="literal">False</span>, interval=<span class="number">100000</span>, quality=<span class="number">50</span>,width=<span class="number">320</span>, height=<span class="number">240</span>, audio=<span class="literal">False</span>, sample_rate=<span class="number">44100</span>, channels=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>播放或录制视频文件。</p><p>【path】文件路径，比如：/sd/badapple.avi；</p><p>【record】=True 表示视频录制，=False 表示视频播放；</p><p>【interval】录制帧间隔，单位是微妙；FPS=1000000/interval，默认值</p><p>是 100000，即 FPS 默认是 10（每秒 10 帧）；</p><p>【quality】jpeg 压缩质量（%），默认 50；</p><p>【width】录制屏幕宽度，默认 320；</p><p>【height】录制屏幕高度，默认 240；</p><p>【audio】是否录制音频，默认 False;</p><p>【sample_rate】录制音频采样率，默认 44100（44.1k）;</p><p>【channels】录制音频声道数，默认 1，即单声道。</p><h4 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.play()</span><br></pre></td></tr></table></figure><p>播放视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.volume([value])</span><br></pre></td></tr></table></figure><p>设置音量值。</p><p>【value】0-100;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord ()</span><br></pre></td></tr></table></figure><p>录制音视频；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.revord_finish ()</span><br></pre></td></tr></table></figure><p>停止录制；</p><p>*更多使用说明请阅读官方文档：</p><p><a href="https://maixpy.sipeed.com/zh/libs/machine_vision/video.html">https://maixpy.sipeed.com/zh/libs/machine_vision/video.html</a></p><p>&nbsp;</p><p>学习了 vedio 的相关用法后，我们整理思路，代码编写流程如下：</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> video, sensor, image, lcd, time</span><br><span class="line"><span class="comment">#摄像头初始化</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>) <span class="comment">#后置拍摄模式</span></span><br><span class="line">sensor.skip_frames(<span class="number">30</span>)</span><br><span class="line"><span class="comment">#LCD 初始化</span></span><br><span class="line">lcd.init()</span><br><span class="line"><span class="comment">#指定录制文件路径和文件名</span></span><br><span class="line">v = video.<span class="built_in">open</span>(<span class="string">&quot;/sd/example.avi&quot;</span>, record=<span class="number">1</span>)</span><br><span class="line">i = <span class="number">0</span> <span class="comment">#计算录制帧数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> tim = time.ticks_ms()</span><br><span class="line"> img = sensor.snapshot()</span><br><span class="line"> lcd.display(img)</span><br><span class="line"> img_len = v.record(img) <span class="comment">#img_len 为返回的录制帧长度。</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;record&quot;</span>,time.ticks_ms() - tim) <span class="comment">#打印录制的每帧间隔</span></span><br><span class="line"> <span class="comment">#录制 100 帧,每帧默认 100ms，即 10 秒视频。</span></span><br><span class="line"> i += <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span> i &gt; <span class="number">100</span>:</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">v.record_finish() <span class="comment">#停止录制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finish&quot;</span>) <span class="comment">#录制完成提示</span></span><br></pre></td></tr></table></figure><h3 id="人脸识别-1"><a href="#人脸识别-1" class="headerlink" title="人脸识别"></a>人脸识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sensor</span><br><span class="line"><span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">import</span> lcd</span><br><span class="line"><span class="keyword">import</span> KPU <span class="keyword">as</span> kpu</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> FPIOA, GPIO</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> board <span class="keyword">import</span> board_info</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment"># task_fd = kpu.load(0x300000)</span></span><br><span class="line"><span class="comment"># task_ld = kpu.load(0x400000)</span></span><br><span class="line"><span class="comment"># task_fe = kpu.load(0x500000)</span></span><br><span class="line"></span><br><span class="line">task_fd = kpu.load(<span class="string">&quot;/sd/FaceDetection.smodel&quot;</span>)</span><br><span class="line">task_ld = kpu.load(<span class="string">&quot;/sd/FaceLandmarkDetection.smodel&quot;</span>)</span><br><span class="line">task_fe = kpu.load(<span class="string">&quot;/sd/FeatureExtraction.smodel&quot;</span>)</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line">fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0)</span><br><span class="line">key_gpio = GPIO(GPIO.GPIOHS0, GPIO.IN)</span><br><span class="line">start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">BOUNCE_PROTECTION = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_key_state</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="keyword">global</span> start_processing</span><br><span class="line">    start_processing = <span class="literal">True</span></span><br><span class="line">    utime.sleep_ms(BOUNCE_PROTECTION)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key_gpio.irq(set_key_state, GPIO.IRQ_RISING, GPIO.WAKEUP_NOT_SUPPORT)</span><br><span class="line"></span><br><span class="line">lcd.init()</span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.RGB565)</span><br><span class="line">sensor.set_framesize(sensor.QVGA)</span><br><span class="line">sensor.set_hmirror(<span class="number">1</span>)</span><br><span class="line">sensor.set_vflip(<span class="number">1</span>)</span><br><span class="line">sensor.run(<span class="number">1</span>)</span><br><span class="line">anchor = (<span class="number">1.889</span>, <span class="number">2.5245</span>, <span class="number">2.9465</span>, <span class="number">3.94056</span>, <span class="number">3.99987</span>, <span class="number">5.3658</span>, <span class="number">5.155437</span>,</span><br><span class="line">          <span class="number">6.92275</span>, <span class="number">6.718375</span>, <span class="number">9.01025</span>)  <span class="comment"># anchor for face detect</span></span><br><span class="line">dst_point = [(<span class="number">44</span>, <span class="number">59</span>), (<span class="number">84</span>, <span class="number">59</span>), (<span class="number">64</span>, <span class="number">82</span>), (<span class="number">47</span>, <span class="number">105</span>),</span><br><span class="line">             (<span class="number">81</span>, <span class="number">105</span>)]  <span class="comment"># standard face key point position</span></span><br><span class="line">a = kpu.init_yolo2(task_fd, <span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">5</span>, anchor)</span><br><span class="line">img_lcd = image.Image()</span><br><span class="line">img_face = image.Image(size=(<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">a = img_face.pix_to_ai()</span><br><span class="line">record_ftr = []</span><br><span class="line">record_ftrs = []</span><br><span class="line">names = [<span class="string">&#x27;Mr.1&#x27;</span>, <span class="string">&#x27;Mr.2&#x27;</span>, <span class="string">&#x27;Mr.3&#x27;</span>, <span class="string">&#x27;Mr.4&#x27;</span>, <span class="string">&#x27;Mr.5&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;Mr.6&#x27;</span>, <span class="string">&#x27;Mr.7&#x27;</span>, <span class="string">&#x27;Mr.8&#x27;</span>, <span class="string">&#x27;Mr.9&#x27;</span>, <span class="string">&#x27;Mr.10&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ACCURACY = <span class="number">85</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    clock.tick()</span><br><span class="line">    code = kpu.run_yolo2(task_fd, img)</span><br><span class="line">    <span class="keyword">if</span> code:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">            <span class="comment"># Cut face and resize to 128x128</span></span><br><span class="line">            a = img.draw_rectangle(i.rect())</span><br><span class="line">            face_cut = img.cut(i.x(), i.y(), i.w(), i.h())</span><br><span class="line">            face_cut_128 = face_cut.resize(<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">            a = face_cut_128.pix_to_ai()</span><br><span class="line">            <span class="comment"># a = img.draw_image(face_cut_128, (0,0))</span></span><br><span class="line">            <span class="comment"># Landmark for face 5 points</span></span><br><span class="line">            fmap = kpu.forward(task_ld, face_cut_128)</span><br><span class="line">            plist = fmap[:]</span><br><span class="line">            le = (i.x() + <span class="built_in">int</span>(plist[<span class="number">0</span>] * i.w() - <span class="number">10</span>), i.y() + <span class="built_in">int</span>(plist[<span class="number">1</span>] * i.h()))</span><br><span class="line">            re = (i.x() + <span class="built_in">int</span>(plist[<span class="number">2</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">3</span>] * i.h()))</span><br><span class="line">            nose = (i.x() + <span class="built_in">int</span>(plist[<span class="number">4</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">5</span>] * i.h()))</span><br><span class="line">            lm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">6</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">7</span>] * i.h()))</span><br><span class="line">            rm = (i.x() + <span class="built_in">int</span>(plist[<span class="number">8</span>] * i.w()), i.y() + <span class="built_in">int</span>(plist[<span class="number">9</span>] * i.h()))</span><br><span class="line">            a = img.draw_circle(le[<span class="number">0</span>], le[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(re[<span class="number">0</span>], re[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(nose[<span class="number">0</span>], nose[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(lm[<span class="number">0</span>], lm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            a = img.draw_circle(rm[<span class="number">0</span>], rm[<span class="number">1</span>], <span class="number">4</span>)</span><br><span class="line">            <span class="comment"># align face to standard position</span></span><br><span class="line">            src_point = [le, re, nose, lm, rm]</span><br><span class="line">            T = image.get_affine_transform(src_point, dst_point)</span><br><span class="line">            a = image.warp_affine_ai(img, img_face, T)</span><br><span class="line">            a = img_face.ai_to_pix()</span><br><span class="line">            <span class="comment"># a = img.draw_image(img_face, (128,0))</span></span><br><span class="line">            <span class="keyword">del</span> (face_cut_128)</span><br><span class="line">            <span class="comment"># calculate face feature vector</span></span><br><span class="line">            fmap = kpu.forward(task_fe, img_face)</span><br><span class="line">            feature = kpu.face_encode(fmap[:])</span><br><span class="line">            reg_flag = <span class="literal">False</span></span><br><span class="line">            scores = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(record_ftrs)):</span><br><span class="line">                score = kpu.face_compare(record_ftrs[j], feature)</span><br><span class="line">                scores.append(score)</span><br><span class="line">            max_score = <span class="number">0</span></span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):</span><br><span class="line">                <span class="keyword">if</span> max_score &lt; scores[k]:</span><br><span class="line">                    max_score = scores[k]</span><br><span class="line">                    index = k</span><br><span class="line">            <span class="keyword">if</span> max_score &gt; ACCURACY:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;%s :%2.1f&quot;</span> % (</span><br><span class="line">                    names[index], max_score)), color=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = img.draw_string(i.x(), i.y(), (<span class="string">&quot;X :%2.1f&quot;</span> % (</span><br><span class="line">                    max_score)), color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), scale=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> start_processing:</span><br><span class="line">                record_ftr = feature</span><br><span class="line">                record_ftrs.append(record_ftr)</span><br><span class="line">                start_processing = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    fps = clock.fps()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2.1f fps&quot;</span> % fps)</span><br><span class="line">    a = lcd.display(img)</span><br><span class="line">    gc.collect()</span><br><span class="line">    <span class="comment"># kpu.memtest()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fe)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_ld)</span></span><br><span class="line"><span class="comment"># a = kpu.deinit(task_fd)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k210基础实验</title>
      <link href="/posts/abdf738c.html"/>
      <url>/posts/abdf738c.html</url>
      
        <content type="html"><![CDATA[<h2 id="点亮第一个-LED"><a href="#点亮第一个-LED" class="headerlink" title="点亮第一个 LED"></a><strong>点亮第一个</strong> <strong>LED</strong></h2><p>其连接到 pyAI-K210 的外部 IO 引脚如下（可以看开发板原理图），LED 蓝灯对应的外部 IO 为 IO12，从电路可以看到当 IO12 为低电平时，蓝灯被点亮。</p><p>K210 为外部 IO 和内部 IO，其片上外设（比如 GPIO、I2C 等）对应的引脚是可以任意设置的，而传统大部分 MCU 片上外设和引脚对应关系已经固定了， 只有部分引脚可以复用， 相比之下 K210 自由度更大。</p><p>因此我们在编程使用 GPIO 的时候需要注册一下硬件 IO 和 K210 内部 IO 的对应关系。注册方式使用 fpioa_manager：简称 fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fm.register(pin,function,force=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【pin】芯片外部 IO</p><p>【function】芯片功能</p><p>【force】=True 则强制注册，清除之前的注册记录；</p><p>例：fm.register(12, fm.fpioa.GPIO0,force=True)</p><p>表示将外部 IO12 注册到内部 GPIO0</p><p>更多有关引脚和功能注册信息请看官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/Maix/gpio.html</a></p><p>注册成功后我们就可以通过 GPIO 对象模块来控制外部 IO，从而控制 LED。</p><p>GPIO 对象说明如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GPIO 对象。</span><br><span class="line"></span><br><span class="line">【ID】内部 GPIO 编号;</span><br><span class="line"></span><br><span class="line">【MODE】GPIO 模式；</span><br><span class="line"></span><br><span class="line">GPIO.IN ：输入模式</span><br><span class="line"></span><br><span class="line">GPIO.OUT ：输出模式</span><br><span class="line"></span><br><span class="line">【PULL】</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_UP ：上拉</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">GPIO.PULL_</span>DOWN ：下拉</span><br><span class="line"></span><br><span class="line">GPIO.PULL<span class="emphasis">_NONE ：无</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">【value】GPIO 初始化电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1：高电平</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">0：低电平</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>方式 1 是：import Maix，然后通过 Maix.GPIO 来操作；</p><p>方式 2 是：from Maix import GPIO，意思是直接从 Maix 中引入 GPIO 模块，然后直接通过 GPIO 来操作。显然方式 2 会显得更直观和方便，本实验也是使用</p><p>方式 2 来编程。代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">实验名称：点亮 LED_B 蓝灯</span></span><br><span class="line"><span class="string">实验目的：学习 led 点亮。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#将蓝灯引脚 IO12 配置到 GPIO0，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0,force=<span class="literal">True</span>)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br></pre></td></tr></table></figure><p>关于python中from和import</p><p><a href="https://www.cnblogs.com/keenajiao/p/15336312.html">Python的from和import用法 - keena_jiao - 博客园 (cnblogs.com)</a></p><h3 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utime()</span><br><span class="line"><span class="comment">#时间模块</span></span><br></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">utime.sleep(seconds)</span><br><span class="line">秒级颜色。seconds:延时秒数</span><br><span class="line">utime.sleep_ms(ms)</span><br><span class="line">毫秒级延时。ms：延时毫秒数。</span><br><span class="line">utime.sleep_us(us)</span><br><span class="line">微秒级延时。us：延时微秒数。</span><br></pre></td></tr></table></figure><p>*更多用法请阅读 MaixPy 官方文档：</p><p><a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/standard/utime.html</a></p><p>知道了延时函数的使用方法后，我们可以简单的梳理一下流程，首先导入LED 和 utime 模块，程序开始先让 RGB LED 灭掉，开启循环，依次点亮每个 LED，延时 1 秒，关闭 LED。流程如下：</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>) <span class="comment">#构建 LED 对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#蓝灯亮 1 秒</span></span><br><span class="line"> LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_B.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#绿灯亮 1 秒</span></span><br><span class="line"> LED_G.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line">    utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED_G.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br><span class="line"> <span class="comment">#红灯亮 1 秒</span></span><br><span class="line"> LED_R.value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line">LED_R.value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><p>上述代码没错是完整地按照编程思路来编写，但可以见到有很多格式相似的地方，这显得代码非常冗余。我们可以通过 for 函数来编写程序，由于是对 3 个LED 的操作，因此我们可以用 for i in range(0,3): 语句来修改，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">实验名称：流水灯</span></span><br><span class="line"><span class="string">版本：v1.0</span></span><br><span class="line"><span class="string">日期：2019.12</span></span><br><span class="line"><span class="string">作者：01Studio</span></span><br><span class="line"><span class="string">实验目的：让 RGB 灯循环闪烁。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"><span class="comment">#将将 LED 外部 IO 注册到内部 GPIO，K210 引脚支持任意配置</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">13</span>, fm.fpioa.GPIO1)</span><br><span class="line">fm.register(<span class="number">14</span>, fm.fpioa.GPIO2)</span><br><span class="line"><span class="comment">#构建 LED 对象，并初始化输出高电平，关闭 LED</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_G = GPIO(GPIO.GPIO1, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">LED_R = GPIO(GPIO.GPIO2, GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#定义数组方便循环语句调用</span></span><br><span class="line">LED=[LED_B, LED_G, LED_R]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">  LED[i].value(<span class="number">0</span>) <span class="comment">#点亮 LED</span></span><br><span class="line"> utime.sleep(<span class="number">1</span>)</span><br><span class="line"> LED[i].value(<span class="number">1</span>) <span class="comment">#关闭 LED</span></span><br></pre></td></tr></table></figure><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a><strong>按键</strong></h3><p>从原理图可以看到，按键 KEY 的一端连接到 K210 的外部 IO16，另一端连接到 GND。所以按键在没按下时候输入高电平（1），按下时候输入低电平（0）。和 LED 一样，按键的输入检测也是用到 GPIO 对象模块，具体如下：</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO(ID,MODE,PULL,VALUE)</span><br></pre></td></tr></table></figure><p>GPIO 对象。</p><p>【ID】内部 GPIO 编号;</p><p>【MODE】GPIO 模式；</p><p>GPIO.IN ：输入模式</p><p>GPIO.OUT ：输出模式</p><p>【PULL】</p><p>GPIO.PULL_UP ：上拉</p><p>GPIO.PULL_DOWN ：下拉</p><p>GPIO.PULL_NONE ：无</p><p>【value】GPIO 初始化电平</p><p>1：高电平</p><p>0：低电平</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.value([value])</span><br></pre></td></tr></table></figure><p>【value】GPIO 输出电平值；</p><p>1：高电平</p><p>0：低电平</p><p>*输入模式时候参数为空，表示获取当前 IO 输入电平值。</p><p>GPIO 对象使用非常简单，我们将按键即外部“IO16”引脚配置成输入，实现当检测到按键被按下时候点亮 LED 蓝灯，松开时关闭 LED 蓝灯来做指示。代码编写流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#注册 IO，蓝灯--&gt;IO12,KEY--&gt;IO16</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIO1)</span><br><span class="line"><span class="comment">#初始化 IO</span></span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line">KEY = GPIO(GPIO.GPIO1, GPIO.IN)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#按键被按下接地</span></span><br><span class="line">  LED_B.value(<span class="number">0</span>) <span class="comment">#点亮 LED_B,蓝灯</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  LED_B.value(<span class="number">1</span>) <span class="comment">#熄灭 LED</span></span><br></pre></td></tr></table></figure><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h3><p>前面我们在做普通的按键（GPIO）时候，虽然能实现 IO 口输入输出功能，但代码是一直在检测 IO 输入口的变化，因此效率不高，特别是在一些特定的场合，比如某个按键，可能 1 天才按下一次去执行相关功能，这样我们就浪费大量时间来实时检测按键的情况。</p><p>为了解决这样的问题，我们引入外部中断概念，顾名思义，就是当按键被按下(产生中断)时，我们才去执行相关功能。这大大节省了 CPU 的资源，因此中断的在实际项目的应用非常普遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION)</span><br></pre></td></tr></table></figure><p>配置中断。</p><p>【CALLBACK_FUNC】中断执行的回调函数；</p><p>【TRIGGER_CONDITION】中断触发方式；</p><p>GPIO.IRQ_RISING：上升沿触发</p><p>GPIO.IRQ_FALLING：下降沿沿触发</p><p>GPIO.IRQ_BOTH：都触发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.disirq()</span><br></pre></td></tr></table></figure><p>关闭中断。</p><p>我们先来了解一下上升沿和下降沿的概念，由于按键 KEY 引脚是通过按键接到 GND，也就是我们所说的低电平“0”，所以当按键被按下再松开时，引脚先获得下降沿，再获得上升沿，如下图所示：</p><p>按键被按下时候可能会发生抖动，抖动如下图，有可能造成误判，因此我们</p><p>需要使用延时函数来进行消抖：</p><p>我们可以选择下降沿方式触发外部中断，也就是当按键被按下的时候立即产</p><p>生中断。</p><p>需要注意的是 K210 只有高速 GPIO 才有外部中断，GPIO 常量表如下：</p><div class="table-container"><table><thead><tr><th><strong>K210 - GPIO</strong></th></tr></thead><tbody><tr><td>普通 GPIO</td></tr><tr><td>GPIO0 - GPIO7</td></tr><tr><td>高速 GPIO</td></tr><tr><td>GPIOHS0 – GPIOHS31</td></tr></tbody></table></div><p>编程思路中断跟 GPIO 按键章节类似，在初始化中断后，当系统检测到外部</p><p>中断时候，执行 LED 状态反转的代码即可。流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">import</span> utime</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO，注意高速 GPIO 口才有中断</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">fm.register(<span class="number">16</span>, fm.fpioa.GPIOHS0)</span><br><span class="line"><span class="comment">#构建 lED 和 KEY 对象</span></span><br><span class="line"></span><br><span class="line">LED_B=GPIO(GPIO.GPIO0,GPIO.OUT,value=<span class="number">1</span>)</span><br><span class="line">KEY=GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_UP)</span><br><span class="line"></span><br><span class="line"><span class="comment">#LED 状态表示</span></span><br><span class="line">state = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#中断回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">KEY</span>):</span><br><span class="line"> <span class="keyword">global</span> state</span><br><span class="line"> utime.sleep_ms(<span class="number">10</span>) <span class="comment">#消除抖动</span></span><br><span class="line"> <span class="keyword">if</span> KEY.value()==<span class="number">0</span>: <span class="comment">#确认按键被按下</span></span><br><span class="line"> state = <span class="keyword">not</span> state</span><br><span class="line"> LED_B.value(state)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#开启中断，下降沿触发</span></span><br><span class="line">KEY.irq(fun, GPIO.IRQ_FALLING)</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h3><h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.Timer(<span class="built_in">id</span>,channel,mode=Timer.MODE_ONE_SHOT,period=<span class="number">1000</span>,unit=Timer.UNIT_MS, callback=<span class="literal">None</span>, arg=<span class="literal">None</span>, start=<span class="literal">True</span>,</span><br><span class="line">priority=<span class="number">1</span>, div=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>定时器对象 Timer 对象在 machine 模块下。</p><p>【id】定时器编号, [Timer.TIMER0~TIMER2] 定时器 0-2;</p><p>【channel】Timer 通道，[Timer.CHANNEL0~Timer.CHANNEL3]</p><p>【mode】定时器模式</p><p>MODE_ONE_SHOT: 一次性</p><p>MODE_PERIODIC: 周期性</p><p>MODE_PWM</p><p>【period】定时器为周期性模块时每个周期时间值</p><p>【unit】周期的单位</p><p>Timer.UNIT_S：秒</p><p>Timer.UNIT_MS：毫秒</p><p>Timer.UNIT_US：微妙</p><p>Timer.UNIT_NS：纳秒</p><p>【callback】定时器中断执行的回调函数；<strong>注意：回调函数是在中断中调用</strong></p><p><strong>的，所以在回调函数中请不要占用太长时间以及做动态内存分配开关中断等</strong></p><p><strong>动作。</strong></p><p>【arg】回调函数第 2 个参数</p><p>【start】是否在构建对象后立即开始定时器，</p><p>=True: 立即开始；</p><p>=False: 不立即开始，需要调用 start()来开启。</p><p>【priority】硬件中断优先级，在 K210 中，取值范围是[1,7],值越小优先级越高</p><p>【div】硬件分频器。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>Timer.callback(fun)</th></tr></thead><tbody><tr><td>定义回调函数。</td></tr><tr><td>Timer.period([value])</td></tr><tr><td>配置周期。</td></tr><tr><td>Timer.start()</td></tr><tr><td>启动定时器。</td></tr><tr><td>Timer.stop()</td></tr><tr><td>停止定时器。</td></tr><tr><td>Timer.deinit()</td></tr><tr><td>注销定时器。</td></tr><tr><td>*更多用法请阅读 MaixPy 官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/timer.html</a></td></tr></tbody></table></div><p>定时器到了预设指定时间后，也会产生中断，因此跟外部中断的编程方式类</p><p>似，代码编程流程图如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Maix <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册 IO 和构建 LED 对象</span></span><br><span class="line">fm.register(<span class="number">12</span>, fm.fpioa.GPIO0)</span><br><span class="line">LED_B = GPIO(GPIO.GPIO0, GPIO.OUT)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计数变量</span></span><br><span class="line">Counter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定时器回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">tim</span>):</span><br><span class="line"> <span class="keyword">global</span> Counter</span><br><span class="line"> Counter = Counter + <span class="number">1</span></span><br><span class="line"> <span class="built_in">print</span>(Counter)</span><br><span class="line"> LED_B.value(Counter%<span class="number">2</span>)<span class="comment">#LED 循环亮灭。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#定时器 0 初始化，周期 1 秒</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, </span><br><span class="line">period=<span class="number">1000</span>, callback=fun)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a><strong>PWM</strong></h3><p>蜂鸣器分有源蜂鸣器和无源蜂鸣器，有源蜂鸣器的使用方式非常简单，只需</p><p>要接上电源，蜂鸣器就发声，断开电源就停止发声。而本实验用到的无源蜂鸣器，是需要给定指定的频率，才能发声的，而且可以通过改变频率来改变蜂鸣器的发声音色，以此来判定 pyAI-K210 的 PWM 输出频率是在变化的。</p><p>pyBase 开发底板上的无源蜂鸣器连接到引脚 X5。如下图所示：</p><p>而 pyAI-K210 并没有引脚直接连接到 pyBase 的 X5（主要避免影响 IO 复用。）而 IO15 连接到 pyBase 开发底板的 X6 引脚，因此我们可以用跳线帽或者跳线来连接 pyBase 的 X5 和 X6 引脚。相当于将无源蜂鸣器接到 pyAI-K210 的外部 IO15引脚。</p><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.PWM(tim, freq, duty, pin, enable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>PWM 对象在 machine 模块下。</p><p>【tim】K210 的 PWM 依赖于定时器来产生波形</p><p>【freq】PWM 频率</p><p>【duty】PWM 占空比</p><p>【pin】PWM 输出引脚</p><p>【enable】是否在构建对象后立即产生波形，默认 True。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><div class="table-container"><table><thead><tr><th>PWM.freq(freq)</th></tr></thead><tbody><tr><td>设置频率。不传参数返回当前频率值。</td></tr><tr><td>PWM.duty(duty)</td></tr><tr><td>设置占空比。不传参数返回当前占空比值。[0-100]表示占空比百分比<strong>107</strong></td></tr><tr><td>PWM.enable()</td></tr><tr><td>使能 PWM 输出。</td></tr><tr><td>PWM.disable()</td></tr><tr><td>暂停 PWM 输出。</td></tr><tr><td>PWM.deinit()</td></tr><tr><td>注销 PWM。</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Timer,PWM</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#PWM 通过定时器配置，接到 IO15 引脚</span></span><br><span class="line">tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)</span><br><span class="line">beep = PWM(tim, freq=<span class="number">1</span>, duty=<span class="number">50</span>, pin=<span class="number">15</span>)</span><br><span class="line"><span class="comment">#循环发出不同频率响声。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> beep.freq(<span class="number">200</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">400</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">600</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">800</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> beep.freq(<span class="number">1000</span>)</span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>有条件的朋友可以使用示波器测量 pyAI-K210 的 IO15 引脚或 pyBase 的 X5 引脚，观察信号波形的变化：</p><p>&nbsp;</p><h3 id="I2C-总线（OLED显示屏）"><a href="#I2C-总线（OLED显示屏）" class="headerlink" title="I2C 总线（OLED显示屏）"></a><strong>I2C</strong> <strong>总线（OLED显示屏）</strong></h3><p>我们先来看看开发板的原理图，也就是MicroPython 上的 OLED 接口是如何连线的。下图是 pyBase 开发底板的原理图。</p><p>我们再来看看 pyAI-K210 转接板的原理图接口部分。</p><p>结合以上可以得知 pyBase 底板连接到 OLED 的对应关系是 Y6→SCL 和Y8→SDA。对应 pyAI-K210 的关系是：IO27→Y6→SCL，IO28→Y8→SDA。本例程将使用 MicroPython 的 Machine 模块的 I2C 来定义 Pin 口和 I2C 初始化。具体如下：</p><p>&nbsp;</p><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">machine.I2C(<span class="built_in">id</span>, mode=I2C.MODE_MASTER, scl=<span class="literal">None</span>, sda=<span class="literal">None</span>,</span><br><span class="line">freq=<span class="number">400000</span>, timeout=<span class="number">1000</span>, addr=<span class="number">0</span>, addr_size=<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>构建 I2C 对象。</p><p>【id】I2C ID,[ I2C.I2C0~I2C.I2C2 ]</p><p>【scl】时钟引脚；直接传引脚编号；</p><p>【sda】数据引脚; 直接传引脚编号；</p><p>【freq】通信频率，即速度；</p><p>【timeout】参数保留，设置无效；</p><p>【addr】从机地址；</p><p>【addr_size】地址长度， 支持 7 位寻址和 10 位寻址， 取值 7 或者 10。</p><div class="table-container"><table><thead><tr><th><strong>使用方法</strong></th></tr></thead><tbody><tr><td>i2c.scan()</td></tr><tr><td>扫描 I2C 总线的设备。返回地址，如：0x3c；</td></tr><tr><td>i2c.readfrom(addr,len)</td></tr><tr><td>从指定地址读数据。addr:指定设备地址；len:读取字节数；</td></tr><tr><td>i2c.writeto(addr,buf)</td></tr><tr><td>写数据。addr:从机地址；buf:数据内容；</td></tr><tr><td>i2c.deinit()</td></tr><tr><td>注销 I2C。</td></tr><tr><td>*其它更多用法请阅读官方文档：<a href="https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h">https://wiki.sipeed.com/soft/maixpy/zh/api_reference/machine/i2c.h</a></td></tr></tbody></table></div><p>定义好 I2C 后，还需要驱动一下 OLED。这里我们已经写好了 OLED 的库函数，在 ssd1306k.py 文件里面。开发者只需要将改 py 文件拷贝到 pyAI-K210 文件系统里面，然后在 main.py 里面调用函数即可。人生苦短，我们学会调用函数即可，也就是注重顶层的应用，想深入的小伙伴也可以自行研究 ssd1306k.py 文件代码。OLED 显示屏对象介绍如下：</p><h4 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oled = SSD1306_I2C(i2c, addr)</span><br></pre></td></tr></table></figure><p>构 OLED 显示屏对象。默认分辨率 128*64；</p><p>【i2c】定义好的 I2C 对象;</p><p>【addr】显示屏设备地址。</p><h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><p>oled.fill([value])</p><p>清屏</p><p>value=0x00 (黑屏)；value=0xFF(白屏)</p><p>oled.text(string,x,y)</p><p>将 string 字符写在指定为位置。</p><p>【string】：字符；</p><p>【x】横坐标；[0-127]；</p><p>【y】纵坐标。[0-7] 共 8 行</p><p>学习了 I2C、OLED 对象用法后我们通过编程流程图来理顺一下思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> I2C</span><br><span class="line"><span class="keyword">from</span> ssd1306k <span class="keyword">import</span> SSD1306</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义 I2C 接口和 OLED 对象</span></span><br><span class="line">i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER,scl=<span class="number">27</span>, sda=<span class="number">28</span>)</span><br><span class="line">oled = SSD1306(i2c, addr=<span class="number">0x3c</span>)</span><br><span class="line"><span class="comment">#清屏,0x00(白屏)，0xff(黑屏)</span></span><br><span class="line">oled.fill(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#显示字符。参数格式为（str,x,y）,其中 x 范围是 0-127，y 范围是 0-7（共 8 行）</span></span><br><span class="line">oled.text(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">#写入第 0 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;MicroPython&quot;</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">#写入第 2 行内容</span></span><br><span class="line">oled.text(<span class="string">&quot;By 01Studio&quot;</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">#写入第 5 行内容</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="UART（串口通信）"><a href="#UART（串口通信）" class="headerlink" title="UART（串口通信）"></a><strong>UART（串口通信）</strong></h3><p>  串口是非常常用的通信接口，有很多工控产品、无线透传模块都是使用串口来收发指令和传输数据，这样用户就可以在无须考虑底层实现原理的前提下将各类串口功能模块灵活应用起来。</p><p>&nbsp;</p><p>K210 一共有 3 个串口，每个串口可以自由映射引脚。 例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IO6→RX1，IO7→TX1</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="构造函数-6"><a href="#构造函数-6" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len)</span><br></pre></td></tr></table></figure><p>创建 UART 对象。</p><p>【uart】串口编号。[UART.UART1~UART3]</p><p>【baudrate】波特率，常用 115200、9600</p><p>【bits】数据位,默认 8</p><p>【parity】校验；默认 None, 0(偶校验)，1(奇校验)</p><p>【stop】停止位，默认 1</p><p>【timeout】串口接收超时时间</p><p>【read_buf_len】串口接收缓冲大小。</p><h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><p>UART.read(num)</p><p>读取串口缓冲数据</p><p>【num】读取字节数</p><p>UART.readline(num)</p><p>读取串口缓冲数据的行</p><p>【num】行数</p><p>UART.write(buf)</p><p>串口发送数据</p><p>【buf】需要发送的数据</p><p>UART.deinit()</p><p>注销串口</p><p>&nbsp;</p><p>我们可以用一个USB转TTL工具，配合电脑上位机串口助手来跟MicroPython</p><p>开发板模拟通信。</p><p>注意要使用 3.3V 电平的 USB 转串口 TTL 工具，本实验我们使用 pyBase 的外</p><p>接串口引脚，也就是 Y9（TX）和 Y10（RX），接线示意图如下：</p><p>从 pyAI-K210 原理图可以看到外部 IO6→Y9→RX ，IO7→Y10→TX。</p><p>在本实验中我们可以先初始化串口，然后给串口发去一条信息，这样 PC 机的串口助手就会在接收区显示出来，然后进入循环，当检测到有数据可以接收时候就将数据接收并打印，并通过 REPL 打印显示。代码编写流程图如下：</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> UART,Timer</span><br><span class="line"><span class="keyword">from</span> fpioa_manager <span class="keyword">import</span> fm</span><br><span class="line"><span class="comment">#映射串口引脚</span></span><br><span class="line">fm.register(<span class="number">6</span>, fm.fpioa.UART1_RX, force=<span class="literal">True</span>)</span><br><span class="line">fm.register(<span class="number">7</span>, fm.fpioa.UART1_TX, force=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#初始化串口</span></span><br><span class="line">uart = UART(UART.UART1, <span class="number">115200</span>, read_buf_len=<span class="number">4096</span>)</span><br><span class="line">uart.write(<span class="string">&#x27;Hello 01Studio!&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> text=uart.read() <span class="comment">#读取数据</span></span><br><span class="line"> <span class="keyword">if</span> text: <span class="comment">#如果读取到了数据</span></span><br><span class="line">  <span class="built_in">print</span>(text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#REPL 打印</span></span><br><span class="line">  uart.write(<span class="string">&#x27;I got&#x27;</span>+text.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment">#数据回传</span></span><br></pre></td></tr></table></figure><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>这时候打开电脑的设备管理器，能看到 2 个 COM。写着 CH340 的是串口工具，另外一个则是 pyAI-K210 的 REPL。如果 CH340 驱动没安装，则需要手动安装，驱动在：配套资料包→开发工具→windows→串口终端→CH340 文件夹下。</p><p>本实验要用到串口助手，打开配套资料包→开发工具→windows→串口终端工具下的【UartAssist.exe】软件。</p><p>将串口工具配置成 COM14（根据自己的串口号调整）。波特率 115200。运行程序，可以看到一开始串口助手收到 pyAI-K210 上电发来的信息“Hello 01Studio!”。我们在串口助手的发送端输入“<a href="http://www.01studio.org”，">http://www.01studio.org”，</a> 点击发送，可以看到pyAI-K210 在接收到该信息后在 REPL 里面打印了出来。如下图所示：</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a><strong>thread（线程）</strong></h3><p>我们看到前面的编程都是一个循环来完成，但当我们需要分时完成不同任务时候，线程编程就派上用场了。这有点像 RTOS(实时操作系统)，今天我们就来学习一下如何通过 MicroPython 编程实现多线程。</p><p>&nbsp;</p><p>pyAI-K210 的 MicroPython 固件已经集成了_thread 线程模块。我们直接调用即可。该模块衍生于 python3，属于低级线程，详情可以看官网介绍：<a href="https://docs.python.org/3.5/library/_thread.html#module-thread">https://docs.python.org/3.5/library/_thread.html#module-thread</a></p><p>编程流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread <span class="comment">#导入线程模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#线程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name</span>):</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name)) </span><br><span class="line"> time.sleep(<span class="number">1</span>)</span><br><span class="line"> _thread.start_new_thread(func,(<span class="string">&quot;1&quot;</span>,)) <span class="comment">#开启线程 1，参数必须是元组</span></span><br><span class="line">_thread.start_new_thread(func,(<span class="string">&quot;2&quot;</span>,)) <span class="comment">#开启线程 2，参数必须是元组</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> k210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k210</title>
      <link href="/posts/a08a9fe.html"/>
      <url>/posts/a08a9fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="k210开发环境"><a href="#k210开发环境" class="headerlink" title="k210开发环境"></a>k210开发环境</h1><h3 id="python的一些基本语法"><a href="#python的一些基本语法" class="headerlink" title="python的一些基本语法"></a>python的一些基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用.format 来格式化字符串</span></span><br><span class="line"><span class="comment"># 可以重复参数以节省时间</span></span><br><span class="line"><span class="string">&quot;&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Jack&quot;</span>, </span><br><span class="line"><span class="string">&quot;candle stick&quot;</span>)</span><br><span class="line"><span class="comment"># =&gt; &quot;Jack be nimble, Jack be quick, Jack jump over the candle stick&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想数参数，可以用关键字</span></span><br><span class="line"><span class="string">&quot;&#123;name&#125; wants to eat &#123;food&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;Bob&quot;</span>, food=<span class="string">&quot;lasagna&quot;</span>) </span><br><span class="line"><span class="comment"># =&gt; &quot;Bob wants to eat lasagna&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># None，0，空字符串，空列表，空字典都算是 False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="安装开发软件-MaixPy-IDE"><a href="#安装开发软件-MaixPy-IDE" class="headerlink" title="安装开发软件 MaixPy IDE"></a><strong>安装开发软件</strong> <strong>MaixPy IDE</strong></h3><p>当前版本为 v0.2.5，官网下载地址：（如有更新请下载最新版）</p><p><a href="http://cn.dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5，下载界面如下图。">http://cn.dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5，下载界面如下图。</a></p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>驱动路径选择：零一科技（01Studio）MicroPython 开发套件配套资料\01-开</p><p>发工具\01-Windows\串口终端工具\CH9102x 驱动，点击确认后即可自动安装：</p><h3 id="例程测试"><a href="#例程测试" class="headerlink" title="例程测试"></a><strong>例程测试</strong></h3><p>我们用最简单的 LED 程序来测试，在 MaixPy IDE 中打开 零一科技（01Studio）</p><p>MicroPython 开发套件配套资料_latest\02-示例程序\5.pyAI-K210\1.基础实验\1.点</p><p>亮第一个 LED 里面的 LED.py 例程</p><p>在连接状态下点击工具—将打开的脚本保存到开发板的 boot.py，这里的意</p><p>思是将当前编辑框的代码拷贝到开发板文件系统中的 boot.py，由于 boot.py 是</p><p>Maixpy 上电运行的第一个脚本文件，因此相当于实现了上电运行写入的程序。</p><h3 id="REPL-串口调试"><a href="#REPL-串口调试" class="headerlink" title="REPL 串口调试"></a><strong>REPL</strong> <strong>串口调试</strong></h3><p>MicroPython 固件集成了交互解释器 REPL 【读取(Read)-运算(Eval)-输出(Print)-循环(Loop) 】，开发者可以直接通过串口终端来调试 pyboard 或 micropython 开发套件。我们使用的软件是一款免费的串口终端软件 putty。</p><p>打开 MicroPython 开发套件配套资料\开发工具\串口终端工具\Putty.exe，选择左下角 Serial，配置信息如下：</p><p>配置好后不是点 open，而是点左边上方 Session，选择 Serial 后可看到刚刚的配置信息。串口号通常不会变化，我们在 Save Session 下方输入 COM4 或者自己喜欢的名称，点右边 Save，在空白框里面就出现 COM4 字样，以后可以直接使用。设置好后我们点击 Open。</p><p>现在对话框相当于连接上了开发板上，由于 pyAI-K210 集成了 MicroPython</p><p>解析器。我们在这里可以进行调试和简单编程，接下来我们测试一下。在对话框</p><p>输入下面代码，按回车，可以看到代码运行情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(“Hello 01Studio!”)</span><br></pre></td></tr></table></figure><h3 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a><strong>固件更新</strong></h3><p>MaixPy 官方提供了免安装的烧录工具，通过板载 USB 转串口烧录的。我们</p><p>打开 MicroPython 开发套件配套资料\开发工具\Windows\固件更新工具\</p><p>kflash_gui 目录下的 kflash_gui.exe 烧录软件。</p><p>选择配套资料包路径 零一科技（01Studio）MicroPython 开发套件配套资料</p><p>\03-相关固件\05-pyAI-K210 下的固件：</p><p>烧录地址默认为 0x00000 即可。选择开发板和串口 COM，开发板可以选择</p><p>跟 pyAI-K210 串口方案一样的 Maix Dock ，而串口则选择自己开发板对应的串口。</p><p>点击 Download 下载。<strong>（如出现一直等待情况说明无法自动下载，这时候按</strong></p><p><strong>一下开发板的</strong> <strong>RST</strong> <strong>复位键即可。）</strong></p><p>或者直接连按两下ret键</p><p>MaixPy 针对不同的应用场景提供不同大小的固件，而且不断更新，详见固件</p><p>下载链接（不同固件区别见里面的 readme.txt）：</p><p><a href="https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master">https://dl.sipeed.com/shareURL/MAIX/MaixPy/release/master</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> k210 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp8266闪存文件系统</title>
      <link href="/posts/58716004.html"/>
      <url>/posts/58716004.html</url>
      
        <content type="html"><![CDATA[<h2 id="ESP8266闪存文件系统"><a href="#ESP8266闪存文件系统" class="headerlink" title="ESP8266闪存文件系统"></a>ESP8266闪存文件系统</h2><p>如果网页比较大，那么只用程序去储存明显是不太可能的，我们可以用esp8266闪存文件系统储存网页。</p><p>通常的闪存文件系统大小为4Mb</p><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th></th></tr></thead><tbody><tr><td>闪存文件系统</td><td>4Mb</td><td></td></tr><tr><td>程序储存</td><td>1Mb</td><td></td></tr><tr><td>用户可以文件储存（会包含一些系统文件）</td><td>3Mb</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="ESP8266闪存文件系统基本操作"><a href="#ESP8266闪存文件系统基本操作" class="headerlink" title="ESP8266闪存文件系统基本操作"></a>ESP8266闪存文件系统基本操作</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/spiffs-operation/">ESP8266闪存文件系统基本操作 </a></p><h3 id="1-通过程序向闪存文件系统写入信息"><a href="#1-通过程序向闪存文件系统写入信息" class="headerlink" title="1.通过程序向闪存文件系统写入信息"></a>1.通过程序向闪存文件系统写入信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-write</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的SPIFFS中建立名为</span></span><br><span class="line"><span class="comment">                            notes.txt的文件，程序还将向该文件写入信息。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;w&quot;); </span></span><br><span class="line"><span class="comment">以上函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;w&quot; 代表写入文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format start&quot;</span>);</span><br><span class="line">  SPIFFS.format();    <span class="comment">// 格式化SPIFFS</span></span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS format finish&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动SPIFFS</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello IOT World.&quot;</span>);       <span class="comment">// 向dataFile写入字符串信息</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="2-通过程序从闪存文件系统读取信息"><a href="#2-通过程序从闪存文件系统读取信息" class="headerlink" title="2.通过程序从闪存文件系统读取信息"></a>2.通过程序从闪存文件系统读取信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-read</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中存储的文件notes.txt读取数据。</span></span><br><span class="line"><span class="comment">                           notes.txt 文件内容将会通过串口监视器显示出来供用户确认。</span></span><br><span class="line"><span class="comment">                           注意在使用本程序以前需要先将notes.txt 文件上传到NodeMCU开发板的SPIFFS中</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;r&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;r&quot; 代表读取文件信息。（如需了解如何写入信息，请参阅示例程序esp8266-flash-write）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//建立File对象用于从SPIFFS中读取文件</span></span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;r&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//读取文件内容并且通过串口监视器输出文件信息</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;dataFile.size(); i++)&#123;</span><br><span class="line">    Serial.print((<span class="type">char</span>)dataFile.read());       </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//完成文件读取后关闭文件</span></span><br><span class="line">  dataFile.close();                           </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="3-通过程序向闪存文件系统文件添加信息"><a href="#3-通过程序向闪存文件系统文件添加信息" class="headerlink" title="3.通过程序向闪存文件系统文件添加信息"></a>3.通过程序向闪存文件系统文件添加信息</h3><p>要注意写入操作和添加操作的区别。假设闪存系统中已经有这样一文件，写入操作会对原文件进行覆盖，而添加操作会将文件最后加入新的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-append</span></span><br><span class="line"><span class="comment">=</span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何向NodeMCU的内置SPIFFS中存储的文件</span></span><br><span class="line"><span class="comment">                            notes.txt添加数据。                      </span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------  </span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.open(file_name, &quot;a&quot;); </span></span><br><span class="line"><span class="comment">以上SPIFFS函数有两个参数：</span></span><br><span class="line"><span class="comment">第一个参数是被操作的文件名称，本示例中该文件为/notes.txt</span></span><br><span class="line"><span class="comment">第二个参数&quot;a&quot; 代表添加文件信息。（如需了解如何读取信息，请参阅示例程序esp8266-flash-read）</span></span><br><span class="line"><span class="comment">此示例程序所演示的是向SPIFFS中的文件里添加信息。这一操作写入信息有所区别。</span></span><br><span class="line"><span class="comment">添加信息是不会删除文件内原有信息，而是在原有信息后面添加新的信息。</span></span><br><span class="line"><span class="comment">但写入操作（示例 esp8266-flash-write.ino）是将文件内容完全清除，重新写入新信息。    </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//确认闪存中是否有file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.exists(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; FOUND.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    File dataFile = SPIFFS.open(file_name, <span class="string">&quot;a&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息</span></span><br><span class="line">    dataFile.println(<span class="string">&quot;This is Appended Info.&quot;</span>); <span class="comment">// 向dataFile添加字符串信息</span></span><br><span class="line">    dataFile.close();                           <span class="comment">// 完成文件操作后关闭文件   </span></span><br><span class="line">    Serial.println(<span class="string">&quot;Finished Appending data to SPIFFS&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.print(<span class="string">&quot; NOT FOUND.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="4-通过程序读取目录内容"><a href="#4-通过程序读取目录内容" class="headerlink" title="4.通过程序读取目录内容"></a>4.通过程序读取目录内容</h3><p>读取某个文件夹中程序的内容。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-folder-read</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何从NodeMCU的内置SPIFFS中文件夹里读取文件信息</span></span><br><span class="line"><span class="comment">                           文件夹内容将会通过串口监视器显示出来。</span></span><br><span class="line"><span class="comment">                           </span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数说明：</span></span><br><span class="line"><span class="comment">SPIFFS.openDir(folder_name);</span></span><br><span class="line"><span class="comment">以上函数打开指定目录并返回一个目录对象实例。</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/myFile.txt&quot;</span>; <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line">String folder_name = <span class="string">&quot;/taichi-maker&quot;</span>;         <span class="comment">//被读取的文件夹</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  File dataFile = SPIFFS.open(file_name, <span class="string">&quot;w&quot;</span>);<span class="comment">// 建立File对象用于向SPIFFS中的file对象（即myFile.txt）写入信息</span></span><br><span class="line">  dataFile.println(<span class="string">&quot;Hello Taichi-Maker.&quot;</span>);    <span class="comment">// 向dataFile写入字符串信息</span></span><br><span class="line">  dataFile.close();                           <span class="comment">// 完成文件写入后关闭文件</span></span><br><span class="line">  Serial.println(F(<span class="string">&quot;Finished Writing data to SPIFFS&quot;</span>));</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 显示目录中文件内容以及文件大小</span></span><br><span class="line">  Dir dir = SPIFFS.openDir(folder_name);  <span class="comment">// 建立“目录”对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (dir.next()) &#123;  <span class="comment">// dir.next()用于检查目录中是否还有“下一个文件”</span></span><br><span class="line">    Serial.println(dir.fileName()); <span class="comment">// 输出文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="5-从闪存文件系统中删除文件"><a href="#5-从闪存文件系统中删除文件" class="headerlink" title="5.从闪存文件系统中删除文件"></a>5.从闪存文件系统中删除文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-remove</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">日期/Date（YYYYMMDD）      : 20191109</span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何删除SPIFFS中存储的文件                        </span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">String file_name = <span class="string">&quot;/taichi-maker/notes.txt&quot;</span>;              <span class="comment">//被读取的文件位置和名称</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(SPIFFS.begin())&#123; <span class="comment">// 启动闪存文件系统</span></span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;SPIFFS Failed to Start.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从闪存中删除file_name文件</span></span><br><span class="line">  <span class="keyword">if</span> (SPIFFS.remove(file_name))&#123;</span><br><span class="line">    </span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove sucess&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.print(file_name);</span><br><span class="line">    Serial.println(<span class="string">&quot; remove fail&quot;</span>);</span><br><span class="line">  &#125;                       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="6-显示闪存文件系统信息"><a href="#6-显示闪存文件系统信息" class="headerlink" title="6.显示闪存文件系统信息"></a>6.显示闪存文件系统信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name      : esp8266-flash-info</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose           : 此程序用于演示如何使用FSInfo对象来显示闪存文件系统状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FS.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">FSInfo fs_info;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line"> </span><br><span class="line">  SPIFFS.begin();       <span class="comment">//启动SPIFFS</span></span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;SPIFFS Started.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 闪存文件系统信息</span></span><br><span class="line">  SPIFFS.info(fs_info);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 可用空间总和（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;totalBytes: &quot;</span>);     </span><br><span class="line">  Serial.print(fs_info.totalBytes); </span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 已用空间（单位：字节）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;usedBytes: &quot;</span>); </span><br><span class="line">  Serial.print(fs_info.usedBytes);</span><br><span class="line">  Serial.println(<span class="string">&quot; Bytes&quot;</span>); </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最大文件名字符限制（含路径和&#x27;\0&#x27;）</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxPathLength: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxPathLength);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最多允许打开文件数量</span></span><br><span class="line">  Serial.print(<span class="string">&quot;maxOpenFiles: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.maxOpenFiles);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 存储块大小</span></span><br><span class="line">  Serial.print(<span class="string">&quot;blockSize: &quot;</span>); </span><br><span class="line">  Serial.println(fs_info.blockSize);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  Serial.print(<span class="string">&quot;: &quot;</span>);</span><br><span class="line">  Serial.println(fs_info.pageSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="ESP8266闪存文件应用"><a href="#ESP8266闪存文件应用" class="headerlink" title="ESP8266闪存文件应用"></a>ESP8266闪存文件应用</h2><p>向esp8266上传任意的文件类型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp8266网络服务器</title>
      <link href="/posts/56387d0f.html"/>
      <url>/posts/56387d0f.html</url>
      
        <content type="html"><![CDATA[<h2 id="ESP8266-NodeMCU网服务器"><a href="#ESP8266-NodeMCU网服务器" class="headerlink" title="ESP8266-NodeMCU网服务器"></a>ESP8266-NodeMCU网服务器</h2><h3 id="建立基本网络服务器"><a href="#建立基本网络服务器" class="headerlink" title="建立基本网络服务器"></a>建立基本网络服务器</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/web-server/">建立基本网络服务器</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">项目名称/Project          : 零基础入门学用物联网</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页（Hello from ESP8266）</span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立ESP8266WebServer对象，对象名称为esp8266_server</span></span><br><span class="line">                                    <span class="comment">// 括号中的数字是网路服务器响应http请求的端口号</span></span><br><span class="line">                                    <span class="comment">// 网络服务器标准http端口号为80，因此这里使用80为端口号</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1</span></span><br><span class="line">  esp8266_server.begin();                   <span class="comment">//  详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">//  第3章-第2节 ESP8266-NodeMCU网络服务器-1</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"><span class="comment">//--------&quot;启动网络服务功能&quot;程序部分结束--------</span></span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数语句为本示例程序重点3</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下两个函数为本示例程序重点2</span></span><br><span class="line"><span class="comment">详细讲解请参见太极创客网站《零基础入门学用物联网》</span></span><br><span class="line"><span class="comment">第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/</span>                                                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站根目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;Hello from ESP8266&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这段示例程序上传给NodeMCU以后，启动NodeMCU并且确保它已经成功连接WiFi。接下来请打开浏览器，并且在地址栏中输入NodeMCU的IP地址并按下回车。假如将在浏览器中看到“Hello from ESP8266”，那么恭喜你已经成功的让NodeMCU实现了网络服务功能，因为你所看到的这条文字信息正是来自于NodeMCU。换句话说，NodeMCU为你建立了一个超级迷你的小网站。这个网站只有一个网页。这个网页只有一行文字“Hello from ESP8266”。</p><p>&nbsp;</p><h3 id="通过网络服务实现NodeMCU开发板基本控制"><a href="#通过网络服务实现NodeMCU开发板基本控制" class="headerlink" title="通过网络服务实现NodeMCU开发板基本控制"></a>通过网络服务实现NodeMCU开发板基本控制</h3><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/pin-control/">通过网络服务实现NodeMCU开发板基本控制 </a></p><p>在网页中控制nodemcu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_2_Turning_on_and_off_an_LED</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址</span></span><br><span class="line"><span class="comment">                           访问8266所建立的基本网页并通过该页面点亮/熄灭NodeMCU的内置LED</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是 &#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT); <span class="comment">//设置内置LED引脚为输出模式以便控制LED</span></span><br><span class="line">  </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);</span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 通过串口监视器输出连接的WiFi名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);</span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// 通过串口监视器输出ESP8266-NodeMCU的IP</span></span><br><span class="line"> </span><br><span class="line">  esp8266_server.begin();                           <span class="comment">// 启动网站服务</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, HTTP_GET, handleRoot);     <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/LED&quot;</span>, HTTP_POST, handleLED);  <span class="comment">// 设置处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        <span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();                     <span class="comment">// 检查http服务器访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line"><span class="comment">  该函数的作用是每当有客户端访问NodeMCU服务器根目录时，</span></span><br><span class="line"><span class="comment">  NodeMCU都会向访问设备发送 HTTP 状态 200 (Ok) 这是send函数的第一个参数。</span></span><br><span class="line"><span class="comment">  同时NodeMCU还会向浏览器发送HTML代码，以下示例中send函数中第三个参数，</span></span><br><span class="line"><span class="comment">  也就是双引号中的内容就是NodeMCU发送的HTML代码。该代码可在网页中产生LED控制按钮。 </span></span><br><span class="line"><span class="comment">  当用户按下按钮时，浏览器将会向NodeMCU的/LED页面发送HTTP请求，请求方式为POST。</span></span><br><span class="line"><span class="comment">  NodeMCU接收到此请求后将会执行handleLED函数内容*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;       </span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;&lt;form action=\&quot;/LED\&quot; method=\&quot;POST\&quot;&gt;&lt;input type=\&quot;submit\&quot; value=\&quot;Toggle LED\&quot;&gt;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理LED控制请求的函数&#x27;handleLED&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleLED</span><span class="params">()</span> &#123;                          </span><br><span class="line">  digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN));<span class="comment">// 改变LED的点亮或者熄灭状态</span></span><br><span class="line">  esp8266_server.sendHeader(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;/&quot;</span>);          <span class="comment">// 跳转回页面根目录</span></span><br><span class="line">  esp8266_server.send(<span class="number">303</span>);                           <span class="comment">// 发送Http相应代码303 跳转  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>); <span class="comment">// 发送 HTTP 状态 404 (未找到页面) 并向浏览器发送文字 &quot;404: Not found&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过网络服务实现NodeMCU开发板基本控制-1"><a href="#通过网络服务实现NodeMCU开发板基本控制-1" class="headerlink" title="通过网络服务实现NodeMCU开发板基本控制"></a>通过网络服务实现NodeMCU开发板基本控制</h3><p>我们可以通过NodeMCU开发板上的FLASH按键控制D3引脚的电平。当我们没有按下该按键时，D3引脚将会保持高电平状态。当按下该按键后，D3引脚会变为低电平。</p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_3_Pin_State_Display</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该页面将会自动刷新并且显示NodeMCU</span></span><br><span class="line"><span class="comment">                           的D3引脚状态。NodeMCU开发板上的FLASH按键可以控制D3引脚的电平。</span></span><br><span class="line"><span class="comment">                           没有按下该按键时D3引脚将会保持高电平状态。当按下该按键后，</span></span><br><span class="line"><span class="comment">                           D3引脚会变为低电平。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WiFi<span class="variable">.h</span>&gt;        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WiFiMulti<span class="variable">.h</span>&gt;   <span class="comment">//  ESP8266WiFiMulti库</span></span><br><span class="line">#<span class="keyword">include</span> &lt;ESP8266WebServer<span class="variable">.h</span>&gt;   <span class="comment">//  ESP8266WebServer库</span></span><br><span class="line"> </span><br><span class="line">#define buttonPin D3            <span class="comment">// 按钮引脚D3</span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer esp8266_server(<span class="number">80</span>);<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line">bool pinState;  <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> setup()&#123;</span><br><span class="line">  Serial<span class="variable">.begin</span>(<span class="number">9600</span>);   <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU再启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti<span class="variable">.addAP</span>(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial<span class="variable">.println</span>(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti<span class="variable">.run</span>() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial<span class="variable">.print</span>(i++); Serial<span class="variable">.print</span>(&#x27; &#x27;);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial<span class="variable">.println</span>(&#x27;\n&#x27;);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial<span class="variable">.print</span>(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial<span class="variable">.println</span>(WiFi<span class="variable">.SSID</span>());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial<span class="variable">.print</span>(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial<span class="variable">.println</span>(WiFi<span class="variable">.localIP</span>());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server<span class="variable">.begin</span>();                   <span class="comment">// 启动网站服务                </span></span><br><span class="line">  esp8266_server<span class="variable">.on</span>(<span class="string">&quot;/&quot;</span>, handleRoot);       <span class="comment">// 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span></span><br><span class="line">  esp8266_server<span class="variable">.onNotFound</span>(handleNotFound);<span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;        </span></span><br><span class="line"> </span><br><span class="line">  Serial<span class="variable">.println</span>(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> loop()&#123;</span><br><span class="line">  esp8266_server<span class="variable">.handleClient</span>();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">*/</span>                                                                       </span><br><span class="line"><span class="keyword">void</span> handleRoot() &#123;   </span><br><span class="line">  String displayPinState;                   <span class="comment">// 存储按键状态的字符串变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pinState == HIGH)&#123;                     <span class="comment">// 当按键引脚D3为高电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: HIGH&quot;</span>; <span class="comment">// 字符串赋值高电平信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                  <span class="comment">// 当按键引脚D3为低电平</span></span><br><span class="line">    displayPinState = <span class="string">&quot;Button State: LOW&quot;</span>;  <span class="comment">// 字符串赋值低电平信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  esp8266_server<span class="variable">.send</span>(<span class="number">200</span>, <span class="string">&quot;text/plain&quot;</span>, displayPinState); </span><br><span class="line">                                            <span class="comment">// 向浏览器发送按键状态信息  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="keyword">void</span> handleNotFound()&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server<span class="variable">.send</span>(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然。也可以不用一种刷新网页，让其自动刷新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序名称/Program name     : 3_2_4_Pin_State_Display_Auto_Refresh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序目的/Purpose          : 使用NodeMCU建立基本服务器。该网页将显示引脚D3状态。同时状态会</span></span><br><span class="line"><span class="comment">                           每隔5秒钟更新一次。</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用 ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">//  ESP8266WiFiMulti库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span>   <span class="comment">//  ESP8266WebServer库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buttonPin D3            <span class="comment">// 按钮引脚D3</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line">ESP8266WebServer <span class="title function_">esp8266_server</span><span class="params">(<span class="number">80</span>)</span>;<span class="comment">// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span></span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> pinState;                      <span class="comment">// 存储引脚状态用变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);          <span class="comment">// 启动串口通讯</span></span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); <span class="comment">// 将按键引脚设置为输入上拉模式</span></span><br><span class="line"> </span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_1&quot;</span>, <span class="string">&quot;your_password_for_AP_1&quot;</span>); <span class="comment">// 将需要连接的一系列WiFi ID和密码输入这里</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_2&quot;</span>, <span class="string">&quot;your_password_for_AP_2&quot;</span>); <span class="comment">// ESP8266-NodeMCU在启动后会扫描当前网络</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;ssid_from_AP_3&quot;</span>, <span class="string">&quot;your_password_for_AP_3&quot;</span>); <span class="comment">// 环境查找是否有这里列出的WiFi ID。如果有</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);                            <span class="comment">// 则尝试使用此处存储的密码进行连接。</span></span><br><span class="line">                                                               <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多</span></span><br><span class="line">                                                               <span class="comment">// 的WiFi信息在此处。</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                          <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                             <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line">  <span class="comment">// WiFi连接成功后将通过串口监视器输出连接成功信息 </span></span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                  </span><br><span class="line">  esp8266_server.on(<span class="string">&quot;/&quot;</span>, handleRoot);      </span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"> </span><br><span class="line">  Serial.println(<span class="string">&quot;HTTP esp8266_server started&quot;</span>);<span class="comment">//  告知用户ESP8266网络服务功能已经启动</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  esp8266_server.handleClient();     <span class="comment">// 处理http服务器访问</span></span><br><span class="line">  pinState = digitalRead(buttonPin); <span class="comment">// 获取引脚状态</span></span><br><span class="line">&#125;                                                                   </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 以下函数处理网站首页的访问请求。此函数为本示例程序重点1</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoot</span><span class="params">()</span> &#123;   <span class="comment">//处理网站目录“/”的访问请求 </span></span><br><span class="line">  esp8266_server.send(<span class="number">200</span>, <span class="string">&quot;text/html&quot;</span>, sendHTML(pinState));  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建立用于发送给客户端浏览器的HTML代码。此代码将会每隔5秒刷新页面。</span></span><br><span class="line"><span class="comment">通过页面刷新，引脚的最新状态也会显示于页面中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String <span class="title function_">sendHTML</span><span class="params">(<span class="type">bool</span> buttonState)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  String htmlCode = <span class="string">&quot;&lt;!DOCTYPE html&gt; &lt;html&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;head&gt;&lt;meta http-equiv=&#x27;refresh&#x27; content=&#x27;5&#x27;/&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;title&gt;ESP8266 Butoon State&lt;/title&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;style&gt;html &#123; font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;body&#123;margin-top: 50px;&#125; h1 &#123;color: #444444;margin: 50px auto 30px;&#125; h3 &#123;color: #444444;margin-bottom: 50px;&#125;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/style&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/head&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;h1&gt;ESP8266 BUTTON STATE&lt;/h1&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(buttonState)</span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: HIGH&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;htmlCode +=<span class="string">&quot;&lt;p&gt;Button Status: LOW&lt;/p&gt;\n&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/body&gt;\n&quot;</span>;</span><br><span class="line">  htmlCode +=<span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> htmlCode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleNotFound</span><span class="params">()</span>&#123;                                        <span class="comment">// 当浏览器请求的网络资源无法在服务器找到时，</span></span><br><span class="line">  esp8266_server.send(<span class="number">404</span>, <span class="string">&quot;text/plain&quot;</span>, <span class="string">&quot;404: Not found&quot;</span>);   <span class="comment">// NodeMCU将调用此函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp8266</title>
      <link href="/posts/6450c6c0.html"/>
      <url>/posts/6450c6c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="esp8266-NodeMCU"><a href="#esp8266-NodeMCU" class="headerlink" title="esp8266-NodeMCU"></a>esp8266-NodeMCU</h1><p>esp8266的数字引脚电压是3.3v，即其引脚输出高电平就是3.3v。</p><p>设置数字引脚为读取模式，其所连接的电压不能超过3.3v。</p><p>模拟引脚可以读取电压范围0-1v。</p><h2 id="互联网协议"><a href="#互联网协议" class="headerlink" title="互联网协议"></a>互联网协议</h2><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>以下内容的具体解释也可以在<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/internet-basics/">第2章 互联网知识基础 – 太极创客 (taichi-maker.com)</a>中找到更好的解释。</p><div class="table-container"><table><thead><tr><th>分层名称</th><th>TCP/IP 包含以下协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP，FTP，mDNS，WebSocket，OSC…..</td></tr><tr><td>传输层</td><td>TCP,UDP</td></tr><tr><td>网络层</td><td>IP</td></tr><tr><td>链路层（网络接口层）</td><td>Ethernet,Wi-Fi…</td></tr></tbody></table></div><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层的主要作用是实现设备之间的物理链接。</p><p>链路层的主要作用是实现设备之间的物理链接。举例来说，我们日常使用的WiFi就是链路层协议中的一种。</p><h4 id="ESP8266利用WiFi联网时有三种工作模式。"><a href="#ESP8266利用WiFi联网时有三种工作模式。" class="headerlink" title="ESP8266利用WiFi联网时有三种工作模式。"></a>ESP8266利用WiFi联网时有三种工作模式。</h4><ul><li>接入点模式（esp8266自己当wifi）</li><li>无线终端模式（esp8266自己跟wifi进行连接，控制其他跟wifi连接后的设备）</li><li>混合模式</li></ul><p>&nbsp;</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>IP地址</li></ul><p>给设备提供地址功能</p><h4 id="IP协议版本"><a href="#IP协议版本" class="headerlink" title="IP协议版本"></a>IP协议版本</h4><p>查看电脑ip</p><p>命令提示符&gt;&gt;&gt;ipconfig</p><p>&nbsp;</p><p>网关相当于连接网络与网络之间的端口</p><p>wifi路由器会创建一个局域网，并给局域网内的每个设备分配一个ip地址，相对于互联网</p><p>&nbsp;</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>特点：稳</p><ul><li><p>保证所有数据都能被接收端接收</p></li><li><p>数据的传输顺序不会打乱</p></li><li><p>传输数据如有损坏则重发受损数据</p></li></ul><p>&nbsp;</p><p>TCP协议经常用于对数据稳定性要求比较高的领域</p><h4 id="TCP协议应用领域："><a href="#TCP协议应用领域：" class="headerlink" title="TCP协议应用领域："></a>TCP协议应用领域：</h4><ul><li>电子邮件</li><li>文件传输</li></ul><p>&nbsp;</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>特点：快</p><ul><li>UDP比TCP速度快</li><li>不保证所有数据都能被接收端接收数数据一旦受损的，UDP协议将抛弃受损数据。</li><li>有数据损坏不会重发受损数据</li></ul><p>&nbsp;</p><h4 id="UDP协议应用领域："><a href="#UDP协议应用领域：" class="headerlink" title="UDP协议应用领域："></a>UDP协议应用领域：</h4><ul><li>在线语音/视频</li><li>网游</li></ul><p>&nbsp;</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>由==请求==和==响应==进行工作的</p><h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET/HTTP/1.1    //请求行</span><br><span class="line">Host:www.taichi-maker.com   //请求头</span><br><span class="line">User-Agent:Mozilla/5.0（Windows NT 10.0WOW64）Accept：：text/html   </span><br><span class="line">Accept-Language:zh-CN,zh；q=0.8</span><br><span class="line">Accept-Encoding:gzip,deflate,sdch</span><br><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure><h6 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h6><h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>HTTP1.0定义了三种请求方法：GET,POST和HEAD方法。 、</p><h5 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h5><p>&nbsp;</p><p>&nbsp;</p><h2 id="ESP8266物联网开发基础"><a href="#ESP8266物联网开发基础" class="headerlink" title="ESP8266物联网开发基础"></a>ESP8266物联网开发基础</h2><p>安装esp8266的网址<a href="https://cn.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads">USB 至 UART 桥 VCP 驱动器 - 芯科科技 (silabs.com)</a></p><p>&nbsp;</p><h3 id="为开发板搭建开发环境"><a href="#为开发板搭建开发环境" class="headerlink" title="为开发板搭建开发环境"></a>为开发板搭建开发环境</h3><p>要想使用Arduino IDE来配合NodeMCU开发板使用，首先要对Arduino IDE进行设置工作。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/nodemcu-arduino-ide/">3-1-2 为ESP8266-NodeMCU搭建Arduino IDE开发环境 – 太极创客 (taichi-maker.com)</a></p><p>如果开发板库中没有，可以去网盘盘里进行手动安装。</p><p>&nbsp;</p><p>如果一切都正常安装，那么我们可以用如下一段代码测试，测试结果应为esp8266一个板载LED间断闪烁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// initialize digital pin LED_BUILTIN as an output.</span></span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the loop function runs over and over again forever</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED_BUILTIN, HIGH);  <span class="comment">// turn the LED on (HIGH is the voltage level)</span></span><br><span class="line">  delay(<span class="number">1000</span>);                      <span class="comment">// wait for a second</span></span><br><span class="line">  digitalWrite(LED_BUILTIN, LOW);   <span class="comment">// turn the LED off by making the voltage LOW</span></span><br><span class="line">  delay(<span class="number">1000</span>);                      <span class="comment">// wait for a second</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NodeMCU开发板的接入点模式"><a href="#NodeMCU开发板的接入点模式" class="headerlink" title="NodeMCU开发板的接入点模式"></a>NodeMCU开发板的接入点模式</h3><p>NodeMCU开发板可以建立WiFi网络供其它设备连接。当NodeMCU以此模式运行时，我们可以使用手机或者电脑搜索NodeMCU所发出的WiFi网络并进行连接。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/ap/">3-1-3 NodeMCU开发板的接入点模式 – 太极创客 (taichi-maker.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU接入点模式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序用于演示如何将NodeMCU以接入点模式工作。通过此程序，您可以使用</span></span><br><span class="line"><span class="comment">电脑或者手机连接NodeMCU所建立WiFi网络。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">网络名: taichi-maker</span></span><br><span class="line"><span class="comment">密码：12345678</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ssid = <span class="string">&quot;taichi-maker&quot;</span>; <span class="comment">// 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span></span><br><span class="line">                                   <span class="comment">// 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *password = <span class="string">&quot;12345678&quot;</span>;  <span class="comment">// 这里定义将要建立的WiFi密码。此处以12345678为示例</span></span><br><span class="line">                                    <span class="comment">// 您可以将自己想要使用的WiFi密码放入引号内</span></span><br><span class="line">                                    <span class="comment">// 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);              <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     <span class="comment">// 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span></span><br><span class="line">                                   <span class="comment">// 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span></span><br><span class="line">                                   <span class="comment">// 这两个参数具体内容在setup函数之前的位置进行定义。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.print(<span class="string">&quot;Access Point: &quot;</span>);    <span class="comment">// 通过串口监视器输出信息</span></span><br><span class="line">  Serial.println(ssid);              <span class="comment">// 告知用户NodeMCU所建立的WiFi名</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address: &quot;</span>);      <span class="comment">// 以及NodeMCU的IP地址</span></span><br><span class="line">  Serial.println(WiFi.softAPIP());   <span class="comment">// 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如上代码，我们可以创建一个wifi</p><p>连接过后在命令提示符中输入&gt;&gt;ping 192.168.4.1</p><p>ping就是用来测试我们的电脑是不是已经与某个网络设备成功连接了</p><p>&nbsp;</p><h3 id="NodeMCU开发板的无线终端模式"><a href="#NodeMCU开发板的无线终端模式" class="headerlink" title="NodeMCU开发板的无线终端模式"></a>NodeMCU开发板的无线终端模式</h3><p>NodeMCU通过WiFi连接无线路由器并访问互联网。</p><p><a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/station/">3-1-4 NodeMCU开发板的无线终端模式 – 太极创客 (taichi-maker.com)</a></p><p>以下示例程序用于演示如何使用NodeMCU以无线终端模式通过WiFi连接无线路由器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">本示例程序用于演示如何使用NodeMCU无线终端模式连接WiFi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>        <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid     = <span class="string">&quot;taichi-maker&quot;</span>;      <span class="comment">// 连接WiFi名（此处使用taichi-maker为示例）</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi名填入引号中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;12345678&quot;</span>;          <span class="comment">// 连接WiFi密码（此处使用12345678为示例）</span></span><br><span class="line">                                            <span class="comment">// 请将您需要连接的WiFi密码填入引号中</span></span><br><span class="line">                                            </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);         <span class="comment">// 启动串口通讯</span></span><br><span class="line">  </span><br><span class="line">  WiFi.begin(ssid, password);                  <span class="comment">// 启动网络连接</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to &quot;</span>);              <span class="comment">// 串口监视器输出网络连接信息</span></span><br><span class="line">  Serial.print(ssid); Serial.println(<span class="string">&quot; ...&quot;</span>);  <span class="comment">// 告知用户NodeMCU正在尝试WiFi连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                   <span class="comment">// 这一段程序语句用于检查WiFi是否连接成功</span></span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;      <span class="comment">// WiFi.status()函数的返回值是由NodeMCU的WiFi连接状态所决定的。 </span></span><br><span class="line">    delay(<span class="number">1000</span>);                               <span class="comment">// 如果WiFi连接成功则返回值为WL_CONNECTED                       </span></span><br><span class="line">    Serial.print(i++); Serial.print(<span class="string">&#x27; &#x27;</span>);      <span class="comment">// 此处通过While循环让NodeMCU每隔一秒钟检查一次WiFi.status()函数返回值</span></span><br><span class="line">  &#125;                                            <span class="comment">// 同时NodeMCU将通过串口监视器输出连接时长读秒。</span></span><br><span class="line">                                               <span class="comment">// 这个读秒是通过变量i每隔一秒自加1来实现的。</span></span><br><span class="line">                                               </span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);                          <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Connection established!&quot;</span>);   <span class="comment">// NodeMCU将通过串口监视器输出&quot;连接成功&quot;信息。</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:    &quot;</span>);             <span class="comment">// 同时还将输出NodeMCU的IP地址。这一功能是通过调用</span></span><br><span class="line">  Serial.println(WiFi.localIP());              <span class="comment">// WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以一次性添加很多wifi名称和密码，使nodemuc选择性添加最强信号的网络。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NodeMCU无线终端模式连接WiFi-2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">此程序将会控制NodeMCU在当前的网络环境里搜索预先存储好的WiFi。</span></span><br><span class="line"><span class="comment">一旦找到预存的WiFi名称，NodeMCU将会使用预存的密码信息尝试连接该WiFi。</span></span><br><span class="line"><span class="comment">如果同时找到多个预存WiFi，NodeMCU将会尝试连接信号最强的WiFi。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span>          <span class="comment">// 本程序使用ESP8266WiFi库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFiMulti.h&gt;</span>   <span class="comment">// 本程序使用ESP8266WiFiMulti库</span></span></span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     <span class="comment">// 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);            <span class="comment">// 启动串口通讯</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过addAp函数存储  WiFi名称       WiFi密码</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker&quot;</span>, <span class="string">&quot;12345678&quot;</span>);  <span class="comment">// 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker2&quot;</span>, <span class="string">&quot;87654321&quot;</span>); <span class="comment">// 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。</span></span><br><span class="line">  wifiMulti.addAP(<span class="string">&quot;taichi-maker3&quot;</span>, <span class="string">&quot;13572468&quot;</span>); <span class="comment">// 这3个网络的密码分别是123456789，87654321，13572468。</span></span><br><span class="line">                                                <span class="comment">// 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span></span><br><span class="line">                                                <span class="comment">// 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span></span><br><span class="line">                                                </span><br><span class="line">  Serial.println(<span class="string">&quot;Connecting ...&quot;</span>);         <span class="comment">// 通过串口监视器输出信息告知用户NodeMCU正在尝试连接WiFi</span></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;                                 </span><br><span class="line">  <span class="keyword">while</span> (wifiMulti.run() != WL_CONNECTED) &#123;  <span class="comment">// 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span></span><br><span class="line">    delay(<span class="number">1000</span>);                             <span class="comment">// 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span></span><br><span class="line">    Serial.print(<span class="string">&#x27;.&#x27;</span>);                       <span class="comment">// 将会连接信号最强的那一个WiFi信号。</span></span><br><span class="line">  &#125;                                           <span class="comment">// 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span></span><br><span class="line">                                              <span class="comment">// 此处while循环判断是否跳出循环的条件。</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.println(<span class="string">&#x27;\n&#x27;</span>);                     <span class="comment">// WiFi连接成功后</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connected to &quot;</span>);            <span class="comment">// NodeMCU将通过串口监视器输出。</span></span><br><span class="line">  Serial.println(WiFi.SSID());              <span class="comment">// 连接的WiFI名称</span></span><br><span class="line">  Serial.print(<span class="string">&quot;IP address:\t&quot;</span>);            <span class="comment">// 以及</span></span><br><span class="line">  Serial.println(WiFi.localIP());           <span class="comment">// NodeMCU的IP地址</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p>]]></content>
      
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inventor开发</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="app-inventor开发蓝牙app"><a href="#app-inventor开发蓝牙app" class="headerlink" title="app inventor开发蓝牙app"></a>app inventor开发蓝牙app</h1><h2 id="蓝牙app开发流程"><a href="#蓝牙app开发流程" class="headerlink" title="蓝牙app开发流程"></a>蓝牙app开发流程</h2><ol><li>App inventor开发APP</li><li>AT指令配置蓝牙模块</li><li>测试</li></ol><p>&nbsp;</p><p>App inventor网址：<a href="http://app.gzjkw.net/">http://app.gzjkw.net/</a></p><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="蓝牙的选择和断开"><a href="#蓝牙的选择和断开" class="headerlink" title="蓝牙的选择和断开"></a>蓝牙的选择和断开</h4><p>表格布局————列表选择框———-可以选择连接哪个蓝牙</p><p>&nbsp;</p><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><p>列表选择框</p>]]></content>
      
      
      
        <tags>
            
            <tag> app开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hc06</title>
      <link href="/posts/85bbd6e3.html"/>
      <url>/posts/85bbd6e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="HC-06-无线蓝牙串口透传模块"><a href="#HC-06-无线蓝牙串口透传模块" class="headerlink" title="HC-06 无线蓝牙串口透传模块"></a>HC-06 无线蓝牙串口透传模块</h1><p>arduino和hc06的高电平时不一样的</p><p>&nbsp;</p><h2 id="串口透传"><a href="#串口透传" class="headerlink" title="串口透传"></a>串口透传</h2><p>在数据传输过程中，数据不发生任何形式的改变，仿佛传输过程是透明的一样。数据原封不动地从发送者传到接收者。</p><h3 id="使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭"><a href="#使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭" class="headerlink" title="使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭"></a>使用Arduino通过无线蓝牙控制Arduino引脚11的LED点亮／熄灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">char</span> serialData;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(<span class="number">11</span>, OUTPUT); <span class="comment">//11引脚连接演示用LED</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( Serial.available()&gt;<span class="number">0</span> )&#123; </span><br><span class="line">    </span><br><span class="line">    serialData =  Serial.read();   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serialData == <span class="string">&#x27;1&#x27;</span> ) &#123;  <span class="comment">//接收到点亮LED指令</span></span><br><span class="line">      Serial.print(<span class="string">&quot;Got command: &quot;</span>);  Serial.println(serialData); </span><br><span class="line">      Serial.println(<span class="string">&quot;LED-ON&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      digitalWrite(<span class="number">11</span>, HIGH);  <span class="comment">//点亮LED指令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//接收到熄灭LED指令</span></span><br><span class="line">      Serial.print(<span class="string">&quot;Got command: &quot;</span>);  </span><br><span class="line">      Serial.println(serialData); </span><br><span class="line">      Serial.println(<span class="string">&quot;LED-OFF&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      digitalWrite(<span class="number">11</span>, LOW);      <span class="comment">//熄灭LED指令  </span></span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗"><a href="#使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗" class="headerlink" title="使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗"></a>使用Arduino通过无线蓝牙控制调节Arduino引脚11的LED明暗</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HC-06-Serial-LED-Fade</span></span><br><span class="line"><span class="comment">by 太极创客（2017-07-08）</span></span><br><span class="line"><span class="comment">www.taici-maker.com</span></span><br><span class="line"><span class="comment">此程序旨在演示如何利用HC-06蓝牙模块通过手机或平板电脑的</span></span><br><span class="line"><span class="comment">蓝牙功能来设置arduino开发板上11引脚上连接LED的亮度。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如需获得更多关于本程序的使用说明，请参见太极创客制作的《零基础入门学用Arduino》教程。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">---- 电路连接 ---- </span></span><br><span class="line"><span class="comment">HC-06     Arduino Uno R3 引脚</span></span><br><span class="line"><span class="comment">TX                0 (RX)  </span></span><br><span class="line"><span class="comment">RX                1 (TX)</span></span><br><span class="line"><span class="comment">VCC              +5v</span></span><br><span class="line"><span class="comment">GND              GND</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">LED       Arduino Uno R3 引脚</span></span><br><span class="line"><span class="comment"> +                11 (RX) </span></span><br><span class="line"><span class="comment"> -                GND (通过220欧姆限流电阻)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1. 须使用分压电路，确保HC-06 RX信号电压为3.3伏特。</span></span><br><span class="line"><span class="comment">2. 须先将此程序上传至ARDUINO后，再将HC-06连接在ARDUINO开发板的串口引脚上。</span></span><br><span class="line"><span class="comment">   否则程序将无法正常上传。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> brightness;  <span class="comment">//LED亮度变量</span></span><br><span class="line"><span class="type">int</span> serialData;  <span class="comment">//串口数据变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">  pinMode(<span class="number">11</span>, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( Serial.available()&gt;<span class="number">0</span> )&#123;             <span class="comment">//如果串口缓存有数据</span></span><br><span class="line">    serialData =  Serial.parseInt();      <span class="comment">//将串口缓存数值存储到serialData变量</span></span><br><span class="line">    Serial.print(<span class="string">&quot;serialData = &quot;</span>); Serial.println(serialData);  </span><br><span class="line">    <span class="keyword">if</span> (serialData &gt;=<span class="number">0</span> &amp;&amp; serialData &lt;= <span class="number">255</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (serialData &gt;= brightness)&#123;       <span class="comment">//逐渐调节LED亮度</span></span><br><span class="line">        <span class="keyword">for</span> (brightness; brightness &lt;= serialData; brightness++)&#123;</span><br><span class="line">          analogWrite(<span class="number">11</span>, brightness); </span><br><span class="line">          Serial.print(<span class="string">&quot;brightness = &quot;</span>); Serial.println(brightness);  </span><br><span class="line">          delay(<span class="number">5</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (brightness; brightness &gt;= serialData; brightness--)&#123;</span><br><span class="line">          analogWrite(<span class="number">11</span>, brightness); </span><br><span class="line">          Serial.print(<span class="string">&quot;brightness = &quot;</span>); Serial.println(brightness);          </span><br><span class="line">          delay(<span class="number">5</span>);          </span><br><span class="line">        &#125;        </span><br><span class="line">      &#125;       </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机</title>
      <link href="/posts/ef868677.html"/>
      <url>/posts/ef868677.html</url>
      
        <content type="html"><![CDATA[<h1 id="电机"><a href="#电机" class="headerlink" title="电机"></a>电机</h1><ul><li><p>普通直流电机</p></li><li><p>步进电机</p></li><li><p>伺服电机（舵机）</p></li></ul><p>  电机又称为电动机、马达，是一种通过电磁感应定律将电能转化成机械能，并可再使用机械能产生动能，用来驱动其他装置的电气设备。</p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>直流电机（DC）</li><li>交流电机（AC）</li><li>交直流两用电机（Universal）</li></ul><p>直流电机根据有无电刷可分为</p><ul><li><p>有刷直流电机（BDC）</p><p>电刷和换向器之间会不断进行摩擦</p></li><li><p>无刷直流电机（BLDC）</p></li></ul><p>​        转子的永磁场和定子的电磁场互动进行工作</p><h2 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h2><h3 id="有刷直流电机（BDC）主要参数"><a href="#有刷直流电机（BDC）主要参数" class="headerlink" title="有刷直流电机（BDC）主要参数"></a>有刷直流电机（BDC）主要参数</h3><h4 id="额定电流"><a href="#额定电流" class="headerlink" title="额定电流"></a>额定电流</h4><p>即电机在额定环境条件下可以长期连续工作的电流。</p><h4 id="空载转速"><a href="#空载转速" class="headerlink" title="空载转速"></a>空载转速</h4><p>电机不带任何负载的转速。</p><h4 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h4><p>重量、工作温度等。</p><p>&nbsp;</p><p>对于电机的控制，我们主要考虑电机的==旋转方向==和==旋转速度==</p><h5 id="旋转方向"><a href="#旋转方向" class="headerlink" title="旋转方向"></a>旋转方向</h5><p>H桥电路可以用来控制电机的旋转方向</p><h5 id="旋转速度"><a href="#旋转速度" class="headerlink" title="旋转速度"></a>旋转速度</h5><p>通过PWM控制转速</p><p>用arduino控制开关的开合，从而使电压产生PWM</p><p>&nbsp;</p><h2 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h2><ul><li>可精确控制电机输出轴角度</li><li>低速运行时可获得更高的扭矩</li><li>开环控制/性价比高</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>单极性步进电机</li><li>双极性步进电机</li></ul><h3 id="单-双极性步进电机比较"><a href="#单-双极性步进电机比较" class="headerlink" title="单/双极性步进电机比较"></a>单/双极性步进电机比较</h3><div class="table-container"><table><thead><tr><th>单极性</th><th>双极性</th></tr></thead><tbody><tr><td>通常有5-6条引线</td><td>通常有4条引线</td></tr><tr><td>相对输出扭矩低</td><td>通常输出扭矩高</td></tr><tr><td>控制电路相对简单</td><td>控制电路相对复杂</td></tr></tbody></table></div><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>永磁式步进电机（Permanent Magnet Stepper）</li><li>反应式步进电机（Variable Reluctance Stepper）</li><li>混含式步进电机（Hybrid Stepper）</li></ul><p>&nbsp;</p><p>永磁式步进电机的转子用永磁材料制成。</p><p>反应式步进电机的转子用软磁材料制成。</p><p>&nbsp;</p><h3 id="28BYJ-48-步进电机"><a href="#28BYJ-48-步进电机" class="headerlink" title="28BYJ-48 步进电机"></a>28BYJ-48 步进电机</h3><h4 id="永磁型单极性四相步进电机"><a href="#永磁型单极性四相步进电机" class="headerlink" title="永磁型单极性四相步进电机"></a>永磁型单极性四相步进电机</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红外遥控</title>
      <link href="/posts/24aabf4.html"/>
      <url>/posts/24aabf4.html</url>
      
        <content type="html"><![CDATA[<h2 id="红外遥控"><a href="#红外遥控" class="headerlink" title="红外遥控"></a>红外遥控</h2><p>常用红外协议资料<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/irremote-library/#ir-protocol">IRremote库 – 太极创客 (taichi-maker.com)</a></p><p>&nbsp;</p><h3 id="1838红外接收器"><a href="#1838红外接收器" class="headerlink" title="1838红外接收器"></a>1838红外接收器</h3> <div class="table-container"><table><thead><tr><th>1838红外接收器引脚</th><th>Arduino引脚</th><th></th></tr></thead><tbody><tr><td>OUT</td><td>11</td><td></td></tr><tr><td>VCC</td><td>+5V</td><td></td></tr><tr><td>GND</td><td>GND</td></tr></tbody></table></div><h3 id="红外接收（NEC协议）"><a href="#红外接收（NEC协议）" class="headerlink" title="红外接收（NEC协议）"></a>红外接收（NEC协议）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IRremote.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  RECV_PIN 11</span></span><br><span class="line"> </span><br><span class="line">IRrecv <span class="title function_">irrecv</span><span class="params">(RECV_PIN)</span>;   <span class="comment">// 红外遥控初始化</span></span><br><span class="line">decode_results results;   <span class="comment">// 储存接收到的红外遥控信息</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT);</span><br><span class="line">  digitalWrite(LED_BUILTIN, LOW);     </span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Enabling IRin&quot;</span>);</span><br><span class="line">  irrecv.enableIRIn();     <span class="comment">// 启动红外接收</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Enabled IRin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  decode()库函数用于判断红外接收器所接收到的红外信号是否可以被解析。</span></span><br><span class="line"><span class="comment">  如可以成功解析，则返回非零数值。并将解析结果存储于results中。</span></span><br><span class="line"><span class="comment">  如无法成功解析，则返回零。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  每一次解析完成，都需要调用resume()函数从而让Arduino开始准备接收下一个红外</span></span><br><span class="line"><span class="comment">  遥控指令。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (irrecv.decode(&amp;results)) &#123;  </span><br><span class="line">    Serial.println(results.value, HEX);  <span class="comment">// results.value为红外遥控信号的具体数值</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(results.value == <span class="number">0xF7C03F</span>) <span class="comment">//如果控制信息数值为F7C03F</span></span><br><span class="line">    &#123;          </span><br><span class="line">        Serial.println(<span class="string">&quot;Command Received: Turn On LED.&quot;</span>);</span><br><span class="line">        digitalWrite(LED_BUILTIN, HIGH); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(results.value == <span class="number">0xF740BF</span>) <span class="comment">//如果控制信息数值为F740BF</span></span><br><span class="line">    &#123;          </span><br><span class="line">        Serial.println(<span class="string">&quot;Command Received: Turn Off LED.&quot;</span>);</span><br><span class="line">        digitalWrite(LED_BUILTIN, LOW); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    irrecv.resume(); <span class="comment">// 恢复接收下一个红外遥控信号</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="信号发射"><a href="#信号发射" class="headerlink" title="信号发射"></a>信号发射</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IRremote.h&gt;</span></span></span><br><span class="line">IRsend irsend;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;  </span><br><span class="line">    irsend.sendNEC(<span class="number">0xF7C03F</span>, <span class="number">32</span>);  <span class="comment">//发射NEC红外遥控协议F7C03F指令码，16进制每个占用4bit，所以一共32个bit</span></span><br><span class="line">    delay(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * IRremote库支持NEC, Sony, Philips RC5, Philips RC6等协议指令。</span></span><br><span class="line"><span class="comment">  * 本示例程序中Arduino将通过调用函数sendSony(0xa90, 12) 来发射Sony协议指令。</span></span><br><span class="line"><span class="comment">  * 该函数的两个参数中， 0xa90为指令信息内容，12位指令信息位数。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 假如需要发射NEC协议指令则可以调用函数sendNEC(0xF7C03F, 32)。</span></span><br><span class="line"><span class="comment">  * 其中0xF740BF为指令信息内容，32位指令信息位数。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 如果需要发射其它遥控协议指令请参考以下程序代码：</span></span><br><span class="line"><span class="comment">  * sendNEC(unsigned long data, int nbits);   //发射NEC协议指令</span></span><br><span class="line"><span class="comment">  * sendSony(unsigned long data, int nbits);  //发射Sony协议指令</span></span><br><span class="line"><span class="comment">  * void sendRC5(unsigned long data, int nbits);   //发射Philips RC5协议指令</span></span><br><span class="line"><span class="comment">  * void sendRC6(unsigned long data, int nbits);   //发射Philips RC6协议指令</span></span><br><span class="line"><span class="comment">  * void sendSharp(unsigned long data, int nbits); //发射Sharp协议指令</span></span><br><span class="line"><span class="comment">  * void sendPanasonic(unsigned int address, unsigned long data); //发射Panasonic协议指令</span></span><br><span class="line"><span class="comment">  * void sendJVC(unsigned long data, int nbits, int repeat);  //发射JVC协议指令</span></span><br><span class="line"><span class="comment">  * void sendRaw(unsigned int buf[], int len, int hz);        //发射原始指令</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">//延迟5秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>红外LED发射的信号具有方向性</li><li>控制距离最远不超过2-3米</li><li>需要为红外LED配限流电阻</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arduino内存</title>
      <link href="/posts/44ae0abd.html"/>
      <url>/posts/44ae0abd.html</url>
      
        <content type="html"><![CDATA[<h2 id="arduino内存"><a href="#arduino内存" class="headerlink" title="arduino内存"></a>arduino内存</h2><p>内部储存单元由几种不同的介质组成</p><div class="table-container"><table><thead><tr><th>介质</th><th>名称</th><th>特点</th><th>储存特点</th></tr></thead><tbody><tr><td>FLASH</td><td>闪存（U盘）</td><td>价格低，读写慢</td><td>数量较大的静态信息。断电后可以保持存储内容。存储程序</td></tr><tr><td>SRAM</td><td>静态随机存储器</td><td>价格高，读写快</td><td>数量较小的动态信息，断电后不可以保持存储内容。储存程序变量</td></tr><tr><td>EEPROM</td><td>电可擦除可编程只读存储器</td><td>可擦写可编程 ，读写速度慢</td><td>只能读取信息，不能储存信息。（例如光盘）用于需要断电保持的程序变量</td></tr></tbody></table></div><p>&nbsp;</p><h3 id="在EEPROM中读取和储存数据"><a href="#在EEPROM中读取和储存数据" class="headerlink" title="在EEPROM中读取和储存数据"></a>在EEPROM中读取和储存数据</h3><p>对于arduino uno其有1024个字节（1kb）</p><p>可以储存1024个0~255十进制数</p><p>&nbsp;</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>SRAM资源远远小于FLASH资源</p><h3 id="优化SRAM"><a href="#优化SRAM" class="headerlink" title="优化SRAM"></a>优化SRAM</h3><h4 id="串口监视器输出时用"><a href="#串口监视器输出时用" class="headerlink" title="串口监视器输出时用"></a>串口监视器输出时用</h4><p>用SRAM储存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial. println(<span class="string">&quot;Taichi-Maker&quot;</span>);</span><br></pre></td></tr></table></figure><p>用FLASH储存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serial. println (F(<span class="string">&quot;Taichi-Maker&quot;</span>));</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="建立常量"><a href="#建立常量" class="headerlink" title="建立常量"></a>建立常量</h3><p>用SRAM储存静态信息会对使用空间进行浪费</p><p>此时我们可以用FLASH分担SRAM的压力</p><p>将常量储存在FLASH中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">125</span>;<span class="comment">//储存在SRAM中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PROGMEM a = <span class="number">125</span>；<span class="comment">//储存在Flash中</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>我们可以从下列代码中来体会全局变量和局部变量的特点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVarl；<span class="comment">//全局变量1</span></span><br><span class="line"><span class="type">int</span> globalVar2；<span class="comment">//全局变量2</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line">function_1（）；<span class="comment">//调用函数1</span></span><br><span class="line">function_2（）；<span class="comment">//调用函数2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> function_1（）&#123;</span><br><span class="line"><span class="type">int</span> localVarl；<span class="comment">//函数1局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> function_2&#123;</span><br><span class="line"><span class="type">int</span> localVar2；<span class="comment">//函数2局部变量</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>内存</th><th>特点</th></tr></thead><tbody><tr><td>SRAM</td><td>共享的局部变量</td></tr><tr><td>SRAM</td><td>独享的全局变量</td></tr></tbody></table></div><p>要更好地优化空间我们就需要尽量多使用==局部变量==代替==全局变量==</p><p>&nbsp;</p><h3 id="用bool型的变量代替int型的变量做逻辑判断"><a href="#用bool型的变量代替int型的变量做逻辑判断" class="headerlink" title="用bool型的变量代替int型的变量做逻辑判断"></a>用bool型的变量代替int型的变量做逻辑判断</h3><h4 id="用整形占用两个字节"><a href="#用整形占用两个字节" class="headerlink" title="用整形占用两个字节"></a>用整形占用两个字节</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a；　　<span class="comment">//变量a用于逻辑判断</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line"><span class="keyword">if</span>（a== <span class="number">1</span>）&#123;</span><br><span class="line"><span class="comment">//变量a等于1时执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h4 id="用bool占用一个字节"><a href="#用bool占用一个字节" class="headerlink" title="用bool占用一个字节"></a>用bool占用一个字节</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a；<span class="comment">//变量a用于逻辑判断</span></span><br><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">｝</span><br><span class="line"><span class="type">void</span> loop（）&#123;</span><br><span class="line"><span class="keyword">if</span>（a == <span class="number">1</span>）&#123;</span><br><span class="line"><span class="comment">//变量a等于1时执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>尽量使用占用内存少的数据类型</p><p>具体的数据类型及其相关信息可以参考这个网站<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/data-types/">Arduino常用数据类型简介 – 太极创客 (taichi-maker.com)</a></p><p>（8位微控制器）</p><p>&nbsp;</p><h3 id="优化FLASH"><a href="#优化FLASH" class="headerlink" title="优化FLASH"></a>优化FLASH</h3><p>即优化我们的arduino程序</p><h4 id="删除无用代码"><a href="#删除无用代码" class="headerlink" title="删除无用代码"></a>删除无用代码</h4><ul><li>无用库</li><li>无用变量</li><li>无用函数</li><li>无用代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LED</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h2 id="RGB-LED"><a href="#RGB-LED" class="headerlink" title="RGB-LED"></a>RGB-LED</h2><p>&nbsp;</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> rLedPin = <span class="number">6</span>; <span class="comment">//引脚R</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> gLedPin = <span class="number">5</span>; <span class="comment">//引脚G</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bLedPin = <span class="number">3</span>; <span class="comment">//引脚B</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ledR  = <span class="number">0</span>; <span class="comment">//R Led 亮度</span></span><br><span class="line"><span class="type">int</span> ledG  = <span class="number">0</span>; <span class="comment">//G Led 亮度</span></span><br><span class="line"><span class="type">int</span> ledB  = <span class="number">0</span>; <span class="comment">//B Led 亮度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(rLedPin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(gLedPin, OUTPUT);</span><br><span class="line">  <span class="built_in">pinMode</span>(bLedPin, OUTPUT);</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Welcome to Taichi-Maker RGB Led Tutorial.&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Please Input RGB value(eg. r128g100b20).&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (Serial.<span class="built_in">available</span>()&gt;<span class="number">0</span>) &#123; </span><br><span class="line">    <span class="type">char</span> serialCmdChar = Serial.<span class="built_in">read</span>();  </span><br><span class="line">    <span class="built_in">serialCmd</span>(serialCmdChar);       </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">50</span>);      </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serialCmd</span><span class="params">(<span class="type">char</span> serialCmdChar)</span> </span>&#123;  <span class="comment">//r128g100b20</span></span><br><span class="line">  <span class="keyword">switch</span> (serialCmdChar)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      ledR = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">      ledG = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      ledB = Serial.<span class="built_in">parseInt</span>();</span><br><span class="line">      <span class="keyword">break</span>;    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      ledR = <span class="number">0</span>;</span><br><span class="line">      ledG = <span class="number">0</span>;</span><br><span class="line">      ledB = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">analogWrite</span>(rLedPin, ledR);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">analogWrite</span>(gLedPin, ledG);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">analogWrite</span>(bLedPin, ledB); </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">100</span>); </span><br><span class="line">  </span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Red Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledR);</span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Green Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledG);</span><br><span class="line">  Serial.<span class="built_in">print</span> (<span class="string">&quot;Blue Value = &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span> (ledB);</span><br><span class="line">  Serial.<span class="built_in">println</span> (<span class="string">&quot;-------------&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红外人体感应模块</title>
      <link href="/posts/ea9332b4.html"/>
      <url>/posts/ea9332b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="红外人体感应模块"><a href="#红外人体感应模块" class="headerlink" title="红外人体感应模块"></a>红外人体感应模块</h2><h3 id="引脚信息"><a href="#引脚信息" class="headerlink" title="引脚信息"></a>引脚信息</h3><h3 id="人体感应传感器基本工作原理"><a href="#人体感应传感器基本工作原理" class="headerlink" title="人体感应传感器基本工作原理"></a>人体感应传感器基本工作原理</h3>d感应到区域内红外状况变化OUT引脚输出高电平OUT引脚输出低电平| 更多操作感应区域内红外状 | OUT引脚输出情况   || ------------------------ | ----------------- || 感应区域内红外状况变化   | OUT引脚输出高电平 || 感应区域内红外状况无变化 | OUT引脚输出低电平 |&nbsp;### 人体感应传感器模块基本参数- 工作电压范围（VCC）：直流电压4.5-20V- 电平输出（OUT）：高3.3 V/低OV- 工作温度：-15摄氏度$\pm ——70摄氏度### 代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> irSensorPin = <span class="number">7</span> ;            <span class="comment">// 连接红外传感器引脚</span></span><br><span class="line"><span class="type">bool</span> irSensorOutput;            <span class="comment">// 红外传感器输出信号</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(irSensorPin, INPUT);</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Welcome to Taichi-Maker&#x27;s IR Motion Sensor tutorial.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  irSensorOutput = digitalRead(irSensorPin);  <span class="comment">// 读取红外传感器输出</span></span><br><span class="line">  <span class="keyword">if</span> (irSensorOutput == HIGH) &#123;  <span class="comment">// 如果红外传感器输出高电平</span></span><br><span class="line">      Serial.println(<span class="string">&quot;IR Motion Sensor OUTPUT: HIGH.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;IR Motion Sensor OUTPUT: LOW.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="人体感应传感器模块感应距离调节"><a href="#人体感应传感器模块感应距离调节" class="headerlink" title="人体感应传感器模块感应距离调节"></a>人体感应传感器模块感应距离调节</h3><h3 id="人体感应传感器模块感应延时调节"><a href="#人体感应传感器模块感应延时调节" class="headerlink" title="人体感应传感器模块感应延时调节"></a>人体感应传感器模块感应延时调节</h3><h3 id="人体感应传感器模块触发方式"><a href="#人体感应传感器模块触发方式" class="headerlink" title="人体感应传感器模块触发方式"></a>人体感应传感器模块触发方式</h3><h4 id="触发方式：（可跳线选择）"><a href="#触发方式：（可跳线选择）" class="headerlink" title="触发方式：（可跳线选择）"></a>触发方式：（可跳线选择）</h4><p>L-不可重复触发方式<br>H-可重复触发方式</p><p>这两种方式最大区别在于模块在输出高电平的延迟时间内，是否再次检查监测区域内的红外状态有无变化</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><div class="table-container"><table><thead><tr><th>人体感应传感器模块触发方式</th><th>解释</th></tr></thead><tbody><tr><td>不可重复触发方式</td><td>即感应输出高电平后，延时时间内不再检查监测区域有无红外状态改变，当延时一结束，输出将自动从高电平变成低电平</td></tr><tr><td>可重复触发方式</td><td>即感应输出高电平后，延时时间内持续不断地检查监测区域有无红外状态改变，如果在延时结束前再次检查到区域内有红外状态改变，模块将重新开始延时</td></tr></tbody></table></div><p>两种触发方式区别：倒计时期间是否检查红外区域内的状况。</p><p>如果没有跳线：一般默认为可重复触发方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修音</title>
      <link href="/posts/1b69608.html"/>
      <url>/posts/1b69608.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件———-studio-one"><a href="#软件———-studio-one" class="headerlink" title="软件———-studio one"></a>软件———-studio one</h2><p>ctrl+m打开插件</p><h4 id="常规设置"><a href="#常规设置" class="headerlink" title="常规设置"></a>常规设置</h4><p>Studio One—-&gt;选项——&gt;常规</p><h4 id="定位设置"><a href="#定位设置" class="headerlink" title="定位设置"></a>定位设置</h4><h5 id="设置默认保存路径"><a href="#设置默认保存路径" class="headerlink" title="设置默认保存路径"></a>设置默认保存路径</h5><p>Studio One—-&gt;选项——-&gt;定位</p><h4 id="音频设置"><a href="#音频设置" class="headerlink" title="音频设置"></a>音频设置</h4><h5 id="选择声卡"><a href="#选择声卡" class="headerlink" title="选择声卡"></a>选择声卡</h5><p>Studio One—-&gt;选项——-&gt;音频设置</p><h4 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h4><p>视图——&gt;显示文件——&gt;直接拖入</p><h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><p>按空格键盘停止录音</p><h3 id="导出干声"><a href="#导出干声" class="headerlink" title="导出干声"></a>导出干声</h3><p>右键—-&gt;选择——&gt;输出选择</p><h5 id="如果有很多断点"><a href="#如果有很多断点" class="headerlink" title="如果有很多断点"></a>如果有很多断点</h5><p>点击S——&gt;乐曲——-&gt;导出混音——-&gt;导出范围———&gt;乐曲开始/结束标记之间</p><h3 id="导出混音"><a href="#导出混音" class="headerlink" title="导出混音"></a>导出混音</h3><h4 id="只想导出一段"><a href="#只想导出一段" class="headerlink" title="只想导出一段"></a>只想导出一段</h4><p>往上点击选择画笔工具勾选范围</p><h3 id="窗口得缩放"><a href="#窗口得缩放" class="headerlink" title="窗口得缩放"></a>窗口得缩放</h3><p>放大E，缩小W</p><h3 id="重录干声片段"><a href="#重录干声片段" class="headerlink" title="重录干声片段"></a>重录干声片段</h3><p>画笔工具选中——-&gt;按i激活穿插录音——&gt;点击录音</p><p>在到达这个区域前是不会进行录音的，右键选择录得最满意的一次</p><h3 id="节奏修正工具"><a href="#节奏修正工具" class="headerlink" title="节奏修正工具"></a>节奏修正工具</h3><p>点击音频轨上的==音频弯曲==工具———-&gt;点击分析———&gt;</p><h3 id="消除无声音频块"><a href="#消除无声音频块" class="headerlink" title="消除无声音频块"></a>消除无声音频块</h3><p>点击音频轨上的==消除无声==工具——&gt;手册模式——-&gt;应用（适当提高最小长度，可以把间隔不是很长的音频快都保存下来）</p><p>设计开启级别可以去掉区范围以下的噪音</p><h3 id="吸附功能"><a href="#吸附功能" class="headerlink" title="吸附功能"></a>吸附功能</h3><p>点击音频轨上的==吸附功能==工具——-&gt;选择量化的节拍</p><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><p>切出来一片———&gt;拖拽上方的小方块</p><h3 id="交叉淡化"><a href="#交叉淡化" class="headerlink" title="交叉淡化"></a>交叉淡化</h3><p>讲两块音频合成一起进行交叉，点击x后即完成交叉淡化</p><h3 id="节拍器"><a href="#节拍器" class="headerlink" title="节拍器"></a>节拍器</h3><p>alt+方向键：音频向某个方向走10ms</p><h3 id="自动化控制"><a href="#自动化控制" class="headerlink" title="自动化控制"></a>自动化控制</h3><p>左下角的小箭头N——-&gt;选择写入————&gt;点击读取 </p><h3 id="升降调"><a href="#升降调" class="headerlink" title="升降调"></a>升降调</h3><p>右键音频片段———-&gt;更改变调———-&gt;（这个变调是针对整个音频轨来说的）</p><h3 id="音频加速减速"><a href="#音频加速减速" class="headerlink" title="音频加速减速"></a>音频加速减速</h3><p>右键音频片段———-&gt;更改变速———-&gt;（这个变速是针对整个音频轨来说的）</p><h3 id="标记轨的使用"><a href="#标记轨的使用" class="headerlink" title="标记轨的使用"></a>标记轨的使用</h3><p>整体听一下，提前标记好什么地方需要修改</p><p>左边得标记上有一个加号，可以加标签</p><h3 id="设置声像"><a href="#设置声像" class="headerlink" title="设置声像"></a>设置声像</h3><p>按f4打开检察器</p><h3 id="认识调音台"><a href="#认识调音台" class="headerlink" title="认识调音台"></a>认识调音台</h3><p>按f3打开 调音台 </p><p>监听，可以听到自己录音时的声音</p><h3 id="插入效果器"><a href="#插入效果器" class="headerlink" title="插入效果器"></a>插入效果器</h3><p>浏览——&gt;效果器————&gt;厂商—-&gt;PreSonus———-&gt;</p><p>f3打开混音器———&gt;拖入效果器放到插入一栏中（或者拖入到轨道）———&gt;</p><h3 id="发送效果"><a href="#发送效果" class="headerlink" title="发送效果"></a>发送效果</h3><p>在轨道下方f3点击发送旁边的加号➕————&gt;添加效果通道————&gt;</p><p>一般这个发送的插入效果用在做混响或延迟</p><h3 id="创建BUS轨"><a href="#创建BUS轨" class="headerlink" title="创建BUS轨"></a>创建BUS轨</h3><p>多选轨道———-&gt;为已选择音轨增加Bus</p><p>此时的bus轨就是可以同时控制多选轨道的一个轨</p><h3 id="分配VCA推子"><a href="#分配VCA推子" class="headerlink" title="分配VCA推子"></a>分配VCA推子</h3><p>多选轨道———-&gt;为已选择音轨增加Vca———-&gt;以一定比例增加或减少音量</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/posts/155618b9.html"/>
      <url>/posts/155618b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h1><h2 id="随机实验"><a href="#随机实验" class="headerlink" title="随机实验"></a>随机实验</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>可以在相同的条件下重复地进行</li><li>每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果</li><li>进行一次试验之前不能确定哪一个结果会出现</li></ol><p>&nbsp;</p><h2 id="样本空间，随机事件"><a href="#样本空间，随机事件" class="headerlink" title="样本空间，随机事件"></a>样本空间，随机事件</h2><div class="table-container"><table><thead><tr><th>名称</th><th>特点</th></tr></thead><tbody><tr><td>样本空间</td><td>随机试验E的所有可能结果组成的集合</td></tr><tr><td>样本点（基本事件）</td><td>样本空间的元素，即E的每个结果</td></tr></tbody></table></div><p>样本空间的两种记法</p><p>$A_{1}=\{0,1,2,3\}$</p><p>$A_{2}=\{x|\mathrm0\leq x\leq3\}$</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="集合理论"><a href="#集合理论" class="headerlink" title="集合理论"></a>集合理论</h2><div class="table-container"><table><thead><tr><th>示例图</th><th>公式</th><th>意义</th></tr></thead><tbody><tr><td>1-1</td><td>$A\subset B$</td><td>A发生必导致B发生</td></tr><tr><td>1-2</td><td>$A \cup B=\left \{  x</td><td>x \in A  {或}x \in B  \right \} $</td><td>A和B的和事件</td></tr><tr><td>1-3</td><td>$A \cap B=\left \{  x</td><td>x \in A  {且}x \in B  \right \} $</td><td>A和B的积事件</td></tr><tr><td>1-4</td><td>$A-B=\{x</td><td>x\in A \mathbb {且}x\notin B\}$</td><td>A和B的差事件</td></tr><tr><td>1-5</td><td>$A\cap B=\varnothing$</td><td>A和B是互斥的</td></tr><tr><td>1-6</td><td>$A\cup B=S{且} A\cap B=\varnothing$</td><td>A与B互为逆事件</td></tr></tbody></table></div><h3 id="进行事件运算时要用到以下定律"><a href="#进行事件运算时要用到以下定律" class="headerlink" title="进行事件运算时要用到以下定律"></a>进行事件运算时要用到以下定律</h3><div class="table-container"><table><thead><tr><th>定律</th><th>公式</th><th>备注</th></tr></thead><tbody><tr><td>交换律</td><td>$A\cup B=B\cup A;A\cap B=B\cap A$</td><td></td></tr><tr><td>结合律</td><td>$A\cup(B\cup C)=(A\cup B)\cup C \\A\cap\left(B\cap C\right)=\left(A\cap B\right)\cap C$</td><td></td></tr><tr><td>分配律</td><td>$A\cap\left(B\cap C\right)=\left(A\cap B\right)\cap C \\ A\cap(B\cup C)=(A\cap B)\cup(A\cap C)$</td><td>注意括号里的符号</td></tr><tr><td>德摩根律</td><td>$\overline{A\cup B}=\overline{A}\cap\overline{B} \\ \overline{A\cap B}=\overline{A}\cup\overline{B}$</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><h2 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h2><h3 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h3><p>在相同的条件下，进行了n次试验，在这n次试验中</p><div class="table-container"><table><thead><tr><th>名称</th><th>特点</th></tr></thead><tbody><tr><td>频数</td><td>事件A发生的次数</td></tr><tr><td>频率</td><td>比值$n_A/n$称为事件A发生的频率</td></tr></tbody></table></div><p>&nbsp;</p><h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><ol><li>$0\leqslant f_n(A)\leqslant1$</li><li>$f_{n}\left(S\right)=1$</li><li>若$A_{1},A_{2},\cdots,A_{k}$是两两互不相容的事件，则$f_n(A_1\cup A_2\cup\cdots\cup A_s)=f_s(A_1)+f_s(A_2)+\cdots+f_s(A_s).$</li></ol><p>&nbsp;</p><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><h4 id="基本性质-1"><a href="#基本性质-1" class="headerlink" title="基本性质"></a>基本性质</h4><p>设E是随机试验，S是它的样本空间.对于E的每一事件A赋予一个实数，记为P（A），称为事件A的概率</p><p>集合函数P满足一个重要的条件；</p><ul><li>==可列可加性==</li></ul><p>设$A_{1},A_{2},\cdots$是两两互不相容的事件，即对于$A_{i}A_{j}=\varnothing$，$i\neq j,i,j=1,2,\cdots,$有$P(A_{1}\cup A_{2}\cup\cdots\big)=P(A_{1})+P(A_{2})+\cdots.$</p><p>&nbsp;</p><h4 id="重要的性质"><a href="#重要的性质" class="headerlink" title="重要的性质"></a>重要的性质</h4><div class="table-container"><table><thead><tr><th>性质</th><th>公式</th></tr></thead><tbody><tr><td>有限可加性</td><td>若$A_1,A_2,\cdots,A_n$是两两互不相容的事件，则$P(A_{1}\cup A_{2}\cup\cdots\cup A_{n})=P(A_{1})+P(A_{2})+\cdots+P(A_{n})$</td></tr><tr><td>性质iii</td><td>设A，B是两个事件，若$A\subset B$，则有$\begin{array}{c}{P(B-A)=P(B)-P(A);}\\ {P(B)\geq P(A).}\\ \end{array}$</td></tr><tr><td>加法公式</td><td>对于任意两事件A，B有$P(A\cup B)=P(A)+P(B)-P(A B)$</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>串口通信</title>
      <link href="/posts/edc30276.html"/>
      <url>/posts/edc30276.html</url>
      
        <content type="html"><![CDATA[<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><div class="table-container"><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>引脚O RX</td><td>接收（Receive）</td></tr><tr><td>引脚1 TX</td><td>发送（Transmit）</td></tr></tbody></table></div><p>RX TX工作时，相应LED会闪烁</p><p>所有要进行串口通讯的设备，接地必须连在一起</p><p>ardunio：TTL标准（0V-5V）</p><p>每一位数据所持续的时间<br>通过波特率来限定<br>波特率：9600→每秒传输9600位</p><p>Serial. available（）函数，</p><p>Serial.available 返回串口接收缓存中等待传输的数据字节数量</p><p>Serial. read 读取数据</p><p>Serial.read成功读取数据后Arduino将已经被读取的数据从缓存中清除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setup（）&#123;</span><br><span class="line">Serial.begin（<span class="number">9600</span>）；<span class="comment">//启动串口通讯，传输波特率9600</span></span><br><span class="line">Serial.println（<span class="string">&quot;Please input serial data&quot;</span>）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="type">void</span> loop <span class="keyword">if</span>（Serial.available（）&gt;<span class="number">0</span>）&#123;<span class="comment">//检查串口缓存是否有数据等待传输</span></span><br><span class="line"><span class="type">int</span> serialData Serial.read（）；</span><br><span class="line">Serial.println（serialData）；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入角度控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myServo;         <span class="comment">//创建Servo对象myServo</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dataIndex = <span class="number">0</span>;     <span class="comment">//创建整数型变量，存储输入数据序列号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myServo.attach(<span class="number">6</span>);</span><br><span class="line">  Serial.begin(<span class="number">9600</span>); <span class="comment">//启动串口通讯，传输波特率9600</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Please input serial data.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;          <span class="comment">// 检查串口缓存是否有数据等待传输 </span></span><br><span class="line">  <span class="keyword">if</span> ( Serial.available()&gt;<span class="number">0</span> ) &#123;  </span><br><span class="line">    dataIndex++;       <span class="comment">// 处理数据序列号并通过串口监视器显示</span></span><br><span class="line">    Serial.print(<span class="string">&quot;dataIndex = &quot;</span>);</span><br><span class="line">    Serial.print(dataIndex);</span><br><span class="line">    Serial.print(<span class="string">&quot; , &quot;</span>);      </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos = Serial.parseInt();   <span class="comment">// 解析串口数据中的整数信息并赋值给变量pos</span></span><br><span class="line">    Serial.print(<span class="string">&quot;Set servo position: &quot;</span>);</span><br><span class="line">    Serial.println(pos);           <span class="comment">// 通过串口监视器显示变量pos数值</span></span><br><span class="line">    myServo.write(pos);             <span class="comment">// 使用pos变量数值设置伺服电机</span></span><br><span class="line">    delay(<span class="number">15</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>让其他引脚实现串行通信（软件模拟）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftwareSerial BTserial（<span class="number">2</span>，<span class="number">3</span>）；<span class="comment">//建立SoftwareSerial对象，RX引脚2，TX引脚3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/posts/ee040603.html"/>
      <url>/posts/ee040603.html</url>
      
        <content type="html"><![CDATA[<h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：</p><script type="math/tex; mode=display">G=(V, E)</script><p>其中：G表示一个图，V是图G中顶点的集合，E是图G中顶点之间边的集合。</p><p>&nbsp;</p><p>在线性表中，元素个数可以为零，称为空表；</p><p>在树中，结点个数可以为零，称为空树；</p><p>在图中，顶点个数不能为零，但可以没有边。(没有空图的概念)</p><p>&nbsp;</p><h2 id="图的逻辑结构"><a href="#图的逻辑结构" class="headerlink" title="图的逻辑结构"></a>图的逻辑结构</h2><p>若顶点$v_i$和$v_j$之间的边没有方向，则称这条边为无向边，表示为$(v_i,v_j)$。<br>如果图的任意两个顶点之间的边都是无向边，则称该图为无向图<br></p><p>若从顶点v，到v，的边有方向，则称这条边为有向边，表示为<vi，v>。<br>如果图的任意两个顶点之间的边都是有向边，则称该图为有向图</vi，v></p><h3 id="图的基本术语"><a href="#图的基本术语" class="headerlink" title="图的基本术语"></a>图的基本术语</h3><p>简单图：在图中，若不存在顶点到其自身的边，且同一条边不重复出现。</p><p>数据结构中讨论的都是简单图。</p><p>&nbsp;</p><h3 id="邻接-依附"><a href="#邻接-依附" class="headerlink" title="邻接,依附"></a>邻接,依附</h3><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p>无向图中，对于任意两个顶点$v_i$，和顶点$v_j$，若存在边$(v_i,v_j)$，则称顶点$v_i$，和顶点$v_j$，互为<strong>邻接</strong>点，同时称边$(v_i,v_j)$依附于顶点$v_i$，和顶点$v_j$</p><p>$v_0$的邻接点：$v_1$,$v_3$<br>$v_1$的邻接点:$v_0$,$v_2$,$v_4$</p><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p>无向图中，对于任意两个顶点$v_i$，和顶点$v_j$，若存在弧$<v_i,v_j>$，则称顶点$v_i$，和顶点$v_j$，互为<strong>邻接</strong>点，同时称弧$<v_i,v_j>$依附于顶点$v_i$，和顶点$v_j$</v_i,v_j></v_i,v_j></p><p>&nbsp;</p><h4 id="不同逻辑结构关系的对比"><a href="#不同逻辑结构关系的对比" class="headerlink" title="不同逻辑结构关系的对比"></a>不同逻辑结构关系的对比</h4><p>在线性结构中，数据元素之间仅具有线性关系；<br>在树结构中，结点之间具有层次关系；<br>在图结构中，任意两个顶点之间都可能有关系。</p><p>在线性结构中，元素之间的关系为前驱和后继<br>在树结构中，结点之间的关系为双亲和孩子<br>在图结构中，顶点之间的关系为邻接。<br>&nbsp;</p><h4 id="图的基本术语-1"><a href="#图的基本术语-1" class="headerlink" title="图的基本术语"></a>图的基本术语</h4><p>无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。<br>有向完全图：在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图</p><p>含有n个顶点的无向完全图有$n\times（n-1）/2$条边。<br>含有n个顶点的有向完全图有$n\times （n-1）$条弧。</p><p>&nbsp;</p><p>稀疏图：称边数很少的图为稀疏图；稠密图：称边数很多的图为稠密图。<br>顶点的度：在无向图中，顶点v的度是指依附于该顶点的边数，通常记为$TD（v）$。<br>顶点的入度：在有向图中，顶点v的入度是指以该顶点为弧头的弧的数目，记为$ID（v）$；顶点的出度：在有向图中，顶点v的出度是指以该顶点为弧尾的弧的数目，记为$OD（v）$。</p><p>&nbsp;</p><p>在具有n个顶点、e条边的无向图中，各顶点的度之和与边数之和有如下关系</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}T D\left(\nu_{i}\right)=2e</script><p>在具有n个顶点、e条边的有向图中，各顶点的入度之和与各顶点的出度之和有如下关系</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}ID\left(v_i\right)=\sum\limits_{i=1}^{n}OD\left(v_i\right)=e</script><p>&nbsp;</p><p>权：是指对边赋予的有意义的数值量。(一个节点到另一个结点需要的代价)<br>网：边上带权的图，也称网图</p><h4 id="路的长度"><a href="#路的长度" class="headerlink" title="路的长度"></a>路的长度</h4><p>非带权图  ————&gt;  路径上边的个数<br>带权图      ————&gt;  路径上各边的权之和</p><h4 id="回路，简单路径，简单回路"><a href="#回路，简单路径，简单回路" class="headerlink" title="回路，简单路径，简单回路"></a>回路，简单路径，简单回路</h4><p>回路（环）：第一个顶点和最后一个顶点相同的路径。<br>简单路径：序列中顶点不重复出现的路径。<br>简单回路（简单环）：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路。</p><p>&nbsp;</p><h4 id="连通图，连通分量"><a href="#连通图，连通分量" class="headerlink" title="连通图，连通分量"></a>连通图，连通分量</h4><p>连通图：在无向图中，如果从一个顶点$v_i$，到另一个顶点$v_j(i\ne j)$有路径，则称顶点$v_i$，和$v_j$，是连通的。如果图中任意两个顶点都是连通的，则称该图是连通图。<br>连通分量：非连通图的极大连通子图称为连通分量。</p><p>​    1.含有极大顶点数；<br>​    2.依附于这些顶点的所有边</p><p>强连通图：在有向图中，对图中任意一对顶点$v_i$，$v_j(i\ne j)$，若从顶点$v_i$，到顶点$v_j$，和从顶点$v_j$，到顶点$v_i$，均有路径则称该有向图是强连通图。<br>强连通分量：非强连通图的极大强连通子图。</p><p>&nbsp;</p><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><p>生成树：n个顶点的连通图G的生成树是包含G中全部顶点的一个$极小连通子图$。</p><p>含有n-1条边，多一条构成回路，少一条不连通</p><p>生成森林：在非连通图中，由每个连通分量都可以得到一棵生成树，这些连通分量的生成树就组成了一个非连通图的生成森林。</p><p>&nbsp;</p><h2 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h2><h4 id="图的粗存结构及实现"><a href="#图的粗存结构及实现" class="headerlink" title="图的粗存结构及实现"></a>图的粗存结构及实现</h4><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>基本思想：用一个一维数组存储图中顶点的信息，用一个二维数组（称为邻接矩阵）存储图中各顶点之间的邻接关系。</p><h5 id="无向图的邻接矩阵"><a href="#无向图的邻接矩阵" class="headerlink" title="无向图的邻接矩阵"></a>无向图的邻接矩阵</h5> <p>特点：</p><p>主对角线为0且一定是对称矩阵。</p><h5 id="如何求邻接矩阵中的度"><a href="#如何求邻接矩阵中的度" class="headerlink" title="如何求邻接矩阵中的度"></a>如何求邻接矩阵中的度</h5><p>通过扫描该点邻接矩阵中的行</p><p>该点边表中结点的个数</p><p>&nbsp;</p><h5 id="有向图的临界矩阵"><a href="#有向图的临界矩阵" class="headerlink" title="有向图的临界矩阵"></a>有向图的临界矩阵</h5><p>可能不是对称的</p><p>&nbsp;</p><h5 id="网图邻接矩阵的定义"><a href="#网图邻接矩阵的定义" class="headerlink" title="网图邻接矩阵的定义"></a>网图邻接矩阵的定义</h5><script type="math/tex; mode=display">\textbf{arc}[i][j]=\left\{\begin{array}{l}\boldsymbol{w}_{ij}，若(v_i,v_j)\in E(或<v_i,v_j>\in E)\\ \boldsymbol{0},若i=j\\{\infty}，其他\end{array}\right.</script><h4 id="图的储存结构及实现"><a href="#图的储存结构及实现" class="headerlink" title="图的储存结构及实现"></a>图的储存结构及实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_VERTEX=<span class="number">10</span>;<span class="comment">//图的最大顶点数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Data Type vertex[MAX_VERTEX];  </span><br><span class="line"><span class="type">int</span> arc[MAX_VERTEX][MAX_VERTEX];</span><br><span class="line"><span class="type">int</span> vertexNum， arcNum；</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="built_in">MGraph</span>(DataType v[]，<span class="type">int</span> n，<span class="type">int</span> e);<span class="comment">//构造函数</span></span><br><span class="line">-<span class="built_in">MGraph</span>();           <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>; <span class="comment">//深度遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTrayerse</span><span class="params">(<span class="type">int</span> v)</span></span>;  <span class="comment">//广度遍历</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="构造函数的实现"><a href="#构造函数的实现" class="headerlink" title="构造函数的实现"></a>构造函数的实现</h4><p>邻接矩阵中图的基本操作——构造函数<br>1.确定图的顶点个数和边的个数；<br>2.输入顶点信息存储在一维数组vertex中；<br>3.初始化邻接矩阵arc；<br>4.依次输入每条边存储在邻接矩阵arc中；<br>    4.1输入边依附的两个顶点的序号i，j；<br>    4.2将邻接矩阵的第i行第j列的元素值置为1；<br>    4.3将邻接矩阵的第j行第i列的元素值置为1；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MGraph::MGraph（Data Type v[], <span class="type">int</span> n,<span class="type">int</span> e）&#123;</span><br><span class="line">vertexNum = n;</span><br><span class="line">arcNum = e;</span><br><span class="line"><span class="keyword">for</span> （i = <span class="number">0</span>; i &lt; vertexNum; i++）</span><br><span class="line">vertex[i] = v[i];</span><br><span class="line"><span class="keyword">for</span> （i = <span class="number">0</span>; i &lt; vertexNum; i++）</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> （j = <span class="number">0</span>; j &lt; vertexNum; j++）</span><br><span class="line">arc[i][] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> （i = <span class="number">0</span>; i&lt; arcNum; i++）[ <span class="comment">//依次输入每一条边</span></span><br><span class="line">cin &gt;&gt;vi&gt;&gt;vj； <span class="comment">//输入边依附的两个顶点的编号</span></span><br><span class="line">arc[vi][vj] = <span class="number">1</span>; <span class="comment">//置有边标志</span></span><br><span class="line">arc[vj][vi] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>图的邻接矩阵储存结构的空间复杂度？</p><p>假设图G有n个顶点e条边，则储存该图需要$O(n^2)$</p><p>&nbsp;</p><p>如果为稀疏图则会出现什么现象？</p><p>邻接表储存的基本思想：对于图的每个顶点$v_i$，将所有邻接于$v_i$的顶点链成一个单链表，称为顶点$v_i$的边表（对于有向图则称为出边表）所有边表的头指针和存储顶点信息的一维数组构成了顶点表。</p><p>&nbsp;</p><div class="table-container"><table><thead><tr><th>vertex</th><th>数据域，存放顶点信息</th></tr></thead><tbody><tr><td>firstEdge</td><td>指针域，指向边表中第一个结点</td></tr><tr><td>adjvex</td><td>邻接点域，边的终点在顶点表中的下标</td></tr><tr><td>next</td><td>指针域，指向边表中的下一个结点</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcNode</span><span class="comment">//边表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> adjvex;</span><br><span class="line">ArcNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> <span class="comment">//顶点表</span></span><br><span class="line">&#123;</span><br><span class="line">DataType vertex;</span><br><span class="line">ArcNode *fristEdge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="图的存储结构及实现"><a href="#图的存储结构及实现" class="headerlink" title="图的存储结构及实现"></a>图的存储结构及实现</h4><h5 id="邻接表存储有向图的类"><a href="#邻接表存储有向图的类" class="headerlink" title="邻接表存储有向图的类"></a>邻接表存储有向图的类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAx_VERTEX = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ALGraph</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">VertexNode adjList[MAX_VERTEX];</span><br><span class="line"><span class="type">int</span> vertexNum,arcNum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ALGraph</span>(DataType v[],<span class="type">int</span> n,<span class="type">int</span> e);<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">ALGraph</span>();                      <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(<span class="type">int</span> v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="邻接表中图的基本操作——构造函数"><a href="#邻接表中图的基本操作——构造函数" class="headerlink" title="邻接表中图的基本操作——构造函数"></a>邻接表中图的基本操作——构造函数</h5><p>1.确定图的顶点个数和边的个数</p><p>2.输入顶点信息，初始化该顶点的边表</p><p>3.依次输入边的信息并储存在边表中</p><p>​    3.1输入边所依附的两个顶点的序号$v_i$和$v_j$</p><p>​    3.2生成邻接点序号为$v_j$的边表结点s</p><p>​    3.3将结点s插入到第$v_i$个边表的头部</p><p>&nbsp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ALGraph:: <span class="built_in">ALGraph</span>(DataType v[], <span class="type">int</span> n, <span class="type">int</span> e)&#123;</span><br><span class="line">vertexNum = n;</span><br><span class="line">arcNum = e;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line"><span class="comment">//初始化顶点信息，指针域都为空</span></span><br><span class="line">adjList[i].vertex = v[i];</span><br><span class="line">adjList[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; arcNum ;i++)&#123;</span><br><span class="line">        <span class="comment">//输入边的信息存储在边表中</span></span><br><span class="line">        cin&gt;&gt;vi&gt;&gt;vj;<span class="comment">//输入边依附的两个顶点的编号</span></span><br><span class="line">        s = newArcNode;</span><br><span class="line">        s-&gt;adjvex = vj;</span><br><span class="line">        s-&gt;next = adjList[vi].fristEdge;</span><br><span class="line">        adjList[vi].fristEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>将邻接表和逆邻接表合二为一，方便计算每个结点的入读和出度。</p><p>要频繁计算数据的入度和出度，用十字链表。</p><div class="table-container"><table><thead><tr><th></th><th>空间性能</th><th>时间性能</th><th>适用范围</th><th>唯一</th></tr></thead><tbody><tr><td>邻接矩阵</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>稠密图</td><td>唯一</td></tr><tr><td>邻接表</td><td>$O(n+e)$</td><td>$O(n+e)$</td><td>稀疏图</td><td>不唯一</td></tr></tbody></table></div><p>&nbsp;</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>1.在图中，任何两个顶点之间都可能存在边，顶点是没有确定的先后次序的，所以，顶点的编号不唯一。<br>为了定义操作的方便，将图中的顶点按任意顺序排列起来，比如，按顶点的存储顺序。</p><p>2.从某个起点始可能到达不了所有其它顶点，怎么办？</p><p>解决方案：多次调用从某顶点出发遍历图的算法。</p><p>3.因图中可能存在回路，某些顶点可能会被重复访问，那么如何避免遍历不会因回路而陷入死循环。</p><p>解决方案：附设访问标志数组visited[n]</p><p>4.在图中，一个顶点可以和其它多个顶点相连，当这样的顶点访问过后，如何选取下一个要访问的顶点？</p><p>深度和广度优先遍历</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>（1）访问顶点v；<br>（2）从v的未被访问的邻接点中选取一个顶点w，从w出发进行深度优先遍历；<br>（3）重复上述两步，直至图中所有和v有路径相通的顶点都被访问到。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>1.访问顶点v；visited[v]= 1；<br>2.w=顶点v的第一个邻接点；<br>3.while（w存在）<br>    3.1 if（w未被访问）从顶点w出发递归执行该算法；<br>    3.2 w=顶点v的下一个邻接点；</p><h5 id="邻接表实现"><a href="#邻接表实现" class="headerlink" title="邻接表实现"></a>邻接表实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALGraph::DFSTraverse</span><span class="params">(<span class="type">int</span> * visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;  <span class="comment">//循环遍历每个顶点</span></span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line"><span class="built_in">DFS</span>(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALGraph::DFS</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> *visited)</span> </span>&#123;   <span class="comment">//遍历单个头顶点</span></span><br><span class="line"></span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; adjList[v].vertex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ArcNode *p = adjList[v].firstEdge;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[p-&gt;adjvex]) &#123;</span><br><span class="line"><span class="built_in">DFS</span>(p-&gt;adjvex, visited);</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="邻接矩阵实现"><a href="#邻接矩阵实现" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">DFS</span>(<span class="type">int</span> i,<span class="type">int</span> * visited)&#123;</span><br><span class="line">cout&lt;&lt;vertex[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[j] == <span class="number">0</span>&amp;&amp;arc[i][j] != <span class="number">0</span> &amp;&amp;arc[i][j] != INFINIT)&#123;</span><br><span class="line"><span class="built_in">DFS</span>(j,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">DFSTraverse</span>(<span class="type">int</span> * visited)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line"><span class="built_in">DFS</span>(i,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>基本思想：<br>（1）访问顶点v；<br>（2）依次访问v的各个未被访问的邻接点v1，V2，..，Vk<br>（3）分别从v1，V2,…., Vk出发依次访问它们未被访问的邻接点，并使“先被访问顶点的邻接点”先于后被访问顶点的邻接点”被访问。直至图中所有与顶点v有路径相通的顶点都被访问到。</p><h5 id="邻接表实现-1"><a href="#邻接表实现-1" class="headerlink" title="邻接表实现"></a>邻接表实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALGraph::BFSTraverse</span><span class="params">(<span class="type">int</span> * visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line"><span class="built_in">BFS</span>(i, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ALGraph::BFS</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> *visited)</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">cout&lt;&lt;adjList[temp].vertex&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ArcNode * p = adjList[i].firstEdge;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[p-&gt;adjvex])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(p-&gt;adjvex);</span><br><span class="line">visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="邻接矩阵实现-1"><a href="#邻接矩阵实现-1" class="headerlink" title="邻接矩阵实现"></a>邻接矩阵实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">BFS</span>(<span class="type">int</span> i,<span class="type">int</span> * visited)&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">cout&lt;&lt;vertex[temp]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vertexNum;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vertex[i]&amp;&amp;arc[i][j]!=<span class="number">0</span>&amp;&amp;arc[i][j]!=INFINIT)&#123;</span><br><span class="line"></span><br><span class="line">visited[j] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MGraph&lt;T&gt;::<span class="built_in">BFSTraverse</span>(<span class="type">int</span> * visited)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line"><span class="built_in">BFS</span>(i,visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="最短路径（Dijkstra算法）"><a href="#最短路径（Dijkstra算法）" class="headerlink" title="最短路径（Dijkstra算法）"></a>最短路径（Dijkstra算法）</h2><p>在网图中，最短路径是指两顶点之间经历的边上权值之和最短的路径。</p><h3 id="单源点最短路径问题"><a href="#单源点最短路径问题" class="headerlink" title="单源点最短路径问题"></a>单源点最短路径问题</h3><p>问题描述：给定带权有向图G=（V，E）和源点v$\in $V，求从v到G中其余各顶点的最短路径。</p><p>图的存储结构：带权的邻接矩阵存储结构</p><p>数组dist[n]：每个分量dist[i]表示当前所找到的从始点v到终点$v_i$，的最短路径的长度。初态为：若从v到$v_i$，有弧，则dist[i]为弧上权值；否则置dist[i]为$\infty $。<br>数组path[n]： path[i]是一个字符串，表示当前所找到的从始点v到终点$v_i$，的最短路径。初态为：若从v到<br>$v_i$有弧，则path[i]为0；否则置path[i]为-1。<br>数组s[n]：存放源点和已经生成的终点，其初态为只有一个源点v。</p><p>&nbsp;</p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><p>1.初始化数组dist、path和s；</p><ol><li>while （s中的元素个数&lt;n）<br>2.1 在dist[n]中求最小值，其下标为k；<br>2.2 输出dist[j]和path[jl；<br>2.3修改数组dist和path；<br>2.4将顶点$v_k$添加到数组s中；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++基础</title>
      <link href="/posts/7b58e60a.html"/>
      <url>/posts/7b58e60a.html</url>
      
        <content type="html"><![CDATA[<h2 id="c-基础"><a href="#c-基础" class="headerlink" title="c++基础"></a>c++基础</h2><h3 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a>new与delete</h3><p>new，delete用于堆空间的分配与回收</p><p>new：用于从堆中分配指定大小得内存区域，并返回内存区域得首地址，相较于malloc可以自动计算大小，无需指针转换。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>delete:用于释放new分配的堆内存</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用是某个对象（即变量）的别名，定义形式如下：</p><p>类型&amp;引用名 = 变量名；</p><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><p>引用很少单独使用，<strong>常常作为形参</strong>的方式</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>（1）在变量声明时出现&amp;才是引用运算符，其它地方的&amp;都是取地址运算符；<br>（2）引用代表一个变量的别名，必须在定义时初始化，不能在定义完成后再赋值；<br>（3）一个引用名只能作为一个变量的别名；</p><p>&nbsp;</p><h3 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h3><h4 id="传地址方式"><a href="#传地址方式" class="headerlink" title="传地址方式"></a>传地址方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span>;</span><br></pre></td></tr></table></figure><p>传地址方式的要点是：main函数和swap函数共用x，y变量的存储空间，只不过在main函数中，用x，y访问此空间；而在swap函数中，则用$<em>p1，</em>p2$这种间接访问方式访问此空间。由于空间是共用的，所以形参$<em>p1，</em>p2$发生了改变，也就影响到了实参x，y。</p><p>&nbsp;</p><h4 id="传引用方式"><a href="#传引用方式" class="headerlink" title="传引用方式"></a>传引用方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br></pre></td></tr></table></figure><p>传引用方式的要点是：在main中，用变量x，y访问存储空间，在swap函数中，用变量的别名a，b访问存储空间。由于a，b就可以看成是x，y，因此交换了a，b的内容，自然就影响了x，y。</p><p>&nbsp;</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h4 id="类与对象的基本概念"><a href="#类与对象的基本概念" class="headerlink" title="类与对象的基本概念"></a>类与对象的基本概念</h4><p>类（class）：它将数据以及这些数据上的操作封装在一起。</p><p>对象（object）：是具有类类型的变量</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><h4 id="构造函数重载"><a href="#构造函数重载" class="headerlink" title="构造函数重载"></a>构造函数重载</h4><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二阶方程</title>
      <link href="/posts/1636524d.html"/>
      <url>/posts/1636524d.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性齐次方程"><a href="#线性齐次方程" class="headerlink" title="线性齐次方程"></a>线性齐次方程</h1><p>形如$x’’+p(t)x’+q(t)x=f(t)$的形式，当f(t)等于零的时候，就是线性齐次方程，否则就是非齐次的方程。</p><p>对于一个普通的二阶线性齐次方程，$x’’+x=0$  $z=x^{\prime}=\frac{d x}{d t}$</p><script type="math/tex; mode=display">x''=\frac{dx'}{dt}=\frac{dz}{dt}=\frac{dz}{dx}\:\frac{dx}{dt}=z\:\frac{dz}{dx}</script><script type="math/tex; mode=display">z\frac{dz}{dx}+x=0</script><script type="math/tex; mode=display">z\:dz+x\:dx=0</script><p>有$\frac{z^{2}}{2}+\frac{x^{2}}{2}=c$可以写作$\:z^{2}+x^{2}=k_{1}$,$x^{\prime}={\frac{d x}{d t}}=\pm{\sqrt{k_{1}-x^{2}}}$</p><script type="math/tex; mode=display">\frac{\pm\:dx}{\sqrt{k_1-x^2}}=dt</script><script type="math/tex; mode=display">s i n^{-1}\frac{x}{\sqrt{k_{1}}}=t+k_2,或者\frac{x}{\sqrt{k_{1}}}=\sin(t+k_{2})</script><p>此时令$k_{2}=0\mathrm{,}{\sqrt{k_{1}}}=c_{1}$</p><p>正负的两种情况是$x=c_1\sin t$和$x=c_2\cos t$,因此，它的解是$x=c_1\:sin t+c_2\:cos t$</p><p>就是找到两个方程的特殊解，然后使得这个方程的其他的解都能够表示成两个特殊解的线性方程组合（通解）。</p><p>1.二阶齐形方程可能有无穷多个零点。</p><p>2.最大或者最小值的解不会在t=0的上下。例如:$x=(t-1)^2$</p><p>即不会出现$x’(t_0)=x’(t)=0$</p><h1 id="线性无关和朗斯基行列式"><a href="#线性无关和朗斯基行列式" class="headerlink" title="线性无关和朗斯基行列式"></a>线性无关和朗斯基行列式</h1><p>对于两个方程$f(x)$和$g(x)$,证明其是线性无关的，只需要证明$c_1f(x)+c_2g(x)=0$当且仅当$c_1=c_2=0$时成立，即可证明。</p><p>例如：$f(t)=sint$,$g(t)=cost$</p><p>当t=0，$c_2$=0；当t=$\frac{\pi}{2}$,$c_1=0$,若$c_1,c_2$要满足对所有的t都成立，那么有$c_1=c_2=0$</p><p>&nbsp;</p><h3 id="朗斯基行列式"><a href="#朗斯基行列式" class="headerlink" title="朗斯基行列式"></a>朗斯基行列式</h3><p>对下列行列式判断是否线性</p><script type="math/tex; mode=display">\left\{\begin{array}{c}c_1\sin t+c_2\cos t=0\\ c_1\cos t-c_2\sin t=0\end{array}\right.</script><p>可以写作下面的朗斯基行列式。</p><script type="math/tex; mode=display">W(f,g)(t)=\begin{vmatrix}f(t)&g(t)\\ f'(t)&g'(t)\end{vmatrix}=f(t)g'(t)-f'(t)g(t)</script><p>那么对于任意的二阶齐形方程$x’’+p(t)x’+q(t)x=0$,都有$W(t)=c e^{-\int p(t)\:dt}$</p><p>如果c=0，那么W(t)恒等于0，否则W(t)不等于0.</p><p>$W(t)=x_1x_2’-x_1’x_2$——-&gt;$W^{\prime}(t)=x_{1}x_{2}^{\prime\prime}-x_{2}x_{1}^{\prime\prime}$——-&gt;$x_{1}^{\prime\prime}=-p(t)x_{1}^{\prime}-q(t)x_{1}$———-&gt;$x_{2}^{\prime\prime}={-}p(t)x_{2}^{\prime}-q(t)x_{2}$——-&gt;$W^{\prime}(t)=[-p(t)x_{2}^{\prime}-q(t)x_{2}]x_{1}-[-p(t)x_{1}^{\prime}-q(t)x_{1}]x_{2}=-p(t)[x_{1}x_{2}^{\prime}-x_{1}^{\prime}x_{2}]=-p(t)W(t)$</p><p>如此便转化成一个可分方程：$W(t)=\stackrel{.}{c}e^{-\int p(t)\:d t}$</p><p>&nbsp;</p><p>如果朗斯基行列式等于0，说明两个解是线性相关的</p><p>如果W(t)不等于0，说明两个解是线性无关的，且两个解叫做方程的两个基本解（fundamental solution）。</p><p>&nbsp;</p><p>如果给了方程的$x=c_1x_1+c_2x_2$，证明$x_1和x_2$是方程的基本解。</p><p>&nbsp;</p><h3 id="已知一个解求另一个解"><a href="#已知一个解求另一个解" class="headerlink" title="已知一个解求另一个解"></a>已知一个解求另一个解</h3><p>在一个二阶方程中，我们已知一个一般解$x_1(t)$,-此时如果$x_1(t) \ne 0$，我们可以通过如下的式子求出另一个一般解$x_2(t)$</p><script type="math/tex; mode=display">x_2(t)=x_1(t)\int\frac{e^{-\int p(t)dt}}{x_1^2(t)}dt</script><p>&nbsp;</p><h3 id="线性非齐次方程"><a href="#线性非齐次方程" class="headerlink" title="线性非齐次方程"></a>线性非齐次方程</h3><p>有如下形式</p><script type="math/tex; mode=display">x''+p(t)x'+q(t)x=f(t).</script><p>带入$x_1$和$x_2$后将两式相减，可以得到如下方程</p><script type="math/tex; mode=display">(x_1''-x_2'')+p(t)(x_1'-x_2')+a(t)(x_1-x_2)=0.</script><p>有二阶线性非齐次方程的一个特解$x_p$</p><p>带入可知$x_P’’+p(t)x_p’+q(t)x_p=f(t).$</p><p>可知，此二阶线性齐次方程的通解为$x=c_1x_1+c_2x_2+x_p$</p><p>&nbsp;</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于如下的二阶非齐次方程</p><script type="math/tex; mode=display">x''+p(t)x'+q(t)x=f(t)</script><p>解题步骤如下</p><p>1.先令<script type="math/tex">f(t)\equiv0</script>，求出$x”+ p（t）x’+ g（t）x = f（t）$的特解$x_1$与$x_2$</p><p>2.非齐次方程的通解可以表示为：$x=c_1x_1+c_2x_2+x_p,$其中<script type="math/tex">x_p=v_1(t)x_1+v_2(t)x_2</script></p><p>3.求解$v_1(t),v_2(t)$</p><p>​        （1）列方程组</p><script type="math/tex; mode=display">\begin{cases}v'_1x_1+v'_2x_2=0\\{}\\v'_1x'_1+v'_2x'_2=f(t)\end{cases}</script><p>​        （2）克莱姆法则求解</p><p><img src="https://i.imgtg.com/2022/11/22/4Bv2S.png" alt="4Bv2S.png" border="0"></p><script type="math/tex; mode=display">v1'=\dfrac{\begin{vmatrix}0&x_2\\ f(t)&x_1'\end{vmatrix}}{W(t)}=-\dfrac{x_2f(t)}{W(t)}v2'=\dfrac{\begin{vmatrix}x_1&0\\ x_1'&f(t)\end{vmatrix}}{W(t)}=-\dfrac{x_1f(t)}{W(t)}</script><p>​        （3）对$v_1’(t)和v(2)’(t)$求解</p><script type="math/tex; mode=display">v_1=\int v_1'dt,v_2=\int v_2'dt</script><p>​        （4）最终可得齐次方程通解:$x=c_1x_1+c_2x_2+x_p$</p><p>&nbsp;</p><h2 id="具有常系数的线性齐次方程组"><a href="#具有常系数的线性齐次方程组" class="headerlink" title="具有常系数的线性齐次方程组"></a>具有常系数的线性齐次方程组</h2><p>方程有如下形式</p><script type="math/tex; mode=display">ax''+bx'+cx=0</script><p>当我们设$x(t)=e^{mt}$带入方程可得</p><script type="math/tex; mode=display">am^2e^{mt}+bme^{mt}+ce^{mt}=0</script><p>化简可得(特征方程)</p><script type="math/tex; mode=display">am^2+bm+c=0</script><p>此时可以求出方程的两个解</p><script type="math/tex; mode=display">m=\frac{-b\pm\sqrt{b^2-4ac}}{2a}</script><p>一般情况下有三种情况：</p><p>​    case1:   $b^2-4ac&gt;\textbf{0}$</p><p>此时方程有两个不同解</p><script type="math/tex; mode=display">m_1=\dfrac{-b+\sqrt{b^2-4ac}}{2a},m_2=\dfrac{-b-\sqrt{b^2-4ac}}{2a}</script><p>此时有方程的解$x=c_1e^{m_1t}+c_2e^{m_2t}$</p><p>&nbsp;</p><p>​    case2:   $b^2-4ac={0}$</p><p>（1）求出唯一解</p><p>此时m有唯一解$m=-\frac{b}{2a}$,代入可得方程的解为$x_1=e^{-\frac{b}{2a}t}$.</p><p>（2）已知一解，求另一解</p><script type="math/tex; mode=display">x_2=e^{-\frac{b}{2a}t}\int\frac{e^{-\frac{b}{a}t}}{(e^{-\frac{b}{2a}t})^2}dt=e^{-\frac{b}{2a}t}\int\frac{e^{-\frac{b}{a}t}}{e^{-\frac{b}{a}t}}dt=e^{-\frac{b}{2a}t}\int dt=te^{-\frac{b}{2a}t}</script><p>（3）得出方程的解</p><script type="math/tex; mode=display">x=c_{1}e^{-\frac{b}{2a}t}+c_{2}t e^{-\frac{b}{2a}t}</script><p> case3：$\quad b^2-4ac&lt;0\quad\text{}$没有实数解</p><p>（1）求出特征方程的解</p><script type="math/tex; mode=display">m=\frac{-b\pm\sqrt{4ac-b^2}{i}}{2a}=u\pm\lambda\text{i}</script><p>有$e^{\mu+\lambda i}=e^{\mu}e^{\lambda i}=e^{\mu}(\mathrm{cos}\lambda+i\mathrm{sin}\lambda)$</p><p>可知两个解分别为$x_1 = u(t),x_2=i(t)$</p><p>  (2)此方程的通解为</p><script type="math/tex; mode=display">c_1x_1+c_2x_2\\C_1\mathrm{e}^{ut}\cos\lambda t+C_2\mathrm{e}^{ut}\sin\lambda t</script><script type="math/tex; mode=display">x=c_1e^{\mu t}\cos{\lambda t}+c_2e^{\mu t}\sin{\lambda t}=e^{\mu t}(c_1\cos{\lambda t}+c_2\sin{\lambda t})</script><p>&nbsp;</p><h2 id="欧拉方程（Euler-equation）"><a href="#欧拉方程（Euler-equation）" class="headerlink" title="欧拉方程（Euler equation）"></a>欧拉方程（Euler equation）</h2><p>欧拉方程形式如下</p><script type="math/tex; mode=display">at^2x''+btx'+cx=0,\quad t>0</script><p>求解方法：</p><p>1.令$t=e^s,s=lnt$</p><p>2.则有</p><p>​    （1）$\frac{ds}{dt}=\frac{1}{t}=\frac{1}{e^s}$</p><p>​    （2）${\frac{\mathrm{d}x}{\mathrm{d}t}}={\frac{\mathrm{d}x}{\mathrm{d}s}}\cdot{\frac{\mathrm{d}s}{\mathrm{d}t}}={\frac{1}{t}}\cdot{\frac{\mathrm{d}x}{\mathrm{d}s}}$</p><p>​    $\frac{\mathrm{d}^2x}{\mathrm{d}t^2}=\frac{\mathrm{d}}{\mathrm{d}t}\left(\frac{1}{t}\cdot\frac{\mathrm{d}x}{\mathrm{d}s}\right)\\\hspace{5cm}=-\frac{1}{t^{2}}\cdot\frac{\mathrm{d}x}{\mathrm{d}s}+\frac{1}{t}\cdot\frac{\mathrm{d}}{\mathrm{d}s}\left(\frac{\mathrm{d}x}{\mathrm{d}s}\right)\cdot\frac{\mathrm{d}s}{\mathrm{d}t}\\\hspace{3cm}=-\frac{1}{t^2}\cdot\frac{\text{d}x}{\text{d}s}+\frac{1}{t^2}\cdot\frac{\text{d}^2x}{\text{d}s^2}$</p><p>可得：$\left\{\begin{array}{c}<br>tx’ = t \frac{\mathrm{d} x}{\mathrm{~d} t}=\frac{\mathrm{d} x}{\mathrm{~d} s} \\<br>t^{2}x’’=t^{2} \frac{\mathrm{d}^{2} x}{\mathrm{~d} t^{2}}=-\frac{\mathrm{d} x}{\mathrm{~d} s}+\frac{\mathrm{d}^{2} x}{\mathrm{~d} s^{2}}<br>\end{array}\right.$</p><p>​    （3）将上式带入原方程，此时原方程（1）可变为$a\frac{\mathrm d^2x}{\mathrm d s^2}+(b-a)\frac{\mathrm dx}{\mathrm d s}+cx=0$</p><p>即此特征方程为$am^2+(b-a)m+c=0$</p><p>可知其通解为：$x=c_1x_1(s)+c_2x_2(s)$</p><p>​    （4）根据常系数的二阶微分方程的求解方法$e^{mt}(am^2+(b-a)m+c)=0$</p><p>​    （5）分三种情讨论$\begin{cases}\Delta&gt;0\\ \\ \Delta=0\\ \\ \Delta&lt;0\end{cases}$</p><p>​    （6）最终用$s = lnt替换掉结果中的s得到x(t)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 常微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子学</title>
      <link href="/posts/9992c400.html"/>
      <url>/posts/9992c400.html</url>
      
        <content type="html"><![CDATA[<h1 id="电子学"><a href="#电子学" class="headerlink" title="电子学"></a>电子学</h1><p>电子学是研究<strong>电子运动</strong>和<strong>控制</strong>的科学分支。</p><h3 id="主要电子元件"><a href="#主要电子元件" class="headerlink" title="主要电子元件"></a>主要电子元件</h3><p>电阻：它限制了电流的流动，因此，电阻是用来控制电路中的电压的。</p><p>电容器：它被用来在两块板之间以电荷的形式出储存能量。</p><p>电感器：以磁能的形式储存电能。</p><h2 id="材料概述"><a href="#材料概述" class="headerlink" title="材料概述"></a>材料概述</h2><p>在材料学中，材料主要被分为导体，绝缘体和半导体</p><p>导体(Metals):能让电流或热通过的材料被称为导体。</p><p>绝缘体(Insulators)：不允许电流或热通过的导体</p><p>半导体(Semiconductors)：介于导体和半导体之间具有导电性的材料</p><p>半导体广泛应用于各种电子器件，如晶体管、<strong>集成电路</strong>和二极管。</p><h2 id="能带图（Energy-band-Diagram）"><a href="#能带图（Energy-band-Diagram）" class="headerlink" title="能带图（Energy band Diagram）"></a>能带图（Energy band Diagram）</h2><p>原子是不能再细分的最小粒子。</p><p>质子（Proton），中子（Neutron）和电子（Electon）.Center of the atom is called nucleus(原子核)</p><p>1.原子核包含质子和中子<br>2.原子的最外层叫做电子壳层，里面有电子。<br>3.电子绕原子核旋转。</p><p>&nbsp;</p><p>传导带（CB）和价带（vB）是如何形成的？<br>情况1：假设：所有原子彼此之间都很远。<br>注：所有原子第一轨道上所有电子的能量保持不变。</p><p>&nbsp;</p><p>Conduction band   导带<br>Forbidden energy gap  禁能隙<br>Valance band  价带</p><p>在晶体中，由于引力和斥力的关系，每个电子都有不同的能级。<br>在任何固体中，都有两种类型的带：价带和导带。</p><p>完全最高的填充或部分填充的能带为<strong>价带</strong>（Valance band ）</p><p>最低未填充能量叫做<strong>导带</strong>（Conduction band）</p><p>&nbsp;</p><p>$E_v$为价带中的最大能量，$E_c$为能带中的最小能量。带隙能量（band Gap）$E_g$是$E_v和E_c$之间的差值，两个能带之间的区域又叫禁带隙，电子不能位于禁带隙中。</p><p>一个电子从价带中获取足够的能量运动到导带中的过程叫做跃迁。</p><p>&nbsp;</p><p>如下如，分别为导体，半导体和绝缘体的能带图</p><p>&nbsp;</p><p>所有的原子在任何固体中都是紧密结合的</p><p>在晶体中，由于引力和斥力的关系，每个电子都有不同的能级。</p><p>&nbsp;</p><p>绝缘体：<br>1.导带为空。这些材料不允许电流通过。<br>玻璃和塑料是绝缘体的例子。<br>2.它们具有高电阻率和非常低的导电性。绝缘体中的能隙在6ev左右非常高。<br>注：导带与价带之间的间隙称为带隙（Eg）。<br>3.要将电子从价带移动到导带，需要大量的能量（超过6ev），这实际上是不可能的。<br>4.因此，电子从价带移动到导带是不可能的。</p><p>&nbsp;</p><p>半导体：<br>1.锗和硅是电性能介于导体和绝缘体之间的最佳材料。<br>2.两个带之间的禁隙非常小，约为1eV。<br>11注：导和价带之间的间隙称为禁带隙或禁带隙（Eg）。<br>3.在低温或绝对零度温度下，半导体表现得像绝缘体。<br>4.即使在室温下，价带中的电子获得的能量也大于能隙，因此电子进入传导带。</p><p>&nbsp;</p><p>导体：</p><p>1.在价带和导带之间没有禁带隙，导致了两个带的重叠。<br>2.在室温下，传导带中自由电子的数量是可用的。电导带几乎充满了电子。</p><p>&nbsp;</p><p>在绝对零度时，半导体是绝缘体，因为是导带中不存在电子.</p><p>在绝对0度和没有外界激发时,价电子被共价键束缚，本征半导体中没有可以运动的带电粒子（即载流子），不导电，相当于绝缘体。</p><p>导体价带与导带之间的能带间隙为0</p><p>&nbsp;</p><h2 id="化学键（Chemical-Bonding）"><a href="#化学键（Chemical-Bonding）" class="headerlink" title="化学键（Chemical Bonding）"></a>化学键（Chemical Bonding）</h2><h3 id="离子键（lonic-Bonding）"><a href="#离子键（lonic-Bonding）" class="headerlink" title="离子键（lonic Bonding）"></a>离子键（lonic Bonding）</h3><p><strong>金属</strong>和<strong>非金属</strong>之间通过电子的完全转移而形成离子键，去达到稳定状态（stability）</p><h3 id="金属键（Metallic-bonding）"><a href="#金属键（Metallic-bonding）" class="headerlink" title="金属键（Metallic bonding）"></a>金属键（Metallic bonding）</h3><h3 id="共价键合（Co-valent-bonding）"><a href="#共价键合（Co-valent-bonding）" class="headerlink" title="共价键合（Co-valent bonding）"></a>共价键合（Co-valent bonding）</h3><p>共价键是当两个原子共享一个或多个电子对时形成的键.</p><p>每个原子为键的形成贡献了相等数量的电子。</p><p>&nbsp;</p><h3 id="本征和非本征半导体-Intrinsic-and-extrinsic-Semiconductor"><a href="#本征和非本征半导体-Intrinsic-and-extrinsic-Semiconductor" class="headerlink" title="本征和非本征半导体(Intrinsic and extrinsic Semiconductor)"></a>本征和非本征半导体(Intrinsic and extrinsic Semiconductor)</h3><h4 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h4><p>1.本征半导体被称为纯半导体，它只由单一类型的元素组成。</p><p>2.本征半导体最常见的例子是硅（Si）和锗（Ge），它们属于元素周期表的第IV组。</p><p>3.硅和锗的原子序数分别为14和32。</p><p>4.这表明Si和Ge的最外层轨道各有4个电子。这些电子是<strong>最外层电子</strong> （valence electrons）， 用于半导体的传导</p><p>5.为了完成它的八隅体，附近的原子通过共用价电子形成共价键。</p><p>6.所有的共价键都是稳定的，没有自由电子可用于传导。在这里，本征半导体充当绝缘体（insulator）或非导体。</p><p>&nbsp;</p><h4 id="温度对本征半导体的影响"><a href="#温度对本征半导体的影响" class="headerlink" title="温度对本征半导体的影响"></a>温度对本征半导体的影响</h4><p>1.在绝对零度下，共价键非常强或紧密结合，没有目由电子可用来传导电流。（表现为绝缘体）</p><p>2.换句话说，如果温度升高，一些共价键会断裂；一个电子的去除会在其后面留下一个空位，即键中缺少一个电子。这种缺失的电子称为<strong>空穴</strong>。</p><p>3.共价键中缺少电子的现象称为空穴。</p><p>4.在固有半导体中，产生相同数量的电子和空穴，因此它表现出<strong>电中性</strong></p><p>&nbsp;</p><h4 id="非本征半导体"><a href="#非本征半导体" class="headerlink" title="非本征半导体"></a>非本征半导体</h4><p>1.本征半导体的电导率（conductivity）不好。由于其导电性低，被认为不适合在电子器件中使用。</p><h5 id="如何提高电导率？"><a href="#如何提高电导率？" class="headerlink" title="如何提高电导率？"></a>如何提高电导率？</h5><p>2.掺杂（doping）：将杂质添加到半导体中的过程称为掺杂。</p><p>3.添加杂质的半导体称为不纯（impure）或非本征半导体</p><p>将杂质添加到半导体中的过程称为掺杂。</p><p>4.在纯材料中加入少量合适的杂质，使其电导率提高数倍.</p><h4 id="一些常用的掺杂剂Some-Commonly-Used-Dopants"><a href="#一些常用的掺杂剂Some-Commonly-Used-Dopants" class="headerlink" title="一些常用的掺杂剂Some Commonly Used Dopants"></a>一些常用的掺杂剂Some Commonly Used Dopants</h4><p>5.五价原子：原子价为5（元素周期表中第5族）的原子；如碑（as）、磷锦（Sb）等。</p><p>6.三价原子：原子价为3（元素周期表中第3组）的原子；如铟（In）、铝（AI）、硼（B）等。</p><p>&nbsp;</p><p>注：当导带中有足够或足够的电子数时，任何材料都参与导通。</p><p>&nbsp;</p><h2 id="非本征半导体：N型半导体"><a href="#非本征半导体：N型半导体" class="headerlink" title="非本征半导体：N型半导体"></a>非本征半导体：N型半导体</h2><p>1.n型半导体是一种与五价杂质掺杂的非本征半导体。</p><p>2.在纯半导体中加入五价杂质，以增加导电所需的电子数量。</p><p>3.五价杂质在其最外层轨道上有五个电子。</p><p>五价杂质的例子是磷[15]（P），碑[33]（As），锦（Sb）[51]</p><p>4.在n型半导体中添加五价杂质，使原始本征半导体的晶体结构不受干扰。</p><p>5.五价杂质原子与四个硅原子形成共价键，第五个电子不与任何硅原子成键</p><p>6.在n型半导体中，这第5个电子主要产生电流。</p><p>让我们假设六个电子来自六个不同的磷元素。</p><p>在室温下，电子-空穴对由于共价键的断裂而产生。<br>假设两个共价键被打破这意味着产生了两个电子和两个空穴。<br>总的来说，它现在有8个电子和2个空穴。</p><p>换句话说，在n型半导体中电子增加了；所以电子电流会很大而空穴电流会很小。<br>为了区分它，科学家用了两个词：多数电荷(majority charge)（i.e.Electron）和少数电荷(minority)（i.e. Hole）。</p><p>7.每个五价杂质原子给n型半导体提供一个电子，因此被称为供体杂质(Donor impurities)。</p>DD在这里，每个电子都与带正电的离子。&nbsp;## 非本征半导体：P型半导体1.p型半导体是一种非本征半导体。2.当三价杂质被添加到固有的或纯的半导体（硅或锗）中时，它被称为p型半导体。3.三价杂质，如硼[5]（B），镓[31]|（Ga）铟[49]（In），铝[13]（AI）等4.三价杂质有三个价电子，它们与三个si原子形成共价键。因此，第四个共价键由于短缺而不完整的电子。这个缺失的电子被称为空穴。5.空穴的行为类似于能接受电子的止电何。因此被称为受体杂质。6.p型半导体中的电流主要由空（hole）贡献。换句话说，在 p型半导体中，空穴有所增加；所以空穴电流会很大，而电子电流会很小。为了区分它，科学家用了两个词：多数电荷（i.e. Hole）和少数电荷（i.e. Electron）。&nbsp;## 11、电子和空穴1.这个空白空间被认为是在原子的特定位置没有一个电子的情况下的空穴。2.这个洞的行为与正电荷相似。这个空的空间吸引了邻近原子的一个电子。本征半导体中的总电流是空穴和电子的总和。电流。总电流=电子电流+空穴电流$\mathbf I=\mathbf I_{hole}+\mathbf I_{electron}$3.因此我们得出了空穴和电子向相反方向运动的结论4.空穴和电子是两种载流子；它们负责半导体中的电流。note：空穴不是电子那样的物理粒子；在半导体材料中，孔洞似乎从一个原子传递到另一个原子。[Semiconductors - Types, Examples, Properties, Application, Uses (byjus.com)](https://byjus.com/jee/semiconductors/#holes-and-electrons)&nbsp;## 12,质量作用定律(mess action law)[Law of mass action (physics-and-radio-electronics.com)](https://www.physics-and-radio-electronics.com/electronic-devices-and-circuits/semiconductor/law-of-mass-action.html)在热平衡下，电子浓度数与空穴浓度数的乘积为常数或等于本征载流子浓度的平方。$n_i$=内在载流子浓度n=单位体积的自由电子数p=每单位体积的自由空穴数2.质量作用规律与添加的给体和受体杂质量无关。&nbsp;### 非本征半导体电子的浓度远远大于空穴的浓度空穴的浓度远远大于电子的浓度掺杂后电子与空穴的复合速率增加。因此，product保持不变。因此我们可以说它独立于给体和受体的杂质。### n型和p型半导体的质量作用定律$n_n$=n型半导体的电子数$p_n$=n型空洞的电子数#### p型半导体$p_p$=p型半导体的空穴数$n_p$=p型半导体的电子数对于非本征半导体，质量作用定律表明：多数载流子和少数载流子的乘积是恒定的。&nbsp;### 基于质量作用定律的问题| 名称                 |            || -------------------- | ---------- || Potential difference | 潜在差异   || Electric Field       | 电场       || Current Density      | 当前密度   || Conductivity         | 电导率     || Resistivity          | 电阻率     || Proportional         | 成比例的   || Reciprocal           | 倒数       || Electron Mobility    | 电子迁移率 || Hole mobility        | 空穴迁移率 |1.电子沿外加电场的相反方向流动2.空穴在外加电场的作用下沿同一方向流动。&nbsp;Vd是漂移速度流动（$\mu$）：单位电场的漂移速度称为迁移率。$$\mu=V_{\mathrm{d}}/E$$$\mu$：电子的迁移率$v_d$:漂移速度E：施加电场换句话说，迁移率是衡量在外加电场或存在的情况下，电子在金属或半导体中移动的速度或容易程度在外加电场的存在下，电子在金属或半导体中移动的能力称为电子迁移能力。$$I=I_e +I_h$$1.电子产生的电流$I_e$$I_e = neAv_d$$I_e = neA \mu_e E$2.空穴电流$I_h = peAv_d$$I_h= peA \mu_h E$3.电子和空穴产生的总电流$I= I_e +I_h$$I = neA \mu_eE + peA\mu_hE$$I = EA[ne\mu_e +pe\mu_h]$$\frac{I}{A}=E[ne\mu_e+pe\mu_h]$其中，$\frac{I}{A}=J$,$[ne\mu_e+pe\mu_h]=\sigma $$J = \sigma  E$$\sigma = ne\mu_e + pe\mu_h$$\sigma \approx  ne\mu_e$&nbsp;## 16,无偏置下的PN结[Zero bias pn junction (physics-and-radio-electronics.com)](https://www.physics-and-radio-electronics.com/electronic-devices-and-circuits/semiconductor-diodes/zero-bias-pn-junction.html)|            | P-型 | N-型 || ---------- | ---- | ---- || 多数充电器 | 空穴 | 电子 || 少数充电器 | 电子 | 空穴 |P-n结是通过连接n型和p型半导体材料形成的。p型和n型之间的边界称为PN结。PN结有三种可能的偏置条件：偏置：如果在PN结二极管的两端施加外部电压（外部电）。A.no bias / zero bias 零偏 / unbiasB.Forward bais 正向偏向C.Reverse bias 反向偏向&nbsp;### 无偏置下的PN结无外部电压的p-n结称为零偏p-n结。<p>N区的电子浓度更高与P区相比。因此，存在扩散电子从N区到P区</p><p>同样，p区域的孔洞浓度高于n区域。因此，有一种扩散从P区到n区。</p><p>从p区流出的空穴揭示了带负电荷的受体离子，从n区流出的电子揭示了带正电荷的供体离子</p><p>&nbsp;</p><p>在载流子从P向N和N向P运动的过程中，在接点处出现的电位差称为势垒电位，它起势垒作用。</p><p>由于这个电位差，就产生了电场。</p><p>一旦在结附近建立势垒电位。电荷载流子不可能从P到N和从N到P进一步移动（运动）</p><h4 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h4><p>由于浓度梯度的作用，在结合部形成了势垒电位。</p><p>&nbsp;</p><h2 id="17-正偏压下的PN结"><a href="#17-正偏压下的PN结" class="headerlink" title="17,正偏压下的PN结"></a>17,正偏压下的PN结</h2><p>1.当正电压加到p侧，负电压加到n侧时，二极管是正向偏置的。</p><p>如果p端施加的电压大于n端，称为<strong>正向偏置</strong>。</p><p>2.孔从电池的正极排斥，并向连接处移动。同样，n型中的电子从电池的负极排斥并向结方向移动。</p><p>3.当外加电压（VF）大于势垒电位（Vb）时，损耗宽度变窄，势垒电位降低。</p><p>注：由于这个电场，一个电子在结的p侧移动到结的n侧。这种运动称为漂移。</p><p>4.这个动作消除了势垒，并建立了传导路径。<br>结果，电流随外加电压呈指数增长。这种电流叫做正向电流。</p><p>5.电流通过二极管迅速增加的正向偏置电压称为膝压或角压或内置电位或打开电压。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电子学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的逻辑结构"><a href="#二叉树的逻辑结构" class="headerlink" title="二叉树的逻辑结构"></a>二叉树的逻辑结构</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>二叉树是n（n$\ge$0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>1.每个结点最多有两颗子树。</p><p>2.二叉树是有序的，其次序不能任意颠倒。</p><p>注意：二叉树和树是两种树结构。</p><p>&nbsp;</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>了解好：斜树，满二叉树，完全二叉树</p><p>&nbsp;</p><h2 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h2><p>性质1:二叉树的第i层上最多有$2^{i-1}$个结点（i$\ge$1）</p><p>性质2:一棵深度为k的二叉树中，最多有$2^{k-1}$个结点，最少有k个结点。</p><p>性质3:在一棵二叉树中，如果叶子结点数为$n_0$，度为2的结点数为$n_2$，则有：$n_0=n_2+1$。</p><p>性质4:具有n个结点的完全二叉树的深度为$\left\lfloor\log _{2} n\right\rfloor+1$。</p><p>性质5:对一棵具有n个结点的完全二叉树中从1开始按层序编号，则对于任意的序号为i（$1\le i \le n$）的结点(简称为结点i），有：<br>（1）如果i&gt;1，则结点的双亲结点的序号为i/2；如果i=1，则结点是根结点，无双亲结点。</p><p>（2）如果$2i \le n$，则结点i的左孩子的序号为2i；如果2i&gt;n，则结点i无左孩子。</p><p>（3）如果$2i+1\le n$，则结点i的右孩子的序号为2i+1；如果$2i+1&gt;n$，则结点无右孩子。</p><p>&nbsp;</p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置（下标）应能体现结点之间的逻辑关系-父子关系。</p><h3 id="完全二叉树的顺序储存"><a href="#完全二叉树的顺序储存" class="headerlink" title="完全二叉树的顺序储存"></a>完全二叉树的顺序储存</h3><p><img src="https://i.imgtg.com/2022/11/07/R6CWa.png" alt="R6CWa.png" border="0"></p><p><img src="https://i.imgtg.com/2022/11/07/R6IjK.png" alt="R6IjK.png" border="0"></p><h3 id="二叉树编号"><a href="#二叉树编号" class="headerlink" title="二叉树编号"></a>二叉树编号</h3><p>按照完全二叉树编号</p><p><img src="https://i.imgtg.com/2022/11/07/R6XhB.png" alt="R6XhB.png" border="0"></p><p>可以编号为：<img src="/posts/e85d694a.htm/R6uRs.png" alt="R6uRs.png" border="0"></p><p><img src="https://i.imgtg.com/2022/11/07/R66Ig.png" alt="R66Ig.png" border="0"></p><p>没有编号的位置直接存储为空。</p><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p><img src="https://i.imgtg.com/2022/11/07/R6wyS.png" alt="R6wyS.png" border="0"></p><div class="table-container"><table><thead><tr><th>data</th><th>数据域，存放该结点的数据信息</th></tr></thead><tbody><tr><td>Ichild</td><td>左指针域，存放指针指向左孩子的指针</td></tr><tr><td>rchild</td><td>右指针域，存放指针指向右孩子的指针</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">tree</span>* Ichild;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">tree</span>* rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">class</span> <span class="title class_">tree</span> node;</span><br><span class="line"><span class="keyword">typedef</span> node *btree;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的组成：根结点D，左子树L，右子树R。</p><p>如果限定先左后右，则二叉树遍历方式有三种：</p><p>前序（Preorder）：DLR</p><p>中序（Inorder）：LDR</p><p>后序（Postorder）：LRD</p><p>如下图所视</p><p><img src="https://i.imgtg.com/2022/11/07/R8MsN.png" alt="R8MsN.png" border="0"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.遍历左子树</span><br><span class="line">2.遍历（或访问）树根</span><br><span class="line">3.遍历右子树</span><br></pre></td></tr></table></figure><p>中序遍历为：FDHGIBEAC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(btree ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Inorder</span>(ptr-&gt;left);   <span class="comment">//遍历左子树</span></span><br><span class="line">cout&lt;&lt;ptr -&gt;data;     <span class="comment">//遍历并打印树根</span></span><br><span class="line"><span class="built_in">Inorder</span>(ptr-&gt;right);   <span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.遍历左子树</span><br><span class="line">2.遍历右子树</span><br><span class="line">3.遍历树根</span><br></pre></td></tr></table></figure><p>中序遍历为：FHIGDEBCA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Postorder (btree ptr)</span><br><span class="line">&#123;</span><br><span class="line">if (ptr != NULL)</span><br><span class="line">&#123;</span><br><span class="line">Postorder(ptr-&gt;left);     //遍历左子树</span><br><span class="line">Postorder(ptr-&gt;right);    //遍历右子树</span><br><span class="line">cout&lt;&lt;ptr-&gt;data;          //遍历并打印树根</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.遍历树根</span><br><span class="line">2.遍历左子树</span><br><span class="line">3.遍历右子树</span><br></pre></td></tr></table></figure><p>中序遍历为：ABDFGHIEC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(btree ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;ptr -&gt;data;     <span class="comment">//遍历并打印树根</span></span><br><span class="line"><span class="built_in">Inorder</span>(ptr-&gt;left);   <span class="comment">//遍历左子树</span></span><br><span class="line"><span class="built_in">Inorder</span>(ptr-&gt;right);   <span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="二叉树节点的插入和删除"><a href="#二叉树节点的插入和删除" class="headerlink" title="二叉树节点的插入和删除"></a>二叉树节点的插入和删除</h3><p>在二叉树建立的过程中，是根据<strong>左子树&lt;树根&lt;右子树</strong>的原则建立的。</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>只需从树根出发比较键值，如果比树根大就往右，否则往左而下，直到相等就找到了要查找的值，如果比到NULL，无法再前进就代表查找不到此值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">btree <span class="title">search</span> <span class="params">(btree ptr,<span class="type">int</span> val)</span>  <span class="comment">//查找二叉树某键值得函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>（<span class="number">1</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)     <span class="comment">//没找到就返回NULL</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(ptr-&gt;data==val)   <span class="comment">//节点值等于查找值</span></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ptr-&gt;data&gt;val)  <span class="comment">//节点值大于查找值</span></span><br><span class="line">ptr=ptr-&gt;left;</span><br><span class="line"><span class="keyword">else</span>                  <span class="comment">//小于查找值</span></span><br><span class="line">ptr=ptr-&gt;right;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>  插入节点的情况和查找相似，关键是插入后仍要保持二叉查找树的<strong>特性（左子树&lt;树根&lt;右子树）</strong>。如果插入的节点在二叉树中没有找到，就是出现查找失败的情况，就相当于找到了要插入的位置。我们可以修改，只要多加一条if判断语句，当查找到键值时输出“二叉树中有此节点了！”，如果找不到，再将此节点加到此二叉树中。算法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">btree ptr=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">search</span>(ptr,data))!=<span class="literal">NULL</span>)     <span class="comment">//查找二叉树</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;二叉树中有此节点了-&quot;</span>&lt;&lt;data&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ptr=<span class="built_in">creat_tree</span>(ptr,data);<span class="comment">//将此键值加入到此二叉树中</span></span><br><span class="line">    <span class="built_in">inorder</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">btree <span class="title">creat_tree</span><span class="params">(btree root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">btree newnode,current,backup;</span><br><span class="line">newnode=(btree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(node));<span class="comment">//创建一个新结点</span></span><br><span class="line">newnode-&gt;data=val;</span><br><span class="line">newnode-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)    <span class="comment">//如果树根为空</span></span><br><span class="line">&#123;  </span><br><span class="line">root=newnode;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>     <span class="comment">//树不为空</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">for</span>(current=root;current!=<span class="literal">NULL</span>;)   <span class="comment">//把树赋给root</span></span><br><span class="line">&#123;  </span><br><span class="line">backup=current;    <span class="comment">//current赋给backup</span></span><br><span class="line"><span class="keyword">if</span>(current-&gt;data &gt; val)    <span class="comment">//val小于此结点的data</span></span><br><span class="line">current=current-&gt;left; <span class="comment">//current被赋为右树的节点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">current=current-&gt;right;<span class="comment">//current被赋为左树的节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(backup-&gt;data &gt;val) <span class="comment">//节点数据域大于val值说明新结点是它的左孩子</span></span><br><span class="line">backup-&gt;left=newnode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">backup-&gt;right=newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(btree ptr)</span><span class="comment">//中序遍历子程序</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">     &#123;  </span><br><span class="line">      <span class="built_in">inorder</span>(ptr-&gt;left);</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;ptr-&gt;data&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">      <span class="built_in">inorder</span>(ptr-&gt;right);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h3><p>1.删除的结点为树叶：只要将其相连的父节点指向NULL即可。</p><p>2.删除的节点只有一颗子树，如下图，要删除节点1，就要将其右指针放到其父节点的左指针</p><p>3.删除的节有两颗子树，如下图，要删除节点4，方式有两种</p><p>​    3.1 找出中序立即先行者（inorder immediate predecessor）</p><p> 即是将欲删除节点的左子树中最大者向上提，在此即为图中的节点2，简单来说，就是在该节点的左子树，往右寻找，直到右指针为NULL，这个节点就是中序立即先行者。</p><p>​    3.2 找出中序立即后继者（inorder immediate successor）</p><p> 即是将欲删除节点的右子树中最小者向上提，在此即为图中的节点5，简单来说，就是在该节点的右子树，往左寻找，直到左指针为NULL，这个节点就是中序立即后继者。</p><p><img src="https://i.imgtg.com/2022/11/07/R8aaC.png" alt="R8aaC.png" border="0"></p><p>&nbsp;</p><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><p>由于二叉查找树的缺点是无法永远保持在最佳状态。当加入的数据部分已排序的情况下，极有可能产生斜二叉树，因而使树的高度增加，导致查找效率降低。所以二叉查找树不利于数据的经常变动（加入或删除）的情况。为了能够尽量降低所需要的时间，在查找的时候能够很快找到所要的键值，就必须让树的高度越小越好。</p><p>现在又a[8] = {1,2,3,4,5,6,7,8}需要构建二叉排序树。在没有学习平衡二叉树之前，根据二叉排序树的特性，通常会将它构建成如下左图。虽然完全符合二叉排序树的定义，但是对这样高度达到8的二叉树来说，查找是非常不利的。因此，更加期望构建出如下右图的样子，高度为4的二叉排序树，这样才可以提供高效的查找效率。<br></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>由序列{1，2，3，4，5}得到二叉排序树：ASL=（1+2+3+4+5）/5=3</p><p>由序列{3，1，2，5，4}得到二叉排序树：ASL =（2+3+1+3+2）/5= 2.2</p><h3 id="平衡树的定义"><a href="#平衡树的定义" class="headerlink" title="平衡树的定义"></a>平衡树的定义</h3><p>在AVL树中，每次在插入数据和删除数据后，必要的时候会对二叉树作一些高度的调整让二叉查找树的高度随时维持平衡。T是一个非空的二叉树，$T_l$和$T_r$，分别是它的左右子树，若符合$\left|h_{1}-h_{r}\right|\leq1$。$h_i$和$h_r$，分别为$T_l$和$T_r$的高度，也就是所有内部节点的左右子树高度相差必定小于或等于1，则称T是个高度平衡树。</p><p>平衡因子：结点的平衡因子是该结点的左子树的深度与右子树的深度之差。</p><h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><p>构造平衡二叉树的基本思想：每插入一个结点，<br>（1）从插入结点开始向上计算各结点的平衡因子，如果某结点平衡因子的绝对值超过1，则说明插入操作破坏了二叉排序树的平衡性，需要进行平衡调整；否则继续执行插入操作。<br>（2）如果二叉排序树不平衡，则找出最小不平衡子树的根结点，根据新插入结点与最小不平衡子树根结点之间的关系判断调整类型。<br>（3）根据调整类型进行相应的调整，使之成为新的平衡子树。</p><p>当我们从零开始插入一个二叉树的时候，最开始是一个空的树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = (AVLTREE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVLTREE));</span><br><span class="line">root-&gt;data = data;</span><br><span class="line">root-&gt;height = <span class="number">0</span>;</span><br><span class="line">root-&gt;leftChlid = root-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果判断树为空，那么我们先给树跟分配一个空间，树的data域储存第一个数据，这个树的高度为零，左右孩子都为空。</p><p>然后当我们去插入节点的时候，通过规则判断，比这个数据小的会储存到左孩子中，比这个数据大的会储存到右孩子中。但当我们插入第三个开始就可能会出现不平衡的情况，即不符合$\left|h_{1}-h_{r}\right|\leq1$我们归纳为以下四种情况，每次插入我们都进行判断，从而保证二叉树一直在一个平衡的状态。</p><p>设结点A为最小不平衡子树的根结点，对该子树进行平衡调整归纳起来有以下四种情况：<br>   1.LL型</p><ol><li><p>RR型</p></li><li><p>LR型</p></li><li><p>RL型</p></li></ol><h4 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h4><p>当根结点左子树的左子树中的节点导致根结点的平衡因子为2时，采用LL型旋转进行调整。</p><p>因为我们插入的时候就已经知道$B_R$是大于B小于A的，所以我们可以把$B_R$当作A的一个左孩子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data &lt; root-&gt;data) &#123;    <span class="comment">//如果要插入的数据小于树的data域，插入为树的左孩子            </span></span><br><span class="line">root-&gt;leftChlid = <span class="built_in">insertPoint</span>(data, root-&gt;leftChlid); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;leftChlid) - <span class="built_in">getHeight</span>(root-&gt;rightChild) == <span class="number">2</span>) &#123;<span class="comment">//如果左子树的深                                                                          度比右子树的深度高1</span></span><br><span class="line"><span class="keyword">if</span> (data &lt; root-&gt;leftChlid-&gt;data)  <span class="comment">//插入数据小于左孩子就是左左</span></span><br><span class="line">root = <span class="built_in">left_Left_Rotation</span>(root);</span><br><span class="line"><span class="keyword">else</span>                               <span class="comment">//反之则为右右</span></span><br><span class="line">root = <span class="built_in">left_Right_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="左左的操作"><a href="#左左的操作" class="headerlink" title="左左的操作"></a>左左的操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTREE* <span class="title">left_Left_Rotation</span><span class="params">(AVLTREE* root)</span> </span>&#123;</span><br><span class="line">AVLTREE* newRoot = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">newRoot = root-&gt;leftChlid;</span><br><span class="line">root-&gt;leftChlid = newRoot-&gt;rightChild;</span><br><span class="line">newRoot-&gt;rightChild = root;</span><br><span class="line"></span><br><span class="line">root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;leftChlid), <span class="built_in">getHeight</span>(root-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line">newRoot-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(newRoot-&gt;leftChlid), root-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTREE* <span class="title">right_Right_Rotation</span><span class="params">(AVLTREE* root)</span> </span>&#123;</span><br><span class="line">AVLTREE* newRoot = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">newRoot = root-&gt;rightChild;</span><br><span class="line">root-&gt;rightChild = newRoot-&gt;leftChlid;</span><br><span class="line">newRoot-&gt;leftChlid = root;</span><br><span class="line"></span><br><span class="line">root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;leftChlid), <span class="built_in">getHeight</span>(root-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line">newRoot-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(newRoot-&gt;rightChild), root-&gt;height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h4><p>LR型是一种特殊情况，前面两次LL和RR都是单旋转，而LR型和RL型是双旋转</p><p>对其应该先进行一次右右，再进行一次左左</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTREE* <span class="title">left_Right_Rotation</span><span class="params">(AVLTREE* root)</span> </span>&#123;</span><br><span class="line">root-&gt;leftChlid = <span class="built_in">right_Right_Rotation</span>(root-&gt;leftChlid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">left_Left_Rotation</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RL形"><a href="#RL形" class="headerlink" title="RL形"></a>RL形</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTREE* <span class="title">right_Left_Rotation</span><span class="params">(AVLTREE* root)</span> </span>&#123;</span><br><span class="line">root-&gt;rightChild = <span class="built_in">left_Left_Rotation</span>(root-&gt;rightChild);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">right_Right_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AVL树的插入"><a href="#AVL树的插入" class="headerlink" title="AVL树的插入"></a>AVL树的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTREE* <span class="title">insertPoint</span><span class="params">(<span class="type">int</span> data, AVLTREE* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = (AVLTREE *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(AVLTREE));</span><br><span class="line">root-&gt;data = data;</span><br><span class="line">root-&gt;height = <span class="number">0</span>;</span><br><span class="line">root-&gt;leftChlid = root-&gt;rightChild = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; root-&gt;data) &#123; <span class="comment">//如果插入数据小于树的数据，则插入到书的左子树        </span></span><br><span class="line">root-&gt;leftChlid = <span class="built_in">insertPoint</span>(data, root-&gt;leftChlid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">getHeight</span>(root-&gt;leftChlid) - <span class="built_in">getHeight</span>(root-&gt;rightChild) == <span class="number">2</span>) &#123;<span class="comment">//判断是LX</span></span><br><span class="line"><span class="keyword">if</span>(data &lt; root-&gt;leftChlid-&gt;data)</span><br><span class="line">root = <span class="built_in">left_Left_Rotation</span>(root);<span class="comment">//判断为LL</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">root = <span class="built_in">left_Right_Rotation</span>(root);<span class="comment">//判断为LR</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(data &gt; root-&gt;data) &#123;<span class="comment">//如果插入数据大于于树的数据，则插入到书的左子树  </span></span><br><span class="line">root-&gt;rightChild = <span class="built_in">insertPoint</span>(data, root-&gt;rightChild);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">getHeight</span>(root-&gt;rightChild) - <span class="built_in">getHeight</span>(root-&gt;leftChlid) == <span class="number">2</span>) &#123;<span class="comment">//判断为RX型</span></span><br><span class="line"><span class="keyword">if</span>(data &gt; root-&gt;rightChild-&gt;data)  <span class="comment">//判断为RR型</span></span><br><span class="line">root = <span class="built_in">right_Right_Rotation</span>(root);</span><br><span class="line"><span class="keyword">else</span>                               <span class="comment">//判断为RL型</span></span><br><span class="line">root = <span class="built_in">right_Left_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(data == root-&gt;data) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;               </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root-&gt;leftChlid), <span class="built_in">getHeight</span>(root-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><p>删除操作和二叉查找树删除一样，分为三种情况讨论</p><p>（1）删除节点没有左右子树，这种情况直接删除此节点即可</p><p>（2）删除节点没有左子树，这种情况直接将删除节点的父节点指向删除节点的右子树。</p><p>（3）删除节点没有右子树，这种情况直接将删除节点的父节点指向删除节点的左子树。</p><p>（4）删除节点左右子树都存在，可以采用两种方式，</p><p>​     1：让删除节点左子树的最右侧节点代替当前节点</p><p>​     2：让删除节点右子树的最左侧节点代替当前节点</p><p>&nbsp;&nbsp;</p><h3 id="只有左右子树，或者无子树"><a href="#只有左右子树，或者无子树" class="headerlink" title="只有左右子树，或者无子树"></a>只有左右子树，或者无子树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVLTREE* temp = root;</span><br><span class="line"></span><br><span class="line">root = root-&gt;leftChlid ? root-&gt;leftChlid : root-&gt;rightChild;</span><br><span class="line"><span class="built_in">destroy</span>(temp);</span><br></pre></td></tr></table></figure><p>创建一个临时节点存放树，如果左孩子不为空，此节点root等于root的左子树，如果左子树节点为空，此节点root就等于root的右孩子。就相当于删除了root</p><p>如果是没有子节点的情况下，三目运算判断root为root的右子树，但是右子树为null就相当于把其删去</p><p>&nbsp;</p><h3 id="有左右子树"><a href="#有左右子树" class="headerlink" title="有左右子树"></a>有左右子树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;leftChlid &amp;&amp; root-&gt;rightChild) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getHeight</span>(root-&gt;leftChlid) &gt; <span class="built_in">getHeight</span>(root-&gt;rightChild)) &#123;</span><br><span class="line"></span><br><span class="line">AVLTREE* max = <span class="built_in">getMaxNum</span>(root-&gt;leftChlid);</span><br><span class="line">root-&gt;data = max-&gt;data;</span><br><span class="line">root-&gt;leftChlid = <span class="built_in">deletePoint</span>(max-&gt;data, root-&gt;leftChlid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">AVLTREE* min = <span class="built_in">getMinNum</span>(root-&gt;rightChild);</span><br><span class="line">root-&gt;data = min-&gt;data;</span><br><span class="line">root-&gt;rightChild = <span class="built_in">deletePoint</span>(min-&gt;data, root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>重要的是，在每一次删除节点以后，都要对新的树进行判断是否平衡，也就是平衡因子是小于等于1。</p><h3 id="待删除的点在左子树"><a href="#待删除的点在左子树" class="headerlink" title="待删除的点在左子树"></a>待删除的点在左子树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">getHeight</span>(root-&gt;rightChild) - <span class="built_in">getHeight</span>(root-&gt;leftChlid)) == <span class="number">2</span>) &#123;</span><br><span class="line">AVLTREE* p = root-&gt;rightChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getHeight</span>(p-&gt;leftChlid) &gt; <span class="built_in">getHeight</span>(p-&gt;rightChild)) &#123;</span><br><span class="line">root = <span class="built_in">right_Left_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root = <span class="built_in">right_Right_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="待删除的点在右子树"><a href="#待删除的点在右子树" class="headerlink" title="待删除的点在右子树"></a>待删除的点在右子树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="built_in">getHeight</span>(root-&gt;leftChlid) - <span class="built_in">getHeight</span>(root-&gt;rightChild)) == <span class="number">2</span>) &#123;</span><br><span class="line">AVLTREE* p = root-&gt;leftChlid;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getHeight</span>(p-&gt;rightChild) &gt; <span class="built_in">getHeight</span>(p-&gt;leftChlid)) &#123;</span><br><span class="line">root = <span class="built_in">left_Right_Rotation</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">root = <span class="built_in">left_Left_Rotation</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舵机</title>
      <link href="/posts/bbc04e21.html"/>
      <url>/posts/bbc04e21.html</url>
      
        <content type="html"><![CDATA[<h2 id="直流伺服电机"><a href="#直流伺服电机" class="headerlink" title="直流伺服电机"></a>直流伺服电机</h2><p>伺服（servo）</p><div class="table-container"><table><thead><tr><th>颜色</th><th>功能</th></tr></thead><tbody><tr><td>棕色</td><td>GND</td></tr><tr><td>红色</td><td>VCC</td></tr><tr><td>橙色</td><td>信号（PWM）</td></tr></tbody></table></div><p>由<strong>控制电路</strong>，<strong>电机</strong>和<strong>电位器</strong>（接受反馈）形成闭环系统</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>创建对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">Servo myServo;         <span class="comment">//创建Servo对象myServo</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dataIndex = <span class="number">0</span>;     <span class="comment">//创建整数型变量，存储输入数据序列号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myServo.attach(<span class="number">6</span>);</span><br><span class="line">  Serial.begin(<span class="number">9600</span>); <span class="comment">//启动串口通讯，传输波特率9600</span></span><br><span class="line">  Serial.println(<span class="string">&quot;Please input serial data.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;          <span class="comment">// 检查串口缓存是否有数据等待传输 </span></span><br><span class="line">  <span class="keyword">if</span> ( Serial.available()&gt;<span class="number">0</span> ) &#123;  </span><br><span class="line">    dataIndex++;       <span class="comment">// 处理数据序列号并通过串口监视器显示</span></span><br><span class="line">    Serial.print(<span class="string">&quot;dataIndex = &quot;</span>);</span><br><span class="line">    Serial.print(dataIndex);</span><br><span class="line">    Serial.print(<span class="string">&quot; , &quot;</span>);      </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pos = Serial.parseInt();   <span class="comment">// 解析串口数据中的整数信息并赋值给变量pos</span></span><br><span class="line">    Serial.print(<span class="string">&quot;Set servo position: &quot;</span>);</span><br><span class="line">    Serial.println(pos);           <span class="comment">// 通过串口监视器显示变量pos数值</span></span><br><span class="line">    myServo.write(pos);             <span class="comment">// 使用pos变量数值设置伺服电机</span></span><br><span class="line">    delay(<span class="number">15</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="控制多个舵机"><a href="#控制多个舵机" class="headerlink" title="控制多个舵机"></a>控制多个舵机</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Serial-Servo-2</span></span><br><span class="line"><span class="comment"> 使用</span></span><br><span class="line"><span class="comment">本示例程序旨在演示如何通过串口监视器控制4个伺服电机（舵机）。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">This example code is in the public domain.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">Servo base, fArm, rArm, claw;  <span class="comment">//建立4个电机对象</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> dataIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  base.attach(<span class="number">11</span>);     <span class="comment">// base 伺服电机连接引脚11 电机代号&#x27;b&#x27;</span></span><br><span class="line">  rArm.attach(<span class="number">10</span>);     <span class="comment">// rArm 伺服电机连接引脚10 电机代号&#x27;r&#x27;</span></span><br><span class="line">  fArm.attach(<span class="number">9</span>);      <span class="comment">// fArm 伺服电机连接引脚9  电机代号&#x27;f&#x27;</span></span><br><span class="line">  claw.attach(<span class="number">6</span>);      <span class="comment">// claw 伺服电机连接引脚6  电机代号&#x27;c&#x27;</span></span><br><span class="line">  Serial.begin(<span class="number">9600</span>);</span><br><span class="line">  Serial.println(<span class="string">&quot;Please input serial data.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Serial.available()) &#123;  <span class="comment">// 检查串口缓存是否有数据等待传输 </span></span><br><span class="line">    <span class="type">char</span> servoName = Serial.read();   <span class="comment">//获取电机指令中电机编号信息</span></span><br><span class="line"> </span><br><span class="line">    Serial.print(<span class="string">&quot;servoName = &quot;</span>);</span><br><span class="line">    Serial.print(servoName);    </span><br><span class="line">    Serial.print(<span class="string">&quot; , &quot;</span>);      </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> data = Serial.parseInt();   <span class="comment">//获取电机指令中电机角度信息</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span>(servoName)&#123; <span class="comment">//根据电机指令中电机信息决定对哪一个电机进行角度设置</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:   <span class="comment">// 电机指令b，设置base电机角度</span></span><br><span class="line">        base.write(data);</span><br><span class="line">        Serial.print(<span class="string">&quot;Set base servo value: &quot;</span>);</span><br><span class="line">        Serial.println(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:  <span class="comment">// 电机指令r，设置rArm电机角度  </span></span><br><span class="line">        rArm.write(data);</span><br><span class="line">        Serial.print(<span class="string">&quot;Set rArm servo value: &quot;</span>);</span><br><span class="line">        Serial.println(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:   <span class="comment">// 电机指令f，设置fArm电机角度  </span></span><br><span class="line">        fArm.write(data);</span><br><span class="line">        Serial.print(<span class="string">&quot;Set fArm servo value: &quot;</span>);</span><br><span class="line">        Serial.println(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:   <span class="comment">// 电机指令c，设置claw电机角度  </span></span><br><span class="line">        claw.write(data);  </span><br><span class="line">        Serial.print(<span class="string">&quot;Set claw servo value: &quot;</span>);</span><br><span class="line">        Serial.println(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一阶非线性微分方程</title>
      <link href="/posts/a913fd01.html"/>
      <url>/posts/a913fd01.html</url>
      
        <content type="html"><![CDATA[<h1 id="一阶非线性微分方程"><a href="#一阶非线性微分方程" class="headerlink" title="一阶非线性微分方程"></a>一阶非线性微分方程</h1><h2 id="可分方程-Separable-Equation"><a href="#可分方程-Separable-Equation" class="headerlink" title="可分方程(Separable Equation)"></a>可分方程(Separable Equation)</h2><p>可分方程一般都有如下形式</p><script type="math/tex; mode=display">x'(t)=h(t)g(x)</script><p>且有h(t)是连续的，g(x)是连续可微的</p><p>&nbsp;</p><h3 id="解可分方程思路"><a href="#解可分方程思路" class="headerlink" title="解可分方程思路"></a>解可分方程思路</h3><p>解可分方程思路一般为两大块———-求常数解和求非常数解</p><p>且要注意的是，常数解和非常数解代表的曲线不相交</p><p>一般会先求出常数解，从而求出非常数解的区间，如果有初值，或者给出图上一个点，就可以确定此非常数解的曲线在哪个区间</p><p>&nbsp;</p><h4 id="求常数解"><a href="#求常数解" class="headerlink" title="求常数解"></a>求常数解</h4><p>我们已知x是关于t的函数，当k是微分方程的一个常熟解时，有$x(t)=k$</p><p>$x’(t)=0$,此时当且仅当$g(k)=0$时，微分方程成立</p><p>&nbsp;</p><p>那么当$g(x) \ne 0$时，此时方程有非常数解。</p><h4 id="求非常数解"><a href="#求非常数解" class="headerlink" title="求非常数解"></a>求非常数解</h4><script type="math/tex; mode=display">\frac{x^{\prime}(t)}{g(x(t))}=h(t)</script><script type="math/tex; mode=display">\int \frac{x^{\prime}(t)}{g(x(t))} dt=\int h(t) dt</script><script type="math/tex; mode=display">\int \frac{d x}{g(x)}=\int h(t)+c</script><p>当解中带有绝对值时，我们可以通过求常数解来确定x的范围，从而去绝对值，求出在此区间上的解。</p><p>&nbsp;</p><h2 id="恰当方程（Exact-Equation）"><a href="#恰当方程（Exact-Equation）" class="headerlink" title="恰当方程（Exact Equation）"></a>恰当方程（Exact Equation）</h2><p>假设有一个微分方程$F(x,y)$,有方程对x的偏导$F_x(x,y)$和关于y的偏导$F_y(x,y)$</p><p>关于x的偏导写作$M(x,y)$,y的偏导为$N(x,y)$。</p><p>$F_x(x,y)=M(x,y),F_y(x,y)=N(x,y)$</p><p>此时</p><script type="math/tex; mode=display">M(x,y)dx+N(x,y)dy=0</script><p>方程有$M_y=N_x$恒成立。</p><h3 id="解法一（M，N分别求原函数）"><a href="#解法一（M，N分别求原函数）" class="headerlink" title="解法一（M，N分别求原函数）"></a>解法一（M，N分别求原函数）</h3><p>我们知道，$M(x,y)$关于x的原函数和$N(x,y)$关于y的原函数都是$F(x,y)$</p><p>根据做题经验，我们可以分别求出M，N的原函数。</p><p>M的原函数加常数解项$c_1$($c_1$中可以包含y)</p><p>N的原函数加常数解项$c_2$($c_2$中可以包含x)</p><p>令两式相等，我们可以得出$c_1,c_2$的值，从而求出恰当方程$F(x,y)$。</p><p>&nbsp;</p><h3 id="解法二（M或N求原函数）"><a href="#解法二（M或N求原函数）" class="headerlink" title="解法二（M或N求原函数）"></a>解法二（M或N求原函数）</h3><script type="math/tex; mode=display">F(x,y)=\int M(x,y)dx+h(y)</script><script type="math/tex; mode=display">F_{x}(x,y)=M(x,y)</script><script type="math/tex; mode=display">F_{y}(x, y)=\frac{\partial}{\partial y}\left(\int M(x, y) d x\right)+h^{\prime}(y)</script><script type="math/tex; mode=display">h^{\prime}(y)=N(x,y)-\frac{\partial}{\partial y}\left(\int M(x,y) dx\right)</script><p>如此，我们可以求出h(y)的值，从而求出$F(x,y)$</p><p>&nbsp;</p><h3 id="解法三（作图）"><a href="#解法三（作图）" class="headerlink" title="解法三（作图）"></a>解法三（作图）</h3><script type="math/tex; mode=display">F(x,y)=\int_{x_{0}}^{x} M(s,y) ds+\int_{y_{0}}^{y} N\left(x_{0},s\right)ds</script><p>其中有两种解法，一种是先对x积分，后对y积分。</p><p>积分路径为$(x_0,y_0)-&gt;(x,y_0)-&gt;(x,y)$</p><p>另一种是先对y积分，后对x积分。</p><p>积分路径为$(x_0,y_0)-&gt;(x_0,y)-&gt;(x,y)$</p><p>&nbsp;</p><p>其中积分路径的起点我们可以根据方程的特点，选取最容易计算的对应点</p><p>例如存在$lnx$时我们不妨设x为1，但一般情况下我们都设积分路径的起点为(0,0)</p><p>&nbsp;</p><h2 id="积分因子"><a href="#积分因子" class="headerlink" title="积分因子"></a>积分因子</h2><p>简单说，有形式为$M(x, y) d x+N(x, y) d y=0$的方程。但是此方程不是恰当方程（$M_y \ne N_x$）</p><p>此时我们令方程的每一项都同时乘一个式子$\mu$，$\mu(x, y) M(x, y) d x+\mu(x, y) N(x, y) d y=0$从而使整个方程为恰当的，我们称作这个式子$\mu$为积分因子。</p><p>例如有方程$ydx-xdy=0$可知此方程不恰当,如果我们在方程的每一项同时乘以$\frac{1}{y^2}$,此时方程为$\frac{1}{y}dx-\frac{x}{y^2}dy=0$,此时方程为恰当方程。从而可以根据求解恰当方程的解法去求解。</p><p>&nbsp;</p><h3 id="寻找积分因子"><a href="#寻找积分因子" class="headerlink" title="寻找积分因子"></a>寻找积分因子</h3><p>我们发现如果直接让我们找一个完整的积分因子$\mu(x,y)$是困难的，不妨先去寻找可以使方程恰当的$\mu(x)$或者$\mu(y)$</p><script type="math/tex; mode=display">\mu(x) M(x, y) d x+\mu(x) N(x, y) d y=0</script><script type="math/tex; mode=display">\mu(y) M(x, y) d x+\mu(y) N(x, y) d y=0</script><p>因为方程是恰当的，满足$M_y=N_x$即$\frac{\partial}{\partial y}(\mu(x) M(x, y))=\frac{\partial}{\partial x}(\mu(x) N(x, y))$</p><p>可得$ M_{y}(x, y)=\mu^{\prime}(x) N(x, y)+\mu(x) N_{x}(x, y) $化简可得$\frac{\mu^{\prime}(x)}{\mu(x)}=\frac{M_{y}(x, y)-N_{x}(x, y)}{N(x, y)} $</p><p>我们令$\frac{\mu’(x)}{\mu(x)}=\Psi$即$\Psi=\frac{M_{y}(x, y)-N_{x}(x, y)}{N(x, y)}$那么求解我们得到的ODE：$\mu(x)=c e^{\int \Psi(x) d x}$</p><p>&nbsp;</p><p>同理，如果设积分因子为$\mu(y)$得到的结果为$\Psi=\frac{N_{x}(x, y)-M_{y}(x, y)}{N(x, y)}$,$\mu(y)=c e^{\int \Psi(y) d y}$</p><p>&nbsp;</p><p>当然，如果想求出$\mu(x,y)$，满足$M_y=N_x$可得$ \mu^{\prime}(x,y) M(x, y)+\mu(x,y) M_{y}(x, y)=\mu^{\prime}(x) N(x, y)+\mu(x) N_{x}(x, y) $化简可得$\Psi=\frac{N_{x}(x, y)-M_{y}(x, y)}{M(x, y)-N(x, y)}$,但明显，求单变量的积分因$\mu(x),\mu_(y)$子比求双变量的积分因子$\mu(x,y)$简单得多。</p><p>因此在找积分因子时，我们通常根据方程去寻找单变量积分因子$\mu(x),\mu_(y)$</p><h2 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h2><p>有齐次方程$x’=f(t,x)$,$f(t,x)$表示为关于$\frac{x}{t}$的方程。</p><p>例如$x^{\prime}=\frac{x^{3}+t^{3}}{t x^{2}}, \quad t \neq 0$是齐次的，$x^{\prime}=x^{2} \sin t$是非齐次的。</p><p>&nbsp;</p><p>因此，齐次方程的形式为</p><script type="math/tex; mode=display">x^{\prime}=x^{2} \sin t</script><p>它可以通过改变未知量$x=tz$,使其而转化为一个可分方程</p><script type="math/tex; mode=display">x'=(tz)'=z+tz'=g(z)</script><script type="math/tex; mode=display">tz'=g(z)-z</script><script type="math/tex; mode=display">\frac{z'}{g(z)-z}=\frac{1}{t}(可分方程)</script><p>z是关于t的函数，如此用可分方程的方法求解即可。</p><p>&nbsp;</p><h2 id="伯努利方程"><a href="#伯努利方程" class="headerlink" title="伯努利方程"></a>伯努利方程</h2><p>伯努利方程有如下形式$x^{\prime}+p(x) x=q(t) x^{k+1}$因为$p(t),q(t)$都是连续的，所以我们只考虑$x^{k+1}$使方程有意义的解。</p><p>对于</p><script type="math/tex; mode=display">x^{\prime}+p(t) x=q(t) x^{k+1}</script><p>令$z=x^{-k}$使转化为线性方程。</p><p>注意：当$k=0,-1或q(t)=0$时，伯努利方程是线性方程</p><p>分别为$x’+p(t)x=q(t)x$,$x’+p(t)x=q(t)$,$x’+p(t)x=0$</p><p>&nbsp;</p><script type="math/tex; mode=display">z'=-kx'x^{-(k+1)}=-kx^{-(k+1)}(-p(t)x+q(t)x^{k+1}=kp(t)x^{-k}-kq(t)=kp(t)z-kq(t)</script><p>带入方程中仍然可以将其当作一个可分方程去求解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 常微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈</title>
      <link href="/posts/af55460a.html"/>
      <url>/posts/af55460a.html</url>
      
        <content type="html"><![CDATA[<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>栈（Stack）是操作受限的<strong>线性表</strong>，<strong>插入</strong>和<strong>删除</strong>数据元素的操作只能在线性表的一端进行。</p><p>&nbsp;</p><p>当然，你也可以简单理解栈为一个很多层的篮子，一层篮子只能存放一个数据，我们对这个篮子能处理的就只有最上面的那个数据。</p><p>往篮子里放入数据的过程就叫做<strong>插入</strong>（入栈，进栈，压栈）</p><p>把篮子最上面的那一层数据拿出的过程就叫做<strong>删除</strong>（出栈，弹栈）</p><p>&nbsp;</p><h2 id="栈的主要操作"><a href="#栈的主要操作" class="headerlink" title="栈的主要操作"></a>栈的主要操作</h2><h3 id="入栈（Push）"><a href="#入栈（Push）" class="headerlink" title="入栈（Push）"></a>入栈（Push）</h3><h3 id="出栈（Pop）"><a href="#出栈（Pop）" class="headerlink" title="出栈（Pop）"></a>出栈（Pop）</h3><p><img src="https://i.imgtg.com/2022/11/03/Rg6ag.png" alt="Rg6ag.png" border="0"></p><h5 id="操作特性：后进先出"><a href="#操作特性：后进先出" class="headerlink" title="操作特性：后进先出"></a>操作特性：后进先出</h5><h2 id="栈的顺序储存结构"><a href="#栈的顺序储存结构" class="headerlink" title="栈的顺序储存结构"></a>栈的顺序储存结构</h2><h3 id="顺序栈—-栈的顺序储存结构"><a href="#顺序栈—-栈的顺序储存结构" class="headerlink" title="顺序栈—-栈的顺序储存结构"></a>顺序栈—-栈的顺序储存结构</h3><p><img src="https://i.imgtg.com/2022/11/03/Rgjdl.png" alt="Rgjdl.png" border="0"></p><p>指针top指示栈顶元素在数组中的位置</p><p>&nbsp;</p><p>进栈：top+1</p><p>栈空：top = -1</p><p>栈出：top-1</p><p>栈满：top = MAX_SIZE</p><p>&nbsp;</p><h3 id="栈的上溢与下溢"><a href="#栈的上溢与下溢" class="headerlink" title="栈的上溢与下溢"></a>栈的上溢与下溢</h3><p>在顺序栈中有”上溢”和”下溢”的概念。</p><p>顺序栈好比一个盒子，我们在里面放了一叠书，当我们要用书的话只能从最上面一本开始拿，那么当我们把书本放到这个栈中超过盒子的顶部时就放不下了，这时就是“上溢”，“上溢”也就是栈顶指针指出栈的外面，显然时出错了。</p><p>反之，当栈中已经没有书时，我们再去拿，发现已经没有书了，这就是“下溢”。“下溢”本身可以表示栈为栈空，因此可以用它来作为控制转移的条件。</p><p>&nbsp;</p><p><img src="https://i.imgtg.com/2022/11/03/Rg9yb.png" alt="Rg9yb.png" border="0"></p><p>如图</p><p>1.$a_N,…,a_2,a_1$用来储存数据。</p><p>2.定义一个top变量储存栈顶指针的位置。</p><p>3.定义一个MAX_SIZE表示栈的最大容量。</p><p>&nbsp;</p><h3 id="上溢的判断"><a href="#上溢的判断" class="headerlink" title="上溢的判断"></a>上溢的判断</h3><p>当栈为空时，top的值为-1.当往栈中压入一个元素时，top的值就会加1.</p><p>这样，a[0]就代表第一个进栈的元素，a[i-1]代表第i个进栈的元素，a[top]则表示栈顶的元素。</p><p>当top=MAX_SIZE-1时，表示栈满。如果再有元素进栈时，则栈会溢出，这时称为”上栈”。</p><h3 id="下栈的判断"><a href="#下栈的判断" class="headerlink" title="下栈的判断"></a>下栈的判断</h3><p>反之，当top=-1时，再将栈顶元素弹出，就要发生”下溢”</p><p>&nbsp;</p><h3 id="栈类的定义"><a href="#栈类的定义" class="headerlink" title="栈类的定义"></a>栈类的定义</h3><p>栈类的定义（以储存字符型数据为例）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>; <span class="comment">//定义栈最大常数值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;     <span class="comment">//线性表</span></span><br><span class="line">    <span class="type">int</span> size;       <span class="comment">//堆栈的实际大小</span></span><br><span class="line">    <span class="type">int</span> top;        <span class="comment">//栈顶</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> s);          <span class="comment">//有参构造函数</span></span><br><span class="line">    ~<span class="built_in">Stack</span>();   <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">char</span> ch)</span></span>;   <span class="comment">//成员函数：入栈</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">pop</span><span class="params">()</span></span>;            <span class="comment">//成员函数：出栈并返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getTop</span><span class="params">()</span></span>;           <span class="comment">//成员函数：获得栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;        <span class="comment">//成员函数：栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;         <span class="comment">//成员函数：栈是否满</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNull</span><span class="params">()</span></span>;        <span class="comment">//设置栈为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">size = MAX_SIZE;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">char</span>[MAX_SIZE];<span class="comment">//缺省构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">Srack</span>(<span class="type">int</span> s)&#123;</span><br><span class="line">size = s;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">char</span>[size]; <span class="comment">//根据指定的大小分配栈的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack::~Stack()&#123;</span><br><span class="line">delete[]data;     //内存回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">push</span>(<span class="type">char</span> ch)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isFull</span>())     <span class="comment">//解决数据上溢问题</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已满，无法入栈&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        top++;</span><br><span class="line">        data[top] = ch;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;已将元素&quot;</span>&lt;&lt;ch&lt;&lt;<span class="string">&quot;压入栈中&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此时top=&quot;</span>&lt;&lt;top&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈并返回栈顶元素"><a href="#出栈并返回栈顶元素" class="headerlink" title="出栈并返回栈顶元素"></a>出栈并返回栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;出栈中&quot;</span>&lt;&lt;endl;</span><br><span class="line">        top--;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此时top=&quot;</span>&lt;&lt;top&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> data[top+<span class="number">1</span>];<span class="comment">//返回被删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//解决数据下溢过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已为空，无法继续出栈&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得栈顶元素"><a href="#获得栈顶元素" class="headerlink" title="获得栈顶元素"></a>获得栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">getTop</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(!<span class="built_in">isEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;获得栈顶元素中...&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此时top=&quot;</span>&lt;&lt;top&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素为&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已为空，无法获得栈顶元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈是否为空"><a href="#栈是否为空" class="headerlink" title="栈是否为空"></a>栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">isEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top = <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//栈为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//栈不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈是否满"><a href="#栈是否满" class="headerlink" title="栈是否满"></a>栈是否满</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stack::isFull</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top &gt;= size - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//栈已满</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>； <span class="comment">//栈未满</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置栈为空"><a href="#设置栈为空" class="headerlink" title="设置栈为空"></a>设置栈为空</h3><h4 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> ch, <span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p> s中当前位置开始向后的n个字节中，把n个字节的<strong>每个字节</strong>都替换成ch。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;This is a new world&quot;</span>;</span><br><span class="line"><span class="built_in">memset</span> (str,<span class="string">&#x27;#&#x27;</span>,<span class="number">6</span>);</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#####<span class="meta">#s a new world</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack::<span class="built_in">setNull</span>(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(data,<span class="number">0</span>,len *<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//将char中元素全班替换为0</span></span><br><span class="line"><span class="keyword">this</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;此时top=&quot;</span>&lt;&lt;top&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="用异常捕获优化顺序栈"><a href="#用异常捕获优化顺序栈" class="headerlink" title="用异常捕获优化顺序栈"></a>用异常捕获优化顺序栈</h2><p>函数中最好不要有cout的输出语句，为保证类能多次重用。</p><p>输入输出的语句在display或者main函数中即可。</p><h3 id="用try…catch语句"><a href="#用try…catch语句" class="headerlink" title="用try…catch语句"></a>用try…catch语句</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(异常类型)&#123;</span><br><span class="line">    异常处理代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">catch</span>(异常处理)&#123;</span><br><span class="line">        异常处理代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="自定义异常类的使用"><a href="#自定义异常类的使用" class="headerlink" title="自定义异常类的使用"></a>自定义异常类的使用</h3><h4 id="定义一场内部类（在类的声明部分定义）"><a href="#定义一场内部类（在类的声明部分定义）" class="headerlink" title="定义一场内部类（在类的声明部分定义）"></a>定义一场内部类（在类的声明部分定义）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="丢出异常类（在pop函数遇到空栈时的语句）"><a href="#丢出异常类（在pop函数遇到空栈时的语句）" class="headerlink" title="丢出异常类（在pop函数遇到空栈时的语句）"></a>丢出异常类（在pop函数遇到空栈时的语句）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">Empty</span>();</span><br></pre></td></tr></table></figure><h4 id="捕获异常类（在调用pop函数时，用try-catch捕获）"><a href="#捕获异常类（在调用pop函数时，用try-catch捕获）" class="headerlink" title="捕获异常类（在调用pop函数时，用try/catch捕获）"></a>捕获异常类（在调用pop函数时，用try/catch捕获）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">       stack.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">catch</span>(Stack::Empty)&#123;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;Stack Empty!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="用类模板实现顺序栈"><a href="#用类模板实现顺序栈" class="headerlink" title="用类模板实现顺序栈"></a>用类模板实现顺序栈</h2><h3 id="通用的栈类"><a href="#通用的栈类" class="headerlink" title="通用的栈类"></a>通用的栈类</h3><p>DataType就是我们要使用的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Stack</span>();                    <span class="comment">//初始化栈</span></span><br><span class="line">    ~<span class="built_in">Stack</span>();                   <span class="comment">//销毁栈</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">empty</span><span class="params">()</span></span>;                <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(DataType &amp; x)</span></span>;   <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(DataType x)</span></span>;    <span class="comment">//压栈</span></span><br><span class="line">    <span class="function">DataType <span class="title">top</span><span class="params">()</span></span>;          <span class="comment">//取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;               <span class="comment">//遍历栈</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    DataType * data;         <span class="comment">//栈数据储存</span></span><br><span class="line">    <span class="type">int</span> len;                    <span class="comment">//栈当前元素个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数定义"><a href="#成员函数定义" class="headerlink" title="成员函数定义"></a>成员函数定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">Stack&lt;DataType&gt;::<span class="built_in">Stack</span>()&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;DataType&gt;::<span class="built_in">push</span>(DataType e)&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有类Stack的地方，后面都要改成Stack<Datatype></Datatype></p><p>&nbsp;</p><p>为了使用类模板对象，必须显示指定模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">char</span>&gt; charStack;</span><br><span class="line">Stack&lt;<span class="type">int</span>&gt; intStack;</span><br></pre></td></tr></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p><a href="https://blog.csdn.net/m0_53157173/article/details/113728312">(44条消息) c++模板学习10之类模板分文件编写_热爱编程的大忽悠的博客-CSDN博客</a></p><p>&nbsp;</p><h2 id="双端堆栈（两栈共享存储空间）"><a href="#双端堆栈（两栈共享存储空间）" class="headerlink" title="双端堆栈（两栈共享存储空间）"></a>双端堆栈（两栈共享存储空间）</h2><h3 id="优点：提高空间利用率"><a href="#优点：提高空间利用率" class="headerlink" title="优点：提高空间利用率"></a>优点：提高空间利用率</h3><p>两栈共享空间：使用一个数组来存储两个栈，让一个栈的栈底为该数组的始端，另一个栈的栈底为该数组的末端，两个栈从各自的端点向中间延伸。</p><p><img src="https://i.imgtg.com/2022/10/30/RUZ9v.png" alt="RUZ9v.png" border="0"></p><p>&nbsp;</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>栈1为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top1 = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>栈2为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op2 = Stack_Size;</span><br></pre></td></tr></table></figure><p>栈满</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top1+<span class="number">1</span> == top2;</span><br></pre></td></tr></table></figure><h3 id="两栈共享空间类的声明"><a href="#两栈共享空间类的声明" class="headerlink" title="两栈共享空间类的声明"></a>两栈共享空间类的声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Stack_Size=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BothStack</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">BothStack</span>( );</span><br><span class="line">       ~<span class="built_in">BothStack</span>( ); </span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> num, DataType x)</span></span>;   </span><br><span class="line">    <span class="comment">//num表示要处理1号栈还是2号栈</span></span><br><span class="line">       <span class="function">DataType <span class="title">Pop</span><span class="params">(<span class="type">int</span> num)</span></span>;          </span><br><span class="line">       <span class="function">DataType <span class="title">GetTop</span><span class="params">(<span class="type">int</span> num)</span></span>;       </span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="type">int</span> num)</span></span>;     </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">       DataType data[Stack_Size];     </span><br><span class="line">       <span class="type">int</span> top1, top2;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，也可以用类模板去实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Stack_Size=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BothStack</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">BothStack</span>( );</span><br><span class="line">       ~<span class="built_in">BothStack</span>( ); </span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> i, T x)</span></span>;   </span><br><span class="line">       <span class="function">T <span class="title">Pop</span><span class="params">(<span class="type">int</span> i)</span></span>;          </span><br><span class="line">       <span class="function">T <span class="title">GetTop</span><span class="params">(<span class="type">int</span> i)</span></span>;       </span><br><span class="line">       <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(<span class="type">int</span> i)</span></span>;     </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">       T data[Stack_Size];     </span><br><span class="line">       <span class="type">int</span> top1, top2;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 如果栈满，则抛出上溢异常；</span><br><span class="line"><span class="bullet">2.</span> 判断是插在栈1还是栈2；</span><br><span class="line"><span class="code">       2.1 若在栈1插入，则</span></span><br><span class="line"><span class="code">             2.1.1 top1加1;</span></span><br><span class="line"><span class="code">             2.1.2 在top1处填入x；</span></span><br><span class="line"><span class="code">       2.2 若在栈2插入，则</span></span><br><span class="line"><span class="code">             2.2.1 top2减1;</span></span><br><span class="line"><span class="code">             2.2.2 在top2处填入x；</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> BothStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">int</span> i, T x )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (top1==top2<span class="number">-1</span>) </span><br><span class="line">   <span class="keyword">throw</span> <span class="string">&quot;上溢&quot;</span>;</span><br><span class="line">   <span class="keyword">if</span> (i==<span class="number">1</span>) </span><br><span class="line">   data[++top1]=x;</span><br><span class="line">   <span class="keyword">if</span> (i==<span class="number">2</span>) </span><br><span class="line">   data[--top2]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.若是在栈1删除，则</span><br><span class="line"><span class="code">1.1 若栈1为空栈，抛出下溢异常；</span></span><br><span class="line"><span class="code">1.2 删除并返回栈1的栈顶元素；</span></span><br><span class="line"><span class="code">2.若是在栈2删除，则</span></span><br><span class="line"><span class="code">2.1 若栈2为空栈，抛出下溢异常；</span></span><br><span class="line"><span class="code">2.2 删除并返回栈2的栈顶元素；</span></span><br></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType BothStack&lt;DataType&gt;::<span class="built_in">Pop</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">   <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;   </span><br><span class="line">       <span class="keyword">if</span> (top1 == <span class="number">-1</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> data[top1--];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;                           </span><br><span class="line">       <span class="keyword">if</span> (top2 == StackSize)  </span><br><span class="line">           <span class="keyword">throw</span> <span class="string">&quot;下溢&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> data[top2++]; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断每个栈空"><a href="#判断每个栈空" class="headerlink" title="判断每个栈空"></a>判断每个栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; </span><br><span class="line"><span class="type">bool</span> BothStack&lt;DataType&gt;::<span class="built_in">Empty</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;     <span class="comment">//对于栈1操作</span></span><br><span class="line">        <span class="keyword">if</span>(top1 == <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//栈空就返回1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;    <span class="comment">//对于栈2操作</span></span><br><span class="line">        <span class="keyword">if</span>(top2 == StackSize)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取某个栈顶"><a href="#取某个栈顶" class="headerlink" title="取某个栈顶"></a>取某个栈顶</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt; </span><br><span class="line">DataType BothStack&lt;DataType&gt;::<span class="built_in">GetTop</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (top1!=<span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> data[top1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(top2!=StackSize)  </span><br><span class="line">            <span class="keyword">return</span> data[top2];</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> BothStack&lt;DataType&gt;::<span class="built_in">push</span>(<span class="type">int</span> num, DataType x)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isFull</span>(num))&#123;      <span class="comment">//如果栈已满</span></span><br><span class="line">    <span class="keyword">throw</span> BothStack&lt;DataType&gt;::<span class="built_in">Full</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">      top1++;</span><br><span class="line">      data[top1] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">      top2--;</span><br><span class="line">      data[top2] = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType BothStack&lt;DataType&gt;::<span class="built_in">pop</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty1</span>(num))&#123;       <span class="comment">//如果栈空</span></span><br><span class="line">      <span class="keyword">throw</span> BothStack&lt;DataType&gt;::<span class="built_in">Empty1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data[top1--];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty2</span>(num))&#123;</span><br><span class="line">      <span class="keyword">throw</span> BothStack&lt;DataType&gt;::<span class="built_in">Empty2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data[top2++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType BothStack&lt;DataType&gt;::<span class="built_in">getTop</span>(<span class="type">int</span> num)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty1</span>(num))&#123;</span><br><span class="line">      <span class="keyword">throw</span> BothStack&lt;DataType&gt;::<span class="built_in">Empty1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data[top1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isEmpty2</span>(num))&#123;</span><br><span class="line">      <span class="keyword">throw</span> BothStack&lt;DataType&gt;::<span class="built_in">Empty2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data[top2];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="栈的链式储存"><a href="#栈的链式储存" class="headerlink" title="栈的链式储存"></a>栈的链式储存</h3><h4 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  DataType data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span>*next;</span><br><span class="line">  &#125;Node;</span><br><span class="line">   Node *top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LinkStack</span>();</span><br><span class="line">  ~<span class="built_in">LinkStack</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(DataType x)</span></span>;</span><br><span class="line">  <span class="function">DataType <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">DataType <span class="title">getTop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h5 id="初始化链栈"><a href="#初始化链栈" class="headerlink" title="初始化链栈"></a>初始化链栈</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">LinkStack&lt;DataType&gt;::<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">  top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="销毁栈"><a href="#销毁栈" class="headerlink" title="销毁栈"></a>销毁栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">LinkStack&lt;DataType&gt;::~<span class="built_in">LinkStack</span>()&#123;</span><br><span class="line">  Node *q = top;</span><br><span class="line">  Node *p = top -&gt; next;</span><br><span class="line">  <span class="keyword">while</span>(top-&gt;next)&#123;</span><br><span class="line">    q = p -&gt;next;</span><br><span class="line">    <span class="built_in">delete</span>(p);</span><br><span class="line">    p = q -&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delete</span>(top);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="压栈-1"><a href="#压栈-1" class="headerlink" title="压栈"></a>压栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;DataType&gt;::<span class="built_in">push</span>(DataType x)&#123;</span><br><span class="line">  Node *s ;</span><br><span class="line">  s = <span class="keyword">new</span> Node;</span><br><span class="line">  s-&gt;data = x;</span><br><span class="line">  s-&gt;next = top;</span><br><span class="line">  top = s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="是否栈空"><a href="#是否栈空" class="headerlink" title="是否栈空"></a>是否栈空</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;DataType&gt;::<span class="built_in">isEmpty</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(top == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType LinkStack&lt;DataType&gt;::<span class="built_in">pop</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())</span><br><span class="line">    <span class="keyword">throw</span> LinkStack&lt;DataType&gt;::<span class="built_in">Empty</span>();</span><br><span class="line">  DataType x = top-&gt;data;</span><br><span class="line">  Node*p = top;</span><br><span class="line">  top = top -&gt;next;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="取栈顶元素-2"><a href="#取栈顶元素-2" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line">DataType LinkStack&lt;DataType&gt;::<span class="built_in">getTop</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())</span><br><span class="line">    <span class="keyword">throw</span> LinkStack&lt;DataType&gt;::<span class="built_in">Empty</span>();</span><br><span class="line">  DataType x = top-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> DataType&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> LinkStack &lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  intStack s;</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;栈顶元素：&quot;</span>&lt;&lt; s.<span class="built_in">getTop</span>() &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    x = s.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">    x = s.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">    x = s.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(intStack::Empty)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LinkStack is Empty!&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="栈的应用—表达式求值"><a href="#栈的应用—表达式求值" class="headerlink" title="栈的应用—表达式求值"></a>栈的应用—表达式求值</h2><h3 id="一、表达式求值的规则"><a href="#一、表达式求值的规则" class="headerlink" title="一、表达式求值的规则"></a>一、表达式求值的规则</h3><p>表达式求值是程序设计语言编译中的一个基本问题。它的实现就是对“栈”的典型应用。<br>首先了解算术四则运算的运算规则：<br>（1）先乘除，后加减。<br>（2）从左到右计算<br>（3）先算括号内，再算括号外</p><p>&nbsp;</p><p>任何一个表达式都由操作数（operand）、运算符（operator）和界定符组成：</p><p>&nbsp;</p><h3 id="二、运算符优先级"><a href="#二、运算符优先级" class="headerlink" title="二、运算符优先级"></a>二、运算符优先级</h3><p>对于两个相继出现的操作符$\theta_1$和$\theta_2$有三种关系：<br>$\theta_1$ &lt;$\theta_2$ $\theta_1$的优先级低于$\theta_2$<br>$\theta_1$ =$\theta_2$ $\theta_1$的优先级等于$\theta_2$<br>$\theta_1$ &gt;$\theta_2$ $\theta_1$的优先级高于$\theta_2$<br>由此可以列出“+-*/”之间的优先级。如下图</p><p><img src="https://i.imgtg.com/2022/10/30/RUmdr.png" alt="RUmdr.png" border="0"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">getPriority</span><span class="params">(<span class="type">char</span> theta1, <span class="type">char</span> theta2)</span>   <span class="comment">//获取theta1与theta2之间的优先级  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> priority[][<span class="number">7</span>] =     <span class="comment">//算符间的优先级关系  </span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;0&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;=&#x27;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index1 = <span class="built_in">getIndex</span>(theta1);    <span class="comment">//theta_1即为表中的行</span></span><br><span class="line">    <span class="type">int</span> index2 = <span class="built_in">getIndex</span>(theta2);    <span class="comment">//theta_1即为表中的列</span></span><br><span class="line">    <span class="keyword">return</span> priority[index1][index2];   <span class="comment">//返回表中的index1行index2列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其返回值为&gt;,&lt;,=</span></span><br></pre></td></tr></table></figure><h3 id="三、算法思路"><a href="#三、算法思路" class="headerlink" title="三、算法思路"></a>三、算法思路</h3><p>为实现优先算法，可以使用两个工作栈，一个是OPTR，用于寄存运算符，一个是OPND，用于寄存操作数和运算结果。算法的基本思想是：<br>（1） 首先置操作数栈为空栈，表达式起始符’#’为栈底元素。<br>（2）依次读入表达式中的每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先级作相应操作，直至整个表达式求值完毕（OPTR栈顶元素和当前读入的字符均为’#’）</p><p><img src="https://i.imgtg.com/2022/10/30/RUgvc.png" alt="RUgvc.png" border="0"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">getAnswer</span><span class="params">()</span> </span>&#123;   <span class="comment">//表达式求值  </span></span><br><span class="line">&#123;</span><br><span class="line">    opter.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>);      <span class="comment">//首先将&#x27;#&#x27;入栈opter  </span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;      <span class="comment">//添加变量counter表示有多少个数字相继入栈，实现多位数的四则运算  </span></span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();    <span class="comment">//读取缓冲区</span></span><br><span class="line">    <span class="keyword">while</span> (c != <span class="string">&#x27;#&#x27;</span> || opter.<span class="built_in">top</span>() != <span class="string">&#x27;#&#x27;</span>)   <span class="comment">//终止条件  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c))   <span class="comment">//如果c在&#x27;0&#x27;~&#x27;9&#x27;之间  </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">1</span>)   <span class="comment">//counter==1表示上一字符也是数字，所以要合并，比如12*12，要算12，而不是单独的1和2  </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> t = opval.<span class="built_in">top</span>();</span><br><span class="line">                opval.<span class="built_in">pop</span>();</span><br><span class="line">                opval.<span class="built_in">push</span>(t * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                counter = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                opval.<span class="built_in">push</span>(c - <span class="string">&#x27;0&#x27;</span>);     <span class="comment">//将c对应的数值入栈opval  </span></span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">            c = <span class="built_in">getchar</span>();   <span class="comment">//读取缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            counter = <span class="number">0</span>;   <span class="comment">//counter置零  </span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">getPriority</span>(opter.<span class="built_in">top</span>(), c))   <span class="comment">//获取运算符栈opter栈顶元素与c之间的优先级，用&#x27;&gt;&#x27;，&#x27;&lt;&#x27;，&#x27;=&#x27;表示  </span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:               <span class="comment">//&lt;则将c入栈opter  </span></span><br><span class="line">                opter.<span class="built_in">push</span>(c);</span><br><span class="line">                c = <span class="built_in">getchar</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:               <span class="comment">//=将opter栈顶元素弹出，用于括号的处理  </span></span><br><span class="line">                opter.<span class="built_in">pop</span>();</span><br><span class="line">                c = <span class="built_in">getchar</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:               <span class="comment">//&gt;则计算  </span></span><br><span class="line">                <span class="type">char</span> theta = opter.<span class="built_in">top</span>();</span><br><span class="line">                opter.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> a = opval.<span class="built_in">top</span>();</span><br><span class="line">                opval.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">double</span> b = opval.<span class="built_in">top</span>();</span><br><span class="line">                opval.<span class="built_in">pop</span>();</span><br><span class="line">                opval.<span class="built_in">push</span>(<span class="built_in">calculate</span>(b, theta, a));<span class="comment">//计算栈出的b，theta和a</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opval.<span class="built_in">top</span>();   <span class="comment">//返回opval栈顶元素的值  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四，计算b，theta和a"><a href="#四，计算b，theta和a" class="headerlink" title="四，计算b，theta和a"></a>四，计算b，theta和a</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">(<span class="type">double</span> b, <span class="type">char</span> theta, <span class="type">double</span> a)</span>   <span class="comment">//计算b theta a  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (theta)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b + a;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b - a;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b * a;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> b / a;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五，获取theta所对应的索引"><a href="#五，获取theta所对应的索引" class="headerlink" title="五，获取theta所对应的索引"></a>五，获取theta所对应的索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(<span class="type">char</span> theta)</span>   <span class="comment">//获取theta所对应的索引  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (theta)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        index = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        index = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        index = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">        index = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六，主函数"><a href="#六，主函数" class="headerlink" title="六，主函数"></a>六，主函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">char</span>&gt; opter;    <span class="comment">//运算符栈  </span></span><br><span class="line">stack&lt;<span class="type">double</span>&gt; opval;  <span class="comment">//操作数栈  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin);  </span></span><br><span class="line">    <span class="type">int</span> t;     <span class="comment">// 需要计算的表达式的个数  </span></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!opter.<span class="built_in">empty</span>())opter.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!opval.<span class="built_in">empty</span>())opval.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">double</span> ans = <span class="built_in">getAnswer</span>();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2+3*4*(5-2)+6#</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/10/30/RUyUq.png" alt="RUyUq.png" border="0"></p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><img src="https://i.imgtg.com/2022/10/30/RUPNG.png" alt="RUPNG.png" border="0"></p><p>&nbsp;</p><h4 id="输入（多位数）"><a href="#输入（多位数）" class="headerlink" title="输入（多位数）"></a>输入（多位数）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">23*(2+5)+62/3#</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/10/30/RURE1.png" alt="RURE1.png" border="0"></p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p><img src="https://i.imgtg.com/2022/10/30/RUDFD.png" alt="RUDFD.png" border="0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ardunio学习笔记</title>
      <link href="/posts/dcbcab13.html"/>
      <url>/posts/dcbcab13.html</url>
      
        <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>属于初始化工作（只运行一次）</span><br><span class="line">2、<span class="type">void</span> loop（）函数会永远反复的运行</span><br><span class="line">    loop函数中最后最好加一个延时函数保证程序正常运行</span><br><span class="line">3、delay （）；延迟某段时间，括号内可以添加变量名称</span><br><span class="line">4、delay （）；：</span><br><span class="line">小LED会亮3s灭3s，一直持续下去</span><br></pre></td></tr></table></figure><p>arduino中有一个可以自己控制的LED连接在引脚13</p><h2 id="编程语句参考"><a href="#编程语句参考" class="headerlink" title="编程语句参考"></a>编程语句参考</h2><p><a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/">Arduino编程语句参考 – 太极创客 (taichi-maker.com)</a></p><p><a href="https://www.arduino.cc/reference/en/">阿尔杜伊诺参考 - 阿尔杜伊诺参考 (arduino.cc)</a></p><p>&nbsp;</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="数字io"><a href="#数字io" class="headerlink" title="数字io"></a>数字io</h3><h4 id="pinMode"><a href="#pinMode" class="headerlink" title="pinMode"></a>pinMode</h4><p>形式pinMode(引脚，工作模式)</p><p>其中可以设置为1.input 2.output 3.INPUT_PULLUP</p><p>上拉电阻模式（INPUT_PULLUP）</p><p>arduino中内部自带上拉电阻</p><h4 id="digitalWrite-引脚，高低电平"><a href="#digitalWrite-引脚，高低电平" class="headerlink" title="digitalWrite(引脚，高低电平)"></a>digitalWrite(引脚，高低电平)</h4><p>将数字引脚写<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/high/">HIGH</a>（高电平）或<a href="http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/low/">LOW</a>（低电平）</p><p>digitalRead(pin)</p><p>pin就是被读取的引脚号</p><p>有返回值HIGH或者LOW </p><p>&nbsp;</p><h3 id="模拟io"><a href="#模拟io" class="headerlink" title="模拟io"></a>模拟io</h3><h4 id="analogRead-读取引脚"><a href="#analogRead-读取引脚" class="headerlink" title="analogRead(读取引脚)"></a>analogRead(读取引脚)</h4><p>Arduino可以将0－5伏特的电压输入信号映射到数值0－1023我们可以将5伏特等分成1024份。0伏特的输入信号对应着数值0，而5伏特的输入信号对应着1023。</p><p>例：<br>当模拟输入引脚的输入电压为2.5伏特的时候，该引脚的数值为512。<br>(2.5伏特 / 5伏特 = 0.5， 1024 X 0.5 ＝512)</p><p>&nbsp;</p><h4 id="analogWrite-pin-value"><a href="#analogWrite-pin-value" class="headerlink" title="analogWrite(pin, value)"></a>analogWrite(pin, value)</h4><p><code>pin</code>：被读取的模拟引脚号码<br><code>value</code>：0到255之间的PWM频率值, 0对应off, 255对应on</p><p>可以将value的数值写入pin</p><p>Arduino每一次对引脚执行analogWrite()指令，都会给该引脚一个固定频率的PWM信号。</p><p>这个操作可以用来控制LED的亮度, 或者控制电机的转速</p><p>&nbsp;</p><h3 id="数学信号"><a href="#数学信号" class="headerlink" title="数学信号"></a>数学信号</h3><h4 id="map（）-等比映射"><a href="#map（）-等比映射" class="headerlink" title="map（）-等比映射"></a>map（）-等比映射</h4><p>map()可以用来将某一数值从一个区间等比映射到一个新的区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> (x, in_min, in_max, out_min, out_max)</span><br></pre></td></tr></table></figure><p>x： 要映射的值<br>in_min： 映射前区间最小值<br>in_max： 映射前区间最大值<br>out_min： 映射后区间最小值<br>out_max 映射后区间最大值</p><p>&nbsp;</p><h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><p>LED工作电流为20毫安，工作是约产生2v左右的电压降</p><p>&nbsp;</p><h2 id="按键开关（数字输入）"><a href="#按键开关（数字输入）" class="headerlink" title="按键开关（数字输入）"></a>按键开关（数字输入）</h2><p>按键开关：相连不同侧，同侧不相连</p><p>arduino的引脚设置为数字输入（input）状态时可以识别两种状态时可以识别两种状态</p><p>HIGH(高电平)LOW(低电平)</p><p>&nbsp;</p><h2 id="串口监视器"><a href="#串口监视器" class="headerlink" title="串口监视器"></a>串口监视器</h2><p>Serial.begin(9600);</p><p>串口初始化，每秒9600位。</p><p>9600是常用的速度档。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光敏电阻</title>
      <link href="/posts/dcbcab13.html"/>
      <url>/posts/dcbcab13.html</url>
      
        <content type="html"><![CDATA[<h2 id="光敏电阻（LDR）"><a href="#光敏电阻（LDR）" class="headerlink" title="光敏电阻（LDR）"></a>光敏电阻（LDR）</h2><p>光敏电阻的阻值随着环境亮度的增加儿减小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);  <span class="comment">//启动串口通讯</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;   </span><br><span class="line">  Serial.print(<span class="string">&quot;LDR Reading: &quot;</span>);  <span class="comment">//通过串口监视器</span></span><br><span class="line">  Serial.println(analogRead(A0)); <span class="comment">//输出LDR读数 </span></span><br><span class="line">  delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过加入一个10k的电子分压，使得AO引脚接收的电压值会随着LDR正向增大或减小。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/79666db.html"/>
      <url>/posts/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表是由若干结点构成</p><p>单链表的结点只有一个指针域（单链表包含一个指针域和一个数据域）</p><h3 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h3><p>头指针：指向第一个结点的地址</p><p>尾标志：终端结点的指针域为空</p><p>&nbsp;</p><h4 id="申请一个结点"><a href="#申请一个结点" class="headerlink" title="申请一个结点"></a>申请一个结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">DataType data;     <span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *next;   <span class="comment">//指针域</span></span><br><span class="line">&#125;Node,*Link;   </span><br><span class="line"><span class="comment">//用typedef去声明结构体时，Node和*Link两个位置就被定义成了类型</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node st;    <span class="comment">//struct node st;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Link p;     <span class="comment">//struct node *p;  //p是一个指向结构体的指针</span></span><br></pre></td></tr></table></figure><h4 id="申请结点"><a href="#申请结点" class="headerlink" title="申请结点"></a>申请结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=(Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(node);     <span class="comment">//计算出node结点的大小</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));   <span class="comment">//用malloc分配给Link这么大的空间  malloc返回函数时viod*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分配地址以后，其把首地址分配给了指针p，在使用这块空间的时候，需要对这块地址进行强制转换。转换成指针p希望看到的类型。</p><p>指针p是一个Link类型，所以把malloc也定义成Link类型</p><p>&nbsp;</p><h3 id="如何引用数据元素？"><a href="#如何引用数据元素？" class="headerlink" title="如何引用数据元素？"></a>如何引用数据元素？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).data;</span><br><span class="line">p-&gt;data;</span><br></pre></td></tr></table></figure><h3 id="如何引用指针域？"><a href="#如何引用指针域？" class="headerlink" title="如何引用指针域？"></a>如何引用指针域？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="单链表的遍历操作"><a href="#单链表的遍历操作" class="headerlink" title="单链表的遍历操作"></a>单链表的遍历操作</h3><p>操作接口：void displayNode(Link head);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayNode</span><span class="params">(Link head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p= head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p-&gt;next&lt;&lt;endl;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求单链表的元素个数"><a href="#求单链表的元素个数" class="headerlink" title="求单链表的元素个数"></a>求单链表的元素个数</h3><p>操作接口：int length(Link head);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(Link head)</span></span>&#123;</span><br><span class="line">p = head-&gt;next;    <span class="comment">//p指向头指针的next域</span></span><br><span class="line">count = <span class="number">0</span>;         <span class="comment">//count的数值为零</span></span><br><span class="line"><span class="keyword">while</span>(p！=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;    <span class="comment">//如果p不为空，则p指向下一个结点的                           // next域</span></span><br><span class="line">count++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> count;      <span class="comment">//注意count和初始化返回值之间的关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="单链表的查找操作"><a href="#单链表的查找操作" class="headerlink" title="单链表的查找操作"></a>单链表的查找操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryNode</span><span class="params">(Link head,DaraType x)</span></span>&#123;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p—&gt;data==x)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;data&lt;&lt;endl;    <span class="comment">//找到则调用输出函数，并提                                  //前返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果链表结束，说明没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的插入操作"><a href="#单链表的插入操作" class="headerlink" title="单链表的插入操作"></a>单链表的插入操作</h3><p>操作接口：void insertNode(Link head,int i,DataType x);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node)); <span class="comment">//申请一个结点node</span></span><br><span class="line">node-&gt;data = x;                    <span class="comment">//结点的数据域是x</span></span><br><span class="line">node -&gt; next = p-&gt;next;            <span class="comment">//p的next域赋给node的                                    //next域</span></span><br><span class="line">p-&gt;next = node;          <span class="comment">//将node的数据域赋值给p的next域</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgcuI.png" alt="RgcuI.png" border="0"></p><ol><li><p>工作指针p初始化</p></li><li><p>查找第i-1个结点并使用、工作指针p指向该结点</p></li><li><p>若查找不成功，则返回false</p><p>3.1生成一个元素值为x的新结点；</p><p>3.2将新结点s插入到结点p之后；</p><p>3.3返回true；  </p><p> &nbsp;</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insertNode</span><span class="params">(Link head,<span class="type">int</span> i,DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = head;          <span class="comment">//工作指针p指向头结点</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;count&lt;i<span class="number">-1</span>) <span class="comment">//查找第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//没有找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));<span class="comment">//申请一个结点                                             //node</span></span><br><span class="line">        node-&gt;data=x;</span><br><span class="line">        node-&gt;next=p-&gt;next; <span class="comment">//结点node插入结点p之后</span></span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="创建一个单链表—-头插法"><a href="#创建一个单链表—-头插法" class="headerlink" title="创建一个单链表—-头插法"></a>创建一个单链表—-头插法</h3><p>操作接口：Link newList(DataType a[],int n)</p><p><strong>头插法</strong>：将待插入结点插在头结点的后面。</p><h4 id="初始化头结点"><a href="#初始化头结点" class="headerlink" title="初始化头结点"></a>初始化头结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgQaM.png" alt="RgQaM.png" border="0"></p><h4 id="插入第一个元素"><a href="#插入第一个元素" class="headerlink" title="插入第一个元素"></a>插入第一个元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">node-&gt;data=a[<span class="number">0</span>];</span><br><span class="line">node-&gt;next=head-&gt;next;</span><br><span class="line">head-&gt;next=node;</span><br></pre></td></tr></table></figure><p><img src="https://img1.imgtp.com/2022/10/13/6ct2kjQH.png" alt="image-20221005111133614.png" title="image<img src=" %e9%93%be%e8%a1%a8.assets rg0e1.png" border="0">-20221005111133614.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">node-&gt;data=a[<span class="number">1</span>];</span><br><span class="line">node-&gt;next=head-&gt;next;</span><br><span class="line">head-&gt;next=node;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgSNG.png" alt="RgSNG.png" border="0"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;</span><br><span class="line"><span class="function">Link <span class="title">newList</span><span class="params">(DataType a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head=(Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建后续结点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = a[i];</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = node;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="创建一个单链表—-尾插法"><a href="#创建一个单链表—-尾插法" class="headerlink" title="创建一个单链表—-尾插法"></a>创建一个单链表—-尾插法</h3><p>操作接口：Link newList(DataType a[],int n)</p><p>尾插法：将待插入结点插在终端结点的后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));  <span class="comment">//创建一个头</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;           </span><br><span class="line">rear = head;               <span class="comment">//将head赋给rear</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgEdr.png" alt="RgEdr.png" border="0"></p><h4 id="插入第一个元素结点"><a href="#插入第一个元素结点" class="headerlink" title="插入第一个元素结点"></a>插入第一个元素结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node)); <span class="comment">//创建结点node</span></span><br><span class="line">node-&gt;data = a[<span class="number">0</span>];         <span class="comment">//结点第一个数据域</span></span><br><span class="line">rear-&gt;next = node;         <span class="comment">//rear的next域是node</span></span><br><span class="line">rear = node;               <span class="comment">//将node名为rear</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgsFD.png" alt="RgsFD.png" border="0"></p><h4 id="依次插入每一个结点"><a href="#依次插入每一个结点" class="headerlink" title="依次插入每一个结点"></a>依次插入每一个结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node))</span><br><span class="line">node-&gt;dat = a[<span class="number">1</span>];</span><br><span class="line">rear-&gt;next = node;</span><br><span class="line">rear = node;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/03/RgVRF.png" alt="RgVRF.png" border="0"></p><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Link <span class="title">newList</span><span class="params">(DataType a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  head = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">  head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  rear = head;         <span class="comment">//尾指针初始化</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   node=(Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));<span class="comment">//创建结点</span></span><br><span class="line">   node-&gt;data = a[i];</span><br><span class="line">   rear-&gt;next = node;</span><br><span class="line">   rear = ndoe;</span><br><span class="line">  &#125;</span><br><span class="line">  rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h4 id="单链表结点的删除"><a href="#单链表结点的删除" class="headerlink" title="单链表结点的删除"></a>单链表结点的删除</h4><p>操作接口：bool deleteNode(Link head, Datatype x);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);     </span><br></pre></td></tr></table></figure><p>将q的next域指向p的next域，将被删除的p空间释放。</p><h5 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h5><p>在查找过程中，如果发现p所指向的结点data值不是要找的x，则p，q同时后移；一旦找到则执行删除操作</p><p>&nbsp;</p><p>查找到p结点并将其删除</p><p>1.如何找到p结点。</p><p>2.如何保证p，q指针一前一后。</p><p>&nbsp;</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = head-&gt;next;</span><br><span class="line">q = head;</span><br></pre></td></tr></table></figure><h5 id="指针移动一次"><a href="#指针移动一次" class="headerlink" title="指针移动一次"></a>指针移动一次</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q = p;</span><br><span class="line">p = p-&gt;next;</span><br></pre></td></tr></table></figure><h5 id="删除中的特殊情况"><a href="#删除中的特殊情况" class="headerlink" title="删除中的特殊情况"></a>删除中的特殊情况</h5><p>在查找过程中，如果一直没有找到data域为x的结点，或者发现待删除的表是空表，则提前返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>1.判断是否是空表，如果是空表返回false；</p><p>2.工作指针p，q初始化</p><p>3.若p指针不为空，则继续下列循环：</p><p>​    3.1如果找到data域等于x的结点，则：</p><p>​        3.1.1摘链，将结点p的从链表上摘下来</p><p>​        3.1.2释放别删除的结点</p><p>​        3.1.3提前返回true，代表删除成功</p><p>4.循环结束了，说明没有找到和x相等的结点，则返回false</p><p>&nbsp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deleteNode</span><span class="params">(Link head,DataType x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">p=head-&gt;next;</span><br><span class="line">q=head;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==x)&#123;</span><br><span class="line">q-&gt;next=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);    <span class="comment">//单链表的释放</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果循环结束了，说明没有找到和x相关的结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h2 id="循环列表的实现"><a href="#循环列表的实现" class="headerlink" title="循环列表的实现"></a>循环列表的实现</h2><p>将单链表的首位相接，将终端结点的指针由空指针改为指向头结点，构成<strong>单循环链表</strong>，简称<strong>循环链表</strong></p><p><img src="https://i.imgtg.com/2022/11/03/RgY96.png" alt="RgY96.png" border="0"></p><p>&nbsp;</p><h4 id="循环链表的插入"><a href="#循环链表的插入" class="headerlink" title="循环链表的插入"></a>循环链表的插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">node-&gt;data = x;</span><br><span class="line">node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = node;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p! = <span class="literal">NULL</span>;     <span class="comment">//p != head</span></span><br><span class="line">p-&gt;next != <span class="literal">NULL</span>;    <span class="comment">//p-&gt;next != head </span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表的每一个结点中再设置一个指向其前驱结点的指针域。</p><p><img src="https://i.imgtg.com/2022/11/03/RglUP.png" alt="RglUP.png" border="0"></p><p>data：数据域，储存数据元素</p><p>prior：指针域，储存该结点的前驱结点地址</p><p>next：指针域，储存该结点的后继结点地址</p><p>&nbsp;</p><h2 id="一元多项式的相加"><a href="#一元多项式的相加" class="headerlink" title="一元多项式的相加"></a>一元多项式的相加</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>实现两个一元n次多项式的加法。例如P(A)=x+3x2-5x5+7，P(B)=2x2+6x3+x5-4x6，求P(A)+P(B)。</p><p>首先弄清楚一元多项式的加法原理，然后明确多项式的存储方法。链表节点存储系数和指数，只存系数非0的项。</p><h3 id="输入二项式数据的函数"><a href="#输入二项式数据的函数" class="headerlink" title="输入二项式数据的函数"></a>输入二项式数据的函数</h3><p>给用户合适的提示，读入用户输入的系数和指数。<br>调用函数insert，将用户输入的二项式的一项插入到链表中去。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputPoly</span><span class="params">(Link head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> coefficient, exp;<span class="comment">//系数和指数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入系数和指数（如：\&quot;2 3\&quot;表示2x^3）:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; coefficient&gt;&gt;exp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (coefficient != <span class="number">0</span> || exp != <span class="number">0</span>)<span class="comment">//连续输入多个系数和指数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(head, coefficient, exp);<span class="comment">//调函数输入多项式</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入系数和指数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; coefficient&gt;&gt;exp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="向多项式链表中插入元素的函数"><a href="#向多项式链表中插入元素的函数" class="headerlink" title="向多项式链表中插入元素的函数"></a>向多项式链表中插入元素的函数</h3><p>int coefficient 一个多项式项的系数<br>int exp 一个多项式项的幂</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Link head, <span class="type">int</span> coefficient, <span class="type">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Link node;  <span class="comment">//node指针指向新创建的节点</span></span><br><span class="line">    Link q, p;   <span class="comment">//q,p两个节点一前一后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个新结点</span></span><br><span class="line">    q = head;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    node = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    node-&gt;coefficient = coefficient;</span><br><span class="line">    node-&gt;exp = exp;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)<span class="comment">//空表,插第1个</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (exp == p-&gt;exp) &#123;</span><br><span class="line">                p-&gt;coefficient += coefficient;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大于当前次数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (exp &gt; p-&gt;exp) &#123;</span><br><span class="line">                q-&gt;next = node;</span><br><span class="line">                node-&gt;next = p;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q-&gt;next = node;</span><br><span class="line">            node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果退出循环是当前指针p移动到链表结尾，则说明之前没有插入，那么当前node节点的指数值是最大值，此时插在链表的最后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="多项式的输出"><a href="#多项式的输出" class="headerlink" title="多项式的输出"></a>多项式的输出</h3><p>数字转换为字符串函数itoa<br>标志是否为第一个节点的flag的设置<br>字符串连接函数strcat<br>字符串清空函数memset。memset(item,0,20);清空长20的字符串item</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cout</span><span class="params">(Link head)</span> </span>&#123;</span><br><span class="line">    Link p; <span class="comment">//指向链表要输出的结点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;多项式如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;多项式为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是空表</span></span><br><span class="line">    <span class="type">char</span> item[<span class="number">20</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//要打印的当前多项式的一项</span></span><br><span class="line">    <span class="type">char</span> number[<span class="number">7</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//暂时存放系数转换成的字符串</span></span><br><span class="line">    <span class="type">bool</span> isFirstItem = <span class="literal">true</span>;<span class="comment">//标志是否为第一个节点的flag</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//打印节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(item, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">//清空字符串item</span></span><br><span class="line">        _itoa_s(p-&gt;coefficient, number, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;coefficient == <span class="number">0</span>) &#123;<span class="comment">//当为0时的判断非常容易出错</span></span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                isFirstItem = <span class="literal">true</span>;<span class="comment">//如果第一项系数为0，移动指针，判断仍为true</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFirstItem != <span class="literal">true</span> &amp;&amp; p-&gt;coefficient &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;coefficient == <span class="number">1</span>) &#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;coefficient == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;coefficient != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;exp == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;exp == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;coefficient == <span class="number">1</span> || p-&gt;coefficient == <span class="number">-1</span>)</span><br><span class="line">                    <span class="built_in">strcat_s</span>(item, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, <span class="string">&quot;x^&quot;</span>);</span><br><span class="line">                _itoa_s(p-&gt;exp, number, <span class="number">10</span>);</span><br><span class="line">                <span class="built_in">strcat_s</span>(item, <span class="number">20</span>,number);</span><br><span class="line">                <span class="comment">//strcat_s(item, _itoa_s(p-&gt;exp, number, 10));</span></span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; item ;<span class="comment">//打印当前节点代表的项</span></span><br><span class="line">        p = p-&gt;next;<span class="comment">//指向下个结点</span></span><br><span class="line">        isFirstItem = <span class="literal">false</span>; <span class="comment">//flag标志不是第一项了</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="链表合并"><a href="#链表合并" class="headerlink" title="链表合并"></a>链表合并</h3><p>合并两个有序链表a，b到链表ab<br>heada.headb,headab分别为链表a,b,ab的头指针</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">combin2List</span><span class="params">(Link heada, Link headb, Link headab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Link pa, pb;<span class="comment">//指向a，b链表和ab的指针</span></span><br><span class="line">    pa = heada-&gt;next;</span><br><span class="line">    pb = headb-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (pa != <span class="literal">NULL</span> &amp;&amp; pb != <span class="literal">NULL</span>)<span class="comment">//a,b链表都没有没有访问完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果指数a&gt;指数b，a节点插入ab链表，a指针后移</span></span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;exp &gt; pb-&gt;exp) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(headab, pa-&gt;coefficient, pa-&gt;exp);</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果指数a&lt;指数b，b节点插入ab链表，b指针后移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;exp &lt; pb-&gt;exp) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(headab, pb-&gt;coefficient, pb-&gt;exp);</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果指数a==指数b，a、b系数相加，插入ab链表，a、b指针后移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;exp == pb-&gt;exp) &#123;</span><br><span class="line">            <span class="type">int</span> coefficient;<span class="comment">//系数</span></span><br><span class="line">            coefficient = pa-&gt;coefficient + pb-&gt;coefficient;</span><br><span class="line">            <span class="built_in">insert</span>(headab, coefficient, pa-&gt;exp);</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果a，b链表后还有尾巴，则加到链表后面   是否可以去掉</span></span><br><span class="line">        <span class="keyword">while</span> (pa != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(headab, pa-&gt;coefficient, pa-&gt;exp);</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(headab, pb-&gt;coefficient, pb-&gt;exp);</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果a、b链表还有尾巴，将它加到ab链表后面</span></span><br><span class="line">    <span class="keyword">while</span> (pa != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(headab, pa-&gt;coefficient, pa-&gt;exp);</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pb != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">insert</span>(headab, pb-&gt;coefficient, pb-&gt;exp);</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><p>在main函数中一定不能忘记释放空间</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearLink</span><span class="params">(Link head)</span> </span>&#123;</span><br><span class="line">    Link p, q;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _UNICODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="定义结点"><a href="#定义结点" class="headerlink" title="定义结点"></a>定义结点</h3><p>其中，数据域包含指数和系数，还有一个指向下一个结点的指针</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> coefficient;<span class="comment">//系数</span></span><br><span class="line">    <span class="type">int</span> exp;<span class="comment">//指数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PNode</span>* next;</span><br><span class="line">&#125;*Link, Node;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputPoly</span><span class="params">(Link head)</span></span>;<span class="comment">//用于从控制台读入链表的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cout</span><span class="params">(Link head)</span></span>;<span class="comment">//打印链表用的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Link head, <span class="type">int</span> coefficient, <span class="type">int</span> exp)</span></span>;<span class="comment">//向链表插入一个元素的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combin2List</span><span class="params">(Link heada, Link headb, Link headab)</span></span>;<span class="comment">//合并两个链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearLink</span><span class="params">(Link head)</span></span>;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Link headA, headB;<span class="comment">//两个多项式的头指针</span></span><br><span class="line">    Link headAB;<span class="comment">//合并后的多项式的头指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*链表的初始化*/</span></span><br><span class="line">    headA = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    headA-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    headB = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    headB-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    headAB = (Link)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    headAB-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入第一个多项式的系数和指数，以（0 0）结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">inputPoly</span>(headA);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个&quot;</span> ;</span><br><span class="line">    <span class="built_in">Cout</span>(headA);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入第二个多项式的系数和指数，以（0 0）结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">inputPoly</span>(headB);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二个&quot;</span> ;</span><br><span class="line">    <span class="built_in">Cout</span>(headB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">combin2List</span>(headA, headB, headAB);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;合并后&quot;</span> ;</span><br><span class="line">    <span class="built_in">Cout</span>(headAB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearLink</span>(headA);</span><br><span class="line">    <span class="built_in">clearLink</span>(headB);</span><br><span class="line">    <span class="built_in">clearLink</span>(headAB);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个多项式的系数和指数，以(<span class="number">0</span> <span class="number">0</span>)结束：</span><br><span class="line">请输入系数和指数(如：<span class="string">&quot;2 3&quot;</span>表示<span class="number">2</span>x^<span class="number">3</span>)：<span class="number">1</span> <span class="number">1</span></span><br><span class="line">请输入系数和指数：<span class="number">-1</span> <span class="number">1</span></span><br><span class="line">请输入系数和指数：<span class="number">2</span> <span class="number">2</span></span><br><span class="line">请输入系数和指数：<span class="number">0</span> <span class="number">0</span></span><br><span class="line">第一个多项式如下：</span><br><span class="line"><span class="number">2</span>x^<span class="number">2</span></span><br><span class="line">请输入第二个多项式的系数和指数，以(<span class="number">0</span> <span class="number">0</span>)结束：</span><br><span class="line">请输入系数和指数(如：<span class="string">&quot;2 3&quot;</span>表示<span class="number">2</span>x^<span class="number">3</span>)：<span class="number">-2</span> <span class="number">2</span></span><br><span class="line">请输入系数和指数：<span class="number">2</span> <span class="number">3</span></span><br><span class="line">请输入系数和指数：<span class="number">4</span> <span class="number">5</span></span><br><span class="line">请输入系数和指数：<span class="number">0</span> <span class="number">0</span></span><br><span class="line">第二个多项式如下：</span><br><span class="line"><span class="number">4</span>x^<span class="number">5</span>+<span class="number">2</span>x^<span class="number">3</span><span class="number">-2</span>x^<span class="number">2</span></span><br><span class="line">合并后多项式如下：</span><br><span class="line"><span class="number">4</span>x^<span class="number">5</span>+<span class="number">2</span>x^<span class="number">3</span></span><br></pre></td></tr></table></figure><p>输入</p><p><img src="https://i.imgtg.com/2022/11/01/RrkBG.png" alt="RrkBG.png" border="0"></p><p>&nbsp;</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个多项式的系数和指数，以(0 0)结束：</span><br><span class="line">请输入系数和指数(如：2 3表示2x^3)：4 2</span><br><span class="line">请输入系数和指数：-3 3</span><br><span class="line">请输入系数和指数：-1 1</span><br><span class="line">请输入系数和指数：2 0</span><br><span class="line">请输入系数和指数：0 0</span><br><span class="line">第一个多项式如下：</span><br><span class="line">-3x^3+4x^2-x+2</span><br><span class="line">请输入第二个多项式的系数和指数，以(0 0)结束：</span><br><span class="line">请输入系数和指数(如：2 3表示2x^3)：4 5</span><br><span class="line">请输入系数和指数：3 3</span><br><span class="line">请输入系数和指数：-3 1</span><br><span class="line">请输入系数和指数：0 0</span><br><span class="line">第二个多项式如下：</span><br><span class="line">4x^5+3x^3-3x</span><br><span class="line">合并后多项式如下：</span><br><span class="line">4x^5+4x^2-4x+2</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/01/RrWlM.png" alt="RrWlM.png" border="0"></p><p>&nbsp;</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请输入第一个多项式的系数和指数，以(<span class="number">0</span> <span class="number">0</span>)结束：</span><br><span class="line">请输入系数和指数(如：<span class="number">2</span> <span class="number">3</span>表示<span class="number">2</span>x^<span class="number">3</span>)：<span class="number">3</span> <span class="number">5</span></span><br><span class="line">请输入系数和指数：<span class="number">3</span> <span class="number">4</span></span><br><span class="line">请输入系数和指数：<span class="number">-3</span> <span class="number">0</span></span><br><span class="line">请输入系数和指数：<span class="number">1</span> <span class="number">4</span></span><br><span class="line">请输入系数和指数：<span class="number">0</span> <span class="number">0</span></span><br><span class="line">第一个多项式如下：</span><br><span class="line"><span class="number">3</span>x^<span class="number">5</span>+<span class="number">4</span>x^<span class="number">4</span><span class="number">-3</span></span><br><span class="line">请输入第二个多项式的系数和指数，以(<span class="number">0</span> <span class="number">0</span>)结束：</span><br><span class="line">请输入系数和指数(如：<span class="number">2</span> <span class="number">3</span>表示<span class="number">2</span>x^<span class="number">3</span>)：<span class="number">-3</span> <span class="number">5</span></span><br><span class="line">请输入系数和指数：<span class="number">7</span> <span class="number">1</span></span><br><span class="line">请输入系数和指数：<span class="number">2</span> <span class="number">4</span></span><br><span class="line">请输入系数和指数：<span class="number">3</span> <span class="number">0</span></span><br><span class="line">请输入系数和指数：<span class="number">0</span> <span class="number">0</span></span><br><span class="line">第二个多项式如下：</span><br><span class="line"><span class="number">-3</span>x^<span class="number">5</span>+<span class="number">2</span>x^<span class="number">4</span>+<span class="number">7</span>x+<span class="number">3</span></span><br><span class="line">合并后多项式如下：</span><br><span class="line"><span class="number">6</span>x^<span class="number">4</span>+<span class="number">7</span>x</span><br></pre></td></tr></table></figure><p><img src="https://i.imgtg.com/2022/11/01/RrUJr.png" alt="RrUJr.png" border="0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p><img src="C:/Users/12733/AppData/Roaming/Typora/typora-user-images/image-20220913103307137.png" alt="image-20220913103307137"></p><p><img src="C:/Users/12733/AppData/Roaming/Typora/typora-user-images/image-20220913105234970.png" alt="image-20220913105234970"></p><p><a href="https://kdocs.cn/l/cofxkBJNM9XX">大赛地址</a></p><p>小田</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微积分三</title>
      <link href="/posts/470d838d.html"/>
      <url>/posts/470d838d.html</url>
      
        <content type="html"><![CDATA[<h1 id="向量与向量值函数"><a href="#向量与向量值函数" class="headerlink" title="向量与向量值函数"></a>向量与向量值函数</h1><h2 id="点积（Dot-Products）"><a href="#点积（Dot-Products）" class="headerlink" title="点积（Dot Products）"></a>点积（Dot Products）</h2><p>已知两个二维或者三维的非零向量<strong>u</strong>和<strong>v</strong>，它们的点积是</p><script type="math/tex; mode=display">u·v=|u| \times |v|cos \theta</script><p>其中，$\theta$是<strong>u</strong>与<strong>v</strong>之间的夹角，且$0 \le \theta \le \pi$。</p><p>&nbsp;</p><h4 id="正交向量（Orthogonal-Vectors）"><a href="#正交向量（Orthogonal-Vectors）" class="headerlink" title="正交向量（Orthogonal Vectors）"></a>正交向量（Orthogonal Vectors）</h4><p>当两个向量<strong>u</strong>和<strong>v</strong>称为是正交，有<strong>u</strong>·<strong>v</strong>=0。这两个正交的非零向量相互垂直。</p><p>&nbsp;</p><h4 id="点积（Dot-Products）-1"><a href="#点积（Dot-Products）-1" class="headerlink" title="点积（Dot Products）"></a>点积（Dot Products）</h4><p>已知两个向量$u=<u_1,u_2,u_3>$和$v=<v_1,v_2,v_3>$,</v_1,v_2,v_3></u_1,u_2,u_3></p><script type="math/tex; mode=display">u·v=u_1v_1+u_2v_2+u_3v_3</script><p>&nbsp;</p><h3 id="正交投影（Orthogonal-Projection-of-u-into-v）"><a href="#正交投影（Orthogonal-Projection-of-u-into-v）" class="headerlink" title="正交投影（Orthogonal Projection of u into v）"></a>正交投影（Orthogonal Projection of u into v）</h3><h4 id="u在v上的（正交投影）"><a href="#u在v上的（正交投影）" class="headerlink" title="u在v上的（正交投影）"></a>u在v上的（正交投影）</h4><p>  设$v \ne 0$,则u在v上的<strong>正交投影</strong>是</p><script type="math/tex; mode=display">proj_vu=|u|cos \theta(\frac{v}{|v|})</script><p>正交投影也可以用如下的公式计算</p><script type="math/tex; mode=display">proj_vu=scal_vu(\frac{v}{|v|})=(\frac{u·v}{v·v})v</script><p>其中u在v方向的<strong>纯分量</strong>是</p><script type="math/tex; mode=display">scal_vu=|u|cos \theta = \frac{u · v}{|v|}</script><p><img src="https://i.imgtg.com/2022/11/03/RmOUC.png" alt="RmOUC.png" border="0"></p><p>ps：<strong>proj</strong>相较于<strong>scal</strong>的区别是其方向是否跟投影的向量一致。</p><p>&nbsp;</p><p>&nbsp;</p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>$u=<u_1,u_2,u_3>$</u_1,u_2,u_3></p><script type="math/tex; mode=display">(u_1+u_2+u_3)^2 \le 3(u_1^2+u_2^2+u_3^2)</script><p>过程如下</p><p>$v=<u_2,u_3,u_1>$有 $u·v=u_1u_2+u_2u_3+u_3u_1$和$|u||v|=u_1^2+u_2^2+u_3^2$，</u_2,u_3,u_1></p><p>因此有$u_1u_2+u_2u_3+u_3u_1 \le |u|^2$</p><p>有$(u_1+u_2+u_3)^2=u_1^2+u_2^2+u_3^2+2(u_1u_2+u_2u_3+u_3u_1) \le u_1^2+u_2^2+u_3^2+2|u|^2 = 3|u|^2$</p><h2 id="叉积（Cross-Product）"><a href="#叉积（Cross-Product）" class="headerlink" title="叉积（Cross Product）"></a>叉积（Cross Product）</h2><p><strong>u</strong>和<strong>v</strong>叉乘$u \times v$是一个大小为</p><script type="math/tex; mode=display">|u \times v| = |u||v|sin \theta</script><p>的向量，其中其方向根据<strong>右手定则</strong>判断</p><p><img src="https://i.imgtg.com/2022/11/03/Rg3ha.png" alt="Rg3ha.png" border="0"></p><p>&nbsp;</p><h4 id="计算叉积"><a href="#计算叉积" class="headerlink" title="计算叉积"></a>计算叉积</h4><p>$u=u_1i+u_2j+u_3k$，$v=v_1i+v_2j+v_3k$,则</p><script type="math/tex; mode=display">u \times v =\begin{vmatrix}  i&j  & k\\  u_1&u_2  &u_3 \\  v_1&v_2 &v_3\end{vmatrix}=\begin{vmatrix} u_2 &u_3  \\  v_2&v_3   \end{vmatrix}i-\begin{vmatrix} u_1 &u_3  \\  v_1& v_3  \end{vmatrix}j+\begin{vmatrix}  u_1&u_2  \\  v_1&v_2   \end{vmatrix}k</script><p><strong>注意：线性代数运算中，偶数项系数为负</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="空间直线与曲线"><a href="#空间直线与曲线" class="headerlink" title="空间直线与曲线"></a>空间直线与曲线</h3><h4 id="直线方程（Equation-of-a-Line）"><a href="#直线方程（Equation-of-a-Line）" class="headerlink" title="直线方程（Equation of a Line）"></a>直线方程（Equation of a Line）</h4><p>过点$p_0(x_0,y_0,z_0)$且以向量$v=<a,b,c>$为方向的<strong>直线方程</strong>是$r = r_0+tv$,或</a,b,c></p><script type="math/tex; mode=display"><x,y,z>=<x_0,y_0,z_0>+t<a,b,c>,-\infty  <t<\infty</script><p>&nbsp;</p><h5 id="空间曲线"><a href="#空间曲线" class="headerlink" title="空间曲线"></a>空间曲线</h5><script type="math/tex; mode=display">r(t)=<f(t),g(t),h(t)>=f(t) i +g(t)j+h(t)k</script><p><img src="https://i.imgtg.com/2022/11/03/RgCRS.png" alt="RgCRS.png" border="0"></p><h4 id="导数与切向量（Derivative-and-Tangent-Vector）"><a href="#导数与切向量（Derivative-and-Tangent-Vector）" class="headerlink" title="导数与切向量（Derivative and Tangent Vector）"></a>导数与切向量（Derivative and Tangent Vector）</h4><p>设$r(t)=f(t)i+g(t)j+h(t)k$其中f，g，h是（a，b）上的可导函数，则r在（a，b）上有<strong>导数</strong>，且</p><script type="math/tex; mode=display">r'(t)=f'(t)i+g'(t)j+h'(t)k</script><p>当$r’(t) \ne 0$时，$r’(t)$是在对应$r(t)$处的<strong>切向量</strong>（速度向量）。</p><p>&nbsp;</p><p>&nbsp;</p><h4 id="单位切向量（Unit-Tangent-Vector）"><a href="#单位切向量（Unit-Tangent-Vector）" class="headerlink" title="单位切向量（Unit Tangent Vector）"></a>单位切向量（Unit Tangent Vector）</h4><p>设$r=f(t)i+g(t)j+h(t)k$是一条光滑参数曲线，其单位切向量是</p><script type="math/tex; mode=display">T(t)=\frac{r'(t)}{|r'(t)|}</script><p>&nbsp;</p><h2 id="曲线的长度"><a href="#曲线的长度" class="headerlink" title="曲线的长度"></a>曲线的长度</h2><p>对于曲线方程，$r(t)=<f(t),g(t),h(t)>$，在$a \le t \le b$上的<strong>弧长</strong>是</f(t),g(t),h(t)></p><script type="math/tex; mode=display">L=\int_{a}^{b} \sqrt{f'(t)^2+g'(t)^2+h'(t)^2}dt=\int_{a }^{b}|r'(t)|dt</script><p>&nbsp;</p><h4 id="极坐标曲线的弧长"><a href="#极坐标曲线的弧长" class="headerlink" title="极坐标曲线的弧长"></a>极坐标曲线的弧长</h4><p>设f是区间$[\alpha ,\beta ]$上的连续函数，极坐标曲线$r=f(\theta)$在$[\alpha ,\beta ]$上的<strong>弧长</strong>为</p><script type="math/tex; mode=display">L=\int_{\alpha}^{\beta} \sqrt{f(\theta)^2+f'(\theta)^2}d\theta</script><p>&nbsp;</p><h2 id="曲率与法向量（Curvate-and-Normal-Vectors）"><a href="#曲率与法向量（Curvate-and-Normal-Vectors）" class="headerlink" title="曲率与法向量（Curvate and Normal Vectors）"></a>曲率与法向量（Curvate and Normal Vectors）</h2><h4 id="弧长作为参数的函数"><a href="#弧长作为参数的函数" class="headerlink" title="弧长作为参数的函数"></a>弧长作为参数的函数</h4><p>设$r(t)$描述一条光滑曲线，$t \ge a$弧长由</p><script type="math/tex; mode=display">s(t)=\int_{a}^{t}|v(u)|du</script><p>其中，$|v|=|r’(t)|$,等价地，$\frac{ds}{dt}=|v(t)|&gt;0$。如果$|v(t)|=1$对所有$t \ge a$成立，则参数t是弧长。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="曲率Curvature"><a href="#曲率Curvature" class="headerlink" title="曲率Curvature"></a>曲率Curvature</h3><p>设r描绘一条光滑参数曲线，记s为弧长，且$T =r’/|r’|$是单位切向量，<strong>曲率</strong>为$\kappa (s)=|\frac{dT}{ds}|$</p><p>&nbsp;</p><h3 id="曲率公式"><a href="#曲率公式" class="headerlink" title="曲率公式"></a>曲率公式</h3><p>设r是一条光滑参数曲线，其中t是任意参数，如果$v=r’$是速度，T是单位切向量，则曲率是</p><script type="math/tex; mode=display">\kappa (t)=\frac{1}{|v|}|\frac{dT}{dt}|=\frac{T'(t)}{r'(t)}</script><p>&nbsp;</p><h3 id="曲率替代公式"><a href="#曲率替代公式" class="headerlink" title="曲率替代公式"></a>曲率替代公式</h3><p>设r时光滑曲线上运动的物体的位置，曲线的<strong>曲率</strong>是</p><script type="math/tex; mode=display">\kappa =\frac{a \times v}{|v|^3}</script><p>其中$v=r’$是速度，$a=v’$是加速度。</p><p>&nbsp;</p><h3 id="单位主法向量（Principal-Unit-Normal-Vector）"><a href="#单位主法向量（Principal-Unit-Normal-Vector）" class="headerlink" title="单位主法向量（Principal Unit Normal Vector）"></a>单位主法向量（Principal Unit Normal Vector）</h3><p>设r描述光滑参数曲线，在曲线上$\kappa \ne 0$的点P处的<strong>单位主法向量</strong>是</p><script type="math/tex; mode=display">N=\frac{dT/ds}{|dT/ds|}=\frac{1}{\kappa }\frac{dT}{ds}</script><p>实际中使用等价公式</p><script type="math/tex; mode=display">N= \frac{dT/dt}{|dT/dt|}</script><p>&nbsp;</p><h3 id="单位副法向量（Unit-Binormal-Vector）和挠率（Torsion）"><a href="#单位副法向量（Unit-Binormal-Vector）和挠率（Torsion）" class="headerlink" title="单位副法向量（Unit Binormal Vector）和挠率（Torsion）"></a>单位副法向量（Unit Binormal Vector）和挠率（Torsion）</h3><p>单位副法向量</p><script type="math/tex; mode=display">B=T·N=\frac{v \times a}{|v \times a|}</script><p>挠率</p><script type="math/tex; mode=display">\tau =-\frac{dB}{ds}·N = \frac{(v \times a)·a'}{|v \times a|^2}=\frac{(r' \times r'')·r'''}{|r' \times r''|^2}</script><h3 id="名词总结"><a href="#名词总结" class="headerlink" title="名词总结"></a>名词总结</h3><div class="table-container"><table><thead><tr><th>名称</th><th>英文</th></tr></thead><tbody><tr><td>位置函数</td><td>Position function</td></tr><tr><td>单位切向量</td><td>Unit tangent vector</td></tr><tr><td>单位主法向量</td><td>Principal unit normal vector</td></tr><tr><td>曲率</td><td>Curvature</td></tr><tr><td>单位副法向量</td><td>Unit Binormal Vector</td></tr><tr><td>挠率</td><td>Torsion</td></tr></tbody></table></div><p>&nbsp;</p><p>&nbsp;</p><h1 id="多元函数（functions-of-serveral-variables）"><a href="#多元函数（functions-of-serveral-variables）" class="headerlink" title="多元函数（functions of serveral variables）"></a>多元函数（functions of serveral variables）</h1><h2 id="平面和曲面-planes-and-surfaces"><a href="#平面和曲面-planes-and-surfaces" class="headerlink" title="平面和曲面(planes and surfaces)"></a>平面和曲面(planes and surfaces)</h2><h3 id="空间平面的一般方程"><a href="#空间平面的一般方程" class="headerlink" title="空间平面的一般方程"></a>空间平面的一般方程</h3><p>  过点$P_0(x_0,y_0,z_O)$且法向量为$n$的平面方程</p><script type="math/tex; mode=display">a(x-x_0)+b(y-y_0)+c(z-z_0)=0</script><p>或</p><script type="math/tex; mode=display">ax+by+cz=d,其中  d=ax_0+by_0+cz_0</script><p>&nbsp;</p><h4 id="平行平面（Parallel）与正交平面-Orthogonal-Planes"><a href="#平行平面（Parallel）与正交平面-Orthogonal-Planes" class="headerlink" title="平行平面（Parallel）与正交平面(Orthogonal Planes)"></a>平行平面（Parallel）与正交平面(Orthogonal Planes)</h4><p>解题时可根据，平行平面和正交平面来进行求解。</p><p>&nbsp;</p><h3 id="迹-trace"><a href="#迹-trace" class="headerlink" title="迹(trace)"></a>迹(trace)</h3><p>一个空间图形与xy平面的相交为xy-迹，同理还有xz-迹，yz-迹。</p><p>&nbsp;</p><ul><li><img src="https://i.imgtg.com/2022/11/03/RmayL.png" alt="RmayL.png" border="0"></li></ul><p>&nbsp;</p><h5 id="法向量求法"><a href="#法向量求法" class="headerlink" title="法向量求法"></a>法向量求法</h5><p>想求一个平面的法向量，可以令平面中相交的两条线<strong>叉乘</strong>即得。</p><h4 id="已知两个平面求其相交的直线"><a href="#已知两个平面求其相交的直线" class="headerlink" title="已知两个平面求其相交的直线"></a>已知两个平面求其相交的直线</h4><p>1.先求两个平面的法向量</p><p>此时我们只需要找到平面上的一个<strong>点</strong>和平面的<strong>法向量</strong></p><p>2.令$x=0$，可得在yz平面上的两条线，及其焦点。</p><p>3.将两个法向量叉乘记得获得平面的向。</p><p>&nbsp;</p><h4 id="已知三个平面求其焦点"><a href="#已知三个平面求其焦点" class="headerlink" title="已知三个平面求其焦点"></a>已知三个平面求其焦点</h4><p>1.由上列方法已知两个平面求相交的直线</p><p>2.直接将已求出的交线带入第二个平面方程即可。</p><p>&nbsp;</p><h2 id="极限与连续性"><a href="#极限与连续性" class="headerlink" title="极限与连续性"></a>极限与连续性</h2><h3 id="内点（Interior）和边界点（Boundary-Point）"><a href="#内点（Interior）和边界点（Boundary-Point）" class="headerlink" title="内点（Interior）和边界点（Boundary Point）"></a>内点（Interior）和边界点（Boundary Point）</h3><p>边界点相较于内点，边界点包含边缘。</p><h4 id="开集（Open）和闭集-Closed-Sets"><a href="#开集（Open）和闭集-Closed-Sets" class="headerlink" title="开集（Open）和闭集(Closed Sets)"></a>开集（Open）和闭集(Closed Sets)</h4><p>如果区域由所有的内点组成，则它是<strong>开的</strong>，如果区域包含所有的边界点，则它是<strong>闭的</strong>。</p><p>&nbsp;</p><h4 id="机选不存在的双路径判别法"><a href="#机选不存在的双路径判别法" class="headerlink" title="机选不存在的双路径判别法"></a>机选不存在的双路径判别法</h4><p>如果（x,y）沿f的定义域中两条不同的路径趋于（a,b）时，f趋于两个不同的值，则$\lim_{(x，y) \to (a,b)}f(x,y) $不存在。</p><p>&nbsp;</p><h4 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h4><p>如果函数f满足</p><p>1.f在（a，b）处有定义</p><p>2.$\lim_{(x，y) \to (a,b)}f(x,y) $存在</p><p>3.$\lim_{(x，y) \to (a,b)}f(x,y) =f(a,b)$</p><p>则称f在（a,b）处连续。</p><p>&nbsp;</p><h4 id="计算技巧（双路径判别法）"><a href="#计算技巧（双路径判别法）" class="headerlink" title="计算技巧（双路径判别法）"></a>计算技巧（双路径判别法）</h4><p>如果在计算时出现$\lim_{(x，y) \to (0,0)}f(x,y) $的情况</p><p>1.我们可以直接令$x=y或x=-y$（分两种情况讨论），从而化两个未知数为一个未知数。</p><p>2.可以先令$x=0$求y化简的值，也可以先令$y=0$求x化简后的值。</p><p>3.可以令$x=ny$，n可取任意常数。</p><p>4.可令$x=y^2$</p><p>主要用于双路径判别法，判断出两个结果不一致即可。</p><p>&nbsp;</p><h4 id="判断-R-2-在方程中的哪一点连续"><a href="#判断-R-2-在方程中的哪一点连续" class="headerlink" title="判断$R^2$在方程中的哪一点连续"></a>判断$R^2$在方程中的哪一点连续</h4><p>1.方程中，分母等于零的情况</p><p>2.如果时分段函数，一般情况下计算断点的值，大部是断点处不连续。</p><p>&nbsp;</p><h4 id="判断是否为连续"><a href="#判断是否为连续" class="headerlink" title="判断是否为连续"></a>判断是否为连续</h4><p>可以将函数方程转化为极坐标方程，$x=rcos\theta, y=rsin\theta$转换，如果化简后的结果里面没有r即为极限不存在，如果结果里面有r，则说明此函数的极限存在。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="偏导数（Partial-Derivatives）"><a href="#偏导数（Partial-Derivatives）" class="headerlink" title="偏导数（Partial Derivatives）"></a>偏导数（Partial Derivatives）</h2><h3 id="偏导（Partial-Derivatives）"><a href="#偏导（Partial-Derivatives）" class="headerlink" title="偏导（Partial Derivatives）"></a>偏导（Partial Derivatives）</h3><p>f在（a,b）处对x的偏导</p><script type="math/tex; mode=display">f_x(a,b)=\lim_{h \to 0}\frac{f(a+h,b)-f(a,b)}{h}</script><p>eg:$f_{yx}函数f$先对y求偏导，然后对x求偏导</p><h4 id="混合偏导相等"><a href="#混合偏导相等" class="headerlink" title="混合偏导相等"></a>混合偏导相等</h4><p>如果$f$在点D点连续，则在D点有$f_{xy}=f_{yx}$。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="链法则（The-Chain-Rule）"><a href="#链法则（The-Chain-Rule）" class="headerlink" title="链法则（The Chain Rule）"></a>链法则（The Chain Rule）</h2><h3 id="链法则"><a href="#链法则" class="headerlink" title="链法则"></a>链法则</h3><p>z是关于x和y的在其定义域上的可微函数，其中x和y是t在区间I上的可微函数，则</p><script type="math/tex; mode=display">\frac{dz}{dt}=\frac{\partial z}{\partial x} \frac{dx}{dt}+\frac{\partial z}{\partial y}\frac{dy}{dt}</script><p>&nbsp;</p><p>&nbsp;</p><h3 id="隐函数求导-Implicit-Differentiation"><a href="#隐函数求导-Implicit-Differentiation" class="headerlink" title="隐函数求导(Implicit Differentiation)"></a>隐函数求导(Implicit Differentiation)</h3><p>设F在其定义域上可微，并假设$F（x,y）=0$,定义y是x的可微函数，只要$F_y \ne 0$,有</p><script type="math/tex; mode=display">\frac{dy}{dx}=-\frac{F_x}{F_y}</script><h4 id="证明隐函数求导"><a href="#证明隐函数求导" class="headerlink" title="证明隐函数求导"></a>证明隐函数求导</h4><p>有$F(x,y,z(x,y))=0$z是x和y的可微函数,证明$\frac{\partial z}{\partial x} =-\frac{F_x}{F_z}$和$\frac{\partial z}{\partial y}=-\frac{F_y}{F_z} $</p><script type="math/tex; mode=display">F(x,y,z(x,y))=F_x·1+F_y·0+F_z\frac{\partial z}{\partial x} =0</script><p>因此可得</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}  =-\frac{F_x}{F_z}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="方向导数和梯度（Directional-Derivatives-and-the-Gradient）"><a href="#方向导数和梯度（Directional-Derivatives-and-the-Gradient）" class="headerlink" title="方向导数和梯度（Directional Derivatives and the Gradient）"></a>方向导数和梯度（Directional Derivatives and the Gradient）</h2><h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><p>设$f$在$（a,b）$处可微，$u=<cos \theta ,sin\theta>$是xy-平面上的<strong>单位向量</strong>，则$f$在点$(a,b)$处沿方向$u$的方向导数是</cos></p><script type="math/tex; mode=display">D_uf(a,b)=\lim_{x \to 0} \frac{f(a+hcos\theta,b+sin\theta)-f(a,b)}{h}</script><p>&nbsp;</p><h3 id="方向导数（Directional-Derivative）"><a href="#方向导数（Directional-Derivative）" class="headerlink" title="方向导数（Directional Derivative）"></a>方向导数（Directional Derivative）</h3><p>设$f$在$(a,b)$处可微，$u=<u_1,u_2>$是xy-平面上的单位向量，f在点$(a,b)$处沿方向u的方向导数是</u_1,u_2></p><script type="math/tex; mode=display">D_uf(a,b)=<f_x(a,b),f_y(a,b)>·<u_1,u_2></script><p>&nbsp;</p><h3 id="梯度（Gradient）"><a href="#梯度（Gradient）" class="headerlink" title="梯度（Gradient）"></a>梯度（Gradient）</h3><p>设$f$在点$(x,y)$处可微分，$f$在$(x,y)$处的<strong>梯度</strong>是向量值函数</p><script type="math/tex; mode=display">\bigtriangledown f(x,y)=<f_x(x,y),f_y(x,y)>=f_x(x,y)i+f_y(x,y)j</script><p>由梯度的定义可知，f在点（a,b）处沿着单位向量$u$的方向导数可写为$D_uf(a,b)=\bigtriangledown f_(a,b)·u $</p><p>&nbsp;</p><h4 id="最速上升和最速下降（Directions-of-Change）"><a href="#最速上升和最速下降（Directions-of-Change）" class="headerlink" title="最速上升和最速下降（Directions of Change）"></a>最速上升和最速下降（Directions of Change）</h4><p>1.$f$在$(a,b)$处沿梯度$\bigtriangledown f(a,b)$方向有最大增长率，沿这个方向的增长率是$|\bigtriangledown  f(a,b)|$</p><p>2,其最大的下降速度是$-|\bigtriangledown  f(a,b)|$</p><p><img src="https://i.imgtg.com/2022/11/03/RgwjN.png" alt="RgwjN.png" border="0"></p><p>&nbsp;</p><h2 id="切平面与线性逼近（Tangent-Planes-and-Linear-Approximation）"><a href="#切平面与线性逼近（Tangent-Planes-and-Linear-Approximation）" class="headerlink" title="切平面与线性逼近（Tangent Planes and Linear Approximation）"></a>切平面与线性逼近（Tangent Planes and Linear Approximation）</h2><h3 id="F-x-y-z-0的切平面方程"><a href="#F-x-y-z-0的切平面方程" class="headerlink" title="F(x,y,z)=0的切平面方程"></a>F(x,y,z)=0的切平面方程</h3><p>设F在点$P_0(a,b,c)$处可微，且$\bigtriangledown F(a,b,c)\ne 0$,曲面$F(a,b,c)=0$在$P_0$处的切平面是过$P_0$且正交于$\bigtriangledown F(a,b,c)$的平面，切平面的方程是</p><script type="math/tex; mode=display">F_0(a,b,c)(x-a)+F_y(a,b,c)(y-b)+F_z(a,b,c)(z-c)=0</script><p>&nbsp;</p><h3 id="z-f-x-y-的切平面"><a href="#z-f-x-y-的切平面" class="headerlink" title="z=f(x,y)的切平面"></a>z=f(x,y)的切平面</h3><p>设$f$在点$(a,b)$处可微，曲面$z=f(x,y)$在点$(a,b,f(a,b))$处的切平面方程是</p><script type="math/tex; mode=display">z=f_x(a,b)(x-a)+f_y(a,b)(y-b)+f(a,b)</script><h4 id="线性逼近（Linear-Approximation）"><a href="#线性逼近（Linear-Approximation）" class="headerlink" title="线性逼近（Linear Approximation）"></a>线性逼近（Linear Approximation）</h4><p>平面$z=f(x,y)$的线性逼近是在该点处的切平面，其方程为</p><script type="math/tex; mode=display">L(x,y)=f_x(a,b)(x-a)+f_y(a,b)(y-b)+f(a,b)</script><p>&nbsp;</p><p>&nbsp;</p><h3 id="微分dz"><a href="#微分dz" class="headerlink" title="微分dz"></a>微分dz</h3><p>设$f$在点$(a,b)$处可微，当因变量从$(a,b)$变化到$(a+dx,b+dy)$时，$z=f(x,y)$的变化</p><script type="math/tex; mode=display">\bigtriangleup  z \approx  dz =f_x(a,b)dx+f_y(a,b)dy</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="最大-最小值问题"><a href="#最大-最小值问题" class="headerlink" title="最大/最小值问题"></a>最大/最小值问题</h2><h3 id="导数与极大值极小值（Local-Maximum-Minimum-Values）"><a href="#导数与极大值极小值（Local-Maximum-Minimum-Values）" class="headerlink" title="导数与极大值极小值（Local Maximum / Minimum Values）"></a>导数与极大值极小值（Local Maximum / Minimum Values）</h3><p>如果$f$在$(a,b)$处有极大值或者极小值，并且偏导数$f_x$和$f_y$在$(a,b)$处存在。则$f_x(a,b)=f_y(a,b)=0$</p><p>&nbsp;</p><h3 id="临界点（Critical-Point）"><a href="#临界点（Critical-Point）" class="headerlink" title="临界点（Critical Point）"></a>临界点（Critical Point）</h3><p>设$(a,b)$是$f$的定义域的一个内点，如果下列条件之一成立：</p><p>1.$f_x(a,b)=f_y(a,b)=0$</p><p>2.$f_x$或$f_y$在$(a,b)$处不存在</p><p>则$(a,b)$称为$f$的一个临界点，临界点是极大值和极小值的候选点</p><p>&nbsp;</p><h3 id="鞍点（Saddle-Point）"><a href="#鞍点（Saddle-Point）" class="headerlink" title="鞍点（Saddle Point）"></a>鞍点（Saddle Point）</h3><p>设$(a,b)$是函数的一个临界点，如果存在一些点$(x,y)$满足$f(x,y) &gt; f(a,b)$和另外一些点$(x,y)$满足$f(x,y)&lt;f(a,b)$,则称f在$(a,b)$处有一个鞍点。</p><p><img src="https://i.imgtg.com/2022/11/03/Rmosi.png" alt="Rmosi.png" border="0"></p><p>&nbsp;</p><h3 id="二阶导数判别法"><a href="#二阶导数判别法" class="headerlink" title="二阶导数判别法"></a>二阶导数判别法</h3><p>设$f$的二阶偏导数是在以点$(a,b)$为圆心的某个开圆盘上连续，其中$f_x(a,b)=f_y(a,b)=0$.令$D(x,y)=f_{xx}f_{yy}-f^2_{xy}$</p><p>1.如果$D(a,b)&gt;0且f_{xx}(a,b)&lt;0$,则$f$在$(a,b)$处有极大值</p><p>2.如果$D(a,b)&gt;0且f_{xx}(a,b)&gt;0$,则$f$在$(a,b)$处有极小值</p><p>3.如果$D(a,b)&lt;0$,则$f$在$(a,b)$处有鞍点</p><p>4.如果$D(a,b)=0$,则判断法无结果</p><p>&nbsp;</p><h3 id="求最大值-最小值（Absolute-Maximum-Minimum-Values）"><a href="#求最大值-最小值（Absolute-Maximum-Minimum-Values）" class="headerlink" title="求最大值/最小值（Absolute Maximum/Minimum Values）"></a>求最大值/最小值（Absolute Maximum/Minimum Values）</h3><p>设$f$在$R^2$的有界闭集R上连续，欲求$f$在R上的最大值和最小值：</p><p>1.确定$f$在R中所有临界点处的值</p><p>2.求$f$在R边界上的最大值和最小值</p><p>求边界点的值中，其中边界分很多情况</p><p><1>$(x,y):x^2+y^2 \le 4$</1></p><p>令$x=2cos\theta,y=2sin\theta且有0\le\theta\le2\pi$将x，y的值带入其中，即可用$\theta$求出最大值和最小值。</p><p><2>$R=(x,y):-2\le x\le2,-1\le y\le1$</2></p><p>先考虑$x=\pm2$.y为任意值的情况；之后考虑$y=\pm1$，x为任意值的情况。</p><p><3>在函数$y=x,y=2x,y=2$之间包围。</3></p><p>可以分别将每一个式子带入求导。从而求出每个式子的最大值。</p><p>3.在第一步和第二步求出函数值，最大者是$f$在R上的最大值，最小者是$f$在R上的最小值。</p><p>&nbsp;</p><h4 id="求与平面最近的点"><a href="#求与平面最近的点" class="headerlink" title="求与平面最近的点"></a>求与平面最近的点</h4><p>如果有平面方程$x+y+z=4$和点$p(0,3,6)$,求平面相对于点的最近距离。</p><p>1.有$z=4-x-y$,带入得平面上的坐标$Q(x,y,4-x-y)$</p><p>2.问题转化为P点与Q点之间得距离</p><p>得$w=x^2+(y-3)^2+(x+y+2)^2$</p><p>3.求出其临界点，及$w_x=w_y=0$的时候。就是最近的点。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="拉格朗日乘子法（Lagrange-Multipliers）"><a href="#拉格朗日乘子法（Lagrange-Multipliers）" class="headerlink" title="拉格朗日乘子法（Lagrange Multipliers）"></a>拉格朗日乘子法（Lagrange Multipliers）</h2><h4 id="平行梯度（Parallel-Gradients）"><a href="#平行梯度（Parallel-Gradients）" class="headerlink" title="平行梯度（Parallel Gradients）"></a>平行梯度（Parallel Gradients）</h4><p>目标函数$f$，约束曲线$g$。</p><p>设$f$是$R^2$的一个区域上的可微函数，区域包含由$g(x,y)$给出的光滑曲线C。假设$f$在C上的点P$(a,b)$处有极值，则$\bigtriangledown f(a,b)$与C在P处的切线正交。假设$\bigtriangledown g（a,b）\ne 0$,于是存在一个实数$\lambda$(拉格朗日乘子)使得$\bigtriangledown f(a,b)=\lambda \bigtriangledown  g(a,b)$</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="二元拉格朗日乘子法"><a href="#二元拉格朗日乘子法" class="headerlink" title="二元拉格朗日乘子法"></a>二元拉格朗日乘子法</h3><p>有目标函数$f$和约束方程$g$，为求$f$在约束条件$g(x,y)=0$下的最大值和最小值</p><p>1.求x,y和$\lambda$的值（如果存在），满足方程</p><script type="math/tex; mode=display">\bigtriangledown f(x,y)=\lambda\bigtriangledown g(x,y)和g(x,y)=0</script><p>2.在第一步得到的值（x，y）中，选择对应的最大和最小函数值，它们就是$f$在约束条件下的最大值或则最小值。</p><p>&nbsp;</p><h4 id="距平面的最短距离"><a href="#距平面的最短距离" class="headerlink" title="距平面的最短距离"></a>距平面的最短距离</h4><p>1.先列出与点的距离方程，例如与点$（-2，5，1）$</p><p>其方程可为$f(x,y,z)=(x+2)^2+(y-5)^2+(z-1)^2$,且有$g(x,y,z)=2x+3y+6z-10=0$</p><p>2.计算其<strong>梯度</strong>$\bigtriangledown  f=<2x+4,2y-10,2z-2>$,$\bigtriangledown g=<2,3,6>$</2,3,6></2x+4,2y-10,2z-2></p><p>3.拉格朗日乘子法，计算$\lambda$化简可得最短距离的坐标。</p><p>4.将坐标带入即可求出最短距离。</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="多重积分（Multiple-Integration）"><a href="#多重积分（Multiple-Integration）" class="headerlink" title="多重积分（Multiple Integration）"></a>多重积分（Multiple Integration）</h2><h3 id="体积与二重积分"><a href="#体积与二重积分" class="headerlink" title="体积与二重积分"></a>体积与二重积分</h3><p>极限</p><script type="math/tex; mode=display">\lim_{\bigtriangleup  \to 0} \sum_{n}^{k=1}f(\bar{x}_k ,\bar{y}_k) \bigtriangleup A_k</script><script type="math/tex; mode=display">\iint_{R}^{} f(x,y)dA</script><p>如果f在R上非负，则二重积分等于区域R上$z=f(x,y)$和$xy-$平面所包围的立体的<strong>体积</strong>。</p><p>&nbsp;</p><h3 id="矩形区域上的二重积分-Double-Integrals-on-Rectangular-Regions"><a href="#矩形区域上的二重积分-Double-Integrals-on-Rectangular-Regions" class="headerlink" title="矩形区域上的二重积分(Double Integrals on Rectangular Regions)"></a>矩形区域上的二重积分(Double Integrals on Rectangular Regions)</h3><p>假设$f$在矩形区域$R={(x,y):a\le x \le b,c \le y\le d}$上连续，$f$在R上的二重积分还可以用下列公式计算。</p><script type="math/tex; mode=display">\iint\limits_{R}^{} f(x,y)dA=\int_{c}^{d}\int_{a}^{b}f(x,y)dxdy=\int_{a}^{b}\int_{c}^{d}f(x,y)dxdy</script><h4 id="平面区域上的平均值"><a href="#平面区域上的平均值" class="headerlink" title="平面区域上的平均值"></a>平面区域上的平均值</h4><script type="math/tex; mode=display">\bar{f}=\frac{1}{R的面积}\iint\limits_{R}^{} f(x,y)dA</script><h2 id="一般区域上的二重积分"><a href="#一般区域上的二重积分" class="headerlink" title="一般区域上的二重积分"></a>一般区域上的二重积分</h2><p>非矩形区域上的二重积分（Double Integrals over Nonrectangular Region）</p><p>设区域R在上下分别由连续函数$y=g(x)$和$y=h(x)$的图像所围，并且由直线$x=a$和$x=b$所围，若$f$在R上连续，则</p><script type="math/tex; mode=display">\iint\limits_{R}^{} f(x,y)dA=\int_{a}^{b}\int_{g(x)}^{h(x)}f(x,y)dxdy</script><h4 id="用二重积分求区域的面积"><a href="#用二重积分求区域的面积" class="headerlink" title="用二重积分求区域的面积"></a>用二重积分求区域的面积</h4><p>设R是xy-平面内的区域，则</p><script type="math/tex; mode=display">R的面积=\iint_{R}dA</script><p>&nbsp;</p><p>&nbsp;</p><h3 id="极坐标下的二重积分"><a href="#极坐标下的二重积分" class="headerlink" title="极坐标下的二重积分"></a>极坐标下的二重积分</h3><p>设$f$在xy-平面内的区域$R={(r,\theta):0\le a\le r \le b,\alpha \le \theta \le \beta}$上连续，其中$\beta - \alpha \le 2\pi$,则</p><script type="math/tex; mode=display">\iint\limits_{R}^{} f(r,\theta)dA=\int_{\alpha}^{\theta}\int_{a}^{b}f(r,\theta)rdrd\theta</script><h3 id="极坐标区域的面积"><a href="#极坐标区域的面积" class="headerlink" title="极坐标区域的面积"></a>极坐标区域的面积</h3><script type="math/tex; mode=display">A=\iint\limits_{R}^{} dA=\int_{\alpha}^{\beta}\int_{g(\theta)}^{h(\theta)}rdrd\theta</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h2><h3 id="三重积分（Triple-Integrals）"><a href="#三重积分（Triple-Integrals）" class="headerlink" title="三重积分（Triple Integrals）"></a>三重积分（Triple Integrals）</h3><p>设$D={(x,y,z):a \le x \le b,g(x) \le y \le h(x) ,G(x,y) \le z \le H(x,y)}$其中g,h,G,H是连续函数，在D上的连续函数$f$的三重积分可以用如下累次积分计算：</p><script type="math/tex; mode=display">\iiint\limits_{D}^{} f(x,y,z)dV=\int_{a}^{b}\int_{g(x)}^{h(x)}\int_{G(x,y)}^{H(x,y)}f(x,y,z)dzdydx</script>]]></content>
      
      
      
        <tags>
            
            <tag> 微积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理(三)</title>
      <link href="/posts/9ab27f24.html"/>
      <url>/posts/9ab27f24.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-电荷和电场"><a href="#1-电荷和电场" class="headerlink" title="1.电荷和电场"></a>1.电荷和电场</h1><h2 id="1-1-静电，电荷及其保护"><a href="#1-1-静电，电荷及其保护" class="headerlink" title="1.1 静电，电荷及其保护"></a>1.1 静电，电荷及其保护</h2><h4 id="电荷守恒定律"><a href="#电荷守恒定律" class="headerlink" title="电荷守恒定律"></a>电荷守恒定律</h4><p>在任何过程中，产生的电荷量的净变化为零。</p><p>例如，当用一条毛巾摩擦一个塑料尺子时，该塑料获得一个负电荷，而该毛巾获得一个等量的正电荷。电荷是分开的，但两者的和是零。</p><p>&nbsp;</p><h2 id="1-4感应电荷和验电器"><a href="#1-4感应电荷和验电器" class="headerlink" title="1.4感应电荷和验电器"></a>1.4感应电荷和验电器</h2><p>在带电棒没有接触验电器时，此时无论电荷还是验电器中的电荷不变，体现同性相斥，异性相吸。</p><p>在带电棒接触验电器后，正负电荷进行中和。</p><p>&nbsp;</p><h2 id="1-5库仑定律"><a href="#1-5库仑定律" class="headerlink" title="1.5库仑定律"></a>1.5库仑定律</h2><script type="math/tex; mode=display">F=k\frac{Q_1Q_2}{R^2}</script><p>常数$k\approx  9.0 \times 10^9N·m^2/C^2$</p><p>元电荷$e=1602 \times 10^{-19}C$</p><h4 id="介电常数（permittivity）"><a href="#介电常数（permittivity）" class="headerlink" title="介电常数（permittivity）"></a>介电常数（permittivity）</h4><p>在等式中的常数k通常用另一个常数(介电常数)$\epsilon_0 $来写</p><script type="math/tex; mode=display">F=\frac{1}{4 \pi \epsilon_0 }\frac{Q_1Q_2}{r^2}</script><script type="math/tex; mode=display">\epsilon_0  =\frac{1}{4 \pi k}=8.85 \times 10^{-12}C^2/N·m^2</script><h5 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h5><p>在一条直线有三个电荷，对其中的某一个电荷进行受力分析</p><p>&nbsp;</p><h2 id="1-6-电场"><a href="#1-6-电场" class="headerlink" title="1.6 电场"></a>1.6 电场</h2><p>假设在电场中有一试验电荷P</p><p><img src="https://img1.imgtp.com/2022/09/08/c7kdPyKq.png" alt="image-20220908224127779.png" title="image-20220908224127779.png"></p><p>那么此电荷所在的电场强度E由下式计算。</p><script type="math/tex; mode=display">E=\frac{F}{q} =\frac{kqQ/r^2}{q}</script><script type="math/tex; mode=display">E= k\frac{Q}{r^2}</script><script type="math/tex; mode=display">E=\frac{1}{4 \pi \epsilon_0} \frac{Q}{r^2}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-7连续电荷分布的电场强度计算"><a href="#1-7连续电荷分布的电场强度计算" class="headerlink" title="1.7连续电荷分布的电场强度计算"></a>1.7连续电荷分布的电场强度计算</h2><p>在很多情况下，我们可以处理连续分布的电荷，可以把分布的电荷分隔成无限小的电荷元dQ，它们每个都相当于一个微小电荷。每个dQ在相距为r的地方对电场强度的贡献为</p><script type="math/tex; mode=display">dE=\frac{1}{4 \pi \epsilon_0}\frac{dQ}{r^2}</script><p>电场强度<strong><em>E</em></strong>为所有这些无限小电荷的贡献累加，即为积分</p><script type="math/tex; mode=display">E = \int dE</script><h5 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h5><p>电荷环，均匀带电的圆盘,两块平行板</p><p>&nbsp;</p><p>&nbsp;</p><h4 id="无限大平面"><a href="#无限大平面" class="headerlink" title="无限大平面"></a>无限大平面</h4><p><img src="https://img1.imgtp.com/2022/09/08/GUhTZYSd.png" alt="image-20220908225430225.png" title="image-20220908225430225.png"></p><p>如果圆盘的半径远远大于P点到盘的距离（例如，$z \ll  R$）那么我们可以得到一个结果</p><script type="math/tex; mode=display">E = \frac{\sigma }{2 \epsilon_0},</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-8电场线"><a href="#1-8电场线" class="headerlink" title="1.8电场线"></a>1.8电场线</h2><ol><li><p>电场线的方向</p></li><li><p>大小问题—电场线的疏密</p></li><li><p>电场的起始问题</p><p>（起于正电荷（或者无穷远）</p></li><li><p>电场线不交叉，不相接</p></li></ol><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-9电场及导体"><a href="#1-9电场及导体" class="headerlink" title="1.9电场及导体"></a>1.9电场及导体</h2><p><img src="https://img1.imgtp.com/2022/09/08/iUlLVvWC.png" alt="image-20220908231347848.png" title="image-20220908231347848.png"></p><p>如图，一个在中性金属球壳内的电荷在金属球壳表面感应出电荷。电场在球壳外也存在，但是在导体内不存在。</p><h2 id="1-10带电粒子在电场中的运动"><a href="#1-10带电粒子在电场中的运动" class="headerlink" title="1.10带电粒子在电场中的运动"></a>1.10带电粒子在电场中的运动</h2><h4 id="经典题型-1"><a href="#经典题型-1" class="headerlink" title="经典题型"></a>经典题型</h4><p>被加速的电子，如右图所示</p><p><img src="https://img1.imgtp.com/2022/09/08/jbjeo8vG.png" alt="image-20220908231705033.png" title="image-20220908231705033.png"></p><p>&nbsp;</p><h2 id="2-11电偶极子（Electric-Dipole-Potentical）"><a href="#2-11电偶极子（Electric-Dipole-Potentical）" class="headerlink" title="2.11电偶极子（Electric Dipole Potentical）"></a>2.11电偶极子（Electric Dipole Potentical）</h2><p>牢记力矩的定义与公式</p><p><strong>力矩</strong>是以<strong>施力大小</strong>与<strong>力臂</strong>的乘积衡量物体的转动效果</p><script type="math/tex; mode=display">M=F \times L</script><p><img src="https://img1.imgtp.com/2022/09/08/hXQ11stK.png" alt="image-20220908232243918.png" title="image-20220908232243918.png"></p><h4 id="在外电场中的电偶极子"><a href="#在外电场中的电偶极子" class="headerlink" title="在外电场中的电偶极子"></a>在外电场中的电偶极子</h4><p>电场是均匀的，在正电荷上的力QE和负电荷上的力-QE将使得作用在电偶极子的合力为零名单上却又一个力矩作用其上。</p><script type="math/tex; mode=display">\tau =QE \frac{l}{2}sin \theta + QE \frac{l}{2}sin\theta=pEsin\theta</script><p>上式可用矢量表示为</p><script type="math/tex; mode=display">\tau = p \times  E \times sin\theta</script><p> &nbsp;</p><p>&nbsp;</p><p>当$\theta=90$时力矩值最大，$\theta=180$势能最大此时E和p时反向平行的</p><h3 id="稳态和亚稳态"><a href="#稳态和亚稳态" class="headerlink" title="稳态和亚稳态"></a>稳态和亚稳态</h3><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>1，长期稳定存在</p><p>2，合力为零</p><p>&nbsp;</p><p>差别</p><p>稳态：给一个非常小的干扰，能保持稳态</p><p>亚稳态：给一个非常小的干扰，不能保持稳态</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>关于电场中的问题分析，一共有四点</p><p>1.作图和确定方向（draw a careful diagram）</p><p>对于受力物体的力和方向的进行作图分析，确定电子在电场中的方向。</p><p>2.应用库伦定理(apply coulomb’s law)</p><p>用库伦定理求出每个电荷所产生的力的大小施加在一个带电物体上。</p><p>3.添加向量(add vectorially and use symmetry)</p><p>在几何图形中尽可能用向量表示</p><p>4.检查(check the reasonableness)</p><h1 id="高斯定理"><a href="#高斯定理" class="headerlink" title="高斯定理"></a>高斯定理</h1><h1 id="电场强度通量（电通量）electric-flux"><a href="#电场强度通量（电通量）electric-flux" class="headerlink" title="电场强度通量（电通量）electric flux"></a>电场强度通量（电通量）electric flux</h1><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>通过一个给定的区域的电场强度，对于均匀电场，穿过一个平面A的电场强度通量$\Phi _E$定义为</p><script type="math/tex; mode=display">\Phi _E =EAcos \theta</script><p><img src="https://i.imgtg.com/2022/10/30/RUL96.png" alt="RUL96.png" border="0"></p><p>面积A，可以有一个矢量<strong>A</strong>来表示，，矢量大小为A，方向垂直于该平面。$\theta$为<strong>E</strong>和<strong>A</strong>之间的夹角，电场强度通量也可以写成</p><script type="math/tex; mode=display">\Phi _E = E·A</script><p>&nbsp;</p><p>在更为普遍的情况下，如下图</p><p><img src="https://i.imgtg.com/2022/10/30/RUGUP.png" alt="RUGUP.png" border="0"></p><p>当电场不均匀，曲面不平坦时，可以把该曲面分割为n个曲面微元，使其满足：</p><p>1.可以看作平面</p><p>2.电场强度在这个微元区域中变化很小</p><p>因此可以默认电场强度时均匀的，整个曲面的电场强度可以近似为</p><script type="math/tex; mode=display">\phi _E \approx  \sum_{i = 1}^{n}E_i ·\bigtriangleup A_i</script><p>对这个曲面进行积分，可以表示为：</p><script type="math/tex; mode=display">\phi _E= \int E ·dA</script><p>对闭合曲面的电场强度通量可写为：</p><script type="math/tex; mode=display">\Phi_{E}=\oint\vec{\mathbf{E}}\cdot d\vec{\mathbf{A}}</script><p>&nbsp;</p><h2 id="高斯定理-1"><a href="#高斯定理-1" class="headerlink" title="高斯定理"></a>高斯定理</h2><p>高斯定理是描述一个<strong>封闭平面</strong>的<strong>电通量</strong>与该表面内封闭的<strong>静电荷</strong>之间的关系。</p><script type="math/tex; mode=display">\Phi_{E}=\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=\oint E d A=E \oint d A=E\left(4 \pi r^{2}\right)</script><script type="math/tex; mode=display">E=\frac{Q}{4 \pi \epsilon_{0} r^{2}}</script><p>&nbsp;</p><p>表示为</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=\frac{Q_{\mathrm{encl}}}{\epsilon_{0}}</script><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1.$Q_{encl}$是指包含在闭合平面表面的净电荷Q，该表面以外的电荷不包含在平面内。</p><p>2.电荷$Q_{encl}$在表面内的位置或如何分布并不重要。</p><p>3.左边的积分超过了任何封闭曲面上的E值，为了方便，我们选择这个曲面</p><p><img src="https://i.imgtg.com/2022/10/30/RUSdl.png" alt="RUSdl.png" border="0"></p><p>如上图的闭合曲面，进入闭合曲面的电场线同时也离开闭合曲面。因此$\Phi _E=\oint Ecos\theta dA=0$</p><p>除非曲面内包含净电荷，$\oint Ecos\theta dA$才不为零。</p><p><img src="https://i.imgtg.com/2022/10/30/RUHRF.png" alt="RUHRF.png" border="0"></p><p>电偶极子通过曲面$A_1$的电场强度通量为正，通过曲面$A_2$的电场强度通量为负。</p><p>电荷$Q_{encl}$是闭合曲面内的净电荷，其分布并不重要。</p><p>&nbsp;</p><h3 id="高斯定理的应用"><a href="#高斯定理的应用" class="headerlink" title="高斯定理的应用"></a>高斯定理的应用</h3><p>关于高斯定理的应用一共有九种题型，一共可以分为：绝缘体（四种），导体（两种），薄球壳，无限长的电荷面，长而均匀的导体线。</p><p>绝缘体：球体和厚球壳的均匀和不均匀分布</p><p>导体：球体和厚球壳</p><p>&nbsp;</p><p>当在做此类题型的时候，重点要注意运用高斯定理，求出来在所选定r表面内的电荷$Q_{encl}$，从而求出此点的电场强度值。</p><h3 id="电荷分布在球的表面"><a href="#电荷分布在球的表面" class="headerlink" title="电荷分布在球的表面"></a>电荷分布在球的表面</h3><p><img src="https://i.imgtg.com/2022/11/07/RX6Js.png" alt="RX6Js.png" border="0"></p><p>分别有导体实心球，导体厚球壳，导体和绝缘体的薄球壳</p><p>求$r_0<r$和 $r_0>0$时候的电场值</r$和></p><p>solution：</p><p>according to the Guss’s law,we can get $\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=\frac{Q_{\mathrm{encl}}}{\epsilon_{0}}$</p><p>when $r&lt;r_0$</p><p> Inside the shell, the electric field must be symmetric. So E have the same value at all points on a spherical gaussian surface , Thus the charge enclosed within the sphere is zero,</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E\left(4 \pi r^{2}\right)=0</script><p>hence E = 0.</p><p>when $r&gt;r_0$</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E\left(4 \pi r^{2}\right)=\frac{Q}{\epsilon_{0}}</script><script type="math/tex; mode=display">E=\frac{1}{4 \pi \epsilon_{0}} \frac{Q}{r^{2}}</script><p>&nbsp;</p><h3 id="绝缘球体"><a href="#绝缘球体" class="headerlink" title="绝缘球体"></a>绝缘球体</h3><p><img src="https://i.imgtg.com/2022/11/07/RX2zB.png" alt="RX2zB.png" border="0"></p><p>特点就是电荷平均分布在球的内部。</p><p>当$r&gt;r_0$</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E\left(4 \pi r^{2}\right)=\frac{Q}{\epsilon_{0}}</script><script type="math/tex; mode=display">E=\frac{1}{4 \pi \epsilon_{0}} \frac{Q}{r^{2}}</script><p>当$r&lt;r_0$</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E\left(4 \pi r^{2}\right)</script><p>此时计算r内部的电荷$Q_{encl}$</p><script type="math/tex; mode=display">Q_{\mathrm{encl}}=\left(\frac{\frac{4}{3} \pi r^{3} \rho_{\mathrm{E}}}{\frac{4}{3} \pi r_{0}^{3} \rho_{\mathrm{E}}}\right) Q=\frac{r^{3}}{r_{0}^{3}} Q</script><script type="math/tex; mode=display">E\left(4 \pi r^{2}\right)=\frac{Q_{\text {encl }}}{\epsilon_{0}}=\frac{r^{3}}{r_{0}^{3}} \frac{Q}{\epsilon_{0}}</script><script type="math/tex; mode=display">E=\frac{1}{4 \pi \epsilon_{0}} \frac{Q}{r_{0}^{3}} r</script><p><img src="https://i.imgtg.com/2022/11/18/tcWuF.png" alt="tcWuF.png" border="0"></p><h3 id="不均匀绝缘体"><a href="#不均匀绝缘体" class="headerlink" title="不均匀绝缘体"></a>不均匀绝缘体</h3><p>如果上图（题）的球体是不均匀的，其密度$\rho_{\mathrm{E}}=\alpha r^{2}$</p><p><a>求$\alpha$,<b>求r和电场的关系</b></a></p><p>solution：</p><script type="math/tex; mode=display">Q=\int \rho_{\mathrm{E}} d V=\int_{0}^{r_{0}}\left(\alpha r^{2}\right)\left(4 \pi r^{2} d r\right)=4 \pi \alpha \int_{0}^{r_{0}} r^{4} d r=\frac{4 \pi \alpha}{5} r_{0}^{5}</script><script type="math/tex; mode=display">\alpha=5 Q / 4 \pi r_{0}^{5}</script><2><p>当$r&gt;r_0$时$Q_{encl}$同上题一样且不变化</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E\left(4 \pi r^{2}\right)=\frac{Q}{\epsilon_{0}}</script><script type="math/tex; mode=display">E=\frac{1}{4 \pi \epsilon_{0}} \frac{Q}{r^{2}}</script><p>当$r&lt;r_0$时</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=\frac{Q_{\mathrm{encl}}}{\epsilon_{0}}</script><script type="math/tex; mode=display">(E)\left(4 \pi r^{2}\right)=Q \frac{r^{5}}{\epsilon_{0} r_{0}^{5}}</script><script type="math/tex; mode=display">E=\frac{Q r^{3}}{4 \pi \epsilon_{0} r_{0}^{5}}</script><p>&nbsp;</p><h3 id="长且均匀的导线"><a href="#长且均匀的导线" class="headerlink" title="长且均匀的导线"></a>长且均匀的导线</h3><p>假设导线单位长度有正电荷$\lambda$</p><p><img src="https://i.imgtg.com/2022/11/18/tcULD.png" alt="tcULD.png" border="0"></p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=E(2 \pi R \ell)=\frac{Q_{\text {encl }}}{\epsilon_{0}}=\frac{\lambda \ell}{\epsilon_{0}}</script><p>for $\ell \ll \text { length of wire }$,$2\pi R$是它的周长</p><script type="math/tex; mode=display">E=\frac{1}{2 \pi \epsilon_{0}} \frac{\lambda}{R}</script><h3 id="无限长的电荷面、"><a href="#无限长的电荷面、" class="headerlink" title="无限长的电荷面、"></a>无限长的电荷面、</h3><p><img src="https://i.imgtg.com/2022/11/18/tcBO1.png" alt="tcBO1.png" border="0"></p><p>单位面积电荷=$\sigma $=dQ/dA</p><p>根据高斯定理</p><script type="math/tex; mode=display">\oint \overrightarrow{\mathbf{E}} \cdot d \overrightarrow{\mathbf{A}}=2EA=\frac{Q_{enxl}}{\epsilon_{0}}=\frac{\sigma A}{\epsilon_{0}}</script><p>where$Q_{encl}= \sigma $</p><script type="math/tex; mode=display">E=\frac{\sigma}{2\epsilon_{0}}</script><p>&nbsp;</p><p>&nbsp;</p><h2 id="电势"><a href="#电势" class="headerlink" title="电势"></a>电势</h2><h3 id="电势能和电势差"><a href="#电势能和电势差" class="headerlink" title="电势能和电势差"></a>电势能和电势差</h3><script type="math/tex; mode=display">W=F d=q E d</script><script type="math/tex; mode=display">U_{b}-U_{a}=-W=-q E d</script><p>a和b两点之间的势能变化，等于物体从a移动时，保守力所做的功的<strong>负值</strong></p><h4 id="电势-1"><a href="#电势-1" class="headerlink" title="电势"></a>电势</h4><script type="math/tex; mode=display">\varphi={\frac{E_{p A}}{q}}</script><h4 id="电势能"><a href="#电势能" class="headerlink" title="电势能"></a>电势能</h4><script type="math/tex; mode=display">U={\frac{W_{A B}}{q}}</script><p>&nbsp;</p><h4 id="电位和电位差"><a href="#电位和电位差" class="headerlink" title="电位和电位差"></a>电位和电位差</h4><p>在a点的的电势（假设有一个点电荷）</p><script type="math/tex; mode=display">V_{a}=\frac{U_{a}}{q}.</script><script type="math/tex; mode=display">V_{b a}=\Delta V=V_{b}-V_{a}=\frac{q_{b}-U_{a}}{q-q}=-\frac{W_{b a}}{q}.</script><p>因为电位差被足义为单位电荷的势能差，所以电荷q在a和b两点之间移动时势能的变化量为，</p><script type="math/tex; mode=display">\Delta U=U_{b}-U_{a}=q\left(V_{b}-V_{a}\right)=q V_{b a}.</script><p>也就是说，如果一个带电荷q的物体通过一个电位差$V_{ba}$，它的势能变化量$qV_{ba}$。</p><p>&nbsp;    </p><h3 id="电势与电场之间的关系"><a href="#电势与电场之间的关系" class="headerlink" title="电势与电场之间的关系"></a>电势与电场之间的关系</h3><p>U是势能能，V是电势</p><p>有$V=\frac{U}{q}$</p><p>电势能的变化等于电力所做的功的负数，</p><p><img src="/posts/9ab27f24.htm/tcqcG.png" alt="tcqcG.png" border="0"></p><script type="math/tex; mode=display">U_{b}-U_{a}=-\int_{a}^{ b}\overrightarrow{F}·d\overrightarrow{l}</script><p>&nbsp;</p><h3 id="由点电荷引起的电位"><a href="#由点电荷引起的电位" class="headerlink" title="由点电荷引起的电位"></a>由点电荷引起的电位</h3><p><img src="https://i.imgtg.com/2022/11/18/tcT7I.png" alt="tcT7I.png" border="0"></p><script type="math/tex; mode=display">E=\frac{1}{4\pi\epsilon_{0}}\frac{Q}{r^{2}},E =k\frac{Q}{r^{2}}</script><script type="math/tex; mode=display">V_{b}-V_{a}=-\int_{r_{a}}^{r_{b}}\vec{E}\cdot d\vec{l}=-\frac{Q}{4\pi \epsilon _{0}}\int_{r_{a}}^{r_{b}}\frac{1}{r^2}dr=\frac{1}{4\pi\epsilon_{0}}\left(\frac{Q}{r_{b}}-\frac{Q}{r_{a}}\right).</script><p>let$V_b =0$  at  $r_b=\infty $</p><script type="math/tex; mode=display">V=\frac{1}{4\pi\epsilon_{0}}\frac{Q}{r}</script><p>&nbsp;</p><h3 id="一般情况下的电荷分布"><a href="#一般情况下的电荷分布" class="headerlink" title="一般情况下的电荷分布"></a>一般情况下的电荷分布</h3><script type="math/tex; mode=display">V_{a}=\sum_{i=1}^{n}V_{i}=\frac{1}{4\pi\epsilon_{0}}\sum_{i=1}^{n}\frac{Q_{i}}{r_{ia}}</script><script type="math/tex; mode=display">V=\dfrac{1}{4\pi\epsilon_0}\int\dfrac{d q}{r}</script><h3 id="任意电荷分布下的电势"><a href="#任意电荷分布下的电势" class="headerlink" title="任意电荷分布下的电势"></a>任意电荷分布下的电势</h3><p>电荷分布在圆环</p><p><img src="https://i.imgtg.com/2022/11/18/tckz6.png" alt="tckz6.png" border="0"></p><script type="math/tex; mode=display">V=\frac{1}{4\pi\epsilon_{0}}\int\frac{d q}{r}=\frac{1}{4\pi\epsilon_{0}}\frac{1}{\left(x^{2}+R^{2}\right)^{\frac{1}{2}}}\int d q=\frac{1}{4\pi\epsilon_{0}}\frac{Q}{\left(x^{2}+R^{2}\right)^{\frac{1}{2}}}</script><p>&nbsp;</p><p>电荷平均分布在圆盘</p><p><img src="https://i.imgtg.com/2022/11/18/tcxPP.png" alt="tcxPP.png" border="0"></p><p>关键在于求出积分点的电荷值q，当然这个是以一圈为定值对其进行积分。</p><script type="math/tex; mode=display">\frac{d q}{Q}=\frac{2\pi R d R}{\pi R_{0}^{2}}</script><script type="math/tex; mode=display">V=\frac{1}{4\pi\epsilon_{0}}\int\frac{d q}{\left(x^{2}+R^{2}\right)_{2}^{1}}=\frac{2Q}{4\pi\epsilon_{0}R_{0}^{2}}\int_{0}^{R_{0}}\frac{R d R}{\left(x^{2}+R^{2}\right)^{\frac{1}{2}}}=\left.\frac{Q}{2\pi\epsilon_{0}R_{0}^{2}}\left(x^{2}+R^{2}\right)^{\frac{1}{2}}\right|_{R=0}^{R=R_{0}}=\frac{Q}{2\pi\epsilon_{0}R_{0}^{2}}\left[\left(x^{2}+R_{0}^{2}\right)^{\frac{1}{2}}-x\right]</script><p>&nbsp;</p><h3 id="电偶极子的电位"><a href="#电偶极子的电位" class="headerlink" title="电偶极子的电位"></a>电偶极子的电位</h3><p><img src="https://i.imgtg.com/2022/11/18/tcz9b.png" alt="tcz9b.png" border="0"></p><script type="math/tex; mode=display">V=\frac{1}{4\pi\epsilon_{0}}\frac{Q}{r}+\frac{1}{4\pi\epsilon_{0}}\frac{\left(-Q\right)}{\left(r+\Delta r\right)}=\frac{1}{4\pi\epsilon_{0}}Q\left(\frac{1}{r}-\frac{1}{r+\Delta r}\right)^{4}=\frac{Q}{4\pi\epsilon_{0}}\frac{\Delta r}{r\left(r+\Delta r\right)}</script><p>$r&gt;&gt;\Delta r=l\cos\theta$</p><script type="math/tex; mode=display">V=\frac{1}{4\pi\epsilon_{0}}\frac{Q l\cos\theta}{r^{2}}=\frac{1}{4\pi\epsilon_{0}}\frac{p\cos\theta}{r^{2}}</script><p>此时的电偶极子为p。$p=Ql$</p><p>&nbsp;</p><h3 id="用V来确定-overrightarrow-text-E"><a href="#用V来确定-overrightarrow-text-E" class="headerlink" title="用V来确定$\overrightarrow{\text{E}}$"></a>用V来确定$\overrightarrow{\text{E}}$</h3><p>我们都知道v是标量，但E是个矢量。其间的关系有</p><script type="math/tex; mode=display">V_{b}-V_{a}=-\int_{a}^{b}\overrightarrow{E}\cdot d\overrightarrow{l},</script><script type="math/tex; mode=display">E_{l}=-\frac{d V_{l}}{d l}.</script><p>此时的l可以是多个方向的。</p><p>&nbsp;</p><h3 id="静电势能-Electrostatic-Potential-Energy"><a href="#静电势能-Electrostatic-Potential-Energy" class="headerlink" title="静电势能(Electrostatic Potential Energy)"></a>静电势能(Electrostatic Potential Energy)</h3><p>假设一个点电荷q在空间中的两点a和b之间移动，其中由其他电荷引起的电势分别为$V_1$和$V_2$。q在这些其他电荷场中的静电势能的变化为</p><script type="math/tex; mode=display">\Delta U=U_{\mathrm{b}}-U_{\mathrm{a}}=q(V_{\mathrm{b}}-V_{\mathrm{a}})</script><p>当电荷相距很远（理想情况下是无限远）时，选择电势能为零是最方便的。</p><p>单点电荷$Q_1$没有势能，因为如果周围没有其他电荷，就不会施加在它身上。如果第二点电荷$Q_2$接近势由于这个第一电荷的位置$Q_1$,此时$Q_1$在$Q_2$位置产生的电势为</p><script type="math/tex; mode=display">V=\dfrac{1}{4\pi\epsilon_0}\dfrac{Q_1}{r_{12}}</script><p>如果系统由三个电荷组成，总势能将是将这三个电荷结合在一起的电势能</p><p>其三个电荷的经典势能就是</p><script type="math/tex; mode=display">U={\frac{1}{4\pi\epsilon_{0}}}\left({\frac{Q_{1}Q_{2}}{r_{12}}}+{\frac{Q_{1}Q_{3}}{r_{13}}}+{\frac{Q_{2}Q_{3}}{r_{23}}}\right)</script><p>&nbsp;</p><h2 id="电容，电解质，电储能"><a href="#电容，电解质，电储能" class="headerlink" title="电容，电解质，电储能"></a>电容，电解质，电储能</h2><h3 id="电容（capacitors-）"><a href="#电容（capacitors-）" class="headerlink" title="电容（capacitors  ）"></a>电容（capacitors  ）</h3><p>电容器是一种可以储存电荷的装置</p><script type="math/tex; mode=display">Q=C V</script><p>对于给定的电容，我们发现每片获得的电荷量Q与它们之间的电位差V的大小成正比</p><p>上述关系中，比例常数C称为电容器的电容，电容的单位是库每伏，称为法拉（F）</p><p>&nbsp;</p><h3 id="计算电容"><a href="#计算电容" class="headerlink" title="计算电容"></a>计算电容</h3><h4 id="平行板中的电容器"><a href="#平行板中的电容器" class="headerlink" title="平行板中的电容器"></a>平行板中的电容器</h4><script type="math/tex; mode=display">E=\frac{Q}{\epsilon_{0}A}</script><script type="math/tex; mode=display">V=V_{b a}=V_{b}-V_{a}=-\int_{a}^{b}\overrightarrow{E}\cdot d\overrightarrow{l}.</script><script type="math/tex; mode=display">V=V_{b}-V_{a}=-\int_{a}^{b}E d l\cos180^{\circ}=+\int_{a}^{b}E d l=\frac{Q}{\epsilon_{0}A}\int_{a}^{b}d l=\frac{Q d}{\epsilon_{0}A}</script><script type="math/tex; mode=display">C=\frac{Q}{V}=\epsilon_{0}\frac{A}{d}</script><p>&nbsp;</p><h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><p>一共有三种，分别为圆柱形电容器，球形电容器，球形导体之间的电容问题。</p><h4 id="圆柱形电容器"><a href="#圆柱形电容器" class="headerlink" title="圆柱形电容器"></a>圆柱形电容器</h4><p><img src="https://i.imgtg.com/2022/11/18/tchTl.png" alt="tchTl.png" border="0"></p><script type="math/tex; mode=display">V=V_{\mathrm{b}}-V_{\mathrm{a}}=-\int_{a}^{\mathrm{b}}\vec{\mathbf{E}}\cdot d\vec{\ell}=-\dfrac{Q}{2\pi\epsilon_0\ell}\int_{R_\mathrm{a}}^{R_\mathrm{b}}\dfrac{dR}{R}=-\dfrac{Q}{2\pi\epsilon_0\ell}\ln\dfrac{R_\mathbb{b}}{R_\mathbb{a}}=\dfrac{Q}{2\pi\epsilon_0\ell}\ln\dfrac{R_\mathbb{a}}{R_\mathbb{b}}.</script><script type="math/tex; mode=display">C=\dfrac{Q}{V}=\dfrac{2\pi\epsilon_0\ell}{\ln(R_\mathrm a/R_\mathrm b)}</script><p>&nbsp;</p><h3 id="球形电容器"><a href="#球形电容器" class="headerlink" title="球形电容器"></a>球形电容器</h3><p><img src="https://i.imgtg.com/2022/11/18/tcivg.png" alt="tcivg.png" border="0"></p><script type="math/tex; mode=display">\begin{array}{rcl}V_{\text{ba}}=-\int_{a}^b\vec{\mathbf{E}}\cdot d\vec{\mathbf{l}}=-\dfrac{Q}{4\pi\epsilon_0}\int_{r_a}^{r_0}\dfrac{1}{r^2}dr\\=\dfrac{Q}{4\pi\epsilon_0}\left(\dfrac{1}{r_b}-\dfrac{1}{r_a}\right)=\dfrac{Q}{4\pi\epsilon_0}\left(\dfrac{r_a-r_b}{r_ar_b}\right)\end{array}</script><script type="math/tex; mode=display">C=\dfrac{Q}{V_{\text{ba}}}=4\pi\epsilon_0\biggl(\dfrac{r_\text{a}r_\text{b}}{r_\text{a}-r_\text{b}}\biggr)</script><p>&nbsp;</p><h4 id="电容的串并联"><a href="#电容的串并联" class="headerlink" title="电容的串并联"></a>电容的串并联</h4><p>并联：等于电容值的加和</p><p>&nbsp;</p><h3 id="电能储存"><a href="#电能储存" class="headerlink" title="电能储存"></a>电能储存</h3><p>移动并联电容板。平行平板电容器的极板面积为a，间距为x，并与电压为v的电池连接。当与电池连接时，极板被拉开，直到它们间隔3x。<br>（a）储存在电容器中的初始和最终能量是多少？　　　</p><p>（b）将两板分开需要做多少功（假设速度恒定）？<br>（c）与电池交换多少能量？</p><script type="math/tex; mode=display">U_1=\frac{1}{2}C_1V^2=\frac{1}{2}\frac{\epsilon_0A}{x}V^2</script><script type="math/tex; mode=display">U_{2}=\frac{1}{2}\frac{\epsilon_{0}A}{3x}V^{2}</script><script type="math/tex; mode=display">\Delta U_{c a p}=U_{2}-U_{1}=-\frac{\epsilon_{0}A V^{2}}{3x}</script><p>（b）</p><script type="math/tex; mode=display">W=\int_{\ell=x}^{\ell-3x}Q E d\ell=\frac{\epsilon_{0}A V^{2}}{2}\int_{x}^{3x}d\ell=-\frac{\epsilon_{0}A V^{2}}{2\ell}\Bigg|_{\ell=x}^{\ell+3x}=\frac{\epsilon_{0}A V^{2}}{2}\left(\frac{-1}{3x}+\frac{1}{x}\right)=\frac{\epsilon_{0}A V^{2}}{3x}</script><p>（c）</p><script type="math/tex; mode=display">W=\Delta U_{\text{cap}}+\Delta U_{\text{batt}}</script><script type="math/tex; mode=display">\Delta U_{b a t t}=W-\Delta U_{c a p}=\frac{\epsilon_{0}A V^{2}}{3x}+\frac{\epsilon_{0}A V^{2}}{V_{0}3x}=\frac{2\epsilon_{0}A V^{2}}{3x}</script><script type="math/tex; mode=display">U=\frac{1}{2}C V^{2}=\frac{1}{2}\left(\frac{\epsilon _{0}A}{d}\right)\left(E^{2}d^{2}\right)=\frac{1}{2}\epsilon_{0}E^{2}A d</script><p>&nbsp;</p><h3 id="电解质"><a href="#电解质" class="headerlink" title="电解质"></a>电解质</h3><p>如果电介质填满了两个导体之间的空间，它会使电容增加一个因数K，这个因数被称为介电常数。因此</p><script type="math/tex; mode=display">C=KC_{0}</script><script type="math/tex; mode=display">C=K\epsilon_{0}\frac{A}{d}</script><p>当电介质被插入时，电场也会改变。当无介质存在时，平行板电容器板间的电场为</p><script type="math/tex; mode=display">E_{0}=\frac{V_{0}}{d}</script><script type="math/tex; mode=display">E=E_{D}=\frac{V}{d}=\frac{V_{0}}{K d}</script><script type="math/tex; mode=display">E_{D}=\frac{E_{0}}{K}</script><p>&nbsp;</p><h3 id="电流和电阻"><a href="#电流和电阻" class="headerlink" title="电流和电阻"></a>电流和电阻</h3><p>电流：$I=\frac{d Q}{d t}$</p><h3 id="欧姆定律（ohm‘s-Law）"><a href="#欧姆定律（ohm‘s-Law）" class="headerlink" title="欧姆定律（ohm‘s Law）"></a>欧姆定律（ohm‘s Law）</h3><script type="math/tex; mode=display">I=\frac{V}{R}</script><h3 id="电阻率"><a href="#电阻率" class="headerlink" title="电阻率"></a>电阻率</h3><script type="math/tex; mode=display">R=\rho\frac{l}{A}</script><p>电阻率的倒数称为电导（conductivity）</p><script type="math/tex; mode=display">\sigma=\frac{1}{\rho}</script><h4 id="电阻率的温度依赖性"><a href="#电阻率的温度依赖性" class="headerlink" title="电阻率的温度依赖性"></a>电阻率的温度依赖性</h4><script type="math/tex; mode=display">\rho_{T}=\rho_{0}\left[1+\alpha\left(T-T_{0}\right)\right]</script><h3 id="功率"><a href="#功率" class="headerlink" title="功率"></a>功率</h3><script type="math/tex; mode=display">P=\frac{d U}{d t}\Rightarrow\frac{d q}{d t}V</script><h3 id="交流电"><a href="#交流电" class="headerlink" title="交流电"></a>交流电</h3><p>方均根值被称为有效值rms$I_{r m s}=\sqrt{\overline{I^{2}}}=\frac{I_{0}}{\sqrt{2}}$</p><h3 id="电流密度和漂移速度-Current-Density-and-Drift-Velocity"><a href="#电流密度和漂移速度-Current-Density-and-Drift-Velocity" class="headerlink" title="电流密度和漂移速度(Current Density and Drift Velocity)"></a>电流密度和漂移速度(Current Density and Drift Velocity)</h3><p>电流密度：j</p><script type="math/tex; mode=display">I=\int\overrightarrow{\mathbf j}\cdot d\overrightarrow{A}</script><p>飘逸速度：</p><script type="math/tex; mode=display">\overrightarrow{j}=-ne\overrightarrow{v}_{d} \\\vec{\textbf{j}}=\sum\limits_i n_i q_i\vec{\textbf{v}}_{\text{d}i}</script><p>&nbsp;</p><h2 id="直流电路"><a href="#直流电路" class="headerlink" title="直流电路"></a>直流电路</h2><h3 id="电动势能和终端电压"><a href="#电动势能和终端电压" class="headerlink" title="电动势能和终端电压"></a>电动势能和终端电压</h3><p>电池本身有自己的电阻，称为内阻（internal resistance）</p><p>电动势能（source of electromotive force）EMF</p><p>&nbsp;</p><h3 id="电阻的串并联"><a href="#电阻的串并联" class="headerlink" title="电阻的串并联"></a>电阻的串并联</h3><h3 id="基尔霍夫定律"><a href="#基尔霍夫定律" class="headerlink" title="基尔霍夫定律"></a>基尔霍夫定律</h3><h3 id="串并联电动势"><a href="#串并联电动势" class="headerlink" title="串并联电动势"></a>串并联电动势</h3><p>在电动势相等的情况下，当需要大电流时，并联电源可以提供更多的能量。<br>并联的每个电池只能产生总电流的一小部分，因此内阻造成的能量损失比单个电池要小；电池很快就没电了。</p><p>&nbsp;</p><h3 id="含电阻和电容的电路（RC电路）"><a href="#含电阻和电容的电路（RC电路）" class="headerlink" title="含电阻和电容的电路（RC电路）"></a>含电阻和电容的电路（RC电路）</h3><p><img src="https://i.imgtg.com/2022/11/22/4BtQt.png" alt="4BtQt.png" border="0"></p><script type="math/tex; mode=display">U=I R+\frac{Q}{C}</script><p>电流并不是一个常数$I=d Q/d t$</p><script type="math/tex; mode=display">U=R\frac{d Q}{d t}+\frac{1}{C}Q\\\frac{d Q}{C U-Q}=\frac{d t}{R C}</script><script type="math/tex; mode=display">\ln\left(1-\frac{Q}{C U}\right)=-\frac{t}{R C}\\Q=C U\left(1-e^{-t/R C}\right)\\V_{C}=U\left(1-e^{-t/R C}\right)</script><h4 id="放电"><a href="#放电" class="headerlink" title="放电"></a>放电</h4><p><img src="https://i.imgtg.com/2022/11/22/4BRrX.png" alt="4BRrX.png" border="0"></p><script type="math/tex; mode=display">Q=Q_{0}e^{-t/R C} \\V_{C}=V_{0}e^{-t/R C}</script><p>&nbsp;</p><h2 id="磁场"><a href="#磁场" class="headerlink" title="磁场"></a>磁场</h2><h3 id="磁铁和磁场"><a href="#磁铁和磁场" class="headerlink" title="磁铁和磁场"></a>磁铁和磁场</h3><p>磁场的性质</p><p>（1）磁场的方向在任意一点上与电场线相切（2）单位面积上的线数与磁场强度成正比。</p><h4 id="磁场线"><a href="#磁场线" class="headerlink" title="磁场线"></a>磁场线</h4><p>（1）磁场线在磁体内连续存在</p><p>（2）不相交</p><p>（3）磁场线总是形成闭环</p><h3 id="电生磁"><a href="#电生磁" class="headerlink" title="电生磁"></a>电生磁</h3><p><img src="https://i.imgtg.com/2022/11/22/4BPqi.png" alt="4BPqi.png" border="0"></p><p>磁生电：电流与磁场方向选用右手螺旋定则。</p><p>&nbsp;</p><h3 id="磁场对电流产生的力"><a href="#磁场对电流产生的力" class="headerlink" title="磁场对电流产生的力"></a>磁场对电流产生的力</h3><p>右手的叉乘定则</p><p><img src="https://i.imgtg.com/2022/11/22/4BpVL.png" alt="4BpVL.png" border="0"></p><script type="math/tex; mode=display">\overrightarrow{F}=I\overrightarrow{l}\times\overrightarrow{B}\\F=I\ell B\sin\theta</script><h4 id="在均匀磁场中运动"><a href="#在均匀磁场中运动" class="headerlink" title="在均匀磁场中运动"></a>在均匀磁场中运动</h4><script type="math/tex; mode=display">\overrightarrow{F}=q\overrightarrow{v}\times\overrightarrow{B}.</script><p><img src="https://i.imgtg.com/2022/11/22/4BmgC.png" alt="4BmgC.png" border="0"></p><p>右手定则</p><p>&nbdp;</p><h2 id="在磁场中移动的电荷所受到的力"><a href="#在磁场中移动的电荷所受到的力" class="headerlink" title="在磁场中移动的电荷所受到的力"></a>在磁场中移动的电荷所受到的力</h2><h4 id="电场和磁场的复合场"><a href="#电场和磁场的复合场" class="headerlink" title="电场和磁场的复合场"></a>电场和磁场的复合场</h4><p>回旋加速器</p><p>质谱仪</p><p>&nbsp;</p><p>电流环上的转矩：磁偶极矩</p><p><img src="https://i.imgtg.com/2022/11/22/4BgbN.png" alt="4BgbN.png" border="0"></p><script type="math/tex; mode=display">\tau=IaB\frac{b}{2}+IaB\frac{b}{2}=IabB=IAB</script><h4 id="磁偶极矩（magnetic-dipole-moment）"><a href="#磁偶极矩（magnetic-dipole-moment）" class="headerlink" title="磁偶极矩（magnetic dipole moment）"></a>磁偶极矩（magnetic dipole moment）</h4><script type="math/tex; mode=display">\vec{\mu}=N{I}\vec{\mathbf{A}}\\\vec{\tau}=NI\vec{\mathbf{A}}\times\vec{\mathbf{B}}</script></2>]]></content>
      
      
      
        <tags>
            
            <tag> 大物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常微分</title>
      <link href="/posts/9c4368b0.html"/>
      <url>/posts/9c4368b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="常微分"><a href="#常微分" class="headerlink" title="常微分"></a>常微分</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><h4 id="一阶线性方程"><a href="#一阶线性方程" class="headerlink" title="一阶线性方程"></a>一阶线性方程</h4><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>微分方程     —&gt;      包含未知函数和未知函数的导数</p><p>微分方程的解    —-&gt;   是在某个区间成立（区间范围也可以是无穷）</p><h6 id="例如：一个常微分方程"><a href="#例如：一个常微分方程" class="headerlink" title="例如：一个常微分方程"></a>例如：一个常微分方程</h6><script type="math/tex; mode=display">x'(t)-x(t)=0</script><p>此微分方程的解是$x（t）=e^{t}$,其解的区间是$(-\infty ,\infty )$</p><p>描述的就是未知函数和导数的关系（注意他们的解的区间)</p><h4 id="常微分和偏微分"><a href="#常微分和偏微分" class="headerlink" title="常微分和偏微分"></a>常微分和偏微分</h4><p>常微分（ODE）：一维的（包含一个未知量）</p><p>偏微分(PDE)：多维的（包含多个未知量）</p><h5 id="常微分的次数"><a href="#常微分的次数" class="headerlink" title="常微分的次数"></a>常微分的次数</h5><p>常微分最高阶的导数就是它的阶数</p><h5 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h5><p>$ x’(t) - x(t) = 0 $ 最高阶导数为一阶导，其阶数为一阶</p><p>$x’’(t) - x(t) = 0$  最高阶导数为二阶导， 其阶数为二阶</p><h5 id="一个特殊写法"><a href="#一个特殊写法" class="headerlink" title="一个特殊写法"></a>一个特殊写法</h5><p>通常情况下微分方程$x’(t)-x(t)=0$</p><p>可以把x(t)简化得写成x</p><p>化简后得写法是$x’-x=0$</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-2-简单的例子"><a href="#1-2-简单的例子" class="headerlink" title="1.2 简单的例子"></a>1.2 简单的例子</h2><h4 id="最重要的一个概念"><a href="#最重要的一个概念" class="headerlink" title="最重要的一个概念"></a>最重要的一个概念</h4><p>一个关于x(t)的微分方程</p><script type="math/tex; mode=display">x'(t)=kx(t),k\in R</script><p>此时，方程的通解为</p><script type="math/tex; mode=display">x(t) = ce^{kt}</script><p>要求：给定一个微分方程的解，我们可以写出对应的微分方程</p><p>给出一个微分方程，我们可以求出它的解</p><p>&nbsp;</p><h5 id="例如-1"><a href="#例如-1" class="headerlink" title="例如"></a>例如</h5><p>一个微分方程的解是$x(t)=2e^{kt}$其微分方程为$x’(t)=2x(t)$</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-3-应用的一些例子"><a href="#1-3-应用的一些例子" class="headerlink" title="1.3 应用的一些例子"></a>1.3 应用的一些例子</h2><p>$x’(t)=kx(t),k \in R$经常运用在我们生活中的一些模型中,比如人口动态模型（Population dynamics），和RC电路模型（An RC electric circuit）</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-4一般的情况"><a href="#1-4一般的情况" class="headerlink" title="1.4一般的情况"></a>1.4一般的情况</h2><p>我们来分析一般的一阶线性方程</p><script type="math/tex; mode=display">x'(t)+p(t)x(t)=q(t),t\in I</script><p>此时p(t),q(t)都是在区间I上连续的。</p><p>-如果q(t)=0,那么就称之为<strong>齐次</strong>的，否则方程就是<strong>非齐次</strong>的。</p><p>&nbsp;</p><p>&nbsp;</p><h4 id="积分因子"><a href="#积分因子" class="headerlink" title="积分因子"></a>积分因子</h4><p>在我们解微分方程的重要一步就是找方程的<strong>积分因子</strong>（Integrating Factor）</p><p>假设一个微分方程u（t）满足$u（t）&gt;0$ </p><p>存在$u(t)x’(t)+u(t)p(t)x(t)=(u(t)x(t))’$</p><p>这样，函数$u(t)$就被称为方程的<strong>积分因子</strong></p><p>有$x’(t)+p(t)x(t)=q(t)$</p><p>将上面的两式化简可得，当$x(t) \ne 0$时</p><script type="math/tex; mode=display">u(t)p(t)=u'(t)</script><p>继续化简可得</p><script type="math/tex; mode=display">u(t)=e^{P(t)}</script><script type="math/tex; mode=display">P(t)=\int {p(t)dt}</script><p>因此，对于方程$(u(t)x(t))’=u(t)q(t)$,方程两边同时进行积分可得</p><script type="math/tex; mode=display">u(t)x(t)=C +\int u(t) q(t)dt</script><p>带入$u(t)=e^{P(t)}$可得</p><script type="math/tex; mode=display">x(t)=e^{-P(t)}(c+ \int e^{P(t)q(t)dt}),P(t)=\int p(t)dt</script><p>&nbsp;</p><p>&nbsp;</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对于下列求初值方程</p><script type="math/tex; mode=display">x'(t)+p(t)x(t)=q(t),x(t_0)=x_0</script><script type="math/tex; mode=display">x(t)=e^{\int_{t_0}^{t}p(s)ds}(x_0+ \int_{t_0}^{t}e^{\int_{t_0}^{t}p(\tau )d\tau }q(s)ds)</script><p>-当q(t)=0时有</p><script type="math/tex; mode=display">x'(t)+p(t)x(t)=0,x(t_0)=x_0</script><script type="math/tex; mode=display">x(t)=x_0e^{\int_{t_0}^{t}p(s)ds}</script><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="一阶非线性微分方程"><a href="#一阶非线性微分方程" class="headerlink" title="一阶非线性微分方程"></a>一阶非线性微分方程</h2><h3 id="可分方程-Separable-Equation"><a href="#可分方程-Separable-Equation" class="headerlink" title="可分方程(Separable Equation)"></a>可分方程(Separable Equation)</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><script type="math/tex; mode=display">x'(t) = h(t)g(x)</script><p>要求：h(t)连续，g(x)连续可微</p><p>&nbsp;</p><h5 id="g-t-的一个零点时函数的常数解"><a href="#g-t-的一个零点时函数的常数解" class="headerlink" title="g(t)的一个零点时函数的常数解"></a>g(t)的一个零点时函数的常数解</h5><p>g(k)=0</p><p>x(t)=k</p><p>&nbsp;</p><h4 id="所有不变的解都用直线x-k分隔"><a href="#所有不变的解都用直线x-k分隔" class="headerlink" title="所有不变的解都用直线x=k分隔"></a>所有不变的解都用直线x=k分隔</h4><p>函数的常数解和非常数解不相交</p><p>&nbsp;</p><h4 id="非常数解"><a href="#非常数解" class="headerlink" title="非常数解"></a>非常数解</h4><script type="math/tex; mode=display">\frac{x'(t)}{g(x(t))}=h(t)，g(x)=0</script><script type="math/tex; mode=display">\int \frac{x'(t)}{g(x(t))}dt = \int h(t)dt</script><script type="math/tex; mode=display">\int \frac{dx}{g(x)}= \int h(t)+c</script><p>&nbsp;</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>对于解一般的可分方程的思路，一般情况下，左边是x的微分形式，方程右边是关于x和关于t的方程</p><p>1.令关于x的方程g(x)等于0，其零点就是关于方程的常数解</p><p>2.将g(x)提取到方程左边，x’dt=1dx</p><p>3.方程两边同时积分，得出化简后的式子</p><p>4.如果有初值，带入即可求出方程中未知量</p><p>5.化简即可求出方程的解</p><p>关于一些会用到的积分技巧</p><p>$\int \frac{1}{x^2 +1}dx=t+c$   ——&gt; $arctanx=t+c$—-&gt;  $x=tan(t+c)$</p><p>$\int \frac{1}{(x+1)(x-1)}dx=t+c$—-&gt;$\frac{1}{2}\int \frac{1}{x-1}-\frac{1}{x+1}dx=t+c$——&gt;$\frac{1}{2}ln|\frac{x-1}{x+1}|=t+c$  (绝对值不要忘记加)</p><h3 id="逻辑方程"><a href="#逻辑方程" class="headerlink" title="逻辑方程"></a>逻辑方程</h3><script type="math/tex; mode=display">x'(t)=x(t)(\alpha - \beta x(t)),\alpha,\beta>0</script><p>此时，$x = 0$和$x(t)=\frac{\alpha}{\beta}$是方程的两个常数解</p><p>如果再假设$x(t)&gt;0$</p><p>根据唯一性，可以将不定方程分为两类</p><script type="math/tex; mode=display">0<x(t)<\frac{\alpha}{\beta}</script><p>和</p><p>其本质上是方程$x’=x(\alpha -\beta x)$的两个解，此时我们有</p><script type="math/tex; mode=display">\frac{dx}{x(\alpha - \beta x)}=dt</script><script type="math/tex; mode=display">\int \frac{1}{\alpha}·\frac{1}{x}dx+\int \frac{\beta}{\alpha}\frac{1}{\alpha - \beta x}dx =t+c</script><script type="math/tex; mode=display">\frac{1}{\alpha}ln|x|-\frac{1}{\alpha}ln|\alpha -\beta x|= t+c</script><script type="math/tex; mode=display">\frac{|x|}{|\alpha - \beta x|}=e^{\alpha t+\alpha c}=ke^{\alpha t}</script><p>这里$k=e^{\alpha c}$,可以获得两个区间</p><script type="math/tex; mode=display">0<x(t)<\frac{\alpha}{\beta}</script><p>和</p><script type="math/tex; mode=display">x(t)>\frac{\alpha}{\beta}</script><p>当$x&lt;x(t)&lt;\frac{\alpha}{\beta}$时</p><script type="math/tex; mode=display">\frac{x}{\alpha - \beta x}=ke^{\alpha t}</script><p>解得</p><script type="math/tex; mode=display">x(t)=\frac{\alpha k e^{\alpha t}}{1+\beta k e^{\alpha t}}</script><p>当$x(t)&gt;\frac{\alpha}{\beta}$时</p><script type="math/tex; mode=display">-\frac{x}{\alpha - \beta x}=ke^{\alpha t}</script><p>解得</p><script type="math/tex; mode=display">x(t)=\frac{-\alpha k e^{\alpha t}}{1-\beta ke^{\alpha t}}</script><p>在此情况下，$\lim_{x \to \infty}x(t)=\frac{\alpha }{\beta}$</p><p><img src="https://i.imgtg.com/2022/11/03/Rg8eB.png" alt="Rg8eB.png" border="0"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 常微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: 'ZhuZiAYuanJWD';}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: 'iconfont' !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 */.bangumi-active {    background: #dbecfe !important;    border-radius: 10px !important;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: #dbecfe !important;    border-radius: 10px !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme='dark'] #recent-posts>.recent-post-item {    background: #121212;}[data-theme='dark'] .card-widget {    background: #121212 !important;}[data-theme='dark'] div#post {    background: #121212 !important;}[data-theme='dark'] div#tag {    background: #121212 !important;}[data-theme='dark'] div#archive {    background: #121212 !important;}[data-theme='dark'] div#page {    background: #121212 !important;}[data-theme='dark'] div#category {    background: #121212 !important;}[data-theme='dark'] div#category {    background: transparent !important;}/* 页脚透明 *//*不需要一图流，删164--173*/#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #49b1f5;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #49b1f5;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {    display: none !important;  } */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* 鼠标图标 */body {    cursor: url('/img/x1.cur'), auto;}a,[type='button']:not(:disabled),[type='reset']:not(:disabled),[type='submit']:not(:disabled),button:not(:disabled) {    cursor: url('/img/x2.cur'), auto !important;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #49b1f5;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei', sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--heo-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/manifest.json"/>
      <url>/js/runtime/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"小江的博客","short_name":"小江","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/coin/coin.js"/>
      <url>/js/coin/coin.js</url>
      
        <content type="html"><![CDATA[var tipButtons = document.querySelectorAll('.tip-button');function coinAudio() {    var coinAudio = document.getElementById('coinAudio');    if (coinAudio) {        coinAudio.play(); //有音频时播放    }}// Loop through all buttons (allows for multiple buttons on page)tipButtons.forEach(button => {    var coin = button.querySelector('.coin');    // The larger the number, the slower the animation    coin.maxMoveLoopCount = 90;    button.addEventListener('click', () => {        if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true; //媒体选择        if (button.clicked) return;        button.classList.add('clicked');        // Wait to start flipping th coin because of the button tilt animation        setTimeout(() => {            // Randomize the flipping speeds just for fun            coin.sideRotationCount = Math.floor(Math.random() * 5) * 90;            coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI;            button.clicked = true;            flipCoin();            coinAudio();        }, 50);    });    var flipCoin = () => {        coin.moveLoopCount = 0;        flipCoinLoop();    };    var resetCoin = () => {        coin.style.setProperty('--coin-x-multiplier', 0);        coin.style.setProperty('--coin-scale-multiplier', 0);        coin.style.setProperty('--coin-rotation-multiplier', 0);        coin.style.setProperty('--shine-opacity-multiplier', 0.4);        coin.style.setProperty('--shine-bg-multiplier', '50%');        coin.style.setProperty('opacity', 1);        // Delay to give the reset animation some time before you can click again        setTimeout(() => {            button.clicked = false;        }, 300);    };    var flipCoinLoop = () => {        coin.moveLoopCount++;        var percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount;        coin.angle = -coin.maxFlipAngle * Math.pow(percentageCompleted - 1, 2) + coin.maxFlipAngle;        // Calculate the scale and position of the coin moving through the air        coin.style.setProperty('--coin-y-multiplier', -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11);        coin.style.setProperty('--coin-x-multiplier', percentageCompleted);        coin.style.setProperty('--coin-scale-multiplier', percentageCompleted * 0.6);        coin.style.setProperty('--coin-rotation-multiplier', percentageCompleted * coin.sideRotationCount);        // Calculate the scale and position values for the different coin faces        // The math uses sin/cos wave functions to similate the circular motion of 3D spin        coin.style.setProperty('--front-scale-multiplier', Math.max(Math.cos(coin.angle), 0));        coin.style.setProperty('--front-y-multiplier', Math.sin(coin.angle));        coin.style.setProperty('--middle-scale-multiplier', Math.abs(Math.cos(coin.angle), 0));        coin.style.setProperty('--middle-y-multiplier', Math.cos((coin.angle + Math.PI / 2) % Math.PI));        coin.style.setProperty('--back-scale-multiplier', Math.max(Math.cos(coin.angle - Math.PI), 0));        coin.style.setProperty('--back-y-multiplier', Math.sin(coin.angle - Math.PI));        coin.style.setProperty('--shine-opacity-multiplier', 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2);        coin.style.setProperty(            '--shine-bg-multiplier',            -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + '%'        );        // Repeat animation loop        if (coin.moveLoopCount < coin.maxMoveLoopCount) {            if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add('shrink-landing');            window.requestAnimationFrame(flipCoinLoop);        } else {            button.classList.add('coin-landed');            coin.style.setProperty('opacity', 0);            setTimeout(() => {                button.classList.remove('clicked', 'shrink-landing', 'coin-landed');                setTimeout(() => {                    resetCoin();                }, 300);            }, 1500);        }    };});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.min.js"/>
      <url>/js/runtime/runtime.min.js</url>
      
        <content type="html"><![CDATA[var now = new Date; function createtime() { var t = new Date("09/02/2022 00:00:00"); now.setTime(now.getTime() + 250); var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a, r = Math.floor(n); 1 == String(r).length && (r = "0" + r); var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s); 1 == String(i).length && (i = "0" + i); var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o); 1 == String(l).length && (l = "0" + l); let g = ""; g = r < 18 && r >= 9 ? `<img class="boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-上班摸鱼中.svg" title="距离月入25k也就还差一个大佬带我~"><span class="textTip"> <br> 本站居然运行了 ${a} 天</span><span id="runtime"> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class="fas fa-heartbeat" style="color:red"></i>` : `<img class="boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-下班啦.svg" title="下班了就该开开心心的玩耍，嘿嘿~"><span class="textTip"> <br> 本站居然运行了 ${a} 天</span><span id="runtime"> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class="fas fa-heartbeat" style="color:red"></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g) } setInterval(() => { createtime() }, 250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.js"/>
      <url>/js/runtime/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    var t = new Date("09/02/2022 00:00:00");    now.setTime(now.getTime() + 250);    var e = (now - t) / 1e3 / 60 / 60 / 24,        a = Math.floor(e),        n = (now - t) / 1e3 / 60 / 60 - 24 * a,        r = Math.floor(n); 1 == String(r).length && (r = "0" + r);    var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r,        i = Math.floor(s); 1 == String(i).length && (i = "0" + i);    var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i,        l = Math.round(o); 1 == String(l).length && (l = "0" + l);    let g = ""; g = r < 18 && r >= 9        ? `<img class="boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-上班摸鱼中.svg" title="距离月入25k也就还差一个大佬带我~"><span class="textTip"> <br> 本站居然运行了 ${a} 天</span><span id="runtime"> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class="fas fa-heartbeat" style="color:red"></i>` : `<img class="boardsign" src="https://npm.elemecdn.com/anzhiyu-blog@2.0.3/img/badge/安知鱼-下班啦.svg" title="下班了就该开开心心的玩耍，嘿嘿~"><span class="textTip"> <br> 本站居然运行了 ${a} 天</span><span id="runtime"> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class="fas fa-heartbeat" style="color:red"></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g)} setInterval((() => { createtime() }), 250);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/coin/coin.css"/>
      <url>/css/coin/coin.css</url>
      
        <content type="html"><![CDATA[.tip-button {    border: 0;    border-radius: 0.25rem;    cursor: pointer;    font-size: 20px;    font-weight: 600;    height: 2.6rem;    margin-bottom: -4rem;    outline: 0;    position: relative;    top: 0;    transform-origin: 0% 100%;    transition: transform 50ms ease-in-out;    width: auto;    -webkit-tap-highlight-color: transparent;}.tip-button:active {    transform: rotate(4deg);}.tip-button.clicked {    animation: 150ms ease-in-out 1 shake;    pointer-events: none;}.tip-button.clicked .tip-button__text {    opacity: 0;    transition: opacity 100ms linear 200ms;}.tip-button.clicked::before {    height: 0.5rem;    width: 60%;    background: $button-hover-color;}.tip-button.clicked .coin {    transition: margin-bottom 1s linear 200ms;    margin-bottom: 0;}.tip-button.shrink-landing::before {    transition: width 200ms ease-in;    width: 0;}.tip-button.coin-landed::after {    opacity: 1;    transform: scale(1);    transform-origin: 50% 100%;}.tip-button.coin-landed .coin-wrapper {    background: radial-gradient(circle at 35% 97%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 45% 92%,            rgba(3, 16, 50, 0.4) 0.04rem,            transparent 0.02rem), radial-gradient(circle at 55% 98%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 65% 96%, rgba(3, 16, 50, 0.4) 0.06rem, transparent 0.06rem);    background-position: center bottom;    background-size: 100%;    bottom: -1rem;    opacity: 0;    transform: scale(2) translateY(-10px);}.tip-button__text {    color: #fff;    margin-right: 1.8rem;    opacity: 1;    position: relative;    transition: opacity 100ms linear 500ms;    z-index: 3;}.tip-button::before {    border-radius: 0.25rem;    bottom: 0;    content: '';    display: block;    height: 100%;    left: 50%;    position: absolute;    transform: translateX(-50%);    transition: height 250ms ease-in-out 400ms, width 250ms ease-in-out 300ms;    width: 100%;    z-index: 2;}.tip-button::after {    bottom: -1rem;    color: white;    content: 'ヾ(≧O≦)〃嗷~';    /*点击后显示的内容*/    height: 110%;    left: 0;    opacity: 0;    position: absolute;    pointer-events: none;    text-align: center;    transform: scale(0);    transform-origin: 50% 20%;    transition: transform 200ms cubic-bezier(0, 0, 0.35, 1.43);    width: 100%;    z-index: 1;}.coin-wrapper {    background: none;    bottom: 0;    height: 18rem;    left: 0;    opacity: 1;    overflow: hidden;    pointer-events: none;    position: absolute;    transform: none;    transform-origin: 50% 100%;    transition: opacity 200ms linear 100ms, transform 300ms ease-out;    width: 100%;}.coin {    --front-y-multiplier: 0;    --back-y-multiplier: 0;    --coin-y-multiplier: 0;    --coin-x-multiplier: 0;    --coin-scale-multiplier: 0;    --coin-rotation-multiplier: 0;    --shine-opacity-multiplier: 0.4;    --shine-bg-multiplier: 50%;    bottom: calc(var(--coin-y-multiplier) * 1rem - 3.5rem);    height: 3.5rem;    margin-bottom: 3.05rem;    position: absolute;    right: calc(var(--coin-x-multiplier) * 34% + 16%);    transform: translateX(50%) scale(calc(0.4 + var(--coin-scale-multiplier))) rotate(calc(var(--coin-rotation-multiplier) * -1deg));    transition: opacity 100ms linear 200ms;    width: 3.5rem;    z-index: 3;}.coin__front,.coin__middle,.coin__back,.coin::before,.coin__front::after,.coin__back::after {    border-radius: 50%;    box-sizing: border-box;    height: 100%;    left: 0;    position: absolute;    width: 100%;    z-index: 3;}.coin__front {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        linear-gradient(210deg, #8590b3 32%, transparent 32%), linear-gradient(150deg, #8590b3 32%, transparent 32%),        linear-gradient(to right, #8590b3 22%, transparent 22%, transparent 78%, #8590b3 78%), linear-gradient(to bottom,            #fcfaf9 44%,            transparent 44%,            transparent 65%,            #fcfaf9 65%,            #fcfaf9 71%,            #8590b3 71%), linear-gradient(to right, transparent 28%, #fcfaf9 28%, #fcfaf9 34%, #8590b3 34%, #8590b3 40%, #fcfaf9 40%, #fcfaf9 47%, #8590b3 47%, #8590b3 53%, #fcfaf9 53%, #fcfaf9 60%, #8590b3 60%, #8590b3 66%, #fcfaf9 66%, #fcfaf9 72%, transparent 72%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--front-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--front-scale-multiplier));}.coin__front::after {    background: rgba(0, 0, 0, 0.2);    content: '';    opacity: var(--front-y-multiplier);}.coin__middle {    background: #737c99;    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--middle-scale-multiplier));}.coin__back {    background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%),        radial-gradient(circle at 50% 40%, #fcfaf9 23%, transparent 23%), radial-gradient(circle at 50% 100%, #fcfaf9 35%, transparent 35%);    background-color: #8590b3;    background-size: 100% 100%;    transform: translateY(calc(var(--back-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--back-scale-multiplier));}.coin__back::after {    background: rgba(0, 0, 0, 0.2);    content: '';    opacity: var(--back-y-multiplier);}.coin::before {    background: radial-gradient(circle at 25% 65%, transparent 50%, rgba(255, 255, 255, 0.9) 90%), linear-gradient(55deg, transparent calc(var(--shine-bg-multiplier) + 0%), #e9f4ff calc(var(--shine-bg-multiplier) + 0%), transparent calc(var(--shine-bg-multiplier) + 50%));    content: '';    opacity: var(--shine-opacity-multiplier);    transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / -2)) scaleY(var(--middle-scale-multiplier)) rotate(calc(var(--coin-rotation-multiplier) * 1deg));    z-index: 10;}.coin::after {    background: #737c99;    content: '';    height: 0.3181818182rem;    left: 0;    position: absolute;    top: 50%;    transform: translateY(-50%);    width: 100%;    z-index: 2;}@keyframes shake {    0% {        transform: rotate(4deg);    }    66% {        transform: rotate(-4deg);    }    100% {        transform: rotate();    }}]]></content>
      
    </entry>
    
    
  
</search>
